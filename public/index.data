module benchmark

import time
import term
/*
Example usage of this module:
```
import benchmark
mut bmark := benchmark.new_benchmark()
// by default the benchmark will be verbose, i.e. it will include timing information
// if you want it to be silent, set bmark.verbose = false
for {
   bmark.step() // call this when you want to advance the benchmark.
                // The timing info in bmark.step_message will be measured starting from the last call to bmark.step
   ....

   //bmark.fail() // call this if the step failed
   //bmark.step_message(('failed')

   bmark.ok() // call this when the step succeeded
   println( bmark.step_message('ok')
}
bmark.stop() // call when you want to finalize the benchmark
println( bmark.total_message('remarks about the benchmark') )
```

benchmark.start() and b.measure() are convenience methods,
intended to be used in combination. Their goal is to make
benchmarking of small snippets of code as *short*, easy to
write, and then to read and analyze the results, as possible.
Example:
```v
import benchmark
b := benchmark.start()

// your code 1 ...
b.measure('code_1')

// your code 2 ...
b.measure('code_2')
```
... which will produce on stdout something like this:
SPENT    17 ms in code_1
SPENT   462 ms in code_2
*/


const (
	b_ok = term.ok_message('OK  ')
	b_fail = term.fail_message('FAIL')
	b_skip  = term.warn_message('SKIP')
	b_spent = term.ok_message('SPENT')
)

pub struct Benchmark {
pub mut:
	bench_timer      time.StopWatch
	verbose          bool
	no_cstep         bool
	step_timer       time.StopWatch
	ntotal           int
	nok              int
	nfail            int
	nskip            int
	nexpected_steps  int
	cstep            int
	bok              string
	bfail            string
}

pub fn new_benchmark() Benchmark {
	return Benchmark{
		bench_timer: time.new_stopwatch()
		verbose: true
	}
}

pub fn new_benchmark_no_cstep() Benchmark {
	return Benchmark{
		bench_timer: time.new_stopwatch()
		verbose: true
		no_cstep: true
	}
}

pub fn new_benchmark_pointer() &Benchmark {
	return &Benchmark{
		bench_timer: time.new_stopwatch()
		verbose: true
	}
}

pub fn (mut b Benchmark) set_total_expected_steps(n int) {
	b.nexpected_steps = n
}

pub fn (mut b Benchmark) stop() {
	b.bench_timer.stop()
}

pub fn (mut b Benchmark) step() {
	b.step_timer.restart()
	if !b.no_cstep {
		b.cstep++
	}
}

pub fn (mut b Benchmark) fail() {
	b.step_timer.stop()
	b.ntotal++
	b.nfail++
}

pub fn (mut b Benchmark) ok() {
	b.step_timer.stop()
	b.ntotal++
	b.nok++
}

pub fn (mut b Benchmark) skip() {
	b.step_timer.stop()
	b.ntotal++
	b.nskip++
}

pub fn (mut b Benchmark) fail_many(n int) {
	b.step_timer.stop()
	b.ntotal += n
	b.nfail += n
}

pub fn (mut b Benchmark) ok_many(n int) {
	b.step_timer.stop()
	b.ntotal += n
	b.nok += n
}

pub fn (mut b Benchmark) neither_fail_nor_ok() {
	b.step_timer.stop()
}

pub fn start() Benchmark {
	mut b := new_benchmark()
	b.step()
	return b
}

pub fn (mut b Benchmark) measure(label string) i64 {
	b.ok()
	res := b.step_timer.elapsed().microseconds()
	println(b.step_message_with_label(b_spent, 'in $label'))
	b.step()
	return res
}

pub fn (b &Benchmark) step_message_with_label(label string, msg string) string {
	timed_line := b.tdiff_in_ms(msg, b.step_timer.elapsed().microseconds())
	if b.nexpected_steps > 1 {
		mut sprogress := ''
		if b.nexpected_steps < 10 {
			sprogress = if b.no_cstep { 'TMP1/${b.nexpected_steps:1d}' } else {
				'${b.cstep:1d}/${b.nexpected_steps:1d}'
			}
		} else if b.nexpected_steps >= 10 && b.nexpected_steps < 100 {
			sprogress = if b.no_cstep { 'TMP2/${b.nexpected_steps:2d}' } else {
				'${b.cstep:2d}/${b.nexpected_steps:2d}'
			}
		} else if b.nexpected_steps >= 100 && b.nexpected_steps < 1000 {
			sprogress = if b.no_cstep { 'TMP3/${b.nexpected_steps:3d}' } else {
				'${b.cstep:3d}/${b.nexpected_steps:3d}'
			}
		} else {
			sprogress = if b.no_cstep { 'TMP4/${b.nexpected_steps:4d}' } else {
				'${b.cstep:4d}/${b.nexpected_steps:4d}'
			}
		}
		return '${label:-5s} [${sprogress}] ${timed_line}'
	}
	return '${label:-5s}${timed_line}'
}

pub fn (b &Benchmark) step_message(msg string) string {
	return b.step_message_with_label('', msg)
}

pub fn (b &Benchmark) step_message_ok(msg string) string {
	return b.step_message_with_label(b_ok, msg)
}

pub fn (b &Benchmark) step_message_fail(msg string) string {
	return b.step_message_with_label(b_fail, msg)
}

pub fn (b &Benchmark) step_message_skip(msg string) string {
	return b.step_message_with_label(b_skip, msg)
}

pub fn (b &Benchmark) total_message(msg string) string {
	mut tmsg := '${msg}\n                 ok, fail, skip, total = ' + term.ok_message('${b.nok:5d}') + ', ' + if b.nfail > 0 { term.red('${b.nfail:5d}') } else { '${b.nfail:5d}' } + ', ' + if b.nskip > 0 { term.bright_yellow('${b.nskip:5d}') } else { '${b.nskip:5d}' } + ', ' + '${b.ntotal:5d}'
	if b.verbose {
		tmsg = '<=== total time spent $tmsg'
	}
	mut spaces := '    '
	if b.nexpected_steps > 1 {
		// NB: the formula below accounts for the progress bar [step/total]
		str_steps := '$b.nexpected_steps'
		x := 4 + str_steps.len * 2 + 5
		spaces = ' '.repeat(x)
	}
	return spaces + b.tdiff_in_ms(tmsg, b.bench_timer.elapsed().microseconds())
}

// .total_duration - returns the duration in ms
pub fn (b &Benchmark) total_duration() i64 {
	return b.bench_timer.elapsed().milliseconds()
}

// //////////////////////////////////////////////////////////////////
fn (b &Benchmark) tdiff_in_ms(s string, tdiff i64) string {
	if b.verbose {
		return '${f64(tdiff)/1000.0:9.3f} ms $s'
	}
	return s
}
module bitfield

/*
bitfield is a module for
manipulating arrays of bits, i.e. series of zeroes and ones spread across an
array of storage units (unsigned 32-bit integers).

BitField structure
------------------

Bit arrays are stored in data structures called 'BitField'. The structure is
'opaque', i.e. its internals are not available to the end user. This module
provides API (functions and methods) for accessing and modifying bit arrays.
*/

pub struct BitField {
mut:
	size int
	//field *u32
	field []u32
}

// helper functions
const (
	slot_size = 32
)

// public functions

// from_bytes() converts a byte array into a bitfield.
pub fn from_bytes(input []byte) BitField {
	mut output := new(input.len * 8)
	for i, b in input {
		output.field[i / 4] |= u32(b) << ((i % 4) * 8)
	}
	return output
}

// from_str converts a string of characters ('0' and '1') to a bit
// array. Any character different from '0' is treated as '1'.
pub fn from_str(input string) BitField {
	mut output := new(input.len)
	for i in 0..input.len {
		if input[i] != `0` {
			output.set_bit(i)
		}
	}
	return output
}

// str converts the bit array to a string of characters ('0' and '1') and
// return the string
pub fn (input BitField) str() string {
	mut output := ''
	for i in 0..input.size {
		if input.get_bit(i) == 1 {
			output = output + '1'
		}
		else {
			output = output + '0'
		}
	}
	return output
}

// new creates an empty bit array of capable of storing 'size' bits.
pub fn new(size int) BitField {
	output := BitField{
		size: size
		//field: *u32(calloc(bitnslots(size) * slot_size / 8))
		field: [u32(0)].repeat(bitnslots(size))
	}
	return output
}
/*
pub fn del(instance *BitField) {
	free(instance.field)
	free(instance)
}
*/

// get_bit returns the value (0 or 1) of bit number 'bit_nr' (count from 0).
pub fn (instance BitField) get_bit(bitnr int) int {
	if bitnr >= instance.size {
		return 0
	}
	return (instance.field[bitslot(bitnr)] >> (bitnr % slot_size)) & u32(1)
}

// set_bit sets bit number 'bit_nr' to 1 (count from 0).
pub fn (mut instance BitField) set_bit(bitnr int) {
	if bitnr >= instance.size {
		return
	}
	instance.field[bitslot(bitnr)] |= bitmask(bitnr)
}

// clear_bit clears (sets to zero) bit number 'bit_nr' (count from 0).
pub fn (mut instance BitField) clear_bit(bitnr int) {
	if bitnr >= instance.size {
		return
	}
	instance.field[bitslot(bitnr)] &= ~bitmask(bitnr)
}

// set_all sets all bits in the array to 1.
pub fn (mut instance BitField) set_all() {
	for i in 0..bitnslots(instance.size) {
		instance.field[i] = u32(-1)
	}
	instance.clear_tail()
}

// clear_all clears (sets to zero) all bits in the array.
pub fn (mut instance BitField) clear_all() {
	for i in 0..bitnslots(instance.size) {
		instance.field[i] = u32(0)
	}
}

// toggle_bit changes the value (from 0 to 1 or from 1 to 0) of bit
// number 'bit_nr'.
pub fn (mut instance BitField) toggle_bit(bitnr int) {
	if bitnr >= instance.size {
		return
	}
	instance.field[bitslot(bitnr)] ^= bitmask(bitnr)
}

// bf_and performs logical AND operation on every pair of bits from 'input1' and
// 'input2' and returns the result as a new array. If inputs differ in size,
// the tail of the longer one is ignored.
pub fn bf_and(input1 BitField, input2 BitField) BitField {
	size := min(input1.size, input2.size)
	bitnslots := bitnslots(size)
	mut output := new(size)
	for i in 0..bitnslots {
		output.field[i] = input1.field[i] & input2.field[i]
	}
	output.clear_tail()
	return output
}

// bf_not toggles all bits in a bit array and returns the result as a new array.
pub fn bf_not(input BitField) BitField {
	size := input.size
	bitnslots := bitnslots(size)
	mut output := new(size)
	for i in 0..bitnslots {
		output.field[i] = ~input.field[i]
	}
	output.clear_tail()
	return output
}

// bf_or performs logical OR operation on every pair of bits from 'input1' and
// 'input2' and returns the result as a new array. If inputs differ in size,
// the tail of the longer one is ignored.
pub fn bf_or(input1 BitField, input2 BitField) BitField {
	size := min(input1.size, input2.size)
	bitnslots := bitnslots(size)
	mut output := new(size)
	for i in 0..bitnslots {
		output.field[i] = input1.field[i] | input2.field[i]
	}
	output.clear_tail()
	return output
}

// bf_xor perform logical XOR operation on every pair of bits from 'input1' and
// 'input2' and returns the result as a new array. If inputs differ in size,
// the tail of the longer one is ignored.
pub fn bf_xor(input1 BitField, input2 BitField) BitField {
	size := min(input1.size, input2.size)
	bitnslots := bitnslots(size)
	mut output := new(size)
	for i in 0..bitnslots {
		output.field[i] = input1.field[i] ^ input2.field[i]
	}
	output.clear_tail()
	return output
}

// join concatenates two bit arrays and return the result as a new array.
pub fn join(input1 BitField, input2 BitField) BitField {
	output_size := input1.size + input2.size
	mut output := new(output_size)
	// copy the first input to output as is
	for i in 0..bitnslots(input1.size) {
		output.field[i] = input1.field[i]
	}

	// find offset bit and offset slot
	offset_bit := input1.size % slot_size
	offset_slot := input1.size / slot_size

	for i in 0..bitnslots(input2.size) {
		output.field[i + offset_slot] |=
		    u32(input2.field[i] << u32(offset_bit))
	}

	/*
	 * If offset_bit is not zero, additional operations are needed.
	 * Number of iterations depends on the nr of slots in output. Two
	 * options:
	 * (a) nr of slots in output is the sum of inputs' slots. In this
	 * case, the nr of bits in the last slot of output is less than the
	 * nr of bits in the second input (i.e. ), OR
	 * (b) nr of slots of output is the sum of inputs' slots less one
	 * (i.e. less iterations needed). In this case, the nr of bits in
	 * the last slot of output is greater than the nr of bits in the second
	 * input.
	 * If offset_bit is zero, no additional copies needed.
	 */
	if (output_size - 1) % slot_size < (input2.size - 1) % slot_size {
		for i in 0..bitnslots(input2.size) {
			output.field[i + offset_slot + 1] |=
			    u32(input2.field[i] >> u32(slot_size - offset_bit))
		}
	} else if (output_size - 1) % slot_size > (input2.size - 1) % slot_size {
		for i in 0..bitnslots(input2.size) - 1 {
			output.field[i + offset_slot + 1] |=
			    u32(input2.field[i] >> u32(slot_size - offset_bit))
		}
	}
	return output
}

// get_size returns the number of bits the array can hold.
pub fn (instance BitField) get_size() int {
	return instance.size
}

// clone creates a copy of a bit array.
pub fn (instance BitField) clone() BitField {
	bitnslots := bitnslots(instance.size)
	mut output := new(instance.size)
	for i in 0..bitnslots {
		output.field[i] = instance.field[i]
	}
	return output
}

// cmp compares two bit arrays bit by bit and returns 'true' if they are
// identical by length and contents and 'false' otherwise.
pub fn (instance BitField) cmp(input BitField) bool {
	if instance.size != input.size {return false}
	for i in 0..bitnslots(instance.size) {
		if instance.field[i] != input.field[i] {return false}
	}
	return true
}

// pop_count returns the number of set bits (ones) in the array.
pub fn (instance BitField) pop_count() int {
	size := instance.size
	bitnslots := bitnslots(size)
	tail := size % slot_size
	mut count := 0
	for i in 0..bitnslots - 1 {
		for j in 0..slot_size {
			if u32(instance.field[i] >> u32(j)) & u32(1) == u32(1) {
				count++
			}
		}
	}
	for j in 0..tail {
		if u32(instance.field[bitnslots - 1] >> u32(j)) & u32(1) == u32(1) {
			count++
		}
	}
	return count
}

// hamming computes the Hamming distance between two bit arrays.
pub fn hamming(input1 BitField, input2 BitField) int {
	input_xored := bf_xor(input1, input2)
	return input_xored.pop_count()
}

// pos checks if the array contains a sub-array 'needle' and returns its
// position if it does, -1 if it does not, and -2 on error.
pub fn (haystack BitField) pos(needle BitField) int {
	heystack_size := haystack.size
	needle_size := needle.size
	diff := heystack_size - needle_size

	// needle longer than haystack; return error code -2
	if diff < 0 {
		return -2
	}
	for i := 0; i <= diff; i++ {
		needle_candidate := haystack.slice(i, needle_size + i)
		if needle_candidate.cmp(needle) {
			// needle matches a sub-array of haystack; return starting position of the sub-array
			return i
		}
	}
	// nothing matched; return -1
	return -1
}

// slice returns a sub-array of bits between 'start_bit_nr' (included) and
// 'end_bit_nr' (excluded).
pub fn (input BitField) slice(_start int, _end int) BitField {
	// boundary checks
	mut start := _start
	mut end := _end
	if end > input.size {
		end = input.size // or panic?
	}
	if start > end {
		start = end // or panic?
	}

	mut output := new(end - start)
	start_offset := start % slot_size
	end_offset := (end - 1) % slot_size
	start_slot := start / slot_size
	end_slot := (end - 1) / slot_size
	output_slots := bitnslots(end - start)

	if output_slots > 1 {
		if start_offset != 0 {
			for i in 0..output_slots - 1 {
				output.field[i] =
				    u32(input.field[start_slot + i] >> u32(start_offset))
				output.field[i] = output.field[i] |
				    u32(input.field[start_slot + i + 1] <<
				    u32(slot_size - start_offset))
			}
		}
		else {
			for i in 0..output_slots - 1 {
				output.field[i] =
				    u32(input.field[start_slot + i])
			}
		}
	}

	if start_offset > end_offset {
		output.field[(end - start - 1) / slot_size] =
		    u32(input.field[end_slot - 1] >> u32(start_offset))
		mut mask := u32((1 << (end_offset + 1)) - 1)
		mask = input.field[end_slot] & mask
		mask = u32(mask << u32(slot_size - start_offset))
		output.field[(end - start - 1) / slot_size] |= mask
	}
	else if start_offset == 0 {
		mut mask := u32(0)
		if end_offset == slot_size - 1 {
			mask = u32(-1)
		}
		else {
			mask = u32(u32(1) << u32(end_offset + 1))
			mask = mask - u32(1)
		}
		output.field[(end - start - 1) / slot_size] =
		    (input.field[end_slot] & mask)
	}
	else {
		mut mask := u32(((1 << (end_offset - start_offset + 1)) - 1)  << start_offset)
		mask = input.field[end_slot] & mask
		mask = u32(mask >> u32(start_offset))
		output.field[(end - start - 1) / slot_size] |= mask
	}
	return output
}

// reverse reverses the order of bits in the array (swap the first with the
// last, the second with the last but one and so on).
pub fn (instance BitField) reverse() BitField {
	size := instance.size
	bitnslots := bitnslots(size)
	mut output := new(size)
	for i:= 0; i < (bitnslots - 1); i++ {
		for j in 0..slot_size {
			if u32(instance.field[i] >> u32(j)) & u32(1) == u32(1) {
				output.set_bit(size - i * slot_size - j - 1)
			}
		}
	}
	bits_in_last_input_slot := (size - 1) % slot_size + 1
	for j in 0..bits_in_last_input_slot {
		if u32(instance.field[bitnslots - 1] >> u32(j)) & u32(1) == u32(1) {
			output.set_bit(bits_in_last_input_slot - j - 1)
		}
	}
	return output
}

// resize changes the size of the bit array to 'new_size'.
pub fn (mut instance BitField) resize(new_size int) {
	new_bitnslots := bitnslots(new_size)
	old_size := instance.size
	old_bitnslots := bitnslots(old_size)
	mut field := [u32(0)].repeat(new_bitnslots)
	for i := 0; i < old_bitnslots && i < new_bitnslots; i++ {
		field[i] = instance.field[i]
	}
	instance.field = field.clone()
	instance.size = new_size
	if new_size < old_size && new_size % slot_size != 0 {
		instance.clear_tail()
	}
}

// rotate circular-shifts the bits by 'offset' positions (move
// 'offset' bit to 0, 'offset+1' bit to 1, and so on).
pub fn (instance BitField) rotate(offset int) BitField {
	/**
	 * This function "cuts" the bitfield into two and swaps them.
	 * If the offset is positive, the cutting point is counted from the
	 * beginning of the bit array, otherwise from the end.
	**/
	size := instance.size
	// removing extra rotations

	mut offset_internal := offset % size
	if offset_internal == 0 {
		// nothing to shift
		return instance
	}
	if offset_internal < 0 {
		offset_internal = offset_internal + size
	}

	first_chunk := instance.slice(0, offset_internal)
	second_chunk := instance.slice(offset_internal, size)
	output := join(second_chunk, first_chunk)
	return output
}

// Internal functions

fn (mut instance BitField) clear_tail() {
	tail := instance.size % slot_size
	if tail != 0 {
		// create a mask for the tail
		mask := u32((1 << tail) - 1)
		// clear the extra bits
		instance.field[bitnslots(instance.size) - 1] = instance.field[bitnslots(instance.size) - 1] & mask
	}
}

fn bitmask(bitnr int) u32 {
	return u32(u32(1) << u32(bitnr % slot_size))
}

fn bitslot(size int) int {
	return size / slot_size
}

fn min(input1 int, input2 int) int {
	if input1 < input2 {
		return input1
	}
	else {
		return input2
	}
}

fn bitnslots(length int) int {
	return (length - 1) / slot_size + 1
}
import bitfield

import rand
import time

fn test_bf_new_size() {
	instance := bitfield.new(75)
	assert instance.get_size() == 75
}

fn test_bf_set_clear_toggle_get() {
	mut instance := bitfield.new(75)
	instance.set_bit(47)
	assert instance.get_bit(47) == 1
	instance.clear_bit(47)
	assert instance.get_bit(47) == 0
	instance.toggle_bit(47)
	assert instance.get_bit(47) == 1
}

fn test_bf_and_not_or_xor() {
	rand.seed(time.now().unix)
	len := 80
	mut input1 := bitfield.new(len)
	mut input2 := bitfield.new(len)
	mut i := 0
	for i < len {
		if rand.next(2) == 1 {
			input1.set_bit(i)
		}
		if rand.next(2) == 1{
			input2.set_bit(i)
		}
		i++
	}
	output1 := bitfield.bf_xor(input1, input2)
	bf_and := bitfield.bf_and(input1, input2)
	bf_or := bitfield.bf_or(input1, input2)
	bf_not := bitfield.bf_not(bf_and)
	output2 := bitfield.bf_and(bf_or, bf_not)
	mut result := 1
	for i < len {
		if output1.get_bit(i) != output2.get_bit(i) {result = 0}
	}
	assert result == 1
}

fn test_clone_cmp() {
	rand.seed(time.now().unix)
	len := 80
	mut input := bitfield.new(len)
	for i in 0..len {
		if rand.next(2) == 1 {
			input.set_bit(i)
		}
	}
	output := input.clone()
	assert output.get_size() == len
	assert input.cmp(output) == true
}

fn test_slice_join() {
	rand.seed(time.now().unix)
	len := 80
	mut input := bitfield.new(len)
	for i in 0..len {
		if rand.next(2) == 1 {
			input.set_bit(i)
		}
	}
	mut result := 1
	for point := 1; point < (len - 1); point++ {
		// divide a bitfield into two subfields
		chunk1 := input.slice(0, point)
		chunk2 := input.slice(point, input.get_size())
		// concatenate them back into one and compare to the original
		output := bitfield.join(chunk1, chunk2)
		if !input.cmp(output) {
			result = 0
		}
	}
	assert result == 1
}

fn test_pop_count() {
	rand.seed(time.now().unix)
	len := 80
	mut count0 := 0
	mut input := bitfield.new(len)
	for i in 0..len {
		if rand.next(2) == 1 {
			input.set_bit(i)
			count0++
		}
	}
	count1 := input.pop_count()
	assert count0 == count1
}

fn test_hamming() {
	rand.seed(time.now().unix)
	len := 80
	mut count := 0
	mut input1 := bitfield.new(len)
	mut input2 := bitfield.new(len)
	for i in 0..len {
		match rand.next(4) {
			0, 1 {
				input1.set_bit(i)
				count++
			}
			2 {
				input2.set_bit(i)
				count++
			}
			3 {
				input1.set_bit(i)
				input2.set_bit(i)
			}
			else {

			}
		}
	}
	assert count == bitfield.hamming(input1, input2)
}

fn test_bf_from_bytes() {
	input := [byte(0xF0), byte(0x0F), byte(0xF0), byte(0xFF)]
	output := bitfield.from_bytes(input)
	mut result := 1
	for i in 0..input.len * 8 {
		if (input[i / 8] >> (i % 8)) & 1 != output.get_bit(i) {
			result = 0
		}
	}
	assert result == 1
}

fn test_bf_from_str() {
	rand.seed(time.now().unix)
	len := 80
	mut input := ''
	for _ in 0..len {
		if rand.next(2) == 1 {
			input = input + '1'
		}
		else {
			input = input + '0'
		}
	}
	output := bitfield.from_str(input)
	mut result := 1
	for i in 0..len {
		if input[i] != output.get_bit(i) + 48 {
			result = 0
		}
	}
	assert result == 1
}

fn test_bf_bf2str() {
	rand.seed(time.now().unix)
	len := 80
	mut input := bitfield.new(len)
	for i in 0..len {
		if rand.next(2) == 1 {
			input.set_bit(i)
		}
	}
	mut check := ''
	for i in 0..len {
		if input.get_bit(i) == 1 {
			check = check + '1'
		}
		else {
			check = check + '0'
		}
	}
	output := input.str()
	mut result := 1
	for i in 0..len {
		if check[i] != output[i] {
			result = 0
		}
	}
	assert result == 1
}

fn test_bf_set_all() {
	rand.seed(time.now().unix)
	len := 80
	mut input := bitfield.new(len)
	input.set_all()
	mut result := 1
	for i in 0..len {
		if input.get_bit(i) != 1 {
			result = 0
		}
	}
	assert result == 1
}

fn test_bf_clear_all() {
	rand.seed(time.now().unix)
	len := 80
	mut input := bitfield.new(len)
	for i in 0..len {
		if rand.next(2) == 1 {
			input.set_bit(i)
		}
	}
	input.clear_all()
	mut result := 1
	for i in 0..len {
		if input.get_bit(i) != 0 {
			result = 0
		}
	}
	assert result == 1
}

fn test_bf_reverse() {
	rand.seed(time.now().unix)
	len := 80
	mut input := bitfield.new(len)
	for i in 0..len {
		if rand.next(2) == 1 {
			input.set_bit(i)
		}
	}
	check := input.clone()
	output := input.reverse()
	mut result := 1
	for i in 0..len {
		if output.get_bit(i) != check.get_bit(len - i - 1) {
			result = 0
		}
	}
	assert result == 1
}

fn test_bf_resize() {
	rand.seed(time.now().unix)
	len := 80
	mut input := bitfield.new(rand.next(len) + 1)
	for _ in 0..100 {
		input.resize(rand.next(len) + 1)
		input.set_bit(input.get_size() - 1)
	}
	assert input.get_bit(input.get_size() - 1) == 1
}

fn test_bf_pos() {
	/**
	 * set haystack size to 80
	 * test different sizes of needle, from 1 to 80
	 * test different positions of needle, from 0 to where it fits
	 * all haystacks here contain exactly one instanse of needle,
	 * so search should return non-negative-values
	**/
	rand.seed(time.now().unix)
	len := 80
	mut result := 1
	for i := 1; i < len; i++ {	// needle size
		for j in 0..len - i {	// needle position in the haystack
			// create the needle
			mut needle := bitfield.new(i)

			// fill the needle with random values
			for k in 0..i {
				if rand.next(2) == 1 {
					needle.set_bit(k)
				}
			}

			// make sure the needle contains at least one set bit, selected randomly
			r := rand.next(i)
			needle.set_bit(r)

			// create the haystack, make sure it contains the needle
			mut haystack := needle.clone()

			// if there is space between the start of the haystack and the sought needle, fill it with zeroes
			if j > 0 {
				start := bitfield.new(j)
				tmp := bitfield.join(start, haystack)
				haystack = tmp
			}

			// if there is space between the sought needle and the end of haystack, fill it with zeroes
			if j + i < len {
				end := bitfield.new(len - j - i)
				tmp2 := bitfield.join(haystack, end)
				haystack = tmp2
			}

			// now let's test
			// the result should be equal to j
			if haystack.pos(needle) != j {
				result = 0
			}
		}
	}
	assert result == 1
}

fn test_bf_rotate() {
	mut result := 1
	len := 80
	for i := 1; i < 80 && result == 1; i++ {
		mut chunk1 := bitfield.new(i)
		chunk2 := bitfield.new(len - i)
		chunk1.set_all()
		input := bitfield.join(chunk1, chunk2)
		output := input.rotate(i)
		if output.get_bit(len - i - 1) != 0 || output.get_bit(len - i) != 1 {
			result = 0
		}
	}
	assert result == 1
}

fn test_bf_printing(){
	rand.seed(time.now().unix)
	len := 80
	mut input := bitfield.new(len)
	for i in 0..len {
	   if rand.next(2) == 0 {
		   input.set_bit(i)
	   }
	}
	// the following should convert the bitfield input into a string automatically
	println(input)
	assert true
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builtin

import strings

pub struct array {
pub:
	element_size int
pub mut:
	data         voidptr// Using a void pointer allows to implement arrays without generics and without generating
// extra code for every type.
	len          int
	cap          int
}

// Internal function, used by V (`nums := []int`)
fn __new_array(mylen int, cap int, elm_size int) array {
	cap_ := if cap < mylen { mylen } else { cap }
	arr := array{
		element_size: elm_size
		data: vcalloc(cap_ * elm_size)
		len: mylen
		cap: cap_
	}
	return arr
}

fn __new_array_with_default(mylen int, cap int, elm_size int, val voidptr) array {
	cap_ := if cap < mylen { mylen } else { cap }
	arr := array{
		element_size: elm_size
		data: vcalloc(cap_ * elm_size)
		len: mylen
		cap: cap_
	}
	if val != 0 {
		for i in 0..arr.len {
			C.memcpy(charptr(arr.data) + i*elm_size, val, elm_size)
		}
	}
	return arr
}

// Private function, used by V (`nums := [1, 2, 3]`)
fn new_array_from_c_array(len, cap, elm_size int, c_array voidptr) array {
	cap_ := if cap < len { len } else { cap }

	arr := array{
		element_size: elm_size
		data: vcalloc(cap_ * elm_size)
		len: len
		cap: cap_
	}
	// TODO Write all memory functions (like memcpy) in V
	C.memcpy(arr.data, c_array, len * elm_size)
	return arr
}

// Private function, used by V (`nums := [1, 2, 3] !`)
fn new_array_from_c_array_no_alloc(len, cap, elm_size int, c_array voidptr) array {
	arr := array{
		element_size: elm_size
		data: c_array
		len: len
		cap: cap
	}
	return arr
}

// Private function. Doubles array capacity if needed
[inline]
fn (mut a array) ensure_cap(required int) {
	if required <= a.cap {
		return
	}
	mut cap := if a.cap == 0 { 2 } else { a.cap * 2 }
	for required > cap {
		cap *= 2
	}
	if a.cap == 0 {
		a.data = vcalloc(cap * a.element_size)
	}
	else {
		a.data = C.realloc(a.data, cap * a.element_size)
	}
	a.cap = cap
}

// repeat returns new array with the given array elements repeated given times.
pub fn (a array) repeat(count int) array {
	if count < 0 {
		panic('array.repeat: count is negative: $count')
	}
	mut size := count * a.len * a.element_size
	if size == 0 {
		size = a.element_size
	}
	arr := array{
		element_size: a.element_size
		data: vcalloc(size)
		len: count * a.len
		cap: count * a.len
	}
	for i in 0..count {
		C.memcpy(byteptr(arr.data) + i * a.len * a.element_size, byteptr(a.data), a.len * a.element_size)
	}
	return arr
}

// array.sort sorts array in-place using given `compare` function as comparator
pub fn (mut a array) sort_with_compare(compare voidptr) {
	C.qsort(a.data, a.len, a.element_size, compare)
}

// TODO array.insert is broken
// Cannot pass literal or primitive type as it cannot be cast to voidptr.
// In the current state only that would work:
// i := 3
// a.insert(0, &i)
// ----------------------------
pub fn (mut a array) insert(i int, val voidptr) {
	$if !no_bounds_checking? {
		if i < 0 || i > a.len {
			panic('array.insert: index out of range (i == $i, a.len == $a.len)')
		}
	}
	a.ensure_cap(a.len + 1)
	size := a.element_size
	C.memmove(byteptr(a.data) + (i + 1) * size, byteptr(a.data) + i * size, (a.len - i) * size)
	C.memcpy(byteptr(a.data) + i * size, val, size)
	a.len++
}

// TODO array.prepend is broken
// It depends on array.insert
// -----------------------------
pub fn (mut a array) prepend(val voidptr) {
	a.insert(0, val)
}

// array.delete deletes array element at the given index
pub fn (mut a array) delete(i int) {
	$if !no_bounds_checking? {
		if i < 0 || i >= a.len {
			panic('array.delete: index out of range (i == $i, a.len == $a.len)')
		}
	}
	size := a.element_size
	// NB: if a is [12,34], a.len = 2, a.delete(0) 
	// should move (2-0-1) elements = 1 element (the 34) forward
	C.memmove(byteptr(a.data) + i * size, byteptr(a.data) + (i + 1) * size, (a.len - i - 1) * size)
	a.len--
}

// clears the array without deallocating the allocated data
pub fn (mut a array) clear() {
	a.len = 0
}

// trims the array length to "index" without modifying the allocated data. If "index" is greater
// than len nothing will be changed
pub fn (mut a array) trim(index int) {
	if index < a.len {
		a.len = index
	}
}

// Private function. Used to implement array[] operator
fn (a array) get(i int) voidptr {
	$if !no_bounds_checking? {
		if i < 0 || i >= a.len {
			panic('array.get: index out of range (i == $i, a.len == $a.len)')
		}
	}
	return byteptr(a.data) + i * a.element_size
}

// array.first returns the first element of the array
pub fn (a array) first() voidptr {
	$if !no_bounds_checking? {
		if a.len == 0 {
			panic('array.first: array is empty')
		}
	}
	return a.data
}

// array.last returns the last element of the array
pub fn (a array) last() voidptr {
	$if !no_bounds_checking? {
		if a.len == 0 {
			panic('array.last: array is empty')
		}
	}
	return byteptr(a.data) + (a.len - 1) * a.element_size
}

// array.slice returns an array using the same buffer as original array
// but starting from the `start` element and ending with the element before
// the `end` element of the original array with the length and capacity
// set to the number of the elements in the slice.
fn (a array) slice(start, _end int) array {
	mut end := _end
	$if !no_bounds_checking? {
		if start > end {
			panic('array.slice: invalid slice index ($start > $end)')
		}
		if end > a.len {
			panic('array.slice: slice bounds out of range ($end >= $a.len)')
		}
		if start < 0 {
			panic('array.slice: slice bounds out of range ($start < 0)')
		}
	}
	l := end - start
	res := array{
		element_size: a.element_size
		data: byteptr(a.data) + start * a.element_size
		len: l
		cap: l
	}
	return res
}

// used internally for [2..4]
fn (a array) slice2(start, _end int, end_max bool) array {
	end := if end_max { a.len } else { _end }
	return a.slice(start, end)
}

// array.clone_static returns an independent copy of a given array
// It should be used only in -autofree generated code.
fn (a array) clone_static() array {
	return a.clone()
}

// array.clone returns an independent copy of a given array
pub fn (a &array) clone() array {
	mut size := a.cap * a.element_size
	if size == 0 {
		size++
	}
	arr := array{
		element_size: a.element_size
		data: vcalloc(size)
		len: a.len
		cap: a.cap
	}
	C.memcpy(byteptr(arr.data), a.data, a.cap * a.element_size)
	return arr
}

fn (a &array) slice_clone(start, _end int) array {
	mut end := _end
	$if !no_bounds_checking? {
		if start > end {
			panic('array.slice: invalid slice index ($start > $end)')
		}
		if end > a.len {
			panic('array.slice: slice bounds out of range ($end >= $a.len)')
		}
		if start < 0 {
			panic('array.slice: slice bounds out of range ($start < 0)')
		}
	}
	l := end - start
	res := array{
		element_size: a.element_size
		data: byteptr(a.data) + start * a.element_size
		len: l
		cap: l
	}
	return res.clone()
}

// Private function. Used to implement assigment to the array element.
fn (mut a array) set(i int, val voidptr) {
	$if !no_bounds_checking? {
		if i < 0 || i >= a.len {
			panic('array.set: index out of range (i == $i, a.len == $a.len)')
		}
	}
	C.memcpy(byteptr(a.data) + a.element_size * i, val, a.element_size)
}

fn (mut a array) push(val voidptr) {
	a.ensure_cap(a.len + 1)
	C.memcpy(byteptr(a.data) + a.element_size * a.len, val, a.element_size)
	a.len++
}

// `val` is array.data
// TODO make private, right now it's used by strings.Builder
pub fn (mut a3 array) push_many(val voidptr, size int) {
	if a3.data == val {
		// handle `arr << arr`
		copy := a3.clone()
		a3.ensure_cap(a3.len + size)
		//C.memcpy(a.data, copy.data, copy.element_size * copy.len)
		C.memcpy(byteptr(a3.data) + a3.element_size * a3.len, copy.data, a3.element_size * size)
	} else {
		a3.ensure_cap(a3.len + size)
		C.memcpy(byteptr(a3.data) + a3.element_size * a3.len, val, a3.element_size * size)
	}
	a3.len += size
}

// array.reverse returns a new array with the elements of
// the original array in reverse order.
pub fn (a array) reverse() array {
	if a.len < 2 {
		return a
	}
	arr := array{
		element_size: a.element_size
		data: vcalloc(a.cap * a.element_size)
		len: a.len
		cap: a.cap
	}
	for i in 0..a.len {
		//C.memcpy(arr.data + i * arr.element_size, &a[a.len - 1 - i], arr.element_size)
		C.memcpy(byteptr(arr.data) + i * arr.element_size, byteptr(a.data) + (a.len - 1 - i) * arr.element_size, arr.element_size)
	}
	return arr
}

// pub fn (a []int) free() {
[unsafe_fn]
pub fn (a &array) free() {
	// if a.is_slice {
	// return
	// }
	C.free(a.data)
}

// []string.str returns a string representation of the array of strings
// => '["a", "b", "c"]'
pub fn (a []string) str() string {
	mut sb := strings.new_builder(a.len * 3)
	sb.write('[')
	for i in 0..a.len {
		val := a[i]
		sb.write("\'")
		sb.write(val)
		sb.write("\'")
		if i < a.len - 1 {
			sb.write(', ')
		}
	}
	sb.write(']')
	return sb.str()
}

// []byte.hex returns a string with the hexadecimal representation
// of the byte elements of the array
pub fn (b []byte) hex() string {
	mut hex := malloc(b.len * 2 + 1)
	mut dst_i := 0
	for i in b {
		n0 := i >> 4
		hex[dst_i++] = if n0 < 10 { n0 + `0` } else { n0 + 87 }
		n1 := i & 0xF
		hex[dst_i++] = if n1 < 10 { n1 + `0` } else { n1 + 87 }
	}
	hex[dst_i] = `\0`
	return tos(hex,dst_i)
}

// copy copies the `src` byte array elements to the `dst` byte array.
// The number of the elements copied is the minimum of the length of both arrays.
// Returns the number of elements copied.
// TODO: implement for all types
pub fn copy(dst, src []byte) int {
	if dst.len > 0 && src.len > 0 {
		mut min := 0
		min = if dst.len < src.len { dst.len } else { src.len }
		C.memcpy(byteptr(dst.data), src[..min].data, dst.element_size * min)
		return min
	}
	return 0
}

// Private function. Comparator for int type.
fn compare_ints(a, b &int) int {
	if *a < *b {
		return -1
	}
	if *a > *b {
		return 1
	}
	return 0
}

// []int.sort sorts array of int in place in ascending order.
pub fn (mut a []int) sort() {
	a.sort_with_compare(compare_ints)
}

// []string.index returns the index of the first element equal to the given value,
// or -1 if the value is not found in the array.
pub fn (a []string) index(v string) int {
	for i in 0..a.len {
		if a[i] == v {
			return i
		}
	}
	return -1
}

// []int.index returns the index of the first element equal to the given value,
// or -1 if the value is not found in the array.
pub fn (a []int) index(v int) int {
	for i in 0..a.len {
		if a[i] == v {
			return i
		}
	}
	return -1
}

// []byte.index returns the index of the first element equal to the given value,
// or -1 if the value is not found in the array.
pub fn (a []byte) index(v byte) int {
	for i in 0..a.len {
		if a[i] == v {
			return i
		}
	}
	return -1
}

// []char.index returns the index of the first element equal to the given value,
// or -1 if the value is not found in the array.
// TODO is `char` type yet in the language?
pub fn (a []char) index(v char) int {
	for i in 0..a.len {
		if a[i] == v {
			return i
		}
	}
	return -1
}

// []int.reduce executes a given reducer function on each element of the array,
// resulting in a single output value.
pub fn (a []int) reduce(iter fn(accum, curr int)int, accum_start int) int {
	mut accum_ := accum_start
	for i in a {
		accum_ = iter(accum_, i)
	}

	return accum_
}

// array_eq<T> checks if two arrays contain all the same elements in the same order.
// []int == []int (also for: i64, f32, f64, byte, string)
/*
fn array_eq<T>(a1, a2 []T) bool {
	if a1.len != a2.len {
		return false
	}
	for i in 0..a1.len {
		if a1[i] != a2[i] {
			return false
		}
	}
	return true
}

pub fn (a []int) eq(a2 []int) bool {
	return array_eq(a, a2)
}

pub fn (a []i64) eq(a2 []i64) bool {
	return array_eq(a, a2)
}


pub fn (a []byte) eq(a2 []byte) bool {
	return array_eq(a, a2)
}

pub fn (a []f32) eq(a2 []f32) bool {
	return array_eq(a, a2)
}
*/

pub fn (a1 []string) eq(a2 []string) bool {
	//return array_eq(a, a2)
	if a1.len != a2.len {
		return false
	}
	for i in 0..a1.len {
		if a1[i] != a2[i] {
			return false
		}
	}
	return true
}

// compare_i64 for []f64 sort_with_compare()
// sort []i64 with quicksort
// usage :
// mut x := [i64(100),10,70,28,92]
// x.sort_with_compare(compare_i64)
// println(x)     // Sorted i64 Array
// output:
// [10, 28, 70, 92, 100]
pub fn compare_i64(a, b &i64) int {
	if *a < *b {
		return -1
	}
	if *a > *b {
		return 1
	}
	return 0
}

// compare_f64 for []f64 sort_with_compare()
// ref. compare_i64(...)
pub fn compare_f64(a, b &f64) int {
	if *a < *b {
		return -1
	}
	if *a > *b {
		return 1
	}
	return 0
}

// compare_f32 for []f32 sort_with_compare()
// ref. compare_i64(...)
pub fn compare_f32(a, b &f32) int {
	if *a < *b {
		return -1
	}
	if *a > *b {
		return 1
	}
	return 0
}

// a.pointers() returns a new array, where each element
// is the address of the corresponding element in a.
pub fn (a array) pointers() []voidptr {
	mut res := []voidptr{}
	for i in 0..a.len {
		res << byteptr(a.data) + i * a.element_size
	}
	return res
}
fn test_pointer() {
	mut arr := []&int{}
	a := 1
	b := 2
	c := 3
	arr << &a
	arr << &b
	arr << &c
	assert *arr[0] == 1
	arr[1] = &c
	assert *arr[1] == 3
	mut d_arr := [arr] // [][]&int
	d_arr << arr
	assert *d_arr[0][1] == 3
	println(*d_arr[0][1])
	assert *d_arr[1][0] == 1
}

fn test_assign() {
	mut arr := [2, 4, 8, 16, 32, 64, 128]

	arr[0] = 2
	arr[1] &= 255
	arr[2] |= 255
	arr[3] <<= 4
	arr[4] >>= 4
	arr[5] %= 5
	arr[6] ^= 3

	assert arr[0] == 2
	assert arr[1] == 4 & 255
	assert arr[2] == 8 | 255
	assert arr[3] == 16 << 4
	assert arr[4] == 32 >> 4
	assert arr[5] == 64 % 5
	assert arr[6] == 128 ^ 3
}

fn test_ints() {
	mut a := [1, 5, 2, 3]
	assert a.len == 4
	assert a[0] == 1
	assert a[2] == 2
	assert a.last() == 3
	a << 4
	assert a.len == 5
	assert a[4] == 4
	assert a.last() == 4
	s := a.str()
	assert s == '[1, 5, 2, 3, 4]'
	assert a[1] == 5
	assert a.last() == 4
}

fn test_deleting() {
	mut a := [1, 5, 2, 3, 4]
	assert a.len == 5
	assert a.str() == '[1, 5, 2, 3, 4]'
	a.delete(0)
	assert a.str() == '[5, 2, 3, 4]'
	assert a.len == 4
	a.delete(1)
	assert a.str() == '[5, 3, 4]'
	assert a.len == 3
	a.delete(a.len - 1)
	assert a.str() == '[5, 3]'
	assert a.len == 2
}

fn test_short() {
	a := [1, 2, 3]
	assert a.len == 3
	assert a.cap == 3
	assert a[0] == 1
	assert a[1] == 2
	assert a[2] == 3
}

fn test_large() {
	mut a := [0].repeat(0)
	for i in 0..10000 {
		a << i
	}
	assert a.len == 10000
	assert a[234] == 234
}

struct Chunk {
	val string
}

struct K {
	q []Chunk
}

fn test_empty() {
	mut chunks := []Chunk{}
	a := Chunk{}
	assert chunks.len == 0
	chunks << a
	assert chunks.len == 1
	chunks = []
	assert chunks.len == 0
	chunks << a
	assert chunks.len == 1
}

fn test_push() {
	mut a := []int{}
	a << 1
	a << 3
	assert a[1] == 3
	assert a.str() == '[1, 3]'
}

// TODO array.insert is broken
// Cannot pass literal or primitive type as it cannot be cast to voidptr.
// In the current state only that would work:
// i := 3
// a.insert(0, &i)
// ----------------------------
/*
fn test_insert() {
	mut a := [1, 2]
	a.insert(0, 3)
	println(a)
}
*/
// fn test_insert() {
// mut a := [1, 2]
// a.insert(0, 3)
// assert a[0] == 3
// assert a[2] == 2
// assert a.len == 3
// a.insert(1, 4)
// assert a[1] == 4
// assert a[2] == 1
// assert a.len == 4
// a.insert(4, 5)
// assert a[4] == 5
// assert a[3] == 2
// assert a.len == 5
// mut b := []f64{}
// assert b.len == 0
// b.insert(0, f64(1.1))
// assert b.len == 1
// assert b[0] == f64(1.1)
// }
// TODO array.prepend is broken
// It depends on array.insert
// -----------------------------
// fn test_prepend() {
// mut a := []int{}
// assert a.len == 0
// a.prepend(1)
// assert a.len == 1
// assert a[0] == 1
// mut b := []f64{}
// assert b.len == 0
// b.prepend(f64(1.1))
// assert b.len == 1
// assert b[0] == f64(1.1)
// }
fn test_strings() {
	a := ['a', 'b', 'c']
	assert a.str() == "['a', 'b', 'c']"
}

/*
fn test_compare_ints() {
    assert compare_ints(1, 2) == -1
    assert compare_ints(2, 1) == 1
    assert compare_ints(0, 0) == 0

    a := 1
    b := 2
    assert compare_ints(a, b) == -1
    assert compare_ints(b, a) == 1
    assert compare_ints(a, a) == 0
}
*/


fn test_repeat() {
	{
		a := [0].repeat(5)
		assert a.len == 5
		assert a[0] == 0 && a[1] == 0 && a[2] == 0 && a[3] == 0 && a[4] == 0
	}
	{
		a := [1.1].repeat(10)
		assert a[0] == 1.1
		assert a[5] == 1.1
		assert a[9] == 1.1
	}
	{
		a := [i64(-123)].repeat(10)
		assert a[0] == -123
		assert a[5] == -123
		assert a[9] == -123
	}
	{
		a := [u64(123)].repeat(10)
		assert a[0] == 123
		assert a[5] == 123
		assert a[9] == 123
	}
	{
		a := [1.1].repeat(10)
		assert a[0] == 1.1
		assert a[5] == 1.1
		assert a[9] == 1.1
	}
	{
		a := [1, 2].repeat(2)
		assert a[0] == 1
		assert a[1] == 2
		assert a[2] == 1
		assert a[3] == 2
	}
	{
		a := ['1', 'abc'].repeat(2)
		assert a[0] == '1'
		assert a[1] == 'abc'
		assert a[2] == '1'
		assert a[3] == 'abc'
	}
	{
		mut a := ['1', 'abc'].repeat(0)
		assert a.len == 0
		a << 'abc'
		assert a[0] == 'abc'
	}
}

fn test_right() {
	a := [1, 2, 3, 4]
	c := a[1..a.len]
	d := a[1..]
	assert c[0] == 2
	assert c[1] == 3
	assert d[0] == 2
	assert d[1] == 3
}

fn test_left() {
	a := [1, 2, 3]
	c := a[0..2]
	d := a[..2]
	assert c[0] == 1
	assert c[1] == 2
	assert d[0] == 1
	assert d[1] == 2
}

fn test_slice() {
	a := [1, 2, 3, 4]
	b := a.slice(2, 4)
	assert b.len == 2
	assert a.slice(1, 2).len == 1
	assert a.len == 4
}


fn test_push_many() {
	mut a := [1, 2, 3]
	b := [4, 5, 6]
	a << b
	assert a.len == 6
	assert a[0] == 1
	assert a[3] == 4
	assert a[5] == 6
}

fn test_reverse() {
	a := [1, 2, 3, 4]
	b := ['test', 'array', 'reverse']
	c := a.reverse()
	println(c)
	d := b.reverse()
	for i, _ in c {
		assert c[i] == a[a.len - i - 1]
	}
	for i, _ in d {
		assert d[i] == b[b.len - i - 1]
	}
	e := []int{}
	f := e.reverse()
	assert f.len == 0
}

const (
	c_n = 5
)

struct Foooj {
	a [5]int // c_n
}

fn test_fixed() {
	mut nums := [4]int
	//x := nums[1..3]
	//assert x.len == 2
	assert nums[0] == 0
	assert nums[1] == 0
	assert nums[2] == 0
	assert nums[3] == 0
	nums[1] = 7
	assert nums[1] == 7
	nums2 := [5]int // c_n
	assert nums2[c_n - 1] == 0
}

fn modify(numbers mut []int) {
	numbers[0] = 777
}

fn test_mut_slice() {
	/*
	QTODO
	mut n := [1, 2, 3]
	//modify(mut n)
	modify(mut n[..2])
	assert n[0] == 777
	modify(mut n[2..])
	assert n[2] == 777
	println(n)
	*/
}

fn double_up(a mut []int) {
	for i := 0; i < a.len; i++ {
		a[i] = a[i]*2
	}
}

fn double_up_v2(a mut []int) {
	for i, _ in a {
		a[i] = a[i]*2 // or val*2, doesn't matter
	}
}

fn test_mut_arg() {
	mut arr := [1,2,3,4,5,6,7,8,9,10]
	double_up(mut arr)
	assert arr.str() == '[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]'
	arr = [1,2,3,4,5,6,7,8,9,10]
	double_up_v2(mut arr)
	assert arr.str() == '[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]'
}

fn test_clone() {
	nums := [1, 2, 3, 4, 100]
	nums2 := nums.clone()
	assert nums2.len == 5
	assert nums.str() == '[1, 2, 3, 4, 100]'
	assert nums2.str() == '[1, 2, 3, 4, 100]'
	assert nums.slice(1, 3).str() == '[2, 3]'
}

fn test_doubling() {
	mut nums := [1, 2, 3, 4, 5]
	for i in 0..nums.len {
		nums[i] *= 2
	}
	println(nums.str())
	assert nums.str() == '[2, 4, 6, 8, 10]'
}

struct Test2 {
	one int
	two int
}

struct Test {
	a string
mut:
	b []Test2
}

// TODO: default array/struct str methods
fn (ta []Test2) str() string {
	mut s := '['
	for i, t in ta {
		s += t.str()
		if i < ta.len-1 {
			s += ', '
		}
	}
	s += ']'
	return s
}

fn (t Test2) str() string {
	return '{$t.one $t.two}'
}

fn (t Test) str() string {
	return '{$t.a $t.b}'
}

fn test_struct_print() {
	mut a := Test{
		a: 'Test'
		b: []
	}
	b := Test2{
		one: 1
		two: 2
	}
	a.b << b
	a.b << b
	assert a.str() == '{Test [{1 2}, {1 2}]}'
	assert b.str() == '{1 2}'
	assert a.b.str() == '[{1 2}, {1 2}]'
}

fn test_single_element() {
	mut a := [1]
	a << 2
	assert a.len == 2
	assert a[0] == 1
	assert a[1] == 2
	println(a)
}

fn test_find_index() {
	// string
	a := ['v', 'is', 'great']
	assert a.index('v') == 0
	assert a.index('is') == 1
	assert a.index('gre') == -1
	// int
	b := [1, 2, 3, 4]
	assert b.index(1) == 0
	assert b.index(4) == 3
	assert b.index(5) == -1
	// byte
	c := [0x22, 0x33, 0x55]
	assert c.index(0x22) == 0
	assert c.index(0x55) == 2
	assert c.index(0x99) == -1
	// char
	d := [`a`, `b`, `c`]
	assert d.index(`b`) == 1
	assert d.index(`c`) == 2
	assert d.index(`u`) == -1
}

fn test_multi() {
	a := [[1, 2, 3], [4, 5, 6]]
	assert a.len == 2
	assert a[0].len == 3
	assert a[0][0] == 1
	assert a[0][2] == 3
	assert a[1][2] == 6
	// TODO
	// b :=  [ [[1,2,3],[4,5,6]], [[1,2]] ]
	// assert b[0][0][0] == 1
}

fn test_in() {
	a := [1, 2, 3]
	assert 1 in a
	assert 2 in a
	assert 3 in a
	assert !(4 in a)
	assert !(0 in a)
	assert 0 !in a
	assert 4 !in a
}

fn sum(prev int, curr int) int {
	return prev + curr
}

fn sub(prev int, curr int) int {
	return prev - curr
}

/*
fn test_reduce() {
	a := [1, 2, 3, 4, 5]
	b := a.reduce(sum, 0)
	c := a.reduce(sum, 5)
	d := a.reduce(sum, -1)
	assert b == 15
	assert c == 20
	assert d == 14
	e := [1, 2, 3]
	f := e.reduce(sub, 0)
	g := e.reduce(sub, -1)
	assert f == -6
	assert g == -7
}
*/

fn filter_test_helper_1(a int) bool {
	return a > 3
}

fn test_filter() {
	a := [1, 2, 3, 4, 5, 6]
	b := a.filter(it % 2 == 0)
	assert b.len == 3
	assert b[0] == 2
	assert b[1] == 4
	assert b[2] == 6
	c := ['v', 'is', 'awesome']
	d := c.filter(it.len > 1)
	assert d[0] == 'is'
	assert d[1] == 'awesome'
	////////
	arr :=[1,2,3,4,5,6,7,8,9,10]
	println(arr.filter(it % 2 == 0 || it % 3 == 0))
	assert true
	assert [1,2,3].len == 3
	mut mut_arr := [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	mut_arr = mut_arr.filter(it < 4)
	assert mut_arr.len == 3
	assert a.filter(filter_test_helper_1) == [4,5,6]
	assert [1,5,10].filter(filter_test_helper_1) == [5,10]

	// TODO
	//assert arr.filter(arr % 2).len == 5
}

fn map_test_helper_1(i int) int {
	return i * i
}
fn map_test_helper_2(i int, b string) int {
	return i + b.len
}
fn map_test_helper_3(i int, b []string) int {
	return i + b.map(it.len)[i % b.len]
}

fn test_map() {
	nums := [1, 2, 3, 4, 5, 6]
	strs := ['v', 'is', 'awesome']

	//assert nums.map() == <error>
	//assert nums.map(it, 'excessive') == <error>

	// identity
	assert nums.map(it) == [1, 2, 3, 4, 5, 6]
	assert strs.map(it) == ['v', 'is', 'awesome']
	assert nums.map(it - it) == [0,0,0,0,0,0]
	assert nums.map(it - it)[0] == 0

	// type switch
	assert nums.map(it * 10) == [10, 20, 30, 40, 50, 60]
	assert nums.map(it * it) == [1, 4, 9, 16, 25, 36]
	assert nums.map('$it') == ['1', '2', '3', '4', '5', '6']
	assert nums.map(it % 2 == 0) == [false, true, false, true, false, true]

	assert strs.map(it.to_upper()) == ['V', 'IS', 'AWESOME']
	assert strs.map(it == 'awesome') == [false, false, true]
	assert strs.map(it.len in nums) == [true, true, false]
	assert strs.map(7) == [7, 7, 7]

	// external func
	assert nums.map(map_test_helper_1(it)) == [1, 4, 9, 16, 25, 36]
	assert nums.map(map_test_helper_2(it, 'bb')) == [3, 4, 5, 6, 7, 8]
	assert nums.map(map_test_helper_3(it, strs)) == [3, 9, 4, 6, 12, 7]

	// empty array as input
	assert []int{len:0}.map(it * 2) == []

	// nested maps (where it is of same type)
	assert nums.map( strs.map(7) == [7, 7, 7] ) == [true, true, true, true, true, true]
	assert nums.map( '$it' + strs.map('a')[0] ) == ['1a', '2a', '3a', '4a', '5a', '6a']
	assert nums.map( it + strs.map(7)[0] ) == [8, 9, 10, 11, 12, 13]
	assert nums.map( it + strs.map(it.len)[0] ) == [2, 3, 4, 5, 6, 7]
	assert strs.map( it.len + strs.map(it.len)[0] ) == [2, 3, 8]

	// nested (different it types)
	assert strs.map( it[ nums.map(it - it)[0] ] ) == [`v`, `i`, `a`]
	assert nums[0..3].map('$it' + strs.map(it)[it-1]) == ['1v','2is','3awesome']

	assert nums.map(map_test_helper_1) == [1,4,9,16,25,36]
	assert [1,5,10].map(map_test_helper_1) == [1,25,100]

	assert nums == [1, 2, 3, 4, 5, 6]
	assert strs == ['v', 'is', 'awesome']
}

fn test_array_str() {
	numbers := [1, 2, 3]
	assert numbers == [1,2,3]
	numbers2 := [numbers, [4, 5, 6]] // dup str() bug
	_=numbers2
	assert true
	assert numbers.str() == '[1, 2, 3]'
	// QTODO
	//assert numbers2.str() == '[[1, 2, 3], [4, 5, 6]]'

}

fn test_eq() {
	/*
	assert [5, 6, 7].eq([6, 7]) == false
	assert [`a`, `b`].eq([`a`, `b`]) == true
	*/
}

fn test_sort() {
	mut a := ['hi', '1', '5', '3']
	a.sort()
	assert a[0] == '1'
	assert a[1] == '3'
	assert a[2] == '5'
	assert a[3] == 'hi'
	//
	mut nums := [67, -3, 108, 42, 7]
	nums.sort()
	assert nums[0] == -3
	assert nums[1] == 7
	assert nums[2] == 42
	assert nums[3] == 67
	assert nums[4] == 108
}

fn test_f32_sort() {
	mut f := [f32(50.0), 15, 1, 79, 38, 0, 27]
	f.sort_with_compare(compare_f32)
	assert f[0] == 0.0
	assert f[1] == 1.0
	assert f[6] == 79.0
}

fn test_f64_sort() {
	mut f := [50.0, 15, 1, 79, 38, 0, 27]
	f.sort_with_compare(compare_f64)
	assert f[0] == 0.0
	assert f[1] == 1.0
	assert f[6] == 79.0
}

fn test_i64_sort() {
	mut f := [i64(50), 15, 1, 79, 38, 0, 27]
	f.sort_with_compare(compare_i64)
	assert f[0] == 0
	assert f[1] == 1
	assert f[6] == 79
}

/*
fn test_for_last() {
	numbers := [1, 2, 3, 4]
	mut s := '['
	for num in numbers {
		s += '$num'
		if !last {
			s += ', '

		}
	}
	s += ']'
	assert s == '[1, 2, 3, 4]'
}
*/


struct Foo {
mut:
	bar []int
}

fn test_in_struct() {
	mut baz := Foo{
		bar: [0, 0, 0]
	}
	baz.bar[0] += 2
	baz.bar[0]++
	assert baz.bar[0] == 3
}

fn test_bools() {
	println('test b')
	mut a := [true, false]
	a << true
	println(a)
}

fn test_push_many_self() {
    mut actual_arr := [1, 2, 3, 4]
    actual_arr << actual_arr
    expected_arr := [1, 2, 3, 4, 1, 2, 3, 4]
    assert actual_arr.len == expected_arr.len
    for i in 0..actual_arr.len {
        assert actual_arr[i] == expected_arr[i]
    }
}

fn test_for() {
	nums := [1,2,3]
	mut sum := 0
	for num in nums {
		sum += num
	}
	assert sum == 6
}

fn test_clear() {
	mut arr := [1,2,3]
	assert arr.len == 3
	arr.clear()
	assert arr.len == 0

	arr << 3
	arr << 2
	arr << 1
	arr << 0
	assert arr.len == 4
	assert arr[0] == 3
	assert arr[1] == 2
	assert arr[2] == 1
	assert arr[3] == 0

	arr.clear()
	assert arr.len == 0
}

fn test_trim() {
	mut arr := [1,2,3,4,5,6,7,8,9]
	assert arr.len == 9

	arr.trim(9)
	assert arr.len == 9
	assert arr.last() == 9

	arr.trim(7)
	assert arr.len == 7
	assert arr.last() == 7

	arr.trim(2)
	assert arr.len == 2
	assert arr.last() == 2
}

fn test_hex(){
	// array hex
	st := [byte(`V`),`L`,`A`,`N`,`G`]
	assert st.hex() == "564c414e47"
	assert st.hex().len == 10

	st1 := [byte(0x41)].repeat(100)
	assert st1.hex() == "41".repeat(100)
}

fn test_left_shift_precendence() {
	mut arr := []int{}
	arr << 1 + 1
	arr << 1 - 1
	arr << 2 / 1
	arr << 2 * 1

	assert arr[0] == 2
	assert arr[1] == 0
	assert arr[2] == 2
	assert arr[3] == 2
}

fn test_array_with_cap() {
	a4 := []int{cap:10, len:1 }
	assert a4.len == 1
	assert a4.cap == 10
	a5 := []int{len:1, cap:10}
	assert a5.len == 1
	assert a5.cap == 10
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builtin

__global g_m2_buf byteptr
__global g_m2_ptr byteptr

pub fn exit(code int) {
	C.exit(code)
}

// isnil returns true if an object is nil (only for C objects).
pub fn isnil(v voidptr) bool {
	return v == 0
}

/*
fn on_panic(f fn(int)int) {
	// TODO
}
*/

pub fn print_backtrace() {
	// at the time of backtrace_symbols_fd call, the C stack would look something like this:
	// 1 frame for print_backtrace_skipping_top_frames
	// 1 frame for print_backtrace itself
	// ... print the rest of the backtrace frames ...
	// => top 2 frames should be skipped, since they will not be informative to the developer
	print_backtrace_skipping_top_frames(2)
}

// replaces panic when -debug arg is passed
fn panic_debug(line_no int, file, mod, fn_name, s string) {
	// NB: the order here is important for a stabler test output
	// module is less likely to change than function, etc...
	// During edits, the line number will change most frequently,
	// so it is last
	eprintln('================ V panic ================')
	eprintln('   module: $mod')
	eprintln(' function: ${fn_name}()')
	eprintln('  message: $s')
	eprintln('     file: $file')
	eprintln('     line: ' + line_no.str())
	eprintln('=========================================')
	print_backtrace_skipping_top_frames(1)
	C.exit(1)
}

pub fn panic(s string) {
	eprintln('V panic: $s')
	print_backtrace()
	C.exit(1)
}

pub fn eprintln(s string) {
	// eprintln is used in panics, so it should not fail at all
	if s.str == 0 {
		eprintln('eprintln(NIL)')
	}
	$if !windows {
		C.fflush(C.stdout)
		C.fflush(C.stderr)
		C.fprintf(C.stderr, '%.*s\n', s.len, s.str)
		C.fflush(C.stderr)
		return
	}
	// TODO issues with stderr and cross compiling for Linux
	println(s)
}

pub fn eprint(s string) {
	if s.str == 0 {
		eprintln('eprint(NIL)')
	}
	$if !windows {
		C.fflush(C.stdout)
		C.fflush(C.stderr)
		C.fprintf(C.stderr, '%.*s', s.len, s.str)
		C.fflush(C.stderr)
		return
	}
	print(s)
}

pub fn print(s string) {
	$if windows {
		output_handle := C.GetStdHandle(C.STD_OUTPUT_HANDLE)
		mut bytes_written := 0
		if is_atty(1) > 0 {
			wide_str := s.to_wide()
			wide_len := C.wcslen(wide_str)
			C.WriteConsole(output_handle, wide_str, wide_len, &bytes_written, 0)
			unsafe {
				free(wide_str)
			}
		} else {
			C.WriteFile(output_handle, s.str, s.len, &bytes_written, 0)
		}
	} $else {
		C.printf('%.*s', s.len, s.str)
	}
}

const (
	new_line_character = '\n'
)
pub fn println(s string) {
	$if windows {
		print(s)
		print(new_line_character)
	} $else {
		//  TODO: a syscall sys_write on linux works, except for the v repl.
		//  Probably it is a stdio buffering issue. Needs more testing...
		//	$if linux {
		//		$if !android {
		//			snl := s + '\n'
		//			C.syscall(/* sys_write */ 1, /* stdout_value */ 1, snl.str, s.len+1)
		//			return
		//		}
		//	}
		C.printf('%.*s\n', s.len, s.str)
	}
}

__global total_m i64=0
__global nr_mallocs int=0

fn looo(){} // TODO remove, [ pratt

[unsafe_fn]
pub fn malloc(n int) byteptr {
	if n <= 0 {
		panic('malloc(<=0)')
	}
	$if prealloc {
		res := g_m2_ptr
		g_m2_ptr += n
		nr_mallocs++
		return res
	} $else {
		ptr := C.malloc(n)
		if ptr == 0 {
			panic('malloc($n) failed')
		}
		return ptr
	}
	/*
TODO
#ifdef VPLAY
	if n > 10000 {
		panic('allocating more than 10 KB is not allowed in the playground')
	}
#endif
#ifdef DEBUG_ALLOC
	total_m += n
	println('\n\n\nmalloc($n) total=$total_m')
	print_backtrace()
#endif
*/

}

pub fn v_calloc(n int) byteptr {
	return C.calloc(n, 1)
}

pub fn vcalloc(n int) byteptr {
	if n < 0 {
		panic('calloc(<=0)')
	} else if n == 0 {
		return byteptr(0)
	} else {
		return C.calloc(n, 1)
	}
}

[unsafe_fn]
pub fn free(ptr voidptr) {
	C.free(ptr)
}

pub fn memdup(src voidptr, sz int) voidptr {
	if sz == 0 {
		return vcalloc(1)
	}
	mem := malloc(sz)
	return C.memcpy(mem, src, sz)
}

fn v_ptr_free(ptr voidptr) {
	C.free(ptr)
}

pub fn is_atty(fd int) int {
	$if windows {
		mut mode := u32(0)
		osfh := voidptr(C._get_osfhandle(fd))
		C.GetConsoleMode(osfh, voidptr(&mode))
		return int(mode)
	} $else {
		return C.isatty(fd)
	}
}

fn __as_cast(obj voidptr, obj_type, expected_type int) voidptr {
	if obj_type != expected_type {
		panic('as cast: cannot cast $obj_type to $expected_type')
	}
	return obj
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builtin

//pub fn vsyscall(id int
//

/*
pub const (
	sys_write = 1
	sys_mkdir = 83
)
const (
	stdin_value = 0
	stdout_value = 1
	stderr_value  = 2
)

fn C.puts(charptr)
*/

fn builtin_init() {
	// Do nothing
}

fn print_backtrace_skipping_top_frames(xskipframes int) bool {
	skipframes := xskipframes + 2
	$if macos {
		return print_backtrace_skipping_top_frames_mac(skipframes)
	}
	$if linux {
		return print_backtrace_skipping_top_frames_linux(skipframes)
	}
	$if freebsd {
		return print_backtrace_skipping_top_frames_freebsd(skipframes)
	}
	$if netbsd {
		return print_backtrace_skipping_top_frames_freebsd(skipframes)
	}
	$if openbsd {
		return print_backtrace_skipping_top_frames_freebsd(skipframes)
	}
	println('print_backtrace_skipping_top_frames is not implemented. skipframes: $skipframes')
	return false
}

// the functions below are not called outside this file,
// so there is no need to have their twins in builtin_windows.v
fn print_backtrace_skipping_top_frames_mac(skipframes int) bool {
	$if macos {
		buffer := [100]byteptr
		nr_ptrs := C.backtrace(buffer, 100)
		C.backtrace_symbols_fd(&buffer[skipframes], nr_ptrs - skipframes, 2)
	}
	return true
}

fn print_backtrace_skipping_top_frames_freebsd(skipframes int) bool {
	$if freebsd {
		buffer := [100]byteptr
		nr_ptrs := C.backtrace(buffer, 100)
		C.backtrace_symbols_fd(&buffer[skipframes], nr_ptrs - skipframes, 2)
	}
	return true
}

fn print_backtrace_skipping_top_frames_linux(skipframes int) bool {
	$if android {
		eprintln('On Android no backtrace is available.')
		return false
	}
	$if !glibc {
		eprintln('backtrace_symbols is missing => printing backtraces is not available.')
		eprintln('Some libc implementations like musl simply do not provide it.')
		return false
	}
	$if tinyc {
		eprintln('TODO: print_backtrace_skipping_top_frames_linux $skipframes')
		eprintln('with tcc fails tests with "stack smashing detected" .')
		return false
	}
	buffer := [100]byteptr
	nr_ptrs := C.backtrace(buffer, 100)
	nr_actual_frames := nr_ptrs - skipframes
	mut sframes := []string{}
	//////csymbols := backtrace_symbols(*voidptr(&buffer[skipframes]), nr_actual_frames)
	csymbols := C.backtrace_symbols(&buffer[skipframes], nr_actual_frames)
	for i in 0 .. nr_actual_frames {
		sframes << tos2( byteptr(csymbols[i]) )
	}
	for sframe in sframes {
		executable := sframe.all_before('(')
		addr := sframe.all_after('[').all_before(']')
		beforeaddr := sframe.all_before('[')
		cmd := 'addr2line -e $executable $addr'
		// taken from os, to avoid depending on the os module inside builtin.v
		f := C.popen(cmd.str, 'r')
		if isnil(f) {
			eprintln(sframe)
			continue
		}
		buf := [1000]byte
		mut output := ''
		for C.fgets(charptr(buf), 1000, f) != 0 {
			output += tos(byteptr(buf), vstrlen(byteptr(buf)))
		}
		output = output.trim_space() + ':'
		if C.pclose(f) != 0 {
			eprintln(sframe)
			continue
		}
		if output in ['??:0:', '??:?:'] {
			output = ''
		}
		// See http://wiki.dwarfstd.org/index.php?title=Path_Discriminators
		// NB: it is shortened here to just d. , just so that it fits, and so
		// that the common error file:lineno: line format is enforced.
		output = output.replace(' (discriminator', ': (d.')
		eprintln('${output:-46s} | ${addr:14s} | $beforeaddr')
	}
	return true
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module builtin

// dbghelp.h is already included in cheaders.v
#flag windows -l dbghelp

pub struct SymbolInfo {
pub mut:
	f_size_of_struct u32 // must be 88 to be recognised by SymFromAddr
	f_type_index u32 // Type Index of symbol
	f_reserved [2]u64
	f_index u32
	f_size u32
	f_mod_base u64 // Base Address of module comtaining this symbol
	f_flags u32
	f_value u64 // Value of symbol, ValuePresent should be 1
	f_address u64 // Address of symbol including base address of module
	f_register u32 // register holding value or pointer to value
	f_scope u32 // scope of the symbol
	f_tag u32 // pdb classification
	f_name_len u32 // Actual length of name
	f_max_name_len u32 // must be manually set
	f_name byte // must be calloc(f_max_name_len)
}

pub struct SymbolInfoContainer {
pub mut:
	syminfo SymbolInfo
	f_name_rest [254]char
}

pub struct Line64 {
pub mut:
	f_size_of_struct u32
	f_key voidptr
	f_line_number u32
	f_file_name byteptr
	f_address u64
}

fn C.SymSetOptions(symoptions u32) u32 // returns the current options mask
fn C.GetCurrentProcess() voidptr // returns handle
fn C.SymInitialize(h_process voidptr, p_user_search_path byteptr, b_invade_process int) int
fn C.CaptureStackBackTrace(frames_to_skip u32, frames_to_capture u32, p_backtrace voidptr, p_backtrace_hash voidptr) u16
fn C.SymFromAddr(h_process voidptr, address u64, p_displacement voidptr, p_symbol voidptr) int
fn C.SymGetLineFromAddr64(h_process voidptr, address u64, p_displacement voidptr, p_line &Line64) int

// Ref - https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nf-dbghelp-symsetoptions
const (
	symopt_undname = 0x00000002
	symopt_deferred_loads = 0x00000004
	symopt_no_cpp = 0x00000008
	symopt_load_lines = 0x00000010
	symopt_include_32bit_modules = 0x00002000
	symopt_allow_zero_address = 0x01000000
	symopt_debug = 0x80000000
)

fn builtin_init() {
	if is_atty(1) > 0 {
		C.SetConsoleMode(C.GetStdHandle(C.STD_OUTPUT_HANDLE), C.ENABLE_PROCESSED_OUTPUT | 0x0004) // enable_virtual_terminal_processing
		C.setbuf(C.stdout, 0)
	}
}

fn print_backtrace_skipping_top_frames(skipframes int) bool {
	$if msvc {
		return print_backtrace_skipping_top_frames_msvc(skipframes)
	}
	$if mingw {
		return print_backtrace_skipping_top_frames_mingw(skipframes)
	}
	eprintln('print_backtrace_skipping_top_frames is not implemented')
	return false
}

fn print_backtrace_skipping_top_frames_msvc(skipframes int) bool {
$if msvc {
	mut offset := u64(0)
	backtraces := [100]voidptr
	sic := SymbolInfoContainer{}
	mut si := &sic.syminfo
	si.f_size_of_struct = sizeof(SymbolInfo) // Note: C.SYMBOL_INFO is 88
	si.f_max_name_len = sizeof(SymbolInfoContainer) - sizeof(SymbolInfo) - 1
	fname := charptr( &si.f_name )
	mut sline64 := Line64{}
	sline64.f_size_of_struct = sizeof(Line64)

	handle := C.GetCurrentProcess()
	defer { C.SymCleanup(handle) }

	C.SymSetOptions(symopt_debug | symopt_load_lines | symopt_undname)

	syminitok := C.SymInitialize( handle, 0, 1)
	if syminitok != 1 {
		eprintln('Failed getting process: Aborting backtrace.\n')
		return true
	}

	frames := int(C.CaptureStackBackTrace(skipframes + 1, 100, backtraces, 0))
	for i in 0..frames {
		frame_addr := backtraces[i]
		if C.SymFromAddr(handle, frame_addr, &offset, si) == 1 {
			nframe := frames - i - 1
			mut lineinfo := ''
			if C.SymGetLineFromAddr64(handle, frame_addr, &offset, &sline64) == 1 {
				file_name := tos3(sline64.f_file_name)
				lineinfo = '${file_name}:${sline64.f_line_number}'
			} else {
				addr :
				lineinfo = '?? : address = 0x${(&frame_addr):x}'
			}
			sfunc := tos3(fname)
			eprintln('${nframe:-2d}: ${sfunc:-25s}  $lineinfo')
		} else {
			// https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes
			cerr := int(C.GetLastError())
			if cerr == 87 {
				eprintln('SymFromAddr failure: $cerr = The parameter is incorrect)')
			} else if cerr == 487 {
				// probably caused because the .pdb isn't in the executable folder
				eprintln('SymFromAddr failure: $cerr = Attempt to access invalid address (Verify that you have the .pdb file in the right folder.)')
			} else {
				eprintln('SymFromAddr failure: $cerr (see https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes)')
			}
		}
	}
	return true
} $else {
	eprintln('print_backtrace_skipping_top_frames_msvc must be called only when the compiler is msvc')
	return false
}
}

fn print_backtrace_skipping_top_frames_mingw(skipframes int) bool {
	eprintln('print_backtrace_skipping_top_frames_mingw is not implemented')
	return false
}
fn test_clone() {
	a := [byte(0), 1, 2] 
	b := a.clone()
	assert b.len == 3
	assert b[0] == 0 
	assert b[1] == 1 
	assert b[2] == 2 
} 
module builtin

// <string.h>
fn C.memcpy(byteptr, byteptr, int) voidptr


fn C.memmove(byteptr, byteptr, int) voidptr
fn C.calloc(int)  byteptr
fn C.malloc(int) byteptr
fn C.realloc(a byteptr, b int) byteptr
fn C.free(ptr voidptr)
fn C.exit(code int)


fn C.qsort(voidptr, int, int, qsort_callback_func)


fn C.sprintf(a ...voidptr) int


fn C.strlen(s byteptr) int


fn C.isdigit(s byteptr) bool
// stdio.h
fn C.popen(c byteptr, t byteptr) voidptr

// <execinfo.h>
fn C.backtrace(a &voidptr, size int) int
fn C.backtrace_symbols(a &voidptr, size int)  &charptr
fn C.backtrace_symbols_fd(a &voidptr, size int, fd int)

// <libproc.h>
pub fn proc_pidpath(int, voidptr, int) int


fn C.realpath(byteptr, byteptr) &char


fn C.chmod(byteptr, int) int


fn C.printf(byteptr, ...byteptr) int


fn C.fputs(byteptr) int


fn C.fflush(byteptr) int
// TODO define args in these functions
fn C.fseek() int


fn C.fopen() voidptr


fn C.fileno(voidptr) int


fn C.fwrite() int


fn C.fclose() int


fn C.pclose() int


fn C.system() int


fn C.setenv() int


fn C.unsetenv() int


fn C.access() int


fn C.remove() int


fn C.rmdir() int


fn C.chdir() int


fn C.fread() int


fn C.rewind() int


fn C.stat() int


fn C.lstat() int


fn C.rename() int


fn C.fgets() int


fn C.memset() int


fn C.sigemptyset() int


fn C.getcwd() int


fn C.signal() int


fn C.mktime() int


fn C.gettimeofday() int


fn C.sleep() int


fn C.usleep() int


fn C.opendir() voidptr


fn C.closedir() int


fn C.mkdir() int


fn C.srand() int


fn C.atof() int


fn C.tolower() int


fn C.toupper() int


fn C.getchar() int


fn C.strerror(int) charptr


fn C.snprintf() int


fn C.fprintf(byteptr, ...byteptr)


fn C.WIFEXITED() bool


fn C.WEXITSTATUS() int


fn C.WIFSIGNALED() bool


fn C.WTERMSIG() int


fn C.DEFAULT_LE() bool


fn C.DEFAULT_EQ() bool


fn C.DEFAULT_GT() bool


fn C.DEFAULT_EQUAL() bool


fn C.DEFAULT_NOT_EQUAL() bool


fn C.DEFAULT_LT() bool


fn C.DEFAULT_GE() bool


fn C.isatty() int


fn C.syscall() int


fn C.sysctl() int


fn C._fileno(int) int


fn C._get_osfhandle(fd int) C.intptr_t


fn C.GetModuleFileNameW(hModule voidptr, lpFilename &u16, nSize u32) u32


fn C.CreatePipe(hReadPipe &voidptr, hWritePipe &voidptr, lpPipeAttributes voidptr, nSize u32) bool


fn C.SetHandleInformation(hObject voidptr, dwMask u32, dw_flags u32) bool


fn C.ExpandEnvironmentStringsW(lpSrc &u16, lpDst &u16, nSize u32) u32


fn C.CreateProcessW(lpApplicationName &u16, lpCommandLine &u16, lpProcessAttributes voidptr, lpThreadAttributes voidptr, bInheritHandles bool, dwCreationFlags u32, lpEnvironment voidptr, lpCurrentDirectory &u16, lpStartupInfo voidptr, lpProcessInformation voidptr) bool


fn C.ReadFile(hFile voidptr, lpBuffer voidptr, nNumberOfBytesToRead u32, lpNumberOfBytesRead voidptr, lpOverlapped voidptr) bool


fn C.GetFileAttributesW(lpFileName byteptr) u32


fn C.RegQueryValueExW(hKey voidptr, lpValueName &u16, lp_reserved &u32, lpType &u32, lpData byteptr, lpcbData &u32) int


fn C.RegOpenKeyExW(hKey voidptr, lpSubKey &u16, ulOptions u32, samDesired u32, phkResult voidptr) int


fn C.RegCloseKey()


fn C.RegQueryValueEx() voidptr


fn C.RemoveDirectory() int


//fn C.GetStdHandle() voidptr
fn C.GetStdHandle(u32) voidptr


//fn C.SetConsoleMode()
fn C.SetConsoleMode(voidptr, u32)


//fn C.GetConsoleMode() int
fn C.GetConsoleMode(voidptr, &u32) int


fn C.wprintf()


//fn C.setbuf()
fn C.setbuf(voidptr, charptr)


fn C.SymCleanup()


fn C.MultiByteToWideChar() int


fn C.wcslen() int


fn C.WideCharToMultiByte() int


fn C._wstat()


fn C._wrename()


fn C._wfopen() voidptr


fn C._wpopen() voidptr


fn C._pclose() int


fn C._wsystem() int


fn C._wgetenv() voidptr


fn C._putenv() int


fn C._waccess() int


fn C._wremove()


fn C.ReadConsole() voidptr


fn C.WriteConsole() voidptr


fn C.WriteFile() voidptr


fn C.GetModuleFileName() int


fn C._wchdir()


fn C._wgetcwd() int


fn C._fullpath() int


fn C.GetCommandLine() voidptr


fn C.LocalFree()


fn C.FindFirstFileW() voidptr


fn C.FindFirstFile() voidptr


fn C.FindNextFile() int


fn C.FindClose()


fn C.MAKELANGID() int


fn C.FormatMessage() voidptr


fn C.CloseHandle()


fn C.GetExitCodeProcess()


fn C.RegOpenKeyEx() voidptr


fn C.GetTickCount() i64


fn C.Sleep()


fn C.WSAStartup(u16, &voidptr) int


fn C.WSAGetLastError() int


fn C.closesocket(int) int


fn C.vschannel_init(&C.TlsContext)


fn C.request(&C.TlsContext, int, &u16, byteptr, &byteptr)


fn C.vschannel_cleanup(&C.TlsContext)


fn C.URLDownloadToFile(int, &u16, &u16, int, int)


fn C.GetLastError() u32


fn C.CreateDirectory(byteptr, int) bool


fn C.BCryptGenRandom(int, voidptr, int, int) int


fn C.CreateMutex(int, bool, byteptr) voidptr


fn C.WaitForSingleObject(voidptr, int) int


fn C.ReleaseMutex(voidptr) bool

// pthread.h

fn C.pthread_mutex_init(voidptr, voidptr) int
fn C.pthread_mutex_lock(voidptr) int
fn C.pthread_mutex_unlock(voidptr) int

// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builtin

import strconv.ftoa

#include <float.h>
// ----- f64 to string functions -----
// str return a f64 as string in scientific notation, auto display digits limit
[inline]
pub fn (d f64) str() string {
	return ftoa.ftoa_64(d)
}

// return a string of the input f64 in scientific notation with digit_num deciamals displayed, max 17 digits
[inline]
pub fn (x f64) strsci(digit_num int) string {
	mut n_digit := digit_num
	if n_digit < 1 {
		n_digit = 1
	} else if n_digit > 17 {
		n_digit = 17
	}
	return ftoa.f64_to_str(x, n_digit)
}

// return a decimal notation of the input f64
[inline]
pub fn (x f64) strlong() string {
	return ftoa.f64_to_str_l(x)
}

// ----- f32 to string functions -----
// str return a f32 as string in scientific notation, auto display digits limit
[inline]
pub fn (d f32) str() string {
	return ftoa.ftoa_32(d)
}

// return a string of the input f32 in scientific notation with digit_num deciamals displayed, max 8 digits
[inline]
pub fn (x f32) strsci(digit_num int) string {
	mut n_digit := digit_num
	if n_digit < 1 {
		n_digit = 1
	} else if n_digit > 8 {
		n_digit = 8
	}
	return ftoa.f32_to_str(x, n_digit)
}

// return a decimal notation of the input f32
[inline]
pub fn (x f32) strlong() string {
	return ftoa.f32_to_str_l(x)
}

// ----- C functions -----
[inline]
fn f32_abs(a f32) f32 {
	return if a < 0 {
		-a
	} else {
		a
	}
}

[inline]
fn f64_abs(a f64) f64 {
	return if a < 0 {
		-a
	} else {
		a
	}
}

// compare floats using C epsilon
// ==
[inline]
pub fn (a f64) eq(b f64) bool {
	return f64_abs(a - b) <= C.DBL_EPSILON
}

[inline]
pub fn (a f32) eq(b f32) bool {
	return f32_abs(a - b) <= C.FLT_EPSILON
}

pub fn (a f64) eqbit(b f64) bool {
	return C.DEFAULT_EQUAL(a, b)
}

pub fn (a f32) eqbit(b f32) bool {
	return C.DEFAULT_EQUAL(a, b)
}

// !=
fn (a f64) ne(b f64) bool {
	return !a.eq(b)
}

fn (a f32) ne(b f32) bool {
	return !a.eq(b)
}

pub fn (a f64) nebit(b f64) bool {
	return C.DEFAULT_NOT_EQUAL(a, b)
}

pub fn (a f32) nebit(b f32) bool {
	return C.DEFAULT_NOT_EQUAL(a, b)
}

// a < b
fn (a f64) lt(b f64) bool {
	return a.ne(b) && a.ltbit(b)
}

fn (a f32) lt(b f32) bool {
	return a.ne(b) && a.ltbit(b)
}

fn (a f64) ltbit(b f64) bool {
	return C.DEFAULT_LT(a, b)
}

fn (a f32) ltbit(b f32) bool {
	return C.DEFAULT_LT(a, b)
}

// a <= b
fn (a f64) le(b f64) bool {
	return !a.gt(b)
}

fn (a f32) le(b f32) bool {
	return !a.gt(b)
}

fn (a f64) lebit(b f64) bool {
	return C.DEFAULT_LE(a, b)
}

fn (a f32) lebit(b f32) bool {
	return C.DEFAULT_LE(a, b)
}

// a > b
fn (a f64) gt(b f64) bool {
	return a.ne(b) && a.gtbit(b)
}

fn (a f32) gt(b f32) bool {
	return a.ne(b) && a.gtbit(b)
}

fn (a f64) gtbit(b f64) bool {
	return C.DEFAULT_GT(a, b)
}

fn (a f32) gtbit(b f32) bool {
	return C.DEFAULT_GT(a, b)
}

// a >= b
fn (a f64) ge(b f64) bool {
	return !a.lt(b)
}

fn (a f32) ge(b f32) bool {
	return !a.lt(b)
}

fn (a f64) gebit(b f64) bool {
	return C.DEFAULT_GE(a, b)
}

fn (a f32) gebit(b f32) bool {
	return C.DEFAULT_GE(a, b)
}
fn test_float_decl() {
  x1 := 1e10
  x2 := -2e16
  x3 := 1e-15
  x4 := -9e-4
  assert typeof(x1) == 'f64'
  assert typeof(x2) == 'f64'
  assert typeof(x3) == 'f64'
  assert typeof(x4) == 'f64'
  x5 := 4e108
  x6 := -7e99
  x7 := 3e-205
  x8 := -6e-147
  assert typeof(x5) == 'f64'
  assert typeof(x6) == 'f64'
  assert typeof(x7) == 'f64'
  assert typeof(x8) == 'f64'
  x9 := 312874834.77
  x10 := -22399994.06
  x11 := 0.0000000019
  x12 := -0.00000000008
  assert typeof(x9) == 'f64'
  assert typeof(x10) == 'f64'
  assert typeof(x11) == 'f64'
  assert typeof(x12) == 'f64'
  x13 := 34234234809890890898903213154353453453253253243432413232228908902183918392183902432432438980380123021983901392183921389083913890389089031.0
  x14 := -39999999999999999999222212128182813294989082302832183928343325325233253242312331324392839238239829389038097438248932789371837218372837293.8
  x15 := 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002
  x16 := -0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
  assert typeof(x13) == 'f64'
  assert typeof(x14) == 'f64'
  assert typeof(x15) == 'f64'
  assert typeof(x16) == 'f64'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builtin

/*
// old function for reference
pub fn (nn int) str1() string {
	mut n := nn
	if n == 0 {
		return '0'
	}
	max := 16
	mut buf := vcalloc(max + 1)
	mut len := 0
	mut is_neg := false
	if n < 0 {
		n = -n
		is_neg = true
	}
	// Fill the string from the end
	for n > 0 {
		d := n % 10
		buf[max - len - 1] = d + int(`0`)
		len++
		n = n / 10
	}
	// Prepend - if it's negative
	if is_neg {
		buf[max - len - 1] = `-`
		len++
	}
	buf[max] = `\0`
	return tos(buf + max - len, len)
}
*/

// ----- value to string functions -----

/*
// old function for reference
pub fn ptr_str(ptr voidptr) string {
	buf := malloc(sizeof(double) * 5 + 1) // TODO
	C.sprintf((buf), '%p', ptr)
	return tos(buf, vstrlen(buf))
}
*/

pub fn ptr_str(ptr voidptr) string {
	buf1 := u64(ptr).hex()
	return buf1
}

const(
	digit_pairs = "00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999"
)

// This implementation is the quickest with gcc -O2
[inline]
pub fn (nn int) str_l(max int) string {
	mut n := nn
	mut d := 0
	if n == 0 {
		return '0'
	}
	mut buf := malloc(max + 1)

	mut is_neg := false
	if n < 0 {
		n = -n
		is_neg = true
	}

	mut index := max
	buf[index--] = `\0`
	for n > 0 {
		n1 := n / 100
		d = ((n - (n1 * 100)) << 1)
		n = n1
		buf[index--] = digit_pairs.str[d++]
		buf[index--] = digit_pairs.str[d]
	}
	index++

	// remove head zero
	if d < 20 {
		index++
	}

	// Prepend - if it's negative
	if is_neg {
		index--
		buf[index] = `-`
	}

	C.memmove(buf,buf+index, (max-index)+1 )
	return tos(buf, (max-index))
	//return tos(buf + index, (max-index))
}

pub fn (n i8) str() string {
	return int(n).str_l(5)
}

pub fn (n i16) str() string {
	return int(n).str_l(7)
}

pub fn (n u16) str() string {
	return int(n).str_l(7)
}

pub fn (n int) str() string {
	return n.str_l(12)
}

pub fn (nn u32) str() string {
	mut n := nn
	mut d := u32(0)
	if n == 0 {
		return '0'
	}
	max := 12
	mut buf := malloc(max + 1)

	mut index := max
	buf[index--] = `\0`
	for n > 0 {
		n1 := n / u32(100)
		d = ((n - (n1 * u32(100))) << u32(1))
		n = n1
		buf[index--] = digit_pairs[d++]
		buf[index--] = digit_pairs[d]
	}
	index++

	// remove head zero
	if d < u32(20) {
		index++
	}

	C.memmove(buf,buf+index, (max-index)+1 )
	return tos(buf, (max-index))
	//return tos(buf + index, (max-index))
}

pub fn (nn i64) str() string {
	mut n := nn
	mut d := i64(0)
	if n == 0 {
		return '0'
	}
	max := 20
	mut buf := vcalloc(max + 1)

	mut is_neg := false
	if n < 0 {
		n = -n
		is_neg = true
	}

	mut index := max
	buf[index--] = `\0`
	for n > 0 {
		n1 := n / i64(100)
		d = ((n - (n1 * i64(100))) << i64(1))
		n = n1
		buf[index--] = digit_pairs[d++]
		buf[index--] = digit_pairs[d]
	}
	index++

	// remove head zero
	if d < i64(20) {
		index++
	}

	// Prepend - if it's negative
	if is_neg {
		index--
		buf[index] = `-`
	}

	C.memmove(buf,buf+index, (max-index)+1 )
	return tos(buf, (max-index))
	//return tos(buf + index, (max-index))
}

pub fn (nn u64) str() string {
	mut n := nn
	mut d := 0
	if n == 0 {
		return '0'
	}
	max := 20
	mut buf := vcalloc(max + 1)

	mut index := max
	buf[index--] = `\0`
	for n > 0 {
		n1 := n / 100
		d = ((n - (n1 * 100)) << 1)
		n = n1
		buf[index--] = digit_pairs[d++]
		buf[index--] = digit_pairs[d]
	}
	index++

	// remove head zero
	if d < 20 {
		index++
	}

	C.memmove(buf,buf+index, (max-index)+1 )
	return tos(buf, (max-index))
	//return tos(buf + index, (max-index))
}

pub fn (b bool) str() string {
	if b {
		return 'true'
	}
	return 'false'
}

// ----- value to hex string functions -----

/*
//old function for reference
pub fn (n int) hex1() string {
	len := if n >= 0 { n.str().len + 3 } else { 11 }
	hex := malloc(len) // 0x + \n
	count := C.sprintf((hex), '0x%x', n)
	return tos(hex, count)
}
*/

pub fn (nn byte) hex() string {
	if nn == 0 {
		return '0'
	}

	mut n := nn
	max := 2
	mut buf := malloc(max + 1)

	mut index := max
	buf[index--] = `\0`
	for n > 0 {
		d := n & 0xF
		n = n >> 4
		buf[index--] = if d < 10 { d + `0` } else { d + 87 }
	}
	//buf[index--] = `x`
	//buf[index]   = `0`
	index++

	return tos(buf + index, (max - index))
}

pub fn (nn i8) hex() string {
	return byte(nn).hex()
}

pub fn (nn u16) hex() string {
	if nn == 0 {
		return '0'
	}

	mut n := nn
	max := 5
	mut buf := malloc(max + 1)

	mut index := max
	buf[index--] = `\0`
	for n > 0 {
		d := n & 0xF
		n = n >> 4
		buf[index--] = if d < 10 { d + `0` } else { d + 87 }
	}
	//buf[index--] = `x`
	//buf[index]   = `0`
	index++

	return tos(buf + index, (max - index))
}

pub fn (nn i16) hex() string {
	return u16(nn).hex()
}

pub fn (nn u32) hex() string {
	if nn == 0 {
		return '0'
	}

	mut n := nn
	max := 10
	mut buf := malloc(max + 1)

	mut index := max
	buf[index--] = `\0`
	for n > 0 {
		d := n & 0xF
		n = n >> 4
		buf[index--] = if d < 10 { d + `0` } else { d + 87 }
	}
	//buf[index--] = `x`
	//buf[index]   = `0`
	index++

	return tos(buf + index, (max - index))
}

pub fn (nn int) hex() string {
	return u32(nn).hex()
}

pub fn (nn u64) hex() string {
	if nn == 0 {
		return '0'
	}

	mut n := nn
	max := 18
	mut buf := malloc(max + 1)

	mut index := max
	buf[index--] = `\0`
	for n > 0 {
		d := n & 0xF
		n = n >> 4
		buf[index--] = if d < 10 { d + `0` } else { d + 87 }
	}
	//buf[index--] = `x`
	//buf[index]   = `0`
	index++

	C.memmove(buf,buf+index, (max-index)+1 )
	return tos(buf, (max-index))
	//return tos(buf + index, (max-index))
}

pub fn (nn i64) hex() string {
	return u64(nn).hex()
}

pub fn (nn voidptr) str() string {
	return u64(nn).hex()
}

pub fn (nn byteptr) str() string {
	return u64(nn).hex()
}

// ----- utilities functions -----

pub fn (a []byte) contains(val byte) bool {
	for aa in a {
		if aa == val {
			return true
		}
	}
	return false
}


/*
pub fn (c rune) str() string {
	fst_byte := int(c)>>8 * 3 & 0xff
	len := utf8_char_len(fst_byte)
	mut str := string{
		len: len
		str: malloc(len + 1)
	}
	for i in 0..len {
		str.str[i] = int(c)>>8 * (3 - i) & 0xff
	}
	str.str[len] = `\0`
	return str
}
*/

pub fn (c byte) str() string {
	mut str := string{
		str: malloc(2)
		len: 1
	}
	str.str[0] = c
	str.str[1] = `\0`
	return str
}

pub fn (c byte) is_capital() bool {
	return c >= `A` && c <= `Z`
}

pub fn (b []byte) clone() []byte {
	mut res := [byte(0)].repeat(b.len)
	//mut res := make([]byte, {repeat:b.len})
	for i in 0..b.len {
		res[i] = b[i]
	}
	return res
}

const (
	a = 3
	u = u64(1)
)

fn test_const() {
	b := (true && true) || false
	assert b == true
	assert a == 3
	assert u == u64(1)
	assert u == 1 // make sure this works without the cast
}

fn test_float_equal_operator() {
	b := f32(1.0)
	mut a := f32(1.0)
	a += 0.000001
	a -= 0.000001
	assert a == b
	assert !a.eqbit(1.0)
	assert !(a != f32(1.0))
	assert a.nebit(f32(1.0))
	a += 0.000001
	assert !(a < 1.0)
	assert !a.ltbit(1.0)
	assert !(a <= 1)
	assert !a.lebit(1)
	assert a > 1
	assert a.gtbit(1)
	assert a >= 1
	assert a.gebit(1)
	assert -1 == 1 * -1
	assert -1.0 == 1.0 * -1.0
	a = 1
	a += 0.000001
	a -= 0.000001
	assert a == f32(1.0)
	assert !a.eqbit(f32(1.0))
	assert !(a != f32(1.0))
	a += 0.000001
	assert !(a < f32(1))
	assert !a.ltbit(f32(1))
	assert !(a <= f32(1))
	assert !a.lebit(f32(1))
	assert a > f32(1)
	assert a.gtbit(f32(1))
	assert a >= 1
	assert a.gebit(1)
	f := 1.2
	ab := int(f)
	assert ab == 1
}

fn test_str_methods() {
	assert i8(1).str() == '1'
	assert i8(-1).str() == '-1'
	assert i16(1).str() == '1'
	assert i16(-1).str() == '-1'
	assert int(1).str() == '1'
	assert int(-1).str() == '-1'
	assert i64(1).str() == '1'
	assert i64(-1).str() == '-1'
	// assert byte(1).str() == '1'
	// assert byte(-1).str() == '255'
	assert u16(1).str() == '1'
	assert u16(-1).str() == '65535'
	assert u32(1).str() == '1'
	assert u32(-1).str() == '4294967295'
	assert u64(1).str() == '1'
	assert u64(-1).str() == '18446744073709551615'
	assert voidptr(-1).str() == 'ffffffffffffffff'
	assert voidptr(1).str() == '1'
	assert byteptr(-1).str() == 'ffffffffffffffff'
	assert byteptr(1).str() == '1'
}

fn test_and_precendence() {
	assert (2 & 0 == 0) == ((2 & 0) == 0)
	assert (2 & 0 != 0) == ((2 & 0) != 0)
	assert (0 & 0 >= 0) == ((0 & 0) >= 0)
	assert (0 & 0 <= 0) == ((0 & 0) <= 0)
	assert (0 & 0 < 1) == ((0 & 0) < 1)
	assert (1 & 2 > 0) == ((1 & 2) > 0)
}

fn test_or_precendence() {
	assert (1 | 0 == 0) == ((1 | 0) == 0)
	assert (1 | 0 != 1) == ((1 | 0) != 1)
	assert (1 | 0 >= 2) == ((1 | 0) >= 2)
	assert (1 | 0 <= 0) == ((1 | 0) <= 0)
	assert (1 | 0 < 0) == ((1 | 0) < 0)
	assert (1 | 0 > 1) == ((1 | 0) > 1)
}

fn test_xor_precendence() {
	assert (1 ^ 0 == 2) == ((1 ^ 0) == 2)
	assert (1 ^ 0 != 2) == ((1 ^ 0) != 2)
	assert (1 ^ 0 >= 0) == ((1 ^ 0) >= 0)
	assert (1 ^ 0 <= 1) == ((1 ^ 0) <= 1)
	assert (1 ^ 0 < 0) == ((1 ^ 0) < 0)
	assert (1 ^ 0 > 1) == ((1 ^ 0) > 1)
}

fn test_left_shift_precendence() {
	assert (2 << 4 | 3) == ((2 << 4) | 3)
	assert (2 << 4 | 3) != (2 << (4 | 3))
}

fn test_right_shift_precendence() {
	assert (256 >> 4 | 3) == ((256 >> 4) | 3)
	assert (256 >> 4 | 3) != (256 >> (4 | 3))
}

fn test_i8_print() {
	b := i8(0)
	println(b)
	c := i16(7)
	println(c)
	d := u16(6)
	println(d)
	assert true
}

/*
fn test_cmp() {
	assert 1  2
	assert 1  2
	assert 1  0
}
*/
type MyInt int

fn test_int_alias() {
	i := MyInt(2)
	assert i + 10 == 12
}

fn test_hex() {
	x := u64(10)
	assert x.hex() == 'a'
	b := 1234
	assert b.hex() == '4d2'
	b1 := -1
	assert b1.hex() == 'ffffffff'
}

fn test_oct() {
	x1 := 0o12
	assert x1 == 10
	x2 := 00000o350
	assert x2 == 232
	x3 := 000o00073
	assert x3 == 59
	x4 := 00000000
	assert x4 == 0
	x5 := 00000195
	assert x5 == 195
	x6 := -0o744
	assert x6 == -484
	x7 := -000o000042
	assert x7 == -34
	x8 := -0000112
	assert x8 == -112
	x9 := -000
	assert x9 == 0
}

fn test_int_decl() {
	x1 := 0
	x2 := 1333
	x3 := -88955
	x4 := 2000000000
	x5 := -1999999999
	assert typeof(x1) == 'int'
	assert typeof(x2) == 'int'
	assert typeof(x3) == 'int'
	assert typeof(x4) == 'int'
	assert typeof(x5) == 'int'
	// integers are always 'int' by default
	x6 := 989898932113111
	x7 := u64(-321314588900011)
	assert typeof(x6) == 'int'
	assert typeof(x7) == 'u64'
}

fn test_int_to_hex() {
	// array hex
	st := [byte(`V`), `L`, `A`, `N`, `G`]
	assert st.hex() == '564c414e47'
	assert st.hex().len == 10
	st1 := [byte(0x41)].repeat(100)
	assert st1.hex() == '41'.repeat(100)
	// --- int to hex tests
	c0 := 12
	// 8Bit
	assert byte(0).hex() == '0'
	assert byte(c0).hex() == 'c'
	assert i8(c0).hex() == 'c'
	assert byte(127).hex() == '7f'
	assert i8(127).hex() == '7f'
	assert byte(255).hex() == 'ff'
	assert byte(-1).hex() == 'ff'
	// 16bit
	assert u16(0).hex() == '0'
	assert i16(c0).hex() == 'c'
	assert u16(c0).hex() == 'c'
	assert i16(32767).hex() == '7fff'
	assert u16(32767).hex() == '7fff'
	assert i16(-1).hex() == 'ffff'
	assert u16(65535).hex() == 'ffff'
	// 32bit
	assert u32(0).hex() == '0'
	assert c0.hex() == 'c'
	assert u32(c0).hex() == 'c'
	assert 2147483647.hex() == '7fffffff'
	assert u32(2147483647).hex() == '7fffffff'
	assert (-1).hex() == 'ffffffff'
	assert u32(4294967295).hex() == 'ffffffff'
	// 64 bit
	assert u64(0).hex() == '0'
	assert i64(c0).hex() == 'c'
	assert u64(c0).hex() == 'c'
	assert i64(9223372036854775807).hex() == '7fffffffffffffff'
	assert u64(9223372036854775807).hex() == '7fffffffffffffff'
	assert i64(-1).hex() == 'ffffffffffffffff'
	assert u64(18446744073709551615).hex() == 'ffffffffffffffff'
}
fn test_isnil_byteptr(){
	pb := byteptr(0)
	assert isnil( pb )
}

fn test_isnil_voidptr(){
	pv := voidptr(0)
	assert isnil( pv )
}

fn test_isnil_charptr(){
	pc := &char(0)
	assert isnil( pc )
}

fn test_isnil_intptr(){
	pi := &int(0)
	assert isnil( pi )
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builtin

import strings
import hash.wyhash

fn C.memcmp(byteptr, byteptr, int) int

/*
This is a highly optimized hashmap implementation. It has several traits that
in combination makes it very fast and memory efficient. Here is a short expl-
anation of each trait. After reading this you should have a basic understand-
ing of how it functions:

1. Hash-function: Wyhash. Wyhash is the fastest hash-function for short keys
passing SMHasher, so it was an obvious choice.

2. Open addressing: Robin Hood Hashing. With this method, a hash-collision is
resolved by probing. As opposed to linear probing, Robin Hood hashing has a
simple but clever twist: As new keys are inserted, old keys are shifted arou-
nd in a way such that all keys stay reasonably close to the slot they origin-
ally hash to. A new key may displace a key already inserted if its probe cou-
nt is larger than that of the key at the current position.

3. Memory layout: key-value pairs are stored in a `DenseArray`. This is a dy-
namic array with a very low volume of unused memory, at the cost of more rea-
llocations when inserting elements. It also preserves the order of the key-v-
alues. This array is named `key_values`. Instead of probing a new key-value,
this map probes two 32-bit numbers collectively. The first number has its 8
most significant bits reserved for the probe-count and the remaining 24 bits
are cached bits from the hash which are utilized for faster re-hashing. This
number is often referred to as `meta`. The other 32-bit number is the index
at which the key-value was pushed to in `key_values`. Both of these numbers
are stored in a sparse array `metas`. The `meta`s and `kv_index`s are stored
at even and odd indices, respectively:

metas = [meta, kv_index, 0, 0, meta, kv_index, 0, 0, meta, kv_index, ...]
key_values = [kv, kv, kv, ...]

4. The size of metas is a power of two. This enables the use of bitwise AND
to  convert the 64-bit hash to a bucket/index that doesn't overflow metas. If
the size is power of two you can use "hash & (SIZE - 1)" instead of "hash %
SIZE". Modulo is extremely expensive so using '&' is a big performance impro-
vement. The general concern with this approach is that you only make use of
the lower bits of the hash which can cause more collisions. This is solved by
using a well-dispersed hash-function.

5. The hashmap keeps track of the highest probe_count. The trick is to alloc-
ate `extra_metas` > max(probe_count), so you never have to do any bounds-che-
cking since the extra meta memory ensures that a meta will never go beyond
the last index.

6. Cached rehashing. When the `load_factor` of the map exceeds the `max_load_
factor` the size of metas is doubled and all the key-values are "rehashed" to
find the index for their meta's in the new array. Instead of rehashing compl-
etely, it simply uses the cached-hashbits stored in the meta, resulting in
much faster rehashing.
*/

const (
// Number of bits from the hash stored for each entry
	hashbits            = 24
	// Number of bits from the hash stored for rehashing
	max_cached_hashbits = 16
	// Initial log-number of buckets in the hashtable
	init_log_capicity   = 5
	// Initial number of buckets in the hashtable
	init_capicity       = 1 << init_log_capicity
	// Maximum load-factor (size / capacity)
	max_load_factor     = 0.8
	// Initial highest even index in metas
	init_cap            = init_capicity - 2
	// Used for incrementing `extra_metas` when max
	// probe count is too high, to avoid overflow
	extra_metas_inc     = 4
	// Bitmask to select all the hashbits
	hash_mask           = u32(0x00FFFFFF)
	// Used for incrementing the probe-count
	probe_inc           = u32(0x01000000)
)

// This function is intended to be fast when
// the strings are very likely to be equal
// TODO: add branch prediction hints
[inline]
fn fast_string_eq(a, b string) bool {
	if a.len != b.len {
		return false
	}
	return C.memcmp(a.str, b.str, b.len) == 0
}

// Dynamic array with very low growth factor
struct DenseArray {
	value_bytes int
mut:
	cap         u32
	size        u32
	deletes     u32
	keys        &string
	values      byteptr
}

[inline]
[unsafe_fn]
fn new_dense_array(value_bytes int) DenseArray {
	return DenseArray{
		value_bytes: value_bytes
		cap: 8
		size: 0
		deletes: 0
		keys: &string(malloc(8 * sizeof(string)))
		values: malloc(8 * value_bytes)
	}
}

// Push element to array and return index
// The growth-factor is roughly 1.125 `(x + (x >> 3))`
[inline]
fn (mut d DenseArray) push(key string, value voidptr) u32 {
	if d.cap == d.size {
		d.cap += d.cap >> 3
		d.keys = &string(C.realloc(d.keys, sizeof(string) * d.cap))
		d.values = C.realloc(d.values, d.value_bytes * d.cap)
	}
	push_index := d.size
	d.keys[push_index] = key
	C.memcpy(d.values + push_index * d.value_bytes, value, d.value_bytes)
	d.size++
	return push_index
}

// Private function. Used to implement array[] operator
fn (d DenseArray) get(i int) voidptr {
	$if !no_bounds_checking? {
		if i < 0 || i >= d.size {
			panic('DenseArray.get: index out of range (i == $i, d.len == $d.size)')
		}
	}
	return byteptr(d.keys) + i * sizeof(string)
}

// Move all zeros to the end of the array
// and resize array
fn (mut d DenseArray) zeros_to_end() {
	mut tmp_value := malloc(d.value_bytes)
	mut count := u32(0)
	for i in 0 .. d.size {
		if d.keys[i].str != 0 {
			// swap keys
			tmp_key := d.keys[count]
			d.keys[count] = d.keys[i]
			d.keys[i] = tmp_key
			// swap values (TODO: optimize)
			C.memcpy(tmp_value, d.values + count * d.value_bytes, d.value_bytes)
			C.memcpy(d.values + count * d.value_bytes, d.values + i * d.value_bytes, d.value_bytes)
			C.memcpy(d.values + i * d.value_bytes, tmp_value, d.value_bytes)
			count++
		}
	}
	free(tmp_value)
	d.deletes = 0
	d.size = count
	d.cap = if count < 8 { u32(8) } else { count }
	d.keys = &string(C.realloc(d.keys, sizeof(string) * d.cap))
	d.values = C.realloc(d.values, d.value_bytes * d.cap)
}

pub struct map {
	// Byte size of value
	value_bytes     int
mut:
	// highest even index in the hashtable
	cap             u32
	// Number of cached hashbits left for rehasing
	cached_hashbits byte
	// Used for right-shifting out used hashbits
	shift           byte
	// Array storing key-values (ordered)
	key_values      DenseArray
	// Pointer to meta-data:
	// Odd indices store kv_index.
	// Even indices store probe_count and hashbits.
	metas           &u32
	// Extra metas that allows for no ranging when incrementing
	// index in the hashmap
	extra_metas     u32
pub mut:
	// Number of key-values currently in the hashmap
	size            int
}

fn new_map_1(value_bytes int) map {
	return map{
		value_bytes: value_bytes
		cap: init_cap
		cached_hashbits: max_cached_hashbits
		shift: init_log_capicity
		key_values: new_dense_array(value_bytes)
		metas: &u32(vcalloc(sizeof(u32) * (init_capicity + extra_metas_inc)))
		extra_metas: extra_metas_inc
		size: 0
	}
}

fn new_map_init(n, value_bytes int, keys &string, values voidptr) map {
	mut out := new_map_1(value_bytes)
	for i in 0 .. n {
		out.set(keys[i], byteptr(values) + i * value_bytes)
	}
	return out
}

[inline]
fn (m &map) key_to_index(key string) (u32,u32) {
	hash := wyhash.wyhash_c(key.str, u64(key.len), 0)
	index := hash & m.cap
	meta := ((hash >> m.shift) & hash_mask) | probe_inc
	return u32(index),u32(meta)
}

[inline]
fn (m &map) meta_less(_index u32, _metas u32) (u32,u32) {
	mut index := _index
	mut meta := _metas
	for meta < m.metas[index] {
		index += 2
		meta += probe_inc
	}
	return index,meta
}

[inline]
fn (mut m map) meta_greater(_index u32, _metas u32, kvi u32) {
	mut meta := _metas
	mut index := _index
	mut kv_index := kvi
	for m.metas[index] != 0 {
		if meta > m.metas[index] {
			tmp_meta := m.metas[index]
			m.metas[index] = meta
			meta = tmp_meta
			tmp_index := m.metas[index + 1]
			m.metas[index + 1] = kv_index
			kv_index = tmp_index
		}
		index += 2
		meta += probe_inc
	}
	m.metas[index] = meta
	m.metas[index + 1] = kv_index
	probe_count := (meta >> hashbits) - 1
	if (probe_count << 1) == m.extra_metas {
		m.extra_metas += extra_metas_inc
		mem_size := (m.cap + 2 + m.extra_metas)
		m.metas = &u32(C.realloc(m.metas, sizeof(u32) * mem_size))
		C.memset(m.metas + mem_size - extra_metas_inc, 0, sizeof(u32) * extra_metas_inc)
		// Should almost never happen
		if probe_count == 252 {
			panic('Probe overflow')
		}
	}
}

fn (mut m map) set(key string, value voidptr) {
	load_factor := f32(m.size << 1) / f32(m.cap)
	if load_factor > max_load_factor {
		m.expand()
	}
	mut index,mut meta := m.key_to_index(key)
	index,meta = m.meta_less(index, meta)
	// While we might have a match
	for meta == m.metas[index] {
		kv_index := m.metas[index + 1]
		if fast_string_eq(key, m.key_values.keys[kv_index]) {
			C.memcpy(m.key_values.values + kv_index * m.value_bytes , value, m.value_bytes)
			return
		}
		index += 2
		meta += probe_inc
	}
	kv_index := m.key_values.push(key, value)
	m.meta_greater(index, meta, kv_index)
	m.size++
}

// Doubles the size of the hashmap
fn (mut m map) expand() {
	old_cap := m.cap
	m.cap = ((m.cap + 2) << 1) - 2
	// Check if any hashbits are left
	if m.cached_hashbits == 0 {
		m.shift += max_cached_hashbits
		m.cached_hashbits = max_cached_hashbits
		m.rehash()
	}
	else {
		m.cached_rehash(old_cap)
		m.cached_hashbits--
	}
}

fn (mut m map) rehash() {
	meta_bytes := sizeof(u32) * (m.cap + 2 + m.extra_metas)
	m.metas = &u32(C.realloc(m.metas, meta_bytes))
	C.memset(m.metas, 0, meta_bytes)
	for i := u32(0); i < m.key_values.size; i++ {
		if m.key_values.keys[i].str == 0 {
			continue
		}
		mut index,mut meta := m.key_to_index(m.key_values.keys[i])
		index,meta = m.meta_less(index, meta)
		m.meta_greater(index, meta, i)
	}
}

fn (mut m map) cached_rehash(old_cap u32) {
	old_metas := m.metas
	m.metas = &u32(vcalloc(sizeof(u32) * (m.cap + 2 + m.extra_metas)))
	old_extra_metas := m.extra_metas
	for i := u32(0); i <= old_cap + old_extra_metas; i += 2 {
		if old_metas[i] == 0 {
			continue
		}
		old_meta := old_metas[i]
		old_probe_count := ((old_meta >> hashbits) - 1) << 1
		old_index := (i - old_probe_count) & (m.cap >> 1)
		mut index := (old_index | (old_meta << m.shift)) & m.cap
		mut meta := (old_meta & hash_mask) | probe_inc
		index,meta = m.meta_less(index, meta)
		kv_index := old_metas[i + 1]
		m.meta_greater(index, meta, kv_index)
	}
	unsafe{
		free(old_metas)
	}
}

fn (m map) get3(key string, zero voidptr) voidptr {
	mut index,mut meta := m.key_to_index(key)
	for {
		if meta == m.metas[index] {
			kv_index := m.metas[index + 1]
			if fast_string_eq(key, m.key_values.keys[kv_index]) {
				return voidptr(m.key_values.values + kv_index * m.value_bytes)
			}
		}
		index += 2
		meta += probe_inc
		if meta > m.metas[index] { break }
	}
	return zero
}

fn (m map) exists(key string) bool {
	mut index,mut meta := m.key_to_index(key)
	for {
		if meta == m.metas[index] {
			kv_index := m.metas[index + 1]
			if fast_string_eq(key, m.key_values.keys[kv_index]) {
				return  true
			}
		}
		index += 2
		meta += probe_inc
		if meta > m.metas[index] { break }
	}
	return false
}

pub fn (mut m map) delete(key string) {
	mut index,mut meta := m.key_to_index(key)
	index,meta = m.meta_less(index, meta)
	// Perform backwards shifting
	for meta == m.metas[index] {
		kv_index := m.metas[index + 1]
		if fast_string_eq(key, m.key_values.keys[kv_index]) {
			for (m.metas[index + 2] >> hashbits) > 1 {
				m.metas[index] = m.metas[index + 2] - probe_inc
				m.metas[index + 1] = m.metas[index + 3]
				index += 2
			}
			m.size--
			m.metas[index] = 0
			m.key_values.deletes++
			C.memset(&m.key_values.keys[kv_index], 0, sizeof(string))
			if m.key_values.size <= 32 {
				return
			}
			// Clean up key_values if too many have been deleted
			if m.key_values.deletes >= (m.key_values.size >> 1) {
				m.key_values.zeros_to_end()
				m.rehash()
				m.key_values.deletes = 0
			}
			return
		}
		index += 2
		meta += probe_inc
	}
}

// TODO: add optimization in case of no deletes
pub fn (m &map) keys() []string {
	mut keys := [''].repeat(m.size)
	mut j := 0
	for i := u32(0); i < m.key_values.size; i++ {
		if m.key_values.keys[i].str == 0 {
			continue
		}
		keys[j] = m.key_values.keys[i]
		j++
	}
	return keys
}

[unsafe_fn]
pub fn (m &map) free() {
	free(m.metas)
	for i := u32(0); i < m.key_values.size; i++ {
		if m.key_values.keys[i].str == 0 {
			continue
		}
		m.key_values.keys[i].free()
	}
	free(m.key_values.keys)
	free(m.key_values.values)
}

pub fn (m map_string) str() string {
	if m.size == 0 {
		return '{}'
	}
	mut sb := strings.new_builder(50)
	sb.writeln('{')
	for key, val in m {
		sb.writeln('  "$key" => "$val"')
	}
	sb.writeln('}')
	return sb.str()
}
// import time

struct User {
	name string
}

struct A {
mut:
	m map[string]int
	users map[string]User
}

fn (mut a A) set(key string, val int) {
	a.m[key] = val
}

fn test_map() {
	mut m := map[string]int
	assert m.size == 0
	m['hi'] = 80
	m['hello'] = 101
	assert m['hi'] == 80
	assert m['hello'] == 101
	assert m.size == 2
	assert 'hi' in m
	mut sum := 0
	// Test `for in`
	for _, val in m {
		sum += val
	}
	assert sum == 80 + 101
	// Test `.keys()`
	keys := m.keys()
	assert keys.len == 2
	assert 'hi' in keys
	assert 'hello' in keys
	m.delete('hi')
	assert m.size == 1
	m.delete('aloha')
	assert m.size == 1

	assert m['hi'] == 0
	assert m.keys().len == 1
	assert m.keys()[0] == 'hello'
	////
	mut users := map[string]User
	users['1'] = User{'Peter'}
	peter := users['1']
	assert  peter.name == 'Peter'
	mut a := A{
		m: map[string]int
		users: map[string]User
	}
	a.users['Bob'] = User{'Bob'}
	q := a.users['Bob']
	assert q.name == 'Bob'
	a.m['one'] = 1
	a.set('two', 2)
	assert a.m['one'] == 1
	assert a.m['two'] == 2
}

fn test_map_init() {
	m := { 'one': 1, 'two': 2 }
	assert m['one'] == 1
	assert m['two'] == 2
	assert m['three'] == 0
}

fn test_string_map() {
	//m := map[string]Fn
}

fn test_large_map() {
	//ticks := time.ticks()
	mut nums := map[string]int
	n := 30 * 1000
	for i in 0..n {
	        key := i.str()
	        nums[key] = i
	}
	assert nums['1'] == 1
	assert nums['999'] == 999
	assert nums['1000000'] == 0
	//println(time.ticks() - ticks)
}

fn test_various_map_value() {
	mut m1 := map[string]int
	m1['test'] = 1
	assert m1['test'] == 1

	mut m2 := map[string]string
	m2['test'] = 'test'
	assert m2['test'] == 'test'

	mut m3 := map[string]i8
	m3['test'] = i8(0)
	assert m3['test'] == i8(0)

	mut m4 := map[string]i16
	m4['test'] = i16(0)
	assert m4['test'] == i16(0)

	mut m7 := map[string]u16
	m7['test'] = u16(0)
	assert m7['test'] == u16(0)

	mut m8 := map[string]u32
	m8['test'] = u32(0)
	assert m8['test'] == u32(0)

	mut m9 := map[string]bool
	m9['test'] = true
	assert m9['test'] == true

	mut m10 := map[string]byte
	m10['test'] = byte(0)
	assert m10['test'] == byte(0)

	mut m11 := map[string]f32
	m11['test'] = f32(0.0)
	assert m11['test'] == f32(0.0)

	mut m12 := map[string]f64
	m12['test'] = f64(0.0)
	assert m12['test'] == f64(0.0)

	mut m13 := map[string]rune
	m13['test'] = rune(0)
	assert m13['test'] == rune(0)

	mut m14 := map[string]voidptr
	m14['test'] = voidptr(0)
	assert m14['test'] == voidptr(0)

	mut m15 := map[string]byteptr
	m15['test'] = byteptr(0)
	assert m15['test'] == byteptr(0)

	mut m16 := map[string]i64
	m16['test'] = i64(0)
	assert m16['test'] == i64(0)

	mut m17 := map[string]u64
	m17['test'] = u64(0)
	assert m17['test'] == u64(0)

	mut m18 := map[string]&int
	m18['test'] = &int(0)
	assert m18['test'] == &int(0)
}


fn test_string_arr() {
	mut m := map[string][]string
	m['a'] = ['one', 'two']
	assert m['a'].len == 2
	assert m['a'][0] == 'one'
	assert m['a'][1] == 'two'
}

fn mut_map(m mut map[string]int) {
	m['a'] = 10
}

fn test_mut_arg() {
	mut m := map[string]int
	mut_map(mut m)
	a := m['a']
	assert a == 10
}

fn test_delete() {
	mut m := map[string]int
	m['one'] = 1
	m['two'] = 2
	println(m['two']) // => "2"
	m.delete('two')
	println(m['two'].str()) // => 0
	assert ('two' in m) == false
	println('two' in m) // => true, on Linux  and Windows  <-- wrong !
}

/*
fn test_ref() {
	m := { 'one': 1 }
	// TODO "cannot take the address of m['one']"
	mut one := &m['one']
	one++
	println(*one)

}
*/

fn test_delete_size() {
    arr := ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
    mut m := map[string]int
    for _ in 0..10 {
        for i in 0..10 {
            m[arr[i]] = i
        }
        assert(m.size == 10)
        println(m.size)
        for i in 0..10 {
            m.delete(arr[i])
        }
    }
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builtin
/*
struct Option2<T> {
	ok bool
	is_none bool
	error string
	ecode int
	data T
}
*/


struct Option {
	ok      bool
	is_none bool
	error   string
	ecode   int
	data    [400]byte
}

pub fn (o Option) str() string {
   if o.ok && !o.is_none {
	  return 'Option{ data: ' + o.data[0..32].hex() + ' }'
   }
   if o.is_none {
	  return 'Option{ none }'
   }
   return 'Option{ error: "${o.error}" }'
}

// `fn foo() ?Foo { return foo }` => `fn foo() ?Foo { return opt_ok(foo); }`
fn opt_ok(data voidptr, size int) Option {
	if size >= 400 {
		panic('option size too big: $size (max is 400), this is a temporary limit')
	}
	res := Option{
		ok: true
	}
	C.memcpy(res.data, data, size)
	return res
}

// used internally when returning `none`
fn opt_none() Option {
	return Option{
		ok: false
		is_none: true
	}
}

pub fn error(s string) Option {
	return Option{
		ok: false
		is_none: false
		error: s
	}
}

pub fn error_with_code(s string, code int) Option {
	return Option{
		ok: false
		is_none: false
		error: s
		ecode: code
	}
}// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module builtin

// import strings

// B-trees are balanced search trees with all leaves at
// the same level. B-trees are generally faster than
// binary search trees due to the better locality of
// reference, since multiple keys are stored in one node.

// The number for `degree` has been picked through vigor-
// ous benchmarking but can be changed to any number > 1.
// `degree` determines the size of each node.
const (
	degree = 6
	mid_index = degree - 1
	max_size = 2 * degree - 1
	children_bytes = sizeof(voidptr) * (max_size + 1)
)

pub struct SortedMap {
	value_bytes int
mut:
	root &mapnode
pub mut:
	size int
}

struct mapnode {
mut:
	children &voidptr
	size     int
	keys     [11]string  // TODO: Should use `max_size`
	values   [11]voidptr // TODO: Should use `max_size`
}

fn new_sorted_map(n, value_bytes int) SortedMap { // TODO: Remove `n`
	return SortedMap {
		value_bytes: value_bytes
		root: new_node()
		size: 0
	}
}

fn new_sorted_map_init(n, value_bytes int, keys &string, values voidptr) SortedMap {
	mut out := new_sorted_map(n, value_bytes)
	for i in 0 .. n {
		out.set(keys[i], byteptr(values) + i * value_bytes)
	}
	return out
}

// The tree is initialized with an empty node as root to
// avoid having to check whether the root is null for
// each insertion.
fn new_node() &mapnode {
	return &mapnode {
		children: 0
		size: 0
	}
}

// This implementation does proactive insertion, meaning
// that splits are done top-down and not bottom-up.
fn (mut m SortedMap) set(key string, value voidptr) {
	mut node := m.root
	mut child_index := 0
	mut parent := &mapnode(0)
	for {
		if node.size == max_size {
			if isnil(parent) {
				parent = new_node()
				m.root = parent
			}
			parent.split_child(child_index, mut node)
			if key == parent.keys[child_index] {
				C.memcpy(parent.values[child_index], value, m.value_bytes)
				return
			}
			node = if key < parent.keys[child_index] {
				&mapnode(parent.children[child_index])
			} else {
				&mapnode(parent.children[child_index + 1])
			}
		}
		mut i := 0
		for i < node.size && key > node.keys[i] { i++ }
		if i != node.size && key == node.keys[i] {
			C.memcpy(node.values[i], value, m.value_bytes)
			return
		}
		if isnil(node.children) {
			mut j := node.size - 1
			for j >= 0 && key < node.keys[j] {
				node.keys[j + 1] = node.keys[j]
				node.values[j + 1] = node.values[j]
				j--
			}
			node.keys[j + 1] = key
			node.values[j + 1] = malloc(m.value_bytes)
			C.memcpy(node.values[j + 1], value, m.value_bytes)
			node.size++
			m.size++
			return
		}
		parent = node
		child_index = i
		node = &mapnode(node.children[child_index])
	}
}

fn (mut n mapnode) split_child(child_index int, y mut mapnode) {
	mut z := new_node()
	z.size = mid_index
	y.size = mid_index
	for j := mid_index - 1; j >= 0; j-- {
		z.keys[j] = y.keys[j + degree]
		z.values[j] = y.values[j + degree]
	}
	if !isnil(y.children) {
		z.children = &voidptr(malloc(children_bytes))
		for jj := degree - 1; jj >= 0; jj-- {
			z.children[jj] = y.children[jj + degree]
		}
	}
	if isnil(n.children) {
		n.children = &voidptr(malloc(children_bytes))
	}
	n.children[n.size + 1] = n.children[n.size]
	for j := n.size; j > child_index; j-- {
		n.keys[j] = n.keys[j - 1]
		n.values[j] = n.values[j - 1]
		n.children[j] = n.children[j - 1]
	}
	n.keys[child_index] = y.keys[mid_index]
	n.values[child_index] = y.values[mid_index]
	n.children[child_index] = voidptr(y)
	n.children[child_index + 1] = voidptr(z)
	n.size++
}

fn (m SortedMap) get(key string, out voidptr) bool {
	mut node := m.root
	for {
		mut i := node.size - 1
		for i >= 0 && key < node.keys[i] { i-- }
		if i != -1 && key == node.keys[i] {
			C.memcpy(out, node.values[i], m.value_bytes)
			return true
		}
		if isnil(node.children) {
			break
		}
		node = &mapnode(node.children[i + 1])
	}
	return false
}

fn (m SortedMap) exists(key string) bool {
	if isnil(m.root) { // TODO: find out why root can be nil
		return false
	}
	mut node := m.root
	for {
		mut i := node.size - 1
		for i >= 0 && key < node.keys[i] { i-- }
		if i != -1 && key == node.keys[i] {
			return true
		}
		if isnil(node.children) {
			break
		}
		node = &mapnode(node.children[i + 1])
	}
	return false
}

fn (n &mapnode) find_key(k string) int {
	mut idx := 0
	for idx < n.size && n.keys[idx] < k {
		idx++
	}
	return idx
}

fn (mut n mapnode) remove_key(k string) bool {
	idx := n.find_key(k)
	if idx < n.size && n.keys[idx] == k {
		if isnil(n.children) {
			n.remove_from_leaf(idx)
		} else {
			n.remove_from_non_leaf(idx)
		}
		return true
	} else {
		if isnil(n.children) {
			return false
		}
		flag := if idx == n.size {true} else {false}
		if (&mapnode(n.children[idx])).size < degree {
			n.fill(idx)
		}

		if flag && idx > n.size {
			return (&mapnode(n.children[idx - 1])).remove_key(k)
		} else {
			return (&mapnode(n.children[idx])).remove_key(k)
		}
	}
}

fn (mut n mapnode) remove_from_leaf(idx int) {
	for i := idx + 1; i < n.size; i++ {
		n.keys[i - 1] = n.keys[i]
		n.values[i - 1] = n.values[i]
	}
	n.size--
}

fn (mut n mapnode) remove_from_non_leaf(idx int) {
	k := n.keys[idx]
	if &mapnode(n.children[idx]).size >= degree {
		mut current := &mapnode(n.children[idx])
		for !isnil(current.children) {
			current = &mapnode(current.children[current.size])
		}
		predecessor := current.keys[current.size - 1]
		n.keys[idx] = predecessor
		n.values[idx] = current.values[current.size - 1]
		(&mapnode(n.children[idx])).remove_key(predecessor)
	} else if &mapnode(n.children[idx + 1]).size >= degree {
		mut current := &mapnode(n.children[idx + 1])
		for !isnil(current.children) {
			current = &mapnode(current.children[0])
		}
		successor := current.keys[0]
		n.keys[idx] = successor
		n.values[idx] = current.values[0]
		(&mapnode(n.children[idx + 1])).remove_key(successor)
	} else {
		n.merge(idx)
		(&mapnode(n.children[idx])).remove_key(k)
	}
}

fn (mut n mapnode) fill(idx int) {
	if idx != 0 && &mapnode(n.children[idx - 1]).size >= degree {
		n.borrow_from_prev(idx)
	} else if idx != n.size && &mapnode(n.children[idx + 1]).size >= degree {
		n.borrow_from_next(idx)
	} else if idx != n.size {
		n.merge(idx)
	} else {
		n.merge(idx - 1)
	}
}

fn (mut n mapnode) borrow_from_prev(idx int) {
	mut child := &mapnode(n.children[idx])
	mut sibling := &mapnode(n.children[idx - 1])
	for i := child.size - 1; i >= 0; i-- {
		child.keys[i + 1] = child.keys[i]
		child.values[i + 1] = child.values[i]
	}
	if !isnil(child.children) {
		for i := child.size; i >= 0; i-- {
			child.children[i + 1] = child.children[i]
		}
	}
	child.keys[0] = n.keys[idx - 1]
	child.values[0] = n.values[idx - 1]
	if !isnil(child.children) {
		child.children[0] = sibling.children[sibling.size]
	}
	n.keys[idx - 1] = sibling.keys[sibling.size - 1]
	n.values[idx - 1] = sibling.values[sibling.size - 1]
	child.size++
	sibling.size--
}

fn (mut n mapnode) borrow_from_next(idx int) {
	mut child := &mapnode(n.children[idx])
	mut sibling := &mapnode(n.children[idx + 1])
	child.keys[child.size] = n.keys[idx]
	child.values[child.size] = n.values[idx]
	if !isnil(child.children) {
		child.children[child.size + 1] = sibling.children[0]
	}
	n.keys[idx] = sibling.keys[0]
	n.values[idx] = sibling.values[0]
	for i := 1; i < sibling.size; i++ {
		sibling.keys[i - 1] = sibling.keys[i]
		sibling.values[i - 1] = sibling.values[i]
	}
	if !isnil(sibling.children) {
		for i := 1; i <= sibling.size; i++ {
			sibling.children[i - 1] = sibling.children[i]
		}
	}
	child.size++
	sibling.size--
}

fn (mut n mapnode) merge(idx int) {
	mut child := &mapnode(n.children[idx])
	sibling := &mapnode(n.children[idx + 1])
	child.keys[mid_index] = n.keys[idx]
	child.values[mid_index] = n.values[idx]
	for i in 0..sibling.size {
		child.keys[i + degree] = sibling.keys[i]
		child.values[i + degree] = sibling.values[i]
	}
	if !isnil(child.children) {
		for i := 0; i <= sibling.size; i++ {
			child.children[i + degree] = sibling.children[i]
		}
	}
	for i := idx + 1; i < n.size; i++ {
		n.keys[i - 1] = n.keys[i]
		n.values[i - 1] = n.values[i]
	}
	for i := idx + 2; i <= n.size; i++ {
		n.children[i - 1] = n.children[i]
	}
	child.size += sibling.size + 1
	n.size--
	// free(sibling)
}

pub fn (mut m SortedMap) delete(key string) {
	if m.root.size == 0 {
		return
	}

	removed := m.root.remove_key(key)
	if removed {
		m.size--
	}

	if m.root.size == 0 {
		// tmp := t.root
		if isnil(m.root.children) {
			return
		} else {
			m.root = &mapnode(m.root.children[0])
		}
		// free(tmp)
	}
}

// Insert all keys of the subtree into array `keys`
// starting at `at`. Keys are inserted in order.
fn (n &mapnode) subkeys(keys mut []string, at int) int {
	mut position := at
	if !isnil(n.children) {
		// Traverse children and insert
		// keys inbetween children
		for i in 0..n.size {
			child := &mapnode(n.children[i])
			position += child.subkeys(mut keys, position)
			keys[position] = n.keys[i]
			position++
		}
		// Insert the keys of the last child
		child := &mapnode(n.children[n.size])
		position += child.subkeys(mut keys, position)
	} else {
		// If leaf, insert keys
		for i in 0..n.size {
			keys[position + i] = n.keys[i]
		}
		position += n.size
	}
	// Return # of added keys
	return position - at
}

pub fn (m &SortedMap) keys() []string {
	mut keys := [''].repeat(m.size)
	if isnil(m.root) || m.root.size == 0 {
		return keys
	}
	m.root.subkeys(mut keys, 0)
	return keys
}

fn (mut n mapnode) free() {
	println('TODO')
}

pub fn (mut m SortedMap) free() {
	if isnil(m.root) {
		return
	}
	m.root.free()
}

pub fn (m SortedMap) print() {
	println('TODO')
}

// pub fn (m map_string) str() string {
// 	if m.size == 0 {
// 		return '{}'
// 	}
// 	mut sb := strings.new_builder(50)
// 	sb.writeln('{')
// 	for key, val  in m {
// 		sb.writeln('  "$key" => "$val"')
// 	}
// 	sb.writeln('}')
// 	return sb.str()
// }
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builtin

import strconv
/*
NB: A V string should be/is immutable from the point of view of
    V user programs after it is first created. A V string is
    also slightly larger than the equivalent C string because
    the V string also has an integer length attached.

    This tradeoff is made, since V strings are created just *once*,
    but potentially used *many times* over their lifetime.

    The V string implementation uses a struct, that has a .str field,
    which points to a C style 0 terminated memory block. Although not
    strictly necessary from the V point of view, that additional 0
    is *very useful for C interoperability*.

    The V string implementation also has an integer .len field,
    containing the length of the .str field, excluding the
    terminating 0 (just like the C's strlen(s) would do).

    The 0 ending of .str, and the .len field, mean that in practice:
      a) a V string s can be used very easily, wherever a
         C string is needed, just by passing s.str,
         without a need for further conversion/copying.

      b) where strlen(s) is needed, you can just pass s.len,
         without having to constantly recompute the length of s
         *over and over again* like some C programs do. This is because
         V strings are immutable and so their length does not change.

    Ordinary V code *does not need* to be concerned with the
    additional 0 in the .str field. The 0 *must* be put there by the
    low level string creating functions inside this module.

    Failing to do this will lead to programs that work most of the
    time, when used with pure V functions, but fail in strange ways,
    when used with modules using C functions (for example os and so on).
*/


pub struct string {
pub:
	str byteptr // points to a C style 0 terminated string of bytes.
	len int // the length of the .str field, excluding the ending 0 byte. It is always equal to strlen(.str).
	is_lit bool
}
	// mut:
	// hash_cache int

pub struct ustring {
pub mut:
	s     string
	runes []int
	len   int
}

pub fn vstrlen(s byteptr) int {
	return C.strlen(charptr(s))
}

// Converts a C string to a V string.
// String data is reused, not copied.
pub fn tos(s byteptr, len int) string {
	// This should never happen.
	if s == 0 {
		panic('tos(): nil string')
	}
	return string{
		str: s
		len: len
	}
}

pub fn tos_clone(s byteptr) string {
	if s == 0 {
		panic('tos: nil string')
	}
	return tos2(s).clone()
}

// Same as `tos`, but calculates the length. Called by `string(bytes)` casts.
// Used only internally.
pub fn tos2(s byteptr) string {
	if s == 0 {
		panic('tos2: nil string')
	}
	return string{
		str: s
		len: vstrlen(s)
	}
}

// Same as `tos2`, but for char*, to avoid warnings
pub fn tos3(s charptr) string {
	if s == 0 {
		panic('tos3: nil string')
	}
	return string{
		str: byteptr(s)
		len: C.strlen(s)
	}
}

pub fn tos_lit(s charptr) string {
	return string{
		str: byteptr(s)
		len: C.strlen(s)
		is_lit:true
	}
}


// string.clone_static returns an independent copy of a given array
// It should be used only in -autofree generated code.
fn (a string) clone_static() string {
	return a.clone()
}

pub fn (a string) clone() string {
	mut b := string{
		str: malloc(a.len + 1)
		len: a.len
	}
	for i in 0..a.len {
		b.str[i] = a.str[i]
	}
	b.str[a.len] = `\0`
	return b
}

/*
pub fn (s string) cstr() byteptr {
	clone := s.clone()
	return clone.str
}
*/

// cstring_to_vstring creates a copy of cstr and turns it into a v string
pub fn cstring_to_vstring(cstr byteptr) string {
	slen := C.strlen(cstr)
	mut s := byteptr(memdup(cstr, slen + 1))
	s[slen] = `\0`
	return tos(s, slen)
}

pub fn (s string) replace_once(rep, with string) string {
	index := s.index(rep) or {
		return s
	}
	return s.substr(0, index) + with + s.substr(index + rep.len, s.len)
}

pub fn (s string) replace(rep, with string) string {
	if s.len == 0 || rep.len == 0 {
		return s.clone()
	}
	// TODO PERF Allocating ints is expensive. Should be a stack array
	// Get locations of all reps within this string
	mut idxs := []int{}
	mut idx := 0
	for {
		idx = s.index_after(rep, idx)
		if idx == -1 {
			break
		}
		idxs << idx
		idx += rep.len
	}
	// Dont change the string if there's nothing to replace
	if idxs.len == 0 {
		return s.clone()
	}
	// Now we know the number of replacements we need to do and we can calc the len of the new string
	new_len := s.len + idxs.len * (with.len - rep.len)
	mut b := malloc(new_len + 1) // add a newline just in case
	// Fill the new string
	mut idx_pos := 0
	mut cur_idx := idxs[idx_pos]
	mut b_i := 0
	for i := 0; i < s.len; i++ {
		if i == cur_idx {
			// Reached the location of rep, replace it with "with"
			for j in 0..with.len {
				b[b_i] = with[j]
				b_i++
			}
			// Skip the length of rep, since we just replaced it with "with"
			i += rep.len - 1
			// Go to the next index
			idx_pos++
			if idx_pos < idxs.len {
				cur_idx = idxs[idx_pos]
			}
		}
		else {
			// Rep doesnt start here, just copy
			b[b_i] = s[i]
			b_i++
		}
	}
	b[new_len] = `\0`
	return tos(b, new_len)
}

struct RepIndex {
	idx     int
	val_idx int
}

fn compare_rep_index(a, b &RepIndex) int {
	if a.idx < b.idx {
		return -1
	}
	if a.idx > b.idx {
		return 1
	}
	return 0
}


fn (mut a []RepIndex) sort() {
	a.sort_with_compare(compare_rep_index)
}

// TODO
/*
fn (a RepIndex) < (b RepIndex) bool {
	return a.idx < b.idx
}
*/


pub fn (s string) replace_each(vals []string) string {
	if s.len == 0 || vals.len == 0 {
		return s
	}
	if vals.len % 2 != 0 {
		println('string.replace_each(): odd number of strings')
		return s
	}
	// `rep` - string to replace
	// `with` - string to replace with
	// Remember positions of all rep strings, and calculate the length
	// of the new string to do just one allocation.
	mut new_len := s.len
	mut idxs := []RepIndex{}
	mut idx := 0
	for rep_i := 0; rep_i < vals.len; rep_i += 2 {
		// vals: ['rep1, 'with1', 'rep2', 'with2']
		rep := vals[rep_i]
		with := vals[rep_i + 1]
		for {
			idx = s.index_after(rep, idx)
			if idx == -1 {
				break
			}
			// We need to remember both the position in the string,
			// and which rep/with pair it refers to.
			idxs << RepIndex {
				idx:idx
				val_idx:rep_i
			}
			idx++
			new_len += with.len - rep.len
		}
	}
	// Dont change the string if there's nothing to replace
	if idxs.len == 0 {
		return s
	}
	idxs.sort()
	mut b := malloc(new_len + 1) // add a \0 just in case
	// Fill the new string
	mut idx_pos := 0
	mut cur_idx := idxs[idx_pos]
	mut b_i := 0
	for i := 0; i < s.len; i++ {
		if i == cur_idx.idx {
			// Reached the location of rep, replace it with "with"
			rep := vals[cur_idx.val_idx]
			with := vals[cur_idx.val_idx + 1]
			for j in 0..with.len {
				b[b_i] = with[j]
				b_i++
			}
			// Skip the length of rep, since we just replaced it with "with"
			i += rep.len - 1
			// Go to the next index
			idx_pos++
			if idx_pos < idxs.len {
				cur_idx = idxs[idx_pos]
			}
		}
		else {
			// Rep doesnt start here, just copy
			b[b_i] = s.str[i]
			b_i++
		}
	}
	b[new_len] = `\0`
	return tos(b, new_len)
}

pub fn (s string) bool() bool {
	return s == 'true' || s == 't' // TODO t for pg, remove
}

pub fn (s string) int() int {
	return int(strconv.common_parse_int(s, 0, 32, false, false))
}

pub fn (s string) i64() i64 {
	return strconv.common_parse_int(s, 0, 64, false, false)
}

pub fn (s string) i8() i8 {
	return i8(strconv.common_parse_int(s, 0, 8, false, false))
}

pub fn (s string) i16() i16 {
	return i16(strconv.common_parse_int(s, 0, 16, false, false))
}

pub fn (s string) f32() f32 {
	// return C.atof(charptr(s.str))
	return f32(strconv.atof64(s))
}

pub fn (s string) f64() f64 {
	// return C.atof(charptr(s.str))
	return strconv.atof64(s)
}

pub fn (s string) u16() u16 {
	return u16(strconv.common_parse_uint(s, 0, 16, false, false))
}

pub fn (s string) u32() u32 {
	return u32(strconv.common_parse_uint(s, 0, 32, false, false))
}

pub fn (s string) u64() u64 {
	return strconv.common_parse_uint(s, 0, 64, false, false)
}

// ==
fn (s string) eq(a string) bool {
	if s.str == 0 {
		// should never happen
		panic('string.eq(): nil string')
	}
	if s.len != a.len {
		return false
	}
	return C.memcmp(s.str, a.str, a.len) == 0
}

// !=
fn (s string) ne(a string) bool {
	return !s.eq(a)
}

// s < a
fn (s string) lt(a string) bool {
	for i in 0..s.len {
		if i >= a.len || s[i] > a[i] {
			return false
		}
		else if s[i] < a[i] {
			return true
		}
	}
	if s.len < a.len {
		return true
	}
	return false
}

// s <= a
fn (s string) le(a string) bool {
	return s.lt(a) || s.eq(a)
}

// s > a
fn (s string) gt(a string) bool {
	return !s.le(a)
}

// s >= a
fn (s string) ge(a string) bool {
	return !s.lt(a)
}

// TODO `fn (s string) + (a string)` ? To be consistent with operator overloading syntax.
fn (s string) add(a string) string {
	new_len := a.len + s.len
	mut res := string{
		str: malloc(new_len + 1)
		len: new_len
	}
	for j in 0..s.len {
		res.str[j] = s.str[j]
	}
	for j in 0..a.len {
		res.str[s.len + j] = a.str[j]
	}
	res.str[new_len] = `\0` // V strings are not null terminated, but just in case
	return res
}

pub fn (s string) split(delim string) []string {
	return s.split_nth(delim, 0)
}

/*
split_nth - splits the string based on the passed `delim` substring.
It returns the first Nth parts. When N=0, return all the splits.
The last returned element has the remainder of the string, even if
the remainder contains more `delim` substrings.
*/
pub fn (s string) split_nth(delim string, nth int) []string {
	mut res := []string{}
	mut i := 0
	if delim.len == 0 {
		i = 1
		for ch in s {
			if nth > 0 && i >= nth {
				res << s.substr(i, s.len)
				break
			}
			res << ch.str()
			i++
		}
		return res
	}
	mut start := 0
	nth_1 := nth - 1
	for i <= s.len {
		mut is_delim := s.str[i] == delim.str[0]
		mut j := 0
		for is_delim && j < delim.len {
			is_delim = is_delim && s.str[i + j] == delim.str[j]
			j++
		}
		last := i == s.len - 1
		if is_delim || last {
			if !is_delim && last {
				i++
			}
			mut val := s.substr(start, i)
			if val.starts_with(delim) {
				val = val.right(delim.len)
			}

			was_last := nth > 0 && res.len == nth_1
			if was_last {
				res << s.right(start)
				break
			}

			res << val
			start = i + delim.len
		}
		i++
	}
	if s.ends_with(delim) && (nth < 1 || res.len < nth) {
		res << ''
	}
	return res
}

pub fn (s string) split_into_lines() []string {
	mut res := []string{}
	if s.len == 0 {
		return res
	}
	mut start := 0
	for i := 0; i < s.len; i++ {
		is_lf := s.str[i] == `\n`
		is_crlf := i != s.len - 1 && s.str[i] == `\r` && s.str[i + 1] == `\n`
		is_eol := is_lf || is_crlf
		is_last := if is_crlf {
			i == s.len - 2
		} else {
			i == s.len - 1
		}

		if is_eol || is_last {
			if is_last && !is_eol {
				i++
			}

			line := s.substr(start, i)
			res << line

			if is_crlf {
				i++
			}

			start = i + 1
		}
	}
	return res
}

// 'hello'.left(2) => 'he'
fn (s string) left(n int) string {
	if n >= s.len {
		return s
	}
	return s.substr(0, n)
}

// 'hello'.right(2) => 'llo'
fn (s string) right(n int) string {
	if n >= s.len {
		return ''
	}
	return s.substr(n, s.len)
}

// used internally for [2..4]
fn (s string) substr2(start, _end int, end_max bool) string {
	end := if end_max { s.len } else { _end }
	return s.substr(start, end)
}

pub fn (s string) substr(start, end int) string {
	$if !no_bounds_checking? {
		if start > end || start > s.len || end > s.len || start < 0 || end < 0 {
			panic('substr($start, $end) out of bounds (len=$s.len)')
		}
	}
	len := end - start
	mut res := string{
		str: malloc(len + 1)
		len: len
	}
	for i in 0..len {
		res.str[i] = s.str[start + i]
	}
	res.str[len] = `\0`
	/*
	res := string {
		str: s.str + start
		len: len
	}
*/

	return res
}

pub fn (s string) index_old(p string) int {
	if p.len > s.len || p.len == 0 {
		return -1
	}
	mut i := 0
	for i < s.len {
		mut j := 0
		for j < p.len && s.str[i + j] == p.str[j] {
			j++
		}
		if j == p.len {
			return i
		}
		i++
	}
	return -1
}

pub fn (s string) index(p string) ?int {
	if p.len > s.len || p.len == 0 {
		return none
	}
	mut i := 0
	for i < s.len {
		mut j := 0
		for j < p.len && s.str[i + j] == p.str[j] {
			j++
		}
		if j == p.len {
			return i
		}
		i++
	}
	return none
}

// KMP search
fn (s string) index_kmp(p string) int {
	if p.len > s.len {
		return -1
	}
	mut prefix := [0].repeat(p.len)
	mut j := 0
	for i := 1; i < p.len; i++ {
		for p.str[j] != p.str[i] && j > 0 {
			j = prefix[j - 1]
		}
		if p.str[j] == p.str[i] {
			j++
		}
		prefix[i] = j
	}
	j = 0
	for i in 0..s.len {
		for p.str[j] != s.str[i] && j > 0 {
			j = prefix[j - 1]
		}
		if p.str[j] == s.str[i] {
			j++
		}
		if j == p.len {
			return i - p.len + 1
		}
	}
	return -1
}

pub fn (s string) index_any(chars string) int {
	for c in chars {
		index := s.index(c.str()) or {
			continue
		}
		return index
	}
	return -1
}

pub fn (s string) last_index(p string) ?int {
	if p.len > s.len || p.len == 0 {
		return none
	}
	mut i := s.len - p.len
	for i >= 0 {
		mut j := 0
		for j < p.len && s.str[i + j] == p.str[j] {
			j++
		}
		if j == p.len {
			return i
		}
		i--
	}
	return none
}

pub fn (s string) index_after(p string, start int) int {
	if p.len > s.len {
		return -1
	}
	mut strt := start
	if start < 0 {
		strt = 0
	}
	if start >= s.len {
		return -1
	}
	mut i := strt
	for i < s.len {
		mut j := 0
		mut ii := i
		for j < p.len && s.str[ii] == p.str[j] {
			j++
			ii++
		}
		if j == p.len {
			return i
		}
		i++
	}
	return -1
}

pub fn (s string) index_byte(c byte) int {
	for i in 0..s.len {
		if s.str[i] == c {
			return i
		}
	}
	return -1
}

pub fn (s string) last_index_byte(c byte) int {
	for i := s.len - 1; i >= 0; i-- {
		if s.str[i] == c {
			return i
		}
	}
	return -1
}

// counts occurrences of substr in s
pub fn (s string) count(substr string) int {
	if s.len == 0 || substr.len == 0 {
		return 0
	}
	if substr.len > s.len {
		return 0
	}
	mut n := 0
	mut i := 0
	for {
		i = s.index_after(substr, i)
		if i == -1 {
			return n
		}
		i += substr.len
		n++
	}
	return 0 // TODO can never get here - v doesn't know that
}

pub fn (s string) contains(p string) bool {
	s.index(p) or {
		return false
	}
	return true
}

pub fn (s string) starts_with(p string) bool {
	if p.len > s.len {
		return false
	}
	for i in 0..p.len {
		if s.str[i] != p.str[i] {
			return false
		}
	}
	return true
}

pub fn (s string) ends_with(p string) bool {
	if p.len > s.len {
		return false
	}
	for i in 0..p.len {
		if p[i] != s[s.len - p.len + i] {
			return false
		}
	}
	return true
}

// TODO only works with ASCII
pub fn (s string) to_lower() string {
	mut b := malloc(s.len + 1)
	for i in 0..s.len {
		b[i] = C.tolower(s.str[i])
	}
	return tos(b, s.len)
}

pub fn (s string) is_lower() bool {
	for i in 0..s.len {
		if s[i] >= `A` && s[i] <= `Z` {
			return false
		}
	}
	return true
}

pub fn (s string) to_upper() string {
	mut b := malloc(s.len + 1)
	for i in 0..s.len {
		b[i] = C.toupper(s.str[i])
	}
	return tos(b, s.len)
}

pub fn (s string) is_upper() bool {
	for i in 0..s.len {
		if s[i] >= `a` && s[i] <= `z` {
			return false
		}
	}
	return true
}

pub fn (s string) capitalize() string {
	if s.len == 0 {
		return ''
	}
	sl := s.to_lower()
	cap := sl[0].str().to_upper() + sl.right(1)
	return cap
}

pub fn (s string) is_capital() bool {
	if s.len == 0 || !(s[0] >= `A` && s[0] <= `Z`) {
		return false
	}
	for i in 1..s.len {
		if s[i] >= `A` && s[i] <= `Z` {
			return false
		}
	}
	return true
}

pub fn (s string) title() string {
	words := s.split(' ')
	mut tit := []string{}
	for word in words {
		tit << word.capitalize()
	}
	title := tit.join(' ')
	return title
}

pub fn (s string) is_title() bool {
	words := s.split(' ')
	for word in words {
		if !word.is_capital() {
			return false
		}
	}
	return true
}

// 'hey [man] how you doin'
// find_between('[', ']') == 'man'
pub fn (s string) find_between(start, end string) string {
	start_pos := s.index(start) or {
		return ''
	}
	// First get everything to the right of 'start'
	val := s.right(start_pos + start.len)
	end_pos := val.index(end) or {
		return val
	}
	return val.left(end_pos)
}

// TODO generic
fn (ar []string) contains(val string) bool {
	for s in ar {
		if s == val {
			return true
		}
	}
	return false
}

// TODO generic
fn (ar []int) contains(val int) bool {
	for s in ar {
		if s == val {
			return true
		}
	}
	return false
}

/*
pub fn (a []string) to_c() voidptr {
	mut res := malloc(sizeof(byteptr) * a.len)
	for i in 0..a.len {
		val := a[i]
		res[i] = val.str
	}
	return res
}
*/

pub fn (c byte) is_space() bool {
	// 0x0085 is NEXT LINE (NEL)
	// 0x00a0 is NO-BREAK SPACE
	return c in [` `, `\n`, `\t`, `\v`, `\f`, `\r`, 0x85, 0xa0]
}

pub fn (s string) trim_space() string {
	return s.trim(' \n\t\v\f\r')
}

pub fn (s string) trim(cutset string) string {
	if s.len < 1 || cutset.len < 1 {
		return s
	}
	cs_arr := cutset.bytes()
	mut pos_left := 0
	mut pos_right := s.len - 1
	mut cs_match := true
	for pos_left <= s.len && pos_right >= -1 && cs_match {
		cs_match = false
		if s[pos_left] in cs_arr {
			pos_left++
			cs_match = true
		}
		if s[pos_right] in cs_arr {
			pos_right--
			cs_match = true
		}
		if pos_left > pos_right {
			return ''
		}
	}
	return s.substr(pos_left, pos_right + 1)
}

pub fn (s string) trim_left(cutset string) string {
	if s.len < 1 || cutset.len < 1 {
		return s
	}
	cs_arr := cutset.bytes()
	mut pos := 0
	for pos < s.len && s[pos] in cs_arr {
		pos++
	}
	return s.right(pos)
}

pub fn (s string) trim_right(cutset string) string {
	if s.len < 1 || cutset.len < 1 {
		return s
	}
	cs_arr := cutset.bytes()
	mut pos := s.len - 1
	for pos >= 0 && s[pos] in cs_arr {
		pos--
	}
	return if pos < 0 { '' } else { s.left(pos + 1) }
}

pub fn (s string) trim_prefix(str string) string {
	if s.starts_with(str) {
		return s.replace(str, "")
	}
	return s
}

pub fn (s string) trim_suffix(str string) string {
	if s.ends_with(str) {
		return s.replace(str, "")
	}
	return s
}

// fn print_cur_thread() {
// //C.printf("tid = %08x \n", pthread_self());
// }
fn compare_strings(a, b &string) int {
	if a.lt(b) {
		return -1
	}
	if a.gt(b) {
		return 1
	}
	return 0
}

fn compare_strings_by_len(a, b &string) int {
	if a.len < b.len {
		return -1
	}
	if a.len > b.len {
		return 1
	}
	return 0
}

fn compare_lower_strings(a, b &string) int {
	aa := a.to_lower()
	bb := b.to_lower()
	return compare_strings(aa, bb)
}

pub fn (mut s []string) sort() {
	s.sort_with_compare(compare_strings)
}

pub fn (mut s []string) sort_ignore_case() {
	s.sort_with_compare(compare_lower_strings)
}

pub fn (mut s []string) sort_by_len() {
	s.sort_with_compare(compare_strings_by_len)
}

pub fn (s string) str() string {
	return s
}

pub fn (s ustring) str() string {
   return s.s
}

pub fn (s string) ustring() ustring {
	mut res := ustring{
		s: s
		// runes will have at least s.len elements, save reallocations
		// TODO use VLA for small strings?

		runes: __new_array(0, s.len, sizeof(int))
	}
	for i := 0; i < s.len; i++ {
		char_len := utf8_char_len(s.str[i])
		res.runes << i
		i += char_len - 1
		res.len++
	}
	return res
}

// A hack that allows to create ustring without allocations.
// It's called from functions like draw_text() where we know that the string is going to be freed
// right away. Uses global buffer for storing runes []int array.
__global g_ustring_runes []int

pub fn (s string) ustring_tmp() ustring {
	if g_ustring_runes.len == 0 {
		g_ustring_runes = __new_array(0, 128, sizeof(int))
	}
	mut res := ustring{
		s: s
	}
	res.runes = g_ustring_runes
	res.runes.len = s.len
	mut j := 0
	for i := 0; i < s.len; i++ {
		char_len := utf8_char_len(s.str[i])
		res.runes[j] = i
		j++
		i += char_len - 1
		res.len++
	}
	return res
}

fn (u ustring) eq(a ustring) bool {
	if u.len != a.len || u.s != a.s {
		return false
	}
	return true
}

fn (u ustring) ne(a ustring) bool {
	return !u.eq(a)
}

fn (u ustring) lt(a ustring) bool {
	return u.s < a.s
}

fn (u ustring) le(a ustring) bool {
	return u.lt(a) || u.eq(a)
}

fn (u ustring) gt(a ustring) bool {
	return !u.le(a)
}

fn (u ustring) ge(a ustring) bool {
	return !u.lt(a)
}

pub fn (u ustring) add(a ustring) ustring {
	mut res := ustring{
		s: u.s + a.s
		runes: __new_array(0, u.s.len + a.s.len, sizeof(int))
	}
	mut j := 0
	for i := 0; i < u.s.len; i++ {
		char_len := utf8_char_len(u.s.str[i])
		res.runes << j
		i += char_len - 1
		j += char_len
		res.len++
	}
	for i := 0; i < a.s.len; i++ {
		char_len := utf8_char_len(a.s.str[i])
		res.runes << j
		i += char_len - 1
		j += char_len
		res.len++
	}
	return res
}

pub fn (u ustring) index_after(p ustring, start int) int {
	if p.len > u.len {
		return -1
	}
	mut strt := start
	if start < 0 {
		strt = 0
	}
	if start > u.len {
		return -1
	}
	mut i := strt
	for i < u.len {
		mut j := 0
		mut ii := i
		for j < p.len && u.at(ii) == p.at(j) {
			j++
			ii++
		}
		if j == p.len {
			return i
		}
		i++
	}
	return -1
}

// counts occurrences of substr in s
pub fn (u ustring) count(substr ustring) int {
	if u.len == 0 || substr.len == 0 {
		return 0
	}
	if substr.len > u.len {
		return 0
	}
	mut n := 0
	mut i := 0
	for {
		i = u.index_after(substr, i)
		if i == -1 {
			return n
		}
		i += substr.len
		n++
	}
	return 0 // TODO can never get here - v doesn't know that
}

pub fn (u ustring) substr(_start, _end int) string {
	$if !no_bounds_checking? {
		if _start > _end || _start > u.len || _end > u.len || _start < 0 || _end < 0 {
			panic('substr($_start, $_end) out of bounds (len=$u.len)')
		}
	}
	end := if _end >= u.len { u.s.len } else { u.runes[_end] }
	return u.s.substr(u.runes[_start], end)
}

pub fn (u ustring) left(pos int) string {
	if pos >= u.len {
		return u.s
	}
	return u.substr(0, pos)
}

pub fn (u ustring) right(pos int) string {
	if pos >= u.len {
		return ''
	}
	return u.substr(pos, u.len)
}

fn (s string) at(idx int) byte {
	$if !no_bounds_checking? {
		if idx < 0 || idx >= s.len {
			panic('string index out of range: $idx / $s.len')
		}
	}
	return s.str[idx]
}

pub fn (u ustring) at(idx int) string {
	$if !no_bounds_checking? {
		if idx < 0 || idx >= u.len {
			panic('string index out of range: $idx / $u.runes.len')
		}
	}
	return u.substr(idx, idx + 1)
}

fn (u &ustring) free() {
	u.runes.free()
}

pub fn (c byte) is_digit() bool {
	return c >= `0` && c <= `9`
}

pub fn (c byte) is_hex_digit() bool {
	return c.is_digit() || (c >= `a` && c <= `f`) || (c >= `A` && c <= `F`)
}

pub fn (c byte) is_oct_digit() bool {
	return c >= `0` && c <= `7`
}

pub fn (c byte) is_bin_digit() bool {
	return c == `0` || c == `1`
}

pub fn (c byte) is_letter() bool {
	return (c >= `a` && c <= `z`) || (c >= `A` && c <= `Z`)
}

pub fn (s &string) free() {
	if s.is_lit {return}
	free(s.str)
}

// all_before('23:34:45.234', '.') == '23:34:45'
pub fn (s string) all_before(dot string) string {
	pos := s.index(dot) or {
		return s
	}
	return s.left(pos)
}

pub fn (s string) all_before_last(dot string) string {
	pos := s.last_index(dot) or {
		return s
	}
	return s.left(pos)
}

pub fn (s string) all_after(dot string) string {
	pos := s.index(dot) or {
		return s
	}
	return s.right(pos + dot.len)
}

pub fn (s string) all_after_last(dot string) string {
	pos := s.last_index(dot) or {
		return s
	}
	return s.right(pos + dot.len)
}

pub fn (s string) after(dot string) string {
	return s.all_after_last(dot)
}

pub fn (s string) after_char(dot byte) string {
	mut pos := 0
	for i, c in s {
		if c == dot {
			pos = i
			break
		}
	}
	if pos == 0 {
		return s
	}
	return s.right(pos+1)

}

// fn (s []string) substr(a, b int) string {
// return join_strings(s.slice_fast(a, b))
// }
pub fn (a []string) join(del string) string {
	if a.len == 0 {
		return ''
	}
	mut len := 0
	for val in a {
		len += val.len + del.len
	}
	len -= del.len
	// Allocate enough memory
	mut res := ''
	res.len = len
	res.str = malloc(res.len + 1)
	mut idx := 0
	// Go thru every string and copy its every char one by one
	for i, val in a {
		for j in 0..val.len {
			res.str[idx] = val.str[j]
			idx++
		}
		// Add del if it's not last
		if i != a.len - 1 {
			for k in 0..del.len {
				res.str[idx] = del.str[k]
				idx++
			}
		}
	}
	res.str[res.len] = `\0`
	return res
}

pub fn (s []string) join_lines() string {
	return s.join('\n')
}

// reverse will return a new reversed string.
pub fn (s string) reverse() string {
	if s.len == 0 || s.len == 1 {
		return s
	}
	mut res := string{
		str: malloc(s.len)
		len: s.len
	}
	for i := s.len - 1; i >= 0; i-- {
		res.str[s.len - i - 1] = s[i]
	}
	return res
}

// limit returns a portion of the string, starting at `0` and extending for a given number of characters afterward.
// 'hello'.limit(2) => 'he'
// 'hi'.limit(10) => 'hi'
pub fn (s string) limit(max int) string {
	u := s.ustring()
	if u.len <= max {
		return s
	}
	return u.substr(0, max)
}

[deprecated]
pub fn (c byte) is_white() bool {
	panic('Use `string.is_space` instead of `string.is_white')
}

pub fn (s string) hash() int {
	// mut h := s.hash_cache
	mut h := 0
	if h == 0 && s.len > 0 {
		for c in s {
			h = h * 31 + int(c)
		}
	}
	return h
}

pub fn (s string) bytes() []byte {
	if s.len == 0 {
		return []
	}
	mut buf := [byte(0)].repeat(s.len)
	C.memcpy(buf.data, s.str, s.len)
	return buf
}

// repeat returns a new string with a specified number of copies of the string it was called on.
pub fn (s string) repeat(count int) string {
	if count < 0 {
		panic('string.repeat: count is negative: $count')
	} else if count == 0 {
		return ''
	} else if count == 1 {
		return s
	}
	mut ret := malloc(s.len * count + 1)
	for i in 0 .. count {
		for j in 0 .. s.len {
			ret[i * s.len + j] = s[j]
		}
	}
	ret[s.len * count] = 0
	return string(ret)
}

// Allows multi-line strings to be formatted in a way that removes white-space
// before a delimeter. by default `|` is used.
// Note: the delimiter has to be a byte at this time. That means surrounding
// the value in ``.
//
// Example:
// st := 'Hello there,
//       |this is a string,
//       |    Everything before the first | is removed'.strip_margin()
// Returns:
// Hello there,
// this is a string,
//     Everything before the first | is removed
pub fn (s string) strip_margin() string {
   return s.strip_margin_custom(`|`)
}
pub fn (s string) strip_margin_custom(del byte) string {
	mut sep := del
	if sep.is_space() {
		eprintln("Warning: `strip_margin` cannot use white-space as a delimiter")
		eprintln("    Defaulting to `|`")
		sep = `|`
	}
	// don't know how much space the resulting string will be, but the max it
	// can be is this big
	mut ret := malloc(s.len + 1)
	mut count := 0
	for i := 0; i < s.len; i++ {
		if s[i] in [`\n`, `\r`] {
			ret[count] = s[i]
			count++
			// CRLF
			if s[i] == `\r` && i < s.len - 1 && s[i+1] == `\n` {
				ret[count] = s[i+1]
				count++
				i++
			}

			for s[i] != sep {
				i++
				if i >= s.len {
					break
				}
			}
		} else {
			ret[count] = s[i]
			count++
		}
	}
	ret[count] = 0
	return string(ret)
}
fn test_common_atoi() {
	// test common cases
	assert "70zzz".int() == 70
	assert "2901issue".int() == 2901
	assert '234232w'.int() == 234232
	assert '-9009x'.int() == -9009
	assert '0y'.int() == 0
	
	// test lead zeros
	assert '0000012'.int() == 12
	assert '-0000012'.int() == -12
	assert '0x001F'.int() == 31
	assert '-0x001F'.int() == -31
	assert '0x001f'.int() == 31
	assert '0o00011'.int() == 9
	assert '0b00001001'.int() == 9

	// test underscore in string
	assert '-10_000'.int() == -10000
	assert '-0x00_0_f_ff'.int() == -0xfff
	assert '10_000_000'.int() == 10000000

	for n in -10000 .. 100000 {
		s := n.str()+"z"
		assert s.int() == n
	}
}

fn test_unsigned_cast() {
	// tests for u16

    // test common cases
	assert "70zzz".u16() == 70
	assert "2901issue".u16() == 2901
	assert '0y'.u16() == 0
	
	// test lead zeros
	assert '0000012'.u16() == 12
	assert '0x001F'.u16() == 31
	assert '0x001f'.u16() == 31
	assert '0o00011'.u16() == 9
	assert '0b00001001'.u16() == 9

	// tests for u32

    // test common cases
	assert "70zzz".u32() == 70
	assert "2901issue".u32() == 2901
	assert '234232w'.u32() == 234232
	assert '-9009x'.u32() == 0
	assert '0y'.u32() == 0
	
	// test lead zeros
	assert '0000012'.u32() == 12
	assert '-0000012'.u32() == 0
	assert '0x001F'.u32() == 31
	assert '-0x001F'.u32() == 0
	assert '0x001f'.u32() == 31
	assert '0o00011'.u32() == 9
	assert '0b00001001'.u32() == 9

	// test underscore in string
	assert '-10_000'.u32() == 0
	assert '-0x00_0_f_ff'.u32() == 0
	assert '10_000_000'.u32() == 10000000

	for n in 0 .. 100 {
		s := n.str()+"z"
		assert s.u32() == n
	}

	// tests for u64

    // test common cases
	assert "70zzz".u64() == 70
	assert "2901issue".u64() == 2901
	assert '234232w'.u64() == 234232
	assert '-9009x'.u64() == 0
	assert '0y'.u64() == 0
	
	// test lead zeros
	assert '0000012'.u64() == 12
	assert '-0000012'.u64() == 0
	assert '0x001F'.u64() == 31
	assert '-0x001F'.u64() == 0
	assert '0x001f'.u64() == 31
	assert '0o00011'.u64() == 9
	assert '0b00001001'.u64() == 9

	// test underscore in string
	assert '-10_000'.u64() == 0
	assert '-0x00_0_f_ff'.u64() == 0
	assert '10_000_000'.u64() == 10000000

	for n in 0 .. 10000 {
		s := n.str()+"z"
		assert s.u64() == n
	}

}

fn test_signed_cast() {
	// tests for i64

    // test common cases
	assert "70zzz".i64() == 70
	assert "2901issue".i64() == 2901
	assert '234232w'.i64() == 234232
	assert '-9009x'.i64() == -9009
	assert '0y'.i64() == 0
	
	// test lead zeros
	assert '0000012'.i64() == 12
	assert '-0000012'.i64() == -12
	assert '0x001F'.i64() == 31
	assert '-0x001F'.i64() == -31
	assert '0x001f'.i64() == 31
	assert '0o00011'.i64() == 9
	assert '0b00001001'.i64() == 9

	// test underscore in string
	assert '-10_000'.i64() == -10000
	assert '-0x00_0_f_ff'.i64() == -0xfff
	assert '10_000_000'.i64() == 10000000

	for n in -10000 .. 100000 {
		s := n.str()+"z"
		assert s.i64() == n
	}

	// tests for i8

    // test common cases
	assert "70zzz".i8() == 70
	assert "29issue".i8() == 29
	assert '22w'.i8() == 22
	assert '-90x'.i8() == -90
	assert '0y'.i8() == 0
	
	// test lead zeros
	assert '0000012'.i8() == 12
	assert '-0000012'.i8() == -12
	assert '0x001F'.i8() == 31
	assert '-0x001F'.i8() == -31
	assert '0x001f'.i8() == 31
	assert '0o00011'.i8() == 9
	assert '0b000011'.i8() == 3

	// test underscore in string
	assert '-10_0'.i8() == -100
	assert '-0x0_0_f'.i8() == -0xf
	assert '10_0'.i8() == 100

	for n in -10 .. 100 {
		s := n.str()+"z"
		assert s.i8() == n
	}

	// tests for i16

    // test common cases
	assert "70zzz".i16() == 70
	assert "2901issue".i16() == 2901
	assert '2342w'.i16() == 2342
	assert '-9009x'.i16() == -9009
	assert '0y'.i16() == 0
	
	// test lead zeros
	assert '0000012'.i16() == 12
	assert '-0000012'.i16() == -12
	assert '0x001F'.i16() == 31
	assert '-0x001F'.i16() == -31
	assert '0x001f'.i16() == 31
	assert '0o00011'.i16() == 9
	assert '0b00001001'.i16() == 9

	// test underscore in string
	assert '-10_0'.i16() == -100
	assert '-0x00_0_fff'.i16() == -0xfff
	assert '10_0'.i16() == 100

	for n in -100 .. 100 {
		s := n.str()+"z"
		assert s.i16() == n
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

fn test_strip_margins_no_tabs() {
	no_tabs := ['Hello there',
	            'This is a string',
	            'With multiple lines',
	           ].join('\n')
	no_tabs_stripped := 'Hello there
	                    |This is a string
						|With multiple lines'.strip_margin()
	assert no_tabs == no_tabs_stripped
}

fn test_strip_margins_text_before() {
	text_before := ['There is text',
	                'before the delimiter',
	                'that should be removed as well',
	               ].join('\n')
	text_before_stripped := 'There is text
	f lasj  asldfj j lksjdf |before the delimiter
	Which is removed hello  |that should be removed as well'.strip_margin()
	assert text_before_stripped == text_before
}

fn test_strip_margins_white_space_after_delim() {
	tabs := ['	Tab',
	         '    spaces',
	         '	another tab',
	        ].join('\n')
	tabs_stripped := '	Tab
	                 |    spaces
					 |	another tab'.strip_margin()
	assert tabs == tabs_stripped
}

fn test_strip_margins_alternate_delim() {
	alternate_delimiter := ['This has a different delim,',
	                        'but that is ok',
	                        'because everything works',
	                       ].join('\n')
	alternate_delimiter_stripped := 'This has a different delim,
	                                #but that is ok
                                    #because everything works'.strip_margin_custom(`#`)
	assert alternate_delimiter_stripped == alternate_delimiter
}

fn test_strip_margins_multiple_delims_after_first() {
	delim_after_first_instance := ['The delimiter used',
	                               'only matters the |||| First time it is seen',
	                               'not any | other | times',
	                              ].join('\n')
	delim_after_first_instance_stripped := 'The delimiter used
	                                       |only matters the |||| First time it is seen
	                                       |not any | other | times'.strip_margin()
	assert delim_after_first_instance_stripped == delim_after_first_instance
}

fn test_strip_margins_uneven_delims() {
	uneven_delims := ['It doesn\'t matter if the delims are uneven,',
	                  'The text will still be delimited correctly.',
	                  'Maybe not everything needs 3 lines?',
	                  'Let us go for 4 then',
	                 ].join('\n')
	uneven_delims_stripped := 'It doesn\'t matter if the delims are uneven,
           |The text will still be delimited correctly.
                      |Maybe not everything needs 3 lines?
				|Let us go for 4 then'.strip_margin()
	assert uneven_delims_stripped == uneven_delims
}

fn test_strip_margins_multiple_blank_lines() {
	multi_blank_lines := ['Multiple blank lines will be removed.',
	                      '	I actually consider this a feature.',
	                     ].join('\n')
	multi_blank_lines_stripped := 'Multiple blank lines will be removed.



		|	I actually consider this a feature.'.strip_margin()
	assert multi_blank_lines == multi_blank_lines_stripped
}

fn test_strip_margins_end_newline() {
	end_with_newline := ['This line will end with a newline',
	                     'Something cool or something.',
	                     '',
	                    ].join('\n')
	end_with_newline_stripped := 'This line will end with a newline
	                             |Something cool or something.

					'.strip_margin()
	assert end_with_newline_stripped == end_with_newline
}

fn test_strip_margins_space_delimiter() {
	space_delimiter := ['Using a white-space char will',
	                    'revert back to default behavior.',
	                   ].join('\n')
	space_delimiter_stripped := 'Using a white-space char will
		|revert back to default behavior.'.strip_margin_custom(`\n`)
	assert space_delimiter == space_delimiter_stripped
}

fn test_strip_margins_crlf() {
	crlf := ['This string\'s line endings have CR as well as LFs.',
	         'This should pass',
	         'Definitely',
	        ].join('\r\n')
	crlf_stripped := 'This string\'s line endings have CR as well as LFs.\r
	                 |This should pass\r
					 |Definitely'.strip_margin()

	assert crlf == crlf_stripped
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

struct Foo {
	bar int
mut:
	str string
}

fn test_add() {
	mut a := 'a'
	a += 'b'
	assert a==('ab')
	a = 'a'
	for i := 1; i < 1000; i++ {
		a += 'b'
	}
	assert a.len == 1000
	assert a.ends_with('bbbbb')
	a += '123'
	assert a.ends_with('3')
}

fn test_ends_with() {
	a := 'browser.v'
	assert a.ends_with('.v')

	s := 'V Programming Language'
	assert s.ends_with('guage') == true
	assert s.ends_with('Language') == true
	assert s.ends_with('Programming Language') == true
	assert s.ends_with('V') == false
}

fn test_between() {
	 s := 'hello [man] how you doing'
	assert s.find_between('[', ']') == 'man'
}

fn test_compare() {
	a := 'Music'
	b := 'src'
	assert b>=(a)
}

fn test_lt() {
	a := ''
	b := 'a'
	c := 'a'
	d := 'b'
	e := 'aa'
	f := 'ab'
	assert a < (b)
	assert !(b < c)
	assert c < (d)
	assert !(d < e)
	assert c < (e)
	assert e < (f)
}

fn test_ge() {
	a := 'aa'
	b := 'aa'
	c := 'ab'
	d := 'abc'
	e := 'aaa'
	assert b >= (a)
	assert c >= (b)
	assert d >= (c)
	assert !(c >= d)
	assert e >= (a)
}

fn test_compare_strings() {
	a := 'aa'
	b := 'aa'
	c := 'ab'
	d := 'abc'
	e := 'aaa'
	assert compare_strings(a, b) == 0
	assert compare_strings(b, c) == -1
	assert compare_strings(c, d) == -1
	assert compare_strings(d, e) == 1
	assert compare_strings(a, e) == -1
	assert compare_strings(e, a) == 1
}

fn test_sort() {
	mut vals := [
		'arr', 'an', 'a', 'any'
	]
	len := vals.len
	vals.sort()
	assert len == vals.len
	assert vals[0] == 'a'
	assert vals[1] == 'an'
	assert vals[2] == 'any'
	assert vals[3] == 'arr'
}

fn test_split_nth() {
	a := "1,2,3"
	assert (a.split(',').len == 3)
	assert (a.split_nth(',', -1).len == 3)
	assert (a.split_nth(',', 0).len == 3)
	assert (a.split_nth(',', 1).len == 1)
	assert (a.split_nth(',', 2).len == 2)
	assert (a.split_nth(',', 10).len == 3)
	b := "1::2::3"
	assert (b.split('::').len == 3)
	assert (b.split_nth('::', -1).len == 3)
	assert (b.split_nth('::', 0).len == 3)
	assert (b.split_nth('::', 1).len == 1)
	assert (b.split_nth('::', 2).len == 2)
	assert (b.split_nth('::', 10).len == 3)
	c := "ABCDEF"
	println(c.split('').len)
	assert (c.split('').len == 6)
	assert (c.split_nth('', 3).len == 3)
	assert (c.split_nth('BC', -1).len == 2)
	d := ","
	assert (d.split(',').len == 2)
	assert (d.split_nth('', 3).len == 1)
	assert (d.split_nth(',', -1).len == 2)
	assert (d.split_nth(',', 3).len == 2)
	e := ",,,0,,,,,a,,b,"
	// assert (e.split(',,').len == 5)
	// assert (e.split_nth(',,', 3).len == 2)
	assert (e.split_nth(',', -1).len == 12)
	assert (e.split_nth(',', 3).len == 3)
}

fn test_split_nth_values() {
	line := 'CMD=eprintln(phase=1)'

	a0 := line.split_nth('=', 0)
	assert a0.len == 3
	assert a0[0] == 'CMD'
	assert a0[1] == 'eprintln(phase'
	assert a0[2] == '1)'

	a1 := line.split_nth('=', 1)
	assert a1.len == 1
	assert a1[0] == 'CMD=eprintln(phase=1)'

	a2 := line.split_nth('=', 2)
	assert a2.len == 2
	assert a2[0] == 'CMD'
	assert a2[1] == 'eprintln(phase=1)'

	a3 := line.split_nth('=', 3)
	assert a3.len == 3
	assert a3[0] == 'CMD'
	assert a3[1] == 'eprintln(phase'
	assert a3[2] == '1)'

	a4 := line.split_nth('=', 4)
	assert a4.len == 3
	assert a4[0] == 'CMD'
	assert a4[1] == 'eprintln(phase'
	assert a4[2] == '1)'
}

fn test_split() {
	mut s := 'volt/twitch.v:34'
	mut vals := s.split(':')
	assert vals.len == 2
	assert vals[0] == 'volt/twitch.v'
	assert vals[1] == '34'
	// /////////
	s = '2018-01-01z13:01:02'
	vals = s.split('z')
	assert vals.len == 2
	assert vals[0] =='2018-01-01'
	assert vals[1] == '13:01:02'
	// //////////
	s = '4627a862c3dec29fb3182a06b8965e0025759e18___1530207969___blue'
	vals = s.split('___')
	assert vals.len == 3
	assert vals[0]== '4627a862c3dec29fb3182a06b8965e0025759e18'
	assert vals[1]=='1530207969'
	assert vals[2]== 'blue'
	// /////////
	s = 'lalala'
	vals = s.split('a')
	assert vals.len == 4
	assert vals[0] == 'l'
	assert vals[1] == 'l'
	assert vals[2] == 'l'
	assert vals[3] == ''
	// /////////
	s = 'awesome'
	a := s.split('')
	assert a.len == 7
	assert a[0] == 'a'
	assert a[1] == 'w'
	assert a[2] == 'e'
	assert a[3] == 's'
	assert a[4] == 'o'
	assert a[5] == 'm'
	assert a[6] == 'e'
}

fn test_trim_space() {
	a := ' a '
	assert a.trim_space() == 'a'
	code := '

fn main() {
        println(2)
}

'
	code_clean := 'fn main() {
        println(2)
}'
	assert code.trim_space() == code_clean
}

fn test_join() {
	mut strings := [ 'a', 'b', 'c' ]
	mut s := strings.join(' ')
	assert s == 'a b c'
	strings = ['one
two ',
	'three!
four!']
	s = strings.join(' ')
	assert s.contains('one') && s.contains('two ') && s.contains('four')
}

fn test_clone() {
	mut a := 'a'
	a += 'a'
	a += 'a'
	b := a
	c := a.clone()
	assert c == a
	assert c == 'aaa'
	assert b == 'aaa'
}

fn test_replace() {
	a := 'hello man!'
	mut b := a.replace('man', 'world')
	assert b==('hello world!')
	b = b.replace('!', '')
	assert b==('hello world')
	b = b.replace('h', 'H')
	assert b==('Hello world')
	b = b.replace('foo', 'bar')
	assert b==('Hello world')
	s := 'hey man how are you'
	assert s.replace('man ', '') == 'hey how are you'
	lol := 'lol lol lol'
	assert lol.replace('lol', 'LOL') == 'LOL LOL LOL'
	b = 'oneBtwoBBthree'
	assert b.replace('B', '') == 'onetwothree'
	b = '*charptr'
	assert b.replace('charptr', 'byteptr') == '*byteptr'
	c :='abc'
	assert c.replace('','-') == c
	v :='a   b c d'
	assert v.replace('  ',' ') == 'a  b c d'

}

fn test_replace_each() {
	s := 'hello man man :)'
	q := s.replace_each([
		'man', 'dude',
		'hello', 'hey'
	])
	assert q == 'hey dude dude :)'
	bb := '[b]bold[/b] [code]code[/code]'
	assert bb.replace_each([
		'[b]', '<b>',
		'[/b]', '</b>',
		'[code]', '<code>',
		'[/code]', '</code>'
	]) == '<b>bold</b> <code>code</code>'
	bb2 := '[b]cool[/b]'
	assert bb2.replace_each([
		'[b]', '<b>',
		'[/b]', '</b>',
	]) == '<b>cool</b>'
}

fn test_itoa() {
	num := 777
	assert num.str() == '777'
	big := 7779998
	assert big.str() == '7779998'
	a := 3
	assert a.str() == '3'
	b := 5555
	assert b.str() == '5555'
	zero := 0
	assert zero.str() == '0'
	neg := -7
	assert neg.str() == '-7'
}

fn test_reassign() {
	a := 'hi'
	mut b := a
	b += '!'
	assert a == 'hi'
	assert b == 'hi!'
}

fn test_runes() {
	s := ''
	assert s.len == 12
	s2 := 'privet'
	assert s2.len == 6
	u := s.ustring()
	assert u.len == 6
	assert s2.substr(1, 4).len == 3
	assert s2.substr(1, 4) == 'riv'
	assert s2[1..4].len == 3
	assert s2[1..4] == 'riv'
	assert s2[..4].len == 4
	assert s2[..4] == 'priv'
	assert s2[2..].len == 4
	assert s2[2..] == 'ivet'
	assert u.substr(1, 4).len == 6
	assert u.substr(1, 4) == ''
	assert s2.substr(1, 2) == 'r'
	assert u.substr(1, 2) == ''
	assert s2.ustring().at(1) == 'r'
	assert u.at(1) == ''
	first := u.at(0)
	last := u.at(u.len - 1)
	assert first.len == 2
	assert last.len == 2
}

fn test_left_right() {
	s := 'ALOHA'
	assert s.left(3) == 'ALO'
	assert s.left(0) == ''
	assert s.left(8) == s
	assert s.right(3) == 'HA'
	assert s.right(6) == ''
	assert s[3..] == 'HA'
	u := s.ustring()
	assert u.left(3) == 'ALO'
	assert u.left(0) == ''
	assert s.left(8) == s
	assert u.right(3) == 'HA'
	assert u.right(6) == ''
}

fn test_contains() {
	s := 'view.v'
	assert s.contains('vi')
	assert !s.contains('random')
}

fn test_arr_contains() {
	a := ['a', 'b', 'c']
	assert a.contains('b')
	ints := [1, 2, 3]
	assert ints.contains(2)
}

fn test_to_num() {
	s := '7'
	assert s.int() == 7
	assert s.u64() == 7
	f := '71.5 hasdf'
	// QTODO
	assert f.f32() == 71.5
	vals := ['9']
	assert vals[0].int() == 9
	big := '93993993939322'
	assert big.u64() == 93993993939322
	assert big.i64() == 93993993939322
}

fn test_inter_format_string() {
	float_num := 1.52345
	float_num_string := '-${float_num:.03f}-'
	assert float_num_string == '-1.523-'
	int_num := 7
	int_num_string := '-${int_num:03d}-'
	assert int_num_string == '-007-'
	ch := `a`
	ch_string := '-${ch:c}-'
	assert ch_string == '-a-'
	hex_n := 192
	hex_n_string := '-${hex_n:x}-'
	assert hex_n_string == '-c0-'
	oct_n := 192
	oct_n_string := '-${oct_n:o}-'
	assert oct_n_string == '-300-'
	str := 'abc'
	str_string := '-${str:s}-'
	assert str_string == '-abc-'
}

fn test_hash() {
	s := '10000'
	assert s.hash() == 46730161
	s2 := '24640'
	assert s2.hash() == 47778736
	s3 := 'Content-Type'
	assert s3.hash() == 949037134
	s4 := 'bad_key'
	assert s4.hash() == -346636507
	s5 := '24640'
	// From a map collision test
	assert s5.hash() % ((1 << 20) -1) == s.hash() % ((1 << 20) -1)
	assert s5.hash() % ((1 << 20) -1) == 592861
}

fn test_trim() {
	assert 'banana'.trim('bna') == ''
	assert 'abc'.trim('ac') == 'b'
	assert 'aaabccc'.trim('ac') == 'b'
}

fn test_trim_left() {
	mut s := 'module main'
	assert s.trim_left(' ') == 'module main'
	s = ' module main'
	assert s.trim_left(' ') == 'module main'
	// test cutset
	s = 'banana'
	assert s.trim_left('ba') == 'nana'
	assert s.trim_left('ban') == ''
}

fn test_trim_right() {
	mut s := 'module main'
	assert s.trim_right(' ') == 'module main'
	s = 'module main '
	assert s.trim_right(' ') == 'module main'
	// test cutset
	s = 'banana'
	assert s.trim_right('na') == 'b'
	assert s.trim_right('ban') == ''
}

fn test_all_before() {
	s := 'fn hello fn'
	assert s.all_before(' ') == 'fn'
	assert s.all_before('2') == s
	assert s.all_before('') == s
}

fn test_all_before_last() {
	s := 'fn hello fn'
	assert s.all_before_last(' ') == 'fn hello'
	assert s.all_before_last('2') == s
	assert s.all_before_last('') == s
}

fn test_all_after() {
	s := 'fn hello'
	assert s.all_after('fn ') == 'hello'
	assert s.all_after('test') == s
	assert s.all_after('') == s
	assert s.after('e') == 'llo'
	x := s.after('e')
	assert x == 'llo'
}

fn test_reverse() {
	assert 'hello'.reverse() == 'olleh'
	assert ''.reverse() == ''
	assert 'a'.reverse() == 'a'
}

fn test_bytes_to_string() {
	mut buf := vcalloc(10)
	buf[0] = `h`
	buf[1] = `e`
	buf[2] = `l`
	buf[3] = `l`
	buf[4] = `o`
	assert string(buf) == 'hello'
	assert string(buf, 2) == 'he'
	bytes := [`h`, `e`, `l`, `l`, `o`]
	assert string(bytes, 5) == 'hello'
}

fn test_count() {
	assert ''.count('') == 0
	assert ''.count('a') == 0
	assert 'a'.count('') == 0
	assert 'aa'.count('a') == 2
	assert 'aa'.count('aa') == 1
	assert 'aabbaa'.count('aa') == 2
	assert 'bbaabb'.count('aa') == 1
}

fn test_lower() {
	mut s := 'A'
	assert !s.is_lower()
	assert s.to_lower() == 'a'
	assert s.to_lower().len == 1
	s = 'HELLO'
	assert !s.is_lower()
	assert s.to_lower() == 'hello'
	assert s.to_lower().len == 5
	s = 'Aloha'
	assert !s.is_lower()
	assert s.to_lower() == 'aloha'
	s = 'Have A nice Day!'
	assert !s.is_lower()
	assert s.to_lower() == 'have a nice day!'
	s = 'hi'
	assert s.is_lower()
	assert s.to_lower() == 'hi'
	assert 'aloha!'[0] == `a`
	assert 'aloha!'[5] == `!`
}

fn test_upper() {
	mut s := 'a'
	assert !s.is_upper()
	assert s.to_upper() == 'A'
	assert s.to_upper().len == 1
	s = 'hello'
	assert !s.is_upper()
	assert s.to_upper() == 'HELLO'
	assert s.to_upper().len == 5
	s = 'Aloha'
	assert !s.is_upper()
	assert s.to_upper() == 'ALOHA'
	s = 'have a nice day!'
	assert !s.is_upper()
	assert s.to_upper() == 'HAVE A NICE DAY!'
	s = 'HI'
	assert s.is_upper()
	assert s.to_upper() == 'HI'
}

fn test_capitalize() {
	mut s := 'hello'
	assert !s.is_capital()
	assert s.capitalize() == 'Hello'
	s = 'test'
	assert !s.is_capital()
	assert s.capitalize() == 'Test'
    s = 'i am ray'
	assert !s.is_capital()
	assert s.capitalize() == 'I am ray'
	s = ''
	assert !s.is_capital()
	assert s.capitalize() == ''
	s = 'TEST IT'
	assert !s.is_capital()
	assert s.capitalize() == 'Test it'
	s = 'Test it'
	assert s.is_capital()
	assert s.capitalize() == 'Test it'
}

fn test_title() {
	mut s := 'hello world'
	assert !s.is_title()
	assert s.title() == 'Hello World'
	s = 'HELLO WORLD'
	assert !s.is_title()
	assert s.title() == 'Hello World'
	s = 'Hello World'
	assert s.is_title()
	assert s.title() == 'Hello World'
}

fn test_for_loop() {
	mut i := 0
	s := 'abcd'

	for c in s {
		assert c == s[i]
		i++
	}
}

fn test_for_loop_two() {
	s := 'abcd'

	for i, c in s {
		assert c == s[i]
	}
}

fn test_quote() {
	a := `'`
	println("testing double quotes")
	b := "hi"
	assert b == 'hi'
	assert a.str() == '\''
}


fn test_ustring_comparisons() {
	/*
	QTODO
	assert ('hll !'.ustring() == 'hll !'.ustring()) == true
	assert ('hll !'.ustring() == 'hll'.ustring()) == false
	assert ('hll !'.ustring() == 'hllo !'.ustring()) == false

	assert ('hll !'.ustring() != 'hll !'.ustring()) == false
	assert ('hll !'.ustring() != 'hll'.ustring()) == true

	assert ('hll'.ustring() < 'hll!'.ustring()) == true
	assert ('hll'.ustring() < 'hllo'.ustring()) == false
	assert ('hllo'.ustring() < 'hll'.ustring()) == true

	assert ('hll'.ustring() <= 'hll!'.ustring()) == true
	assert ('hll'.ustring() <= 'hll'.ustring()) == true
	assert ('hll!'.ustring() <= 'hll'.ustring()) == false

	assert ('hll!'.ustring() > 'hll'.ustring()) == true
	assert ('hll'.ustring() > 'hll'.ustring()) == false

	assert ('hll!'.ustring() >= 'hll'.ustring()) == true
	assert ('hll'.ustring() >= 'hll'.ustring()) == true
	assert ('hll'.ustring() >= 'hll!'.ustring()) == false
	*/
}

fn test_ustring_count() {
	a := 'hll hll '.ustring()
	assert (a.count('l'.ustring())) == 4
	assert (a.count(''.ustring())) == 2
	assert (a.count('hll'.ustring())) == 2
	assert (a.count(''.ustring())) == 2
	assert (a.count('a'.ustring())) == 0
}

fn test_limit() {
	s := 'hello'
	assert s.limit(2) == 'he'
	assert s.limit(9) == s
	assert s.limit(0) == ''
	// assert s.limit(-1) == ''
}

fn test_repeat() {
	s1 := 'V! '
	assert s1.repeat(5) == 'V! V! V! V! V! '
	assert s1.repeat(1) == s1
	assert s1.repeat(0) == ''
	s2 := ''
	assert s2.repeat(5) == s2
	assert s2.repeat(1) == s2
	assert s2.repeat(0) == s2
	// TODO Add test for negative values
}

fn test_starts_with() {
	s := 'V Programming Language'
	assert s.starts_with('V') == true
	assert s.starts_with('V Programming') == true
	assert s.starts_with('Language') == false
}

fn test_trim_prefix() {
	s := 'V Programming Language'
	assert s.trim_prefix('V ') == 'Programming Language'
	assert s.trim_prefix('V Programming ') == 'Language'
	assert s.trim_prefix('Language') == s
}

fn test_trim_suffix() {
	s := 'V Programming Language'
	assert s.trim_suffix(' Language') == 'V Programming'
	assert s.trim_suffix(' Programming Language') == 'V'
	assert s.trim_suffix('V') == s
}

fn test_raw() {
	raw := r'raw\nstring'
	lines := raw.split('\n')
	println(lines)
	assert lines.len == 1
	println('raw string: "$raw"')
}

fn test_raw_with_quotes() {
	raw := r"some'" + r'"thing' // " should be escaped in the generated C code
	assert raw[0] == `s`
	assert raw[5] == `"`
	assert raw[6] == `t`
}

fn test_escape() {
	// TODO
	//a := 10
	//println("\"$a")
}

fn test_atoi() {
	assert '234232'.int() == 234232
	assert '-9009'.int() == -9009
	assert '0'.int() == 0
	for n in -10000 .. 100000 {
		s := n.str()
		assert s.int() == n
	}
}

fn test_raw_inter() {
	world := 'world'
	println(world)
	s := r'hello\n$world'
	assert s == r'hello\n$world'
	assert s.contains('$')
}

fn test_c_r() {
	// This used to break because of r'' and c''
	c := 42
	println('$c')
	r := 50
	println('$r')
}

fn test_inter_before_comp_if() {
	s := '123'
	// This used to break ('123 $....')
	$if linux {
		println(s)
	}
	assert s == '123'
}

fn test_double_quote_inter() {
	a := 1
	b := 2
	println("${a} ${b}")
	assert "${a} ${b}" == "1 2"
	assert '${a} ${b}' == "1 2"
}

fn test_split_into_lines() {
	line_content := 'Line'
	text_crlf := '${line_content}\r\n${line_content}\r\n${line_content}'
	lines_crlf := text_crlf.split_into_lines()

	assert lines_crlf.len == 3
	for line in lines_crlf {
		assert line == line_content
	}

	text_lf := '${line_content}\n${line_content}\n${line_content}'
	lines_lf := text_lf.split_into_lines()

	assert lines_lf.len == 3
	for line in lines_lf {
		assert line == line_content
	}
}

fn test_string_literal_with_backslash(){
    a := 'Hello\
          World'
    assert a == 'HelloWorld'

	b := 'One\
		  Two\
		  Three'
	assert b == 'OneTwoThree'
}

/*
type MyString string

fn test_string_alias() {
	s := MyString('hi')
	ss := s + '!'
}
*/
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builtin

pub fn utf8_char_len(b byte) int {
	return ((0xe5000000>>((b>>3) & 0x1e)) & 3) + 1
}

// Convert utf32 to utf8
// utf32 == Codepoint
pub fn utf32_to_str(code u32) string {
	icode := int(code) // Prevents doing casts everywhere
	mut buffer := malloc(5)
	if icode <= 127/* 0x7F */ {
		buffer[0] = icode
		return tos(buffer, 1)
	}
	if icode <= 2047/* 0x7FF */ {
		buffer[0] = 192/*0xC0*/ | (icode>>6)/* 110xxxxx */

		buffer[1] = 128/*0x80*/ | (icode & 63/*0x3F*/)/* 10xxxxxx */

		return tos(buffer, 2)
	}
	if icode <= 65535/* 0xFFFF */ {
		buffer[0] = 224/*0xE0*/ | (icode>>12)/* 1110xxxx */

		buffer[1] = 128/*0x80*/ | ((icode>>6) & 63/*0x3F*/)/* 10xxxxxx */

		buffer[2] = 128/*0x80*/ | (icode & 63/*0x3F*/)/* 10xxxxxx */

		return tos(buffer, 3)
	}
	if icode <= 1114111/* 0x10FFFF */ {
		buffer[0] = 240/*0xF0*/ | (icode>>18)/* 11110xxx */

		buffer[1] = 128/*0x80*/ | ((icode>>12) & 63/*0x3F*/)/* 10xxxxxx */

		buffer[2] = 128/*0x80*/ | ((icode>>6) & 63/*0x3F*/)/* 10xxxxxx */

		buffer[3] = 128/*0x80*/ | (icode & 63/*0x3F*/)/* 10xxxxxx */

		return tos(buffer, 4)
	}
	return ''
}

// TODO copypasta
pub fn utf32_to_str_no_malloc(code u32, buf voidptr) string {
	icode := int(code) // Prevents doing casts everywhere
	mut buffer := byteptr(buf)
	if icode <= 127/* 0x7F */ {
		buffer[0] = icode
		return tos(buffer, 1)
	}
	if icode <= 2047/* 0x7FF */ {
		buffer[0] = 192/*0xC0*/ | (icode>>6)/* 110xxxxx */

		buffer[1] = 128/*0x80*/ | (icode & 63/*0x3F*/)/* 10xxxxxx */

		return tos(buffer, 2)
	}
	if icode <= 65535/* 0xFFFF */ {
		buffer[0] = 224/*0xE0*/ | (icode>>12)/* 1110xxxx */

		buffer[1] = 128/*0x80*/ | ((icode>>6) & 63/*0x3F*/)/* 10xxxxxx */

		buffer[2] = 128/*0x80*/ | (icode & 63/*0x3F*/)/* 10xxxxxx */

		return tos(buffer, 3)
	}
	if icode <= 1114111/* 0x10FFFF */ {
		buffer[0] = 240/*0xF0*/ | (icode>>18)/* 11110xxx */

		buffer[1] = 128/*0x80*/ | ((icode>>12) & 63/*0x3F*/)/* 10xxxxxx */

		buffer[2] = 128/*0x80*/ | ((icode>>6) & 63/*0x3F*/)/* 10xxxxxx */

		buffer[3] = 128/*0x80*/ | (icode & 63/*0x3F*/)/* 10xxxxxx */

		return tos(buffer, 4)
	}
	return ''
}

// Convert utf8 to utf32
pub fn (_rune string) utf32_code() int {
	if _rune.len == 0 {
		return 0
	}
	// save ASC symbol as is
	if _rune.len == 1 {
		return int(_rune[0])
	}
	mut b := byte(int(_rune[0]))
	// TODO should be
	// res := int( rune[0] << rune.len)
	b = b<<_rune.len
	mut res := int(b)
	mut shift := 6 - _rune.len
	for i := 1; i < _rune.len; i++ {
		c := int(_rune[i])
		res = res<<shift
		res |= c & 63 // 0x3f
		shift = 6
	}
	return res
}

const (
	cp_utf8 = 65001
)

pub fn (_str string) to_wide() &u16 {
	$if windows {
		num_chars := (C.MultiByteToWideChar(cp_utf8, 0, _str.str, _str.len, 0, 0))
		mut wstr := &u16(malloc((num_chars + 1) * 2)) // sizeof(wchar_t)
		if wstr != 0 {
			C.MultiByteToWideChar(cp_utf8, 0, _str.str, _str.len, wstr, num_chars)
			C.memset(&byte(wstr) + num_chars * 2, 0, 2)
		}
		return wstr
	} $else {
		return 0
	}
}

pub fn string_from_wide(_wstr &u16) string {
	$if windows {
		wstr_len := C.wcslen(_wstr)
		return string_from_wide2(_wstr, wstr_len)
	} $else {
		return ''
	}
}

pub fn string_from_wide2(_wstr &u16, len int) string {
	$if windows {
		num_chars := C.WideCharToMultiByte(cp_utf8, 0, _wstr, len, 0, 0, 0, 0)
		mut str_to := malloc(num_chars + 1)
		if str_to != 0 {
			C.WideCharToMultiByte(cp_utf8, 0, _wstr, len, str_to, num_chars, 0, 0)
			C.memset(str_to + num_chars, 0, 1)
		}
		return tos2(str_to)
	} $else {
		return ''
	}
}

// Calculate length to read from the first byte
fn utf8_len(c byte) int {
	mut b := 0
	mut x := c
	if (x & 240) != 0 {
		// 0xF0
		x >>= 4
	}
	else {
		b += 4
	}
	if (x & 12) != 0 {
		// 0x0C
		x >>= 2
	}
	else {
		b += 2
	}
	if (x & 2) == 0 {
		// 0x02
		b++
	}
	return b
}

// Calculate string length for in number of codepoints
fn utf8_str_len(s string) int {
	mut l := 0
	for i := 0; i < s.len; i++ {
		l++
		c := s.str[i]
		if (c & (1 << 7)) != 0 {
			for t := byte(1 << 6); (c & t) != 0; t >>= 1 {
				i++
			}
		}
	}
	return l
}

// Calculate string length for formatting, i.e. number of "characters"
fn utf8_str_visible_length(s string) int {
	mut l := 0
	mut ul := 1
	for i := 0; i < s.len; i+=ul {
		ul = 1
		c := s.str[i]
		if (c & (1 << 7)) != 0 {
			for t := byte(1 << 6); (c & t) != 0; t >>= 1 {
				ul++
			}
		}
		if i + ul > s.len { // incomplete UTF-8 sequence
			return l
		}
		l++
		// recognize combining characters
		if c == 0xcc || c == 0xcd {
			r := (u16(c) << 8) | s.str[i+1]
			if r >= 0xcc80 && r < 0xcdb0 { // diacritical marks
				l--
			}
		} else if c == 0xe1 || c == 0xe2 || c == 0xef {
			r := (u32(c) << 16) | (u32(s.str[i+1]) << 8) | s.str[i+2]
			if r >= 0xe1aab0 && r < 0xe1ac80 // diacritical marks extended
			|| r >= 0xe1b780 && r < 0xe1b880 // diacritical marks supplement
			|| r >= 0xe28390 && r < 0xe28480 // diacritical marks for symbols
			|| r >= 0xefb8a0 && r < 0xefb8b0 { // half marks
				l--
			}
		}
	}
	return l
}

// Reads an utf8 character from standard input
pub fn utf8_getchar() int {
	c := C.getchar()
	len := utf8_len(~c)
	if c < 0 {
		return 0
	}
	else if len == 0 {
		return c
	}
	else if len == 1 {
		return -1
	}
	else {
		mut uc := c & ((1<<(7 - len)) - 1)
		for i := 0; i + 1 < len; i++ {
			c2 := C.getchar()
			if c2 != -1 && (c2>>6) == 2 {
				uc <<= 6
				uc |= (c2 & 63)
			}
			else if c2 == -1 {
				return 0
			}
			else {
				return -1
			}
		}
		return uc
	}
}
fn test_utf8_char_len() {
	assert utf8_char_len(`a`) == 1
	println(utf8_char_len(`a`))
	s := ''
	assert utf8_char_len(s[0]) == 2
}
module builtin

pub struct array {
pub:
	data voidptr
	len int
	cap int
	element_size int
}

// for now off the stack
fn new_array_from_c_array(len int, cap int, elm_size int, c_array voidptr) array {
	arr := array {
		len: len
		cap: cap
		element_size: elm_size
		data: c_array
	}
	return arr
}

// Private function. Used to implement array[] operator
fn (a array) get(i int) voidptr {
	if i < 0 || i >= a.len {
		panic('array.get: index out of range') // FIXME: (i == $i, a.len == $a.len)')
	}
	return a.data + i * a.element_size
}

// Private function. Used to implement assigment to the array element.
fn (mut a array) set(i int, val voidptr) {
	if i < 0 || i >= a.len {
		panic('array.set: index out of range') //FIXME: (i == $i, a.len == $a.len)')
	}
	mem_copy(a.data + a.element_size * i, val, a.element_size)
}


// array.repeat returns new array with the given array elements
// repeated `nr_repeat` times
pub fn (a array) repeat(nr_repeats int) array {
	assert nr_repeats >= 0

	arr := array {
		len: nr_repeats * a.len
		cap: nr_repeats * a.len
		element_size: a.element_size
		data: malloc(nr_repeats * a.len * a.element_size)
	}
	for i in 0..nr_repeats {
		mem_copy(arr.data + i * a.len * a.element_size, a.data, a.len * a.element_size)
	}
	return arr
}
module builtin

// called by the generated main/init
fn init() {
}

pub fn isnil(p voidptr) bool {
	return p == 0
}

pub fn print(s string) {
	sys_write(1, s.str, u64(s.len))
}

pub fn println(s string) {
	print(s)
	print("\n")
}

pub fn panic(s string) {
	eprint('V panic: ')
	eprintln(s)
	sys_exit(1)
}

// replaces panic when -debug arg is passed
fn panic_debug(line_no int, file,  mod, fn_name, s string) {
	eprintln('================ V panic ================')
	eprint('   module: ')
	eprintln('mod')
	eprint(' function: ')
	eprint(fn_name)
	eprintln('()')
	eprintln('     file: ')
	eprintln(file)
	//println('     line: ${line_no}')
	eprint('  message: ')
	eprintln(s)
	eprintln('=========================================')
	sys_exit(1)
}
pub fn eprint(s string) {
	if isnil(s.str) {
		panic('eprint(NIL)')
	}
	sys_write(2, s.str, u64(s.len))
}

pub fn eprint_ln(s string) {
	eprint(s)
	eprint("\n")
}

pub fn eprintln(s string) {
	if isnil(s.str) {
		panic('eprintln(NIL)')
	}
	eprint_ln(s)
}
module builtin

pub enum Linux_mem {
	page_size = 4096
}

pub enum Wp_sys {
	wnohang = 0x00000001
	wuntraced = 0x00000002
	wstopped = 0x00000002
	wexited	= 0x00000004
	wcontinued = 0x00000008
	wnowait = 0x01000000 // don't reap, just poll status.
	__wnothread = 0x20000000 // don't wait on children of other threads in this group
	__wall = 0x40000000 // wait on all children, regardless of type
	__wclone = 0x80000000 // wait only on non-sigchld children
}

// First argument to waitid:
pub enum Wi_which {
	p_all = 0
	p_pid = 1
	p_pgid = 2
}

pub enum Wi_si_code {
	cld_exited = 1 // child has exited
	cld_killed = 2 // child was killed
	cld_dumped = 3 // child terminated abnormally
	cld_trapped = 4 // traced child has trapped
	cld_stopped = 5 // child has stopped
	cld_continued = 6 // stopped child has continued
}

/* Paraphrased from "man 2 waitid" on Linux

	Upon successful return, waitid() fills in the
	following fields of the siginfo_t structure
	pointed to by infop:

	si_pid, offset 0x10, int index 0x04:
		The process ID of the child.

	si_uid: offset 0x14, int index 0x05
		The real user ID of the child.

	si_signo: offset 0x00, int index 0x00
		Always set to SIGCHLD.

	si_status: ofset 0x18, int index 0x06
		1 the exit status of the child, as given to _exit(2)
			(or exit(3)) (sc_sys.cld_exited)
		2 the signal that caused the child to terminate, stop,
			or continue.
		3 The si_code field can be used to determine how to
			interpret this field.

	si_code, set to one of (enum Wi_si_code), offset 0x08, int index 0x02:
		CLD_EXITED (child called _exit(2));
		CLD_KILLED (child killed by signal);
		CLD_DUMPED (child  killed by signal, and dumped core);
		CLD_STOPPED (child stopped by signal);
		CLD_TRAPPED (traced child has trapped);
		CLD_CONTINUED (child continued by SIGCONT).
*/

pub enum Sig_index {
	si_signo = 0x00
	si_code = 0x02
	si_pid = 0x04
	si_uid = 0x05
	si_status = 0x06
	si_size = 0x80
}

pub enum Signo {
	sigint = 2	// Interactive attention signal.
	sigill = 4	// Illegal instruction.
	sigabrt = 6	// Abnormal termination.
	sigfpe = 8	// Erroneous arithmetic operation.
	sigsegv = 11	// Invalid access to storage.
	sigterm = 15	// Termination request.

	sighup =  1	// Hangup.
	sigquit = 3	// Quit.
	sigtrap = 5	// Trace/breakpoint trap.
	sigkill = 9	// Killed.
	sigpipe = 13	// Broken pipe.
	sigalrm = 14	// Alarm clock.

	sigttin = 21	// Background read from control terminal.
	sigttou = 22	// Background write to control terminal.
	sigxcpu = 24	// CPU time limit exceeded.
	sigxfsz = 25	// File size limit exceeded.
	sigvtalrm = 26	// Virtual timer expired.
	sigprof = 27	// Profiling timer expired.

	sigbus = 7
	sigusr1 = 10
	sigusr2 = 12
	sigchld = 17
	sigcont = 18
	sigstop = 19
	sigtstp = 20
	sigurg = 23
	sigpoll = 29
	sigsys = 31
}


pub enum Fcntl {
	fd_cloexec = 0x00000001
	f_dupfd = 0x00000000
	f_exlck = 0x00000004
	f_getfd = 0x00000001
	f_getfl = 0x00000003
	f_getlk = 0x00000005
	f_getlk64 = 0x0000000c
	f_getown = 0x00000009
	f_getowner_uids = 0x00000011
	f_getown_ex = 0x00000010
	f_getsig = 0x0000000b
	f_ofd_getlk = 0x00000024
	f_ofd_setlk = 0x00000025
	f_ofd_setlkw = 0x00000026
	f_owner_pgrp = 0x00000002
	f_owner_pid = 0x00000001
	f_owner_tid = 0x00000000
	f_rdlck = 0x00000000
	f_setfd = 0x00000002
	f_setfl = 0x00000004
	f_setlk = 0x00000006
	f_setlk64 = 0x0000000d
	f_setlkw = 0x00000007
	f_setlkw64 = 0x0000000e
	f_setown = 0x00000008
	f_setown_ex = 0x0000000f
	f_setsig = 0x0000000a
	f_shlck = 0x00000008
	f_unlck = 0x00000002
	f_wrlck = 0x00000001
	lock_ex = 0x00000002
	lock_mand = 0x00000020
	lock_nb = 0x00000004
	lock_read = 0x00000040
	lock_rw = 0x000000c0
	lock_sh = 0x00000001
	lock_un = 0x00000008
	lock_write = 0x00000080
	o_accmode = 0x00000003
	o_append = 0x00000400
	o_cloexec = 0x00080000
	o_creat = 0x00000040
	o_direct = 0x00004000
	o_directory = 0x00010000
	o_dsync = 0x00001000
	o_excl = 0x00000080
	o_largefile = 0x00008000
	o_ndelay = 0x00000800
	o_noatime = 0x00040000
	o_noctty = 0x00000100
	o_nofollow = 0x00020000
	o_nonblock = 0x00000800
	o_path = 0x00200000
	o_rdonly = 0x00000000
	o_rdwr = 0x00000002
	o_trunc = 0x00000200
	o_wronly = 0x00000001
}

pub enum Errno {
	enoerror = 0x00000000
	e2big = 0x00000007
	eacces = 0x0000000d
	eagain = 0x0000000b
	ebadf = 0x00000009
	ebusy = 0x00000010
	echild = 0x0000000a
	edom = 0x00000021
	eexist = 0x00000011
	efault = 0x0000000e
	efbig = 0x0000001b
	eintr = 0x00000004
	einval = 0x00000016
	eio = 0x00000005
	eisdir = 0x00000015
	emfile = 0x00000018
	emlink = 0x0000001f
	enfile = 0x00000017
	enodev = 0x00000013
	enoent = 0x00000002
	enoexec = 0x00000008
	enomem = 0x0000000c
	enospc = 0x0000001c
	enotblk = 0x0000000f
	enotdir = 0x00000014
	enotty = 0x00000019
	enxio = 0x00000006
	eperm = 0x00000001
	epipe = 0x00000020
	erange = 0x00000022
	erofs = 0x0000001e
	espipe = 0x0000001d
	esrch = 0x00000003
	etxtbsy = 0x0000001a
	exdev = 0x00000012
}

pub enum Mm_prot {
	prot_read = 0x1
	prot_write = 0x2
	prot_exec = 0x4
	prot_none = 0x0
	prot_growsdown = 0x01000000
	prot_growsup = 0x02000000
}

pub enum Map_flags {
	map_shared = 0x01
	map_private = 0x02
	map_shared_validate = 0x03
	map_type = 0x0f
	map_fixed = 0x10
	map_file = 0x00
	map_anonymous = 0x20
	map_anon = 0x20
	map_huge_shift = 26
	map_huge_mask = 0x3f
}

fn do_not_call_me_asm_keeper0() {
	unsafe {
		asm {
			"\n"
			"ret\n"
			""
			".intel_syntax noprefix\n"
			".globl _start, sys_call0\n"
			".globl sys_call1, sys_call2, sys_call3\n"
			".globl sys_call4, sys_call5, sys_call6\n"
			""
			"_start:\n"
				"xor rbp,rbp\n"
				"pop rdi\n"
				"mov rsi,rsp\n"
				"and rsp,-16\n"
				"call main\n"
				"mov rdi,rax\n" /* syscall param 1 = rax (ret value of main) */
				"mov rax,60\n"  /* SYS_exit */
				"syscall\n"
				""
				// should never be reached, but if the OS somehow fails to kill us,
				// it will cause a segmentation fault
				"ret\n"
			"sys_call0:\n"
				"mov rax,rdi\n"
				"syscall\n"
				"ret\n"
			""
			"sys_call1:\n"
				"mov rax,rdi\n"
				"mov rdi,rsi\n"
				"syscall\n"
				"ret\n"
			""
			"sys_call2:\n"
				"mov rax,rdi\n"
				"mov rdi,rsi\n"
				"mov rsi,rdx\n"
				"syscall\n"
				"ret\n"
			""
			"sys_call3:\n"
				"mov rax,rdi\n"
				"mov rdi,rsi\n"
				"mov rsi,rdx\n"
				"mov rdx,rcx\n"
				"syscall\n"
				"ret\n"
			""
			"sys_call4:\n"
				"mov rax,rdi\n"
				"mov rdi,rsi\n"
				"mov rsi,rdx\n"
				"mov rdx,rcx\n"
				"mov r10,r8\n"
				"syscall\n"
				"ret\n"
			""
			"sys_call5:\n"
				"mov rax,rdi\n"
				"mov rdi,rsi\n"
				"mov rsi,rdx\n"
				"mov rdx,rcx\n"
				"mov r10,r8\n"
				"mov r8,r9\n"
				"syscall\n"
				"ret\n"
			""
			"sys_call6:\n"
				"mov rax,rdi\n"
				"mov rdi,rsi\n"
				"mov rsi,rdx\n"
				"mov rdx,rcx\n"
				"mov r10,r8\n"
				"mov r8,r9\n"
				"mov r9, [rsp+8]\n"
				"syscall\n"
				"ret\n"
			""
			".att_syntax \n"
		}
	}
}

fn sys_call0(scn u64) u64
fn sys_call1(scn, arg1 u64) u64
fn sys_call2(scn, arg1, arg2 u64) u64
fn sys_call3(scn, arg1, arg2, arg3 u64) u64
fn sys_call4(scn, arg1, arg2, arg3, arg4 u64) u64
fn sys_call5(scn, arg1, arg2, arg3, arg4, arg5 u64) u64
fn sys_call6(scn, arg1, arg2, arg3, arg4, arg5, arg6 u64) u64


fn split_int_errno(rc_in u64) (i64, Errno) {
	rc := i64(rc_in)
	if rc < 0 {
		return i64(-1), Errno(-rc)
	}
	return rc, Errno.enoerror
}

// 0 sys_read unsigned int fd char *buf size_t count
pub fn sys_read (fd i64, buf byteptr, count u64) (i64, Errno) {
	return split_int_errno(sys_call3(0, u64(fd), u64(buf), count))
}

// 1 sys_write unsigned int fd, const char *buf, size_t count
pub fn sys_write(fd i64, buf byteptr, count u64) (i64, Errno) {
	return split_int_errno(sys_call3(1, u64(fd), u64(buf), count))
}

pub fn sys_open(filename byteptr, flags Fcntl, mode int) (i64, Errno) {
	//2 sys_open  const char *filename  int flags int mode
	return split_int_errno(sys_call3(2, u64(filename), u64(flags), u64(mode)))
}

pub fn sys_close(fd i64) Errno {
	// 3 sys_close unsigned int fd
	return Errno(-i64(sys_call1(3, u64(fd))))
}

// 9 sys_mmap unsigned long addr  unsigned long len unsigned long prot  unsigned long flags unsigned long fd  unsigned long off
pub fn sys_mmap(addr byteptr, len u64, prot Mm_prot, flags Map_flags, fildes u64, off u64) (byteptr, Errno) {
	rc := sys_call6(9, u64(addr), len, u64(prot), u64(flags), fildes, off)
	a, e := split_int_errno(rc)
	return byteptr(a), e
}

pub fn sys_munmap(addr voidptr, len u64) Errno {
	// 11 sys_munmap  unsigned long addr  size_t len
	return Errno(-sys_call2(11, u64(addr), len))
}

// 22  sys_pipe  int *filedes
pub fn sys_pipe(filedes &int) Errno {
	return Errno(sys_call1(22, u64(filedes)))
}

// 24 sys_sched_yield
pub fn sys_sched_yield() Errno {
	return Errno(sys_call0(24))
}

pub fn sys_madvise(addr voidptr, len u64, advice int) Errno {
	// 28 sys_madvise unsigned long start size_t len_in int behavior
	return Errno(sys_call3(28, u64(addr), len, u64(advice)))
}

// 39 sys_getpid
pub fn sys_getpid() int {
	return int(sys_call0(39))
}

// 57 sys_fork
pub fn sys_fork() int {
	return int(sys_call0(57))
}

// 58 sys_vfork
pub fn sys_vfork() int {
	return int(sys_call0(58))
}

// 33  sys_dup2  unsigned int oldfd  unsigned int newfd
pub fn sys_dup2 (oldfd, newfd int) (i64, Errno) {
	return split_int_errno(sys_call2(33, u64(oldfd),u64(newfd)))
}


//59  sys_execve  const char *filename  const char *const argv[]  const char *const envp[]
//pub fn sys_execve(filename byteptr, argv []byteptr, envp []byteptr) int {
//  return sys_call3(59, filename, argv, envp)
//}


// 60 sys_exit  int error_code
pub fn sys_exit (ec int) {
	sys_call1(60, u64(ec))
}

// 102 sys_getuid
pub fn sys_getuid() int {
	return int(sys_call0(102))
}

// 247 sys_waitid  int which pid_t upid  struct siginfo *infop int options struct rusage *ru
pub fn sys_waitid (which Wi_which, pid int, infop &int, options Wp_sys, ru voidptr) Errno {
	return Errno(sys_call5(247, u64(which), u64(pid), u64(infop), u64(options), u64(ru)))
}



/*
A few years old, but still relevant
https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/

>0 sys_read unsigned int fd char *buf size_t count
>1 sys_write unsigned int fd const char *buf size_t count
>2 sys_open  const char *filename  int flags int mode
>3 sys_close unsigned int fd
4 sys_stat  const char *filename  struct stat *statbuf
5 sys_fstat unsigned int fd struct stat *statbuf
6 sys_lstat fconst char *filename struct stat *statbuf
7 sys_poll  struct poll_fd *ufds  unsigned int nfds long timeout_msecs
8 sys_lseek unsigned int fd off_t offset  unsigned int origin
>9 sys_mmap unsigned long addr  unsigned long len unsigned long prot  unsigned long flags unsigned long fd  unsigned long off
10  sys_mprotect  unsigned long start size_t len  unsigned long prot
>11 sys_munmap  unsigned long addr  size_t len
12  sys_brk unsigned long brk
13  sys_rt_sigaction  int sig const struct sigaction *act struct sigaction *oact  size_t sigsetsize
14  sys_rt_sigprocmask  int how sigset_t *nset  sigset_t *oset  size_t sigsetsize
15  sys_rt_sigreturn  unsigned long __unused
16  sys_ioctl unsigned int fd unsigned int cmd  unsigned long arg
17  sys_pread64 unsigned long fd  char *buf size_t count  loff_t pos
18  sys_pwrite64  unsigned int fd const char *buf size_t count  loff_t pos
19  sys_readv unsigned long fd  const struct iovec *vec unsigned long vlen
20  sys_writev  unsigned long fd  const struct iovec *vec unsigned long vlen
21  sys_access  const char *filename  int mode
>22  sys_pipe  int *filedes
23  sys_select  int n fd_set *inp fd_set *outp  fd_set*exp  struct timeval *tvp
>24 sys_sched_yield
25  sys_mremap  unsigned long addr  unsigned long old_len unsigned long new_len unsigned long flags unsigned long new_addr
26  sys_msync unsigned long start size_t len  int flags
27  sys_mincore unsigned long start size_t len  unsigned char *vec
>28 sys_madvise unsigned long start size_t len_in int behavior
29  sys_shmget  key_t key size_t size int shmflg
30  sys_shmat int shmid char *shmaddr int shmflg
31  sys_shmctl  int shmid int cmd struct shmid_ds *buf
32  sys_dup unsigned int fildes
33  sys_dup2  unsigned int oldfd  unsigned int newfd
34  sys_pause
35  sys_nanosleep struct timespec *rqtp struct timespec *rmtp
36  sys_getitimer int which struct itimerval *value
37  sys_alarm unsigned int seconds
38  sys_setitimer int which struct itimerval *value struct itimerval *ovalue
>39 sys_getpid
40  sys_sendfile  int out_fd  int in_fd off_t *offset size_t count
41  sys_socket  int family  int type  int protocol
42  sys_connect int fd  struct sockaddr *uservaddr  int addrlen
43  sys_accept  int fd  struct sockaddr *upeer_sockaddr int *upeer_addrlen
44  sys_sendto  int fd  void *buff  size_t len  unsigned flags  struct sockaddr *addr int addr_len
45  sys_recvfrom  int fd  void *ubuf  size_t size unsigned flags  struct sockaddr *addr int *addr_len
46  sys_sendmsg int fd  struct msghdr *msg  unsigned flags
47  sys_recvmsg int fd  struct msghdr *msg  unsigned int flags
48  sys_shutdown  int fd  int how
49  sys_bind  int fd  struct sokaddr *umyaddr int addrlen
50  sys_listen  int fd  int backlog
51  sys_getsockname int fd  struct sockaddr *usockaddr  int *usockaddr_len
52  sys_getpeername int fd  struct sockaddr *usockaddr  int *usockaddr_len
53  sys_socketpair  int family  int type  int protocol  int *usockvec
54  sys_setsockopt  int fd  int level int optname char *optval  int optlen
55  sys_getsockopt  int fd  int level int optname char *optval  int *optlen
56  sys_clone unsigned long clone_flags unsigned long newsp void *parent_tid  void *child_tid
>57 sys_fork
>58 sys_vfork
>59 sys_execve  const char *filename  const char *const argv[]  const char *const envp[]
>60 sys_exit  int error_code
61  sys_wait4 pid_t upid  int *stat_addr  int options struct rusage *ru
62  sys_kill  pid_t pid int sig
63  sys_uname struct old_utsname *name
64  sys_semget  key_t key int nsems int semflg
65  sys_semop int semid struct sembuf *tsops  unsigned nsops
66  sys_semctl  int semid int semnum  int cmd union semun arg
67  sys_shmdt char *shmaddr
68  sys_msgget  key_t key int msgflg
69  sys_msgsnd  int msqid struct msgbuf *msgp size_t msgsz  int msgflg
70  sys_msgrcv  int msqid struct msgbuf *msgp size_t msgsz  long msgtyp int msgflg
71  sys_msgctl  int msqid int cmd struct msqid_ds *buf
72  sys_fcntl unsigned int fd unsigned int cmd  unsigned long arg
73  sys_flock unsigned int fd unsigned int cmd
74  sys_fsync unsigned int fd
75  sys_fdatasync unsigned int fd
76  sys_truncate  const char *path  long length
77  sys_ftruncate unsigned int fd unsigned long length
78  sys_getdents  unsigned int fd struct linux_dirent *dirent unsigned int count
79  sys_getcwd  char *buf unsigned long size
80  sys_chdir const char *filename
81  sys_fchdir  unsigned int fd
82  sys_rename  const char *oldname const char *newname
83  sys_mkdir const char *pathname  int mode
84  sys_rmdir const char *pathname
85  sys_creat const char *pathname  int mode
86  sys_link  const char *oldname const char *newname
87  sys_unlink  const char *pathname
88  sys_symlink const char *oldname const char *newname
89  sys_readlink  const char *path  char *buf int bufsiz
90  sys_chmod const char *filename  mode_t mode
91  sys_fchmod  unsigned int fd mode_t mode
92  sys_chown const char *filename  uid_t user  gid_t group
93  sys_fchown  unsigned int fd uid_t user  gid_t group
94  sys_lchown  const char *filename  uid_t user  gid_t group
95  sys_umask int mask
96  sys_gettimeofday  struct timeval *tv  struct timezone *tz
97  sys_getrlimit unsigned int resource struct rlimit *rlim
98  sys_getrusage int who struct rusage *ru
99  sys_sysinfo struct sysinfo *info
100 sys_times struct sysinfo *info
101 sys_ptrace  long request  long pid  unsigned long addr  unsigned long data
>102 sys_getuid
103 sys_syslog  int type  char *buf int len
104 sys_getgid
105 sys_setuid  uid_t uid
106 sys_setgid  gid_t gid
107 sys_geteuid
108 sys_getegid
109 sys_setpgid pid_t pid pid_t pgid
110 sys_getppid
111 sys_getpgrp
112 sys_setsid
113 sys_setreuid  uid_t ruid  uid_t euid
114 sys_setregid  gid_t rgid  gid_t egid
115 sys_getgroups int gidsetsize  gid_t *grouplist
116 sys_setgroups int gidsetsize  gid_t *grouplist
117 sys_setresuid uid_t *ruid uid_t *euid uid_t *suid
118 sys_getresuid uid_t *ruid uid_t *euid uid_t *suid
119 sys_setresgid gid_t rgid  gid_t egid  gid_t sgid
120 sys_getresgid gid_t *rgid gid_t *egid gid_t *sgid
121 sys_getpgid pid_t pid
122 sys_setfsuid  uid_t uid
123 sys_setfsgid  gid_t gid
124 sys_getsid  pid_t pid
125 sys_capget  cap_user_header_t header  cap_user_data_t dataptr
126 sys_capset  cap_user_header_t header  const cap_user_data_t data
127 sys_rt_sigpending sigset_t *set size_t sigsetsize
128 sys_rt_sigtimedwait const sigset_t *uthese  siginfo_t *uinfo  const struct timespec *uts  size_t sigsetsize
129 sys_rt_sigqueueinfo pid_t pid int sig siginfo_t *uinfo
130 sys_rt_sigsuspend sigset_t *unewset size_t sigsetsize
131 sys_sigaltstack const stack_t *uss  stack_t *uoss
132 sys_utime char *filename  struct utimbuf *times
133 sys_mknod const char *filename  umode_t mode  unsigned dev
134 sys_uselib  NOT IMPLEMENTED
135 sys_personality unsigned int personality
136 sys_ustat unsigned dev  struct ustat *ubuf
137 sys_statfs  const char *pathname  struct statfs *buf
138 sys_fstatfs unsigned int fd struct statfs *buf
139 sys_sysfs int option  unsigned long arg1  unsigned long arg2
140 sys_getpriority int which int who
141 sys_setpriority int which int who int niceval
142 sys_sched_setparam  pid_t pid struct sched_param *param
143 sys_sched_getparam  pid_t pid struct sched_param *param
144 sys_sched_setscheduler  pid_t pid int policy  struct sched_param *param
145 sys_sched_getscheduler  pid_t pid
146 sys_sched_get_priority_max  int policy
147 sys_sched_get_priority_min  int policy
148 sys_sched_rr_get_interval pid_t pid struct timespec *interval
149 sys_mlock unsigned long start size_t len
150 sys_munlock unsigned long start size_t len
151 sys_mlockall  int flags
152 sys_munlockall
153 sys_vhangup
154 sys_modify_ldt  int func  void *ptr unsigned long bytecount
155 sys_pivot_root  const char *new_root  const char *put_old
156 sys__sysctl struct __sysctl_args *args
157 sys_prctl int option  unsigned long arg2  unsigned long arg3  unsigned long arg4    unsigned long arg5
158 sys_arch_prctl  struct task_struct *task  int code  unsigned long *addr
159 sys_adjtimex  struct timex *txc_p
160 sys_setrlimit unsigned int resource struct rlimit *rlim
161 sys_chroot  const char *filename
162 sys_sync
163 sys_acct  const char *name
164 sys_settimeofday  struct timeval *tv  struct timezone *tz
165 sys_mount char *dev_name  char *dir_name  char *type  unsigned long flags void *data
166 sys_umount2 const char *target  int flags
167 sys_swapon  const char *specialfile int swap_flags
168 sys_swapoff const char *specialfile
169 sys_reboot  int magic1  int magic2  unsigned int cmd  void *arg
170 sys_sethostname char *name  int len
171 sys_setdomainname char *name  int len
172 sys_iopl  unsigned int level  struct pt_regs *regs
173 sys_ioperm  unsigned long from  unsigned long num int turn_on
174 sys_create_module REMOVED IN Linux 2.6
175 sys_init_module void *umod  unsigned long len const char *uargs
176 sys_delete_module const chat *name_user unsigned int flags
177 sys_get_kernel_syms REMOVED IN Linux 2.6
178 sys_query_module  REMOVED IN Linux 2.6
179 sys_quotactl  unsigned int cmd  const char *special qid_t id  void *addr
180 sys_nfsservctl  NOT IMPLEMENTED
181 sys_getpmsg NOT IMPLEMENTED
182 sys_putpmsg NOT IMPLEMENTED
183 sys_afs_syscall NOT IMPLEMENTED
184 sys_tuxcall NOT IMPLEMENTED
185 sys_security  NOT IMPLEMENTED
186 sys_gettid
187 sys_readahead int fd  loff_t offset size_t count
188 sys_setxattr  const char *pathname  const char *name  const void *value size_t size int flags
189 sys_lsetxattr const char *pathname  const char *name  const void *value size_t size int flags
190 sys_fsetxattr int fd  const char *name  const void *value size_t size int flags
191 sys_getxattr  const char *pathname  const char *name  void *value size_t size
192 sys_lgetxattr const char *pathname  const char *name  void *value size_t size
193 sys_fgetxattr int fd  const har *name void *value size_t size
194 sys_listxattr const char *pathname  char *list  size_t size
195 sys_llistxattr  const char *pathname  char *list  size_t size
196 sys_flistxattr  int fd  char *list  size_t size
197 sys_removexattr const char *pathname  const char *name
198 sys_lremovexattr  const char *pathname  const char *name
199 sys_fremovexattr  int fd  const char *name
200 sys_tkill pid_t pid ing sig
201 sys_time  time_t *tloc
202 sys_futex u32 *uaddr  int op  u32 val struct timespec *utime  u32 *uaddr2 u32 val3
203 sys_sched_setaffinity pid_t pid unsigned int len  unsigned long *user_mask_ptr
204 sys_sched_getaffinity pid_t pid unsigned int len  unsigned long *user_mask_ptr
205 sys_set_thread_area NOT IMPLEMENTED. Use arch_prctl
206 sys_io_setup  unsigned nr_events  aio_context_t *ctxp
207 sys_io_destroy  aio_context_t ctx
208 sys_io_getevents  aio_context_t ctx_id  long min_nr long nr struct io_event *events
209 sys_io_submit aio_context_t ctx_id  long nr struct iocb **iocbpp
210 sys_io_cancel aio_context_t ctx_id  struct iocb *iocb struct io_event *result
211 sys_get_thread_area NOT IMPLEMENTED. Use arch_prctl
212 sys_lookup_dcookie  u64 cookie64  long buf  long len
213 sys_epoll_create  int size
214 sys_epoll_ctl_old NOT IMPLEMENTED
215 sys_epoll_wait_old  NOT IMPLEMENTED
216 sys_remap_file_pages  unsigned long start unsigned long size  unsigned long prot  unsigned long pgoff unsigned long flags
217 sys_getdents64  unsigned int fd struct linux_dirent64 *dirent unsigned int count
218 sys_set_tid_address int *tidptr
219 sys_restart_syscall
220 sys_semtimedop  int semid struct sembuf *tsops  unsigned nsops  const struct timespec *timeout
221 sys_fadvise64 int fd  loff_t offset size_t len  int advice
222 sys_timer_create  const clockid_t which_clock struct sigevent *timer_event_spec timer_t *created_timer_id
223 sys_timer_settime timer_t timer_id  int flags const struct itimerspec *new_setting  struct itimerspec *old_setting
224 sys_timer_gettime timer_t timer_id  struct itimerspec *setting
225 sys_timer_getoverrun  timer_t timer_id
226 sys_timer_delete  timer_t timer_id
227 sys_clock_settime const clockid_t which_clock const struct timespec *tp
228 sys_clock_gettime const clockid_t which_clock struct timespec *tp
229 sys_clock_getres  const clockid_t which_clock struct timespec *tp
230 sys_clock_nanosleep const clockid_t which_clock int flags const struct timespec *rqtp struct timespec *rmtp
231 sys_exit_group  int error_code
232 sys_epoll_wait  int epfd  struct epoll_event *events  int maxevents int timeout
233 sys_epoll_ctl int epfd  int op  int fd  struct epoll_event *event
234 sys_tgkill  pid_t tgid  pid_t pid int sig
235 sys_utimes  char *filename  struct timeval *utimes
236 sys_vserver NOT IMPLEMENTED
237 sys_mbind unsigned long start unsigned long len unsigned long mode  unsigned long *nmask  unsigned long maxnode unsigned flags
238 sys_set_mempolicy int mode  unsigned long *nmask  unsigned long maxnode
239 sys_get_mempolicy int *policy unsigned long *nmask  unsigned long maxnode unsigned long addr  unsigned long flags
240 sys_mq_open const char *u_name  int oflag mode_t mode struct mq_attr *u_attr
241 sys_mq_unlink const char *u_name
242 sys_mq_timedsend  mqd_t mqdes const char *u_msg_ptr size_t msg_len  unsigned int msg_prio const stuct timespec *u_abs_timeout
243 sys_mq_timedreceive mqd_t mqdes char *u_msg_ptr size_t msg_len  unsigned int *u_msg_prio  const struct timespec *u_abs_timeout
244 sys_mq_notify mqd_t mqdes const struct sigevent *u_notification
245 sys_mq_getsetattr mqd_t mqdes const struct mq_attr *u_mqstat  struct mq_attr *u_omqstat
246 sys_kexec_load  unsigned long entry unsigned long nr_segments struct kexec_segment *segments  unsigned long flags
>247 sys_waitid  int which pid_t upid  struct siginfo *infop int options struct rusage *ru
248 sys_add_key const char *_type const char *_description  const void *_payload  size_t plen
249 sys_request_key const char *_type const char *_description  const char *_callout_info key_serial_t destringid
250 sys_keyctl  int option  unsigned long arg2  unsigned long arg3  unsigned long arg4  unsigned long arg5
251 sys_ioprio_set  int which int who int ioprio
252 sys_ioprio_get  int which int who
253 sys_inotify_init
254 sys_inotify_add_watch int fd  const char *pathname  u32 mask
255 sys_inotify_rm_watch  int fd  __s32 wd
256 sys_migrate_pages pid_t pid unsigned long maxnode const unsigned long *old_nodes  const unsigned long *new_nodes
257 sys_openat  int dfd const char *filename  int flags int mode
258 sys_mkdirat int dfd const char *pathname  int mode
259 sys_mknodat int dfd const char *filename  int mode  unsigned dev
260 sys_fchownat  int dfd const char *filename  uid_t user  gid_t group int flag
261 sys_futimesat int dfd const char *filename  struct timeval *utimes
262 sys_newfstatat  int dfd const char *filename  struct stat *statbuf  int flag
263 sys_unlinkat  int dfd const char *pathname  int flag
264 sys_renameat  int oldfd const char *oldname int newfd const char *newname
265 sys_linkat  int oldfd const char *oldname int newfd const char *newname int flags
266 sys_symlinkat const char *oldname int newfd const char *newname
267 sys_readlinkat  int dfd const char *pathname  char *buf int bufsiz
268 sys_fchmodat  int dfd const char *filename  mode_t mode
269 sys_faccessat int dfd const char *filename  int mode
270 sys_pselect6  int n fd_set *inp fd_set *outp  fd_set *exp struct timespec *tsp  void *sig
271 sys_ppoll struct pollfd *ufds unsigned int nfds struct timespec *tsp  const sigset_t *sigmask size_t sigsetsize
272 sys_unshare unsigned long unshare_flags
273 sys_set_robust_list struct robust_list_head *head size_t len
274 sys_get_robust_list int pid struct robust_list_head **head_ptr  size_t *len_ptr
275 sys_splice  int fd_in loff_t *off_in  int fd_out  loff_t *off_out size_t len  unsigned int flags
276 sys_tee int fdin  int fdout size_t len  unsigned int flags
277 sys_sync_file_range long fd loff_t offset loff_t bytes  long flags
278 sys_vmsplice  int fd  const struct iovec *iov unsigned long nr_segs unsigned int flags
279 sys_move_pages  pid_t pid unsigned long nr_pages  const void **pages  const int *nodes  int *status int flags
280 sys_utimensat int dfd const char *filename  struct timespec *utimes int flags
281 sys_epoll_pwait int epfd  struct epoll_event *events  int maxevents int timeout const sigset_t *sigmask size_t sigsetsize
282 sys_signalfd  int ufd sigset_t *user_mask size_t sizemask
283 sys_timerfd_create  int clockid int flags
284 sys_eventfd unsigned int count
285 sys_fallocate long fd long mode loff_t offset loff_t len
286 sys_timerfd_settime int ufd int flags const struct itimerspec *utmr struct itimerspec *otmr
287 sys_timerfd_gettime int ufd struct itimerspec *otmr
288 sys_accept4 int fd  struct sockaddr *upeer_sockaddr int *upeer_addrlen  int flags
289 sys_signalfd4 int ufd sigset_t *user_mask size_t sizemask int flags
290 sys_eventfd2  unsigned int count  int flags
291 sys_epoll_create1 int flags
292 sys_dup3  unsigned int oldfd  unsigned int newfd  int flags
293 sys_pipe2 int *filedes  int flags
294 sys_inotify_init1 int flags
295 sys_preadv  unsigned long fd  const struct iovec *vec unsigned long vlen  unsigned long pos_l unsigned long pos_h
296 sys_pwritev unsigned long fd  const struct iovec *vec unsigned long vlen  unsigned long pos_l unsigned long pos_h
297 sys_rt_tgsigqueueinfo pid_t tgid  pid_t pid int sig siginfo_t *uinfo
298 sys_perf_event_open struct perf_event_attr *attr_uptr pid_t pid int cpu int group_fd  unsigned long flags
299 sys_recvmmsg  int fd  struct msghdr *mmsg unsigned int vlen unsigned int flags  struct timespec *timeout
300 sys_fanotify_init unsigned int flags  unsigned int event_f_flags
301 sys_fanotify_mark long fanotify_fd  long flags  __u64 mask  long dfd  long pathname
302 sys_prlimit64 pid_t pid unsigned int resource const struct rlimit64 *new_rlim struct rlimit64 *old_rlim
303 sys_name_to_handle_at int dfd const char *name  struct file_handle *handle  int *mnt_id int flag
304 sys_open_by_handle_at int dfd const char *name  struct file_handle *handle  int *mnt_id int flags
305 sys_clock_adjtime clockid_t which_clock struct timex *tx
306 sys_syncfs  int fd
307 sys_sendmmsg  int fd  struct mmsghdr *mmsg  unsigned int vlen unsigned int flags
308 sys_setns int fd  int nstype
309 sys_getcpu  unsigned *cpup  unsigned *nodep struct getcpu_cache *unused
310 sys_process_vm_readv  pid_t pid const struct iovec *lvec  unsigned long liovcnt const struct iovec *rvec  unsigned long riovcnt unsigned long flags
311 sys_process_vm_writev pid_t pid const struct iovec *lvec  unsigned long liovcnt const struct iovcc *rvec  unsigned long riovcnt unsigned long flags
312 sys_kcmp  pid_t pid1  pid_t pid2  int type  unsigned long idx1  unsigned long idx2
313 sys_finit_module  int fd  const char __user *uargs  int flags
314 sys_sched_setattr pid_t pid struct sched_attr __user *attr  unsigned int flags
315 sys_sched_getattr pid_t pid struct sched_attr __user *attr  unsigned int size unsigned int flags
316 sys_renameat2 int olddfd  const char __user *oldname  int newdfd  const char __user *newname  unsigned int flags
317 sys_seccomp unsigned int op unsigned int flags  const char __user *uargs
318 sys_getrandom char __user *buf  size_t count  unsigned int flags
319 sys_memfd_create  const char __user *uname_ptr  unsigned int flags
320 sys_kexec_file_load int kernel_fd int initrd_fd unsigned long cmdline_len const char __user *cmdline_ptr  unsigned long flags
321 sys_bpf int cmd union bpf_attr *attr  unsigned int size
322 stub_execveat int dfd const char __user *filename const char __user *const __user *argv const char __user *const __user *envp int flags
323 userfaultfd int flags
324 membarrier  int cmd int flags
325 mlock2  unsigned long start size_t len  int flags
326 copy_file_range int fd_in loff_t __user *off_in int fd_out  loff_t __user * off_out size_t len  unsigned int flags
327 preadv2 unsigned long fd  const struct iovec __user *vec  unsigned long vlen  unsigned long pos_l unsigned long pos_h int flags
328 pwritev2  unsigned long fd  const struct iovec __user *vec  unsigned long vlen  unsigned long pos_l unsigned long pos_h int flags
*/
module builtin

const (
	mem_prot = Mm_prot(int(Mm_prot.prot_read) | int(Mm_prot.prot_write))
	mem_flags = Map_flags(int(Map_flags.map_private) | int(Map_flags.map_anonymous))
	page_size = u64(Linux_mem.page_size)
)

pub fn mm_pages(size u64) u32 {
	pages := (size+u64(4)+page_size)/page_size
	return u32(pages)
}

pub fn mm_alloc(size u64) (byteptr, Errno) {
	pages := mm_pages(size)
	n_bytes := u64(pages*u32(Linux_mem.page_size))

	a, e := sys_mmap(0, n_bytes, mem_prot, mem_flags, -1, 0)
	if e == .enoerror {
		mut ap := &int(a)
		*ap = pages
		return byteptr(a+4), e
	}
	return byteptr(0), e
}

pub fn mm_free(addr byteptr) Errno {
	ap := &int(addr-4)
	size := u64(*ap) * u64(Linux_mem.page_size)

	return sys_munmap(ap, size)
}

pub fn mem_copy(dest0 voidptr, src0 voidptr, n int) voidptr {
	mut dest := byteptr(dest0)
	src := byteptr(src0)
	for i in 0..n {
		dest[i] = src[i]
	}
	return dest0
}

[unsafe_fn]
pub fn malloc(n int) byteptr {
	if n < 0 {
		panic('malloc(<0)')
	}

	ptr, e := mm_alloc(u64(n))
	assert e == .enoerror
	assert !isnil(ptr)
	return ptr
}

[unsafe_fn]
pub fn free(ptr voidptr) {
	assert mm_free(ptr) == .enoerror
}
module builtin

pub struct string {
pub:
	str byteptr
	len int
}

pub fn strlen(s byteptr) int {
	mut i := 0
	for ; s[i] != 0; i++ {}
	return i
}

pub fn tos(s byteptr, len int) string {
	if s == 0 {
		panic('tos(): nil string')
	}
	return string {
		str: s
		len: len
	}
}

fn (s string) add(a string) string {
	new_len := a.len + s.len
	mut res := string {
		len: new_len
		str: malloc(new_len + 1)
	}
	for j in 0..s.len {
		res[j] = s[j]
	}
	for j in 0..a.len {
		res[s.len + j] = a[j]
	}
	res[new_len] = `\0`// V strings are not null terminated, but just in case
	return res
}

/*
pub fn tos_clone(s byteptr) string {
	if s == 0 {
		panic('tos: nil string')
	}
	return tos2(s).clone()
}
*/

// Same as `tos`, but calculates the length. Called by `string(bytes)` casts.
// Used only internally.
pub fn tos2(s byteptr) string {
	if s == 0 {
		panic('tos2: nil string')
	}
	return string {
		str: s
		len: strlen(s)
	}
}

pub fn tos3(s charptr) string {
	if s == 0 {
		panic('tos3: nil string')
	}
	return string {
		str: byteptr(s)
		len: strlen(byteptr(s))
	}
}

pub fn string_eq (s1, s2 string) bool {
	if s1.len != s2.len { return false }
	for i in 0..s1.len {
		if s1[i] != s2[i] { return false }
	}
	return true
}
pub fn string_ne (s1, s2 string) bool {
	return !string_eq(s1,s2)
}


pub fn i64_tos(buf byteptr, len int, n0 i64, base int) string {
	if base < 2 { panic("base must be >= 2")}
	if base > 36 { panic("base must be <= 36")}

	mut b := tos(buf, len)
	mut i := len-1

	mut n := n0
	neg := n < 0
	if neg { n = -n }

	b[i--] = 0

	for {
		c := (n%base) + 48
		b[i--] = if c > 57 {c+7} else {c}
		if i < 0 { panic ("buffer to small") }
		n /= base
		if n < 1 {break}
	}
	if neg {
		if i < 0 { panic ("buffer to small") }
		b[i--] = 45
	}
	offset := i+1
	b.str = b.str + offset
	b.len -= (offset+1)
	return b
}

pub fn i64_str(n0 i64, base int) string {
	buf := malloc(80)
	return i64_tos(buf, 79, n0, base)
}

pub fn ptr_str(ptr voidptr) string {
  buf := [16]byte
  hex := i64_tos(buf, 15, i64(ptr), 16)
  res := '0x' + hex
  return res
}

pub fn (a string) clone() string {
	mut b := string {
		len: a.len
		str: malloc(a.len + 1)
	}
	mem_copy(b.str, a.str, a.len)
	b[a.len] = `\0`
	return b
}
import os

fn test_syscallwrappers() {
	if true { return }
	$if linux {
		$if x64 {
			exe := os.executable()
			vdir := os.dir(exe)
			if vdir.len > 1 {
				dot_checks := vdir + "/.checks"
				assert os.is_dir(dot_checks)

				os.chdir(dot_checks)
				checks_v := "checks.v"
				assert os.exists(checks_v)
				rc := os.exec("v run $checks_v") or { panic(err) }
				assert !rc.output.contains("V panic: An assertion failed.")
				assert !rc.output.contains("failed")
				assert rc.exit_code == 0
			} else {
				panic("Can't find test directory")
			}
		}
	}
}
checks
linuxsys/linuxsys
string/string
consts/consts
structs/structs
module main

import os

fn failed (msg string) {
	println ("!!! failed: $msg")
}

fn passed (msg string) {
	println (">>> passed: $msg")
}


fn vcheck(vfile string) {
	run_check := "v -user_mod_path . -freestanding run "
	if 0 == os.system("$run_check $vfile/${vfile}.v") {
		passed(run_check)
	} else {
		failed(run_check)
	}
	os.system("ls -lh $vfile/$vfile")
	os.system("rm -f $vfile/$vfile")
}

fn main() {
	vcheck("linuxsys")
	vcheck("string")
	vcheck("consts")
	vcheck("structs")
	exit(0)
}

In this directory:
```
v run checks.v
```

Do not change this text.
module main
import forkedtest

const (
	integer1 = 111
	integer2 = 222
	integer3 = integer1+integer2
	integer9 = integer3 * 3
	abc = "123"
)

fn check_const_initialization() {
	assert abc == "123"
	assert integer9 == 999
}

fn main(){
	mut fails := 0
	fails += forkedtest.normal_run(check_const_initialization, "check_const_initialization")
	assert fails == 0
	sys_exit(0)
}
module forkedtest

pub fn run (op fn(), label string, code Wi_si_code, status int) int {
	child := sys_fork()
	if child == 0 {
		op()
		sys_exit(0)
	}

	siginfo := [0].repeat(int(Sig_index.si_size))

	e := sys_waitid(.p_pid, child, intptr(&siginfo[0]), .wexited, 0)

	assert e == .enoerror
	assert siginfo[int(Sig_index.si_pid)] == child
	assert siginfo[int(Sig_index.si_signo)] == int(Signo.sigchld)
	assert siginfo[int(Sig_index.si_uid)] == sys_getuid()

	r_code := siginfo[Sig_index.si_code]
	r_status := siginfo[Sig_index.si_status]

	print("+++ ")
	print(label)
	if (int(code) == r_code) && (status == r_status) {
		println(" PASSED")
		return 0
	}
	println(" FAILED")

	if int(code) != r_code {
		print(">> Expecting si_code 0x")
		println(i64_str(int(code),16))
		print(">> Got 0x")
		println(i64_str(r_code,16))
	}

	if status != r_status {
		print(">> Expecting status 0x")
		println(i64_str(status,16))
		print(">> Got 0x")
		println(i64_str(r_status,16))
	}

	return 1
}

pub fn normal_run (op fn(), label string) int {
	return run (op, label, .cld_exited, 0)
}
module main
import forkedtest

const (
	sample_text_file1 = ""
)

fn check_fork_minimal () {
	child := sys_fork()
	ec := 100
	if child == 0 {
		println("child")
		sys_exit(ec)
	}
	siginfo := [
		0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0]

	e := sys_waitid(.p_pid, child, intptr(siginfo.data) , .wexited, 0)

	assert e == .enoerror
	//println(i64_tos(buffer0,80,siginfo[Sig_index.si_code],16))
	assert siginfo[Sig_index.si_code] == int(Wi_si_code.cld_exited)
	assert siginfo[Sig_index.si_pid] == child
	assert siginfo[Sig_index.si_status] == ec
	assert siginfo[Sig_index.si_signo] == int(Signo.sigchld)
	assert siginfo[Sig_index.si_uid] == sys_getuid()
}

fn check_read_write_pipe() {
	//	Checks the following system calls:
	//		sys_pipe
	//		sys_write
	//		sys_read
	//		sys_close
	//
	buffer0 := [byte(0)].repeat(128)
	buffer := byteptr(buffer0.data)

	fd := [-1, -1]

	assert fd[0] == -1
	assert fd[1] == -1

	a := sys_pipe(intptr(&fd[0]))

	assert a == .enoerror

	assert fd[0] != -1
	assert fd[1] != -1

	test_data := "test_data"
	b := test_data.len + 1
	c1, e1 := sys_write (fd[1], test_data.str, u64(b))

	assert e1 == .enoerror
	assert c1 == b

	c2, e2 := sys_read(fd[0], buffer, u64(b))

	assert e2 == .enoerror
	assert c2 == b

	assert buffer[b-1] == 0

	for i in 0..b {
		assert test_data[i] == buffer[i]
	}

	assert sys_close(fd[0]) == .enoerror
	assert sys_close(fd[1]) == .enoerror

	assert sys_close(-1) == .ebadf
}

fn check_read_file() {
	/*
		Checks the following system calls:
			sys_read
			sys_write
			sys_close
			sys_open
	*/
	buffer0 := [byte(0)].repeat(128)
	buffer := byteptr(buffer0.data)

	test_file := "sample_text1.txt"
	sample_text := "Do not change this text.\n"
	fd, ec := sys_open(test_file.str, .o_rdonly, 0)
	assert fd > 0
	assert ec == .enoerror
	n := sample_text.len
	c, e := sys_read(fd, buffer, u64(n*2))
	assert e == .enoerror
	assert c == n
	for i in 0..n {
		assert sample_text[i] == buffer[i]
	}
	assert sys_close(fd) == .enoerror
}

fn check_open_file_fail() {
	fd1, ec1 := sys_open("./nofilehere".str, .o_rdonly, 0)
	assert fd1 == -1
	assert ec1 == .enoent
}

/*
fn check_print() {
	println ("checking print and println")

	a := sys_pipe(intptr(fd))
	assert a != -1
	assert fd[0] != -1
	assert fd[1] != -1

	//sys_dup2
	println ("print and println passed")
}
*/

fn check_munmap_fail() {
	ec := sys_munmap(-16384,8192)
	assert ec == .einval
}

fn check_mmap_one_page() {
	mp := int(Mm_prot.prot_read) | int(Mm_prot.prot_write)
	mf := int(Map_flags.map_private) | int(Map_flags.map_anonymous)
	mut a, e := sys_mmap(0, u64(Linux_mem.page_size), Mm_prot(mp), Map_flags(mf), -1, 0)

	assert e == .enoerror
	assert a != byteptr(-1)

	for i in 0..int(Linux_mem.page_size) {
		b := i & 0xFF
		a[i] = b
		assert a[i] == b
	}

	ec := sys_munmap(a, u64(Linux_mem.page_size))
	assert ec == .enoerror
}

fn check_mm_pages() {
	for i in 0 .. int(Linux_mem.page_size)-4 {
		assert u32(1) == mm_pages(u64(i))
	}
	for i in int(Linux_mem.page_size)-3 .. (int(Linux_mem.page_size)*2)-4 {
		assert u32(2) == mm_pages(u64(i))
	}
	for i in (int(Linux_mem.page_size)*2)-3 .. (int(Linux_mem.page_size)*3)-4 {
		assert u32(3) == mm_pages(u64(i))
	}
}

//pub fn mm_alloc(size u64) (voidptr, Errno)

fn check_mm_alloc() {
	for i in 1 .. 2000 {
		size := u64(i*1000)
		pages := mm_pages(size)
		mut a, e := mm_alloc(size)

		assert e == .enoerror
		ap := intptr(a-4)
		assert *ap == int(pages)
		assert e == .enoerror
		assert !isnil(a)

		if (i%111) == 0 {
			for j in 0 .. int(size) {
				b := j & 0xFF
				a[j] = b
				assert b == int(a[j])
			}
		}

		mfa := mm_free(a)

		assert mfa == .enoerror
	}
}

fn check_int_array_ro() {
	a := [100,110,120,130]
	assert a.len == 4
	assert a[0] == 100
	assert a[1] == 110
	assert a[2] == 120
	assert a[3] == 130
}

fn check_int_array_rw() {
	mut a := [-10,-11,-12,-13]
	assert a.len == 4
	assert a[0] == -10
	assert a[1] == -11
	assert a[2] == -12
	assert a[3] == -13
	for i in 0..a.len {
		b := -a[i] * 10
		a[i] = b
		assert a[i] == b
	}
	assert a[3] == 130
}

fn check_int64_array_ro() {
	a := [i64(1000),1100,1200,1300,1400]
	assert a.len == 5
	assert a[0] == 1000
	assert a[1] == 1100
	assert a[2] == 1200
	assert a[3] == 1300
	assert a[4] == 1400
}

fn check_voidptr_array_ro() {
	a := [
		voidptr(10000),
		voidptr(11000),
		voidptr(12000),
		voidptr(13000),
		voidptr(14000),
		voidptr(15000)
	]
	assert a.len == 6
	assert a[0] == voidptr(10000)
	assert a[1] == voidptr(11000)
	assert a[2] == voidptr(12000)
	assert a[3] == voidptr(13000)
	assert a[4] == voidptr(14000)
	assert a[5] == voidptr(15000)
}

fn check_voidptr_array_rw() {
	mut a := [
		voidptr(-1),
		voidptr(-1),
		voidptr(-1),
		voidptr(-1),
		voidptr(-1),
		voidptr(-1)
	]
	assert a.len == 6

	assert a[0] == voidptr(-1)
	assert a[1] == voidptr(-1)
	assert a[2] == voidptr(-1)
	assert a[3] == voidptr(-1)
	assert a[4] == voidptr(-1)
	assert a[5] == voidptr(-1)

	a[0] = voidptr(100000)
	assert a[0] == voidptr(100000)

	a[1] = voidptr(110000)
	assert a[1] == voidptr(110000)

	a[2] = voidptr(120000)
	assert a[2] == voidptr(120000)

	a[3] = voidptr(130000)
	assert a[3] == voidptr(130000)

	a[4] = voidptr(140000)
	assert a[4] == voidptr(140000)

	a[5] = voidptr(150000)
	assert a[5] == voidptr(150000)
}


fn main() {
	mut fails := 0
	fails += forkedtest.normal_run(check_fork_minimal, "check_fork_minimal")
	fails += forkedtest.normal_run(check_munmap_fail, "check_munmap_fail")
	fails += forkedtest.normal_run(check_mmap_one_page, "check_mmap_one_page")
	fails += forkedtest.normal_run(check_mm_pages, "check_mm_pages")
	fails += forkedtest.normal_run(check_mm_alloc, "check_mm_alloc")
	fails += forkedtest.normal_run(check_read_write_pipe, "check_read_write_pipe")
	fails += forkedtest.normal_run(check_read_file, "check_read_file")
	// check_print()
	fails += forkedtest.normal_run(check_open_file_fail, "check_open_file_fail")
	fails += forkedtest.normal_run(check_int_array_ro, "check_int_array_ro")
	fails += forkedtest.normal_run(check_int_array_rw, "check_int_array_rw")
	fails += forkedtest.normal_run(check_int64_array_ro, "check_int64_array_ro")
	fails += forkedtest.normal_run(check_voidptr_array_ro, "check_voidptr_array_ro")
	fails += forkedtest.normal_run(check_voidptr_array_rw, "check_voidptr_array_rw")

	assert fails == 0
	sys_exit(0)
}
module main
import forkedtest

fn check_string_eq () {
	assert "monkey" != "rat"
	some_animal := "a bird"
	assert some_animal == "a bird"
}

fn check_i64_tos() {
	buffer0 := [byte(0)].repeat(128)
	buffer := byteptr(buffer0.data)

	s0 := i64_tos(buffer, 70, 140, 10)
	assert s0 == "140"

	s1 := i64_tos(buffer, 70, -160, 10)
	assert s1 == "-160"

	s2 := i64_tos(buffer, 70, 65537, 16)
	assert s2 == "10001"

	s3 := i64_tos(buffer, 70, -160000, 10)
	assert s3 == "-160000"
}

fn check_i64_str() {
	assert "141" == i64_str(141, 10)
	assert "-161" == i64_str(-161, 10)
	assert "10002" == i64_str(65538, 16)
	assert "-160001" == i64_str(-160001, 10)
}

fn check_str_clone() {
	a := i64_str(1234,10)
	b := a.clone()
	assert a == b
	c := i64_str(-6789,10).clone()
	assert c == "-6789"
}

fn check_string_add_works(){
  abc := 'abc'
  combined := 'a' + 'b' + 'c'
  assert abc.len == combined.len
  assert abc[0] == combined[0]
  assert abc[1] == combined[1]
  assert abc[2] == combined[2]
  assert abc[0] == `a`
  assert abc == combined
}  

fn main () {
	mut fails := 0
	fails += forkedtest.normal_run(check_string_eq, "check_string_eq")
	fails += forkedtest.normal_run(check_i64_tos, "check_i64_tos")
	fails += forkedtest.normal_run(check_i64_str, "check_i64_str")
	fails += forkedtest.normal_run(check_str_clone, "check_str_clone")
	fails += forkedtest.normal_run(check_string_add_works,    "check_string_add_works")
	assert fails == 0
	sys_exit(0)
}

module main
import forkedtest

struct SimpleEmptyStruct{
}

struct NonEmptyStruct{
  x int
  y int
  z int
}

fn check_simple_empty_struct(){  
  s := SimpleEmptyStruct{}
  addr_s := &s
  str_addr_s := ptr_str( addr_s )
  assert !isnil(addr_s)
  assert str_addr_s.len > 3
  println(str_addr_s)
}

fn check_non_empty_struct(){  
  a := NonEmptyStruct{1,2,3}
  b := NonEmptyStruct{4,5,6}
  assert sizeof(NonEmptyStruct) > 0
  assert sizeof(SimpleEmptyStruct) < sizeof(NonEmptyStruct)
  assert a.x == 1
  assert a.y == 2
  assert a.z == 3
  assert b.x + b.y + b.z == 15
  assert ptr_str(&a) != ptr_str(&b)
  println('sizeof SimpleEmptyStruct:' + i64_str( sizeof(SimpleEmptyStruct) , 10 ))
  println('sizeof NonEmptyStruct:' + i64_str( sizeof(NonEmptyStruct) , 10 ))
}

fn main(){
	mut fails := 0
	fails += forkedtest.normal_run(check_simple_empty_struct, "check_simple_empty_struct")
	fails += forkedtest.normal_run(check_non_empty_struct,    "check_non_empty_struct")
	assert fails == 0
	sys_exit(0)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module builtin

fn JS.console.log(arg ...string)
fn JS.process.stdout.write(arg string)

pub fn println(s any) {
	JS.console.log(s)
}

pub fn print(s any) {
	JS.process.stdout.write(s)
}module cli

type CallbackFn fn(cmd Command)

pub struct Command {
pub mut:
	name string
	description string
	version string
	pre_execute CallbackFn
	execute CallbackFn
	post_execute CallbackFn

	disable_help bool
	disable_version bool

	parent &Command
	commands []Command
	flags []Flag
	args []string
}

pub fn (cmd Command) full_name() string {
	if isnil(cmd.parent) {
		return cmd.name
	}
	return cmd.parent.full_name() + ' ${cmd.name}'
}

pub fn (cmd Command) root() Command {
	if isnil(cmd.parent) {
		return cmd
	}
	return cmd.parent.root()
}

pub fn (mut cmd Command) add_command(command Command) {
	cmd.commands << command
}

pub fn (mut cmd Command) add_flag(flag Flag) {
	cmd.flags << flag
}

pub fn (mut cmd Command) parse(args []string) {
	cmd.add_default_flags()
	cmd.add_default_commands()

	cmd.args = args[1..]
	for i in 0..cmd.commands.len {
		cmd.commands[i].parent = cmd
	}

	cmd.parse_flags()
	cmd.parse_commands()
}

fn (mut cmd Command) add_default_flags() {
	if !cmd.disable_help && !cmd.flags.contains('help') && !cmd.flags.contains('h') {
		cmd.add_flag(help_flag())
	}
	if !cmd.disable_version && cmd.version != '' && !cmd.flags.contains('version') && !cmd.flags.contains('v') {
		cmd.add_flag(version_flag())
	}
}

fn (mut cmd Command) add_default_commands() {
	if !cmd.disable_help && !cmd.commands.contains('help') {
		cmd.add_command(help_cmd())
	}
	if !cmd.disable_version && cmd.version != '' && !cmd.commands.contains('version') {
		cmd.add_command(version_cmd())
	}
}

fn (mut cmd Command) parse_flags() {
	for {
		if cmd.args.len < 1 || !cmd.args[0].starts_with('-') {
			break
		}
		mut found := false
		for i in 0..cmd.flags.len {
			mut flag := &cmd.flags[i]
			if flag.matches(cmd.args) {
				found = true
				args := flag.parse(cmd.args) or {	// TODO: fix once options types can be assigned to struct variables
					println('failed to parse flag ${cmd.args[0]}: ${err}')
					exit(1)
				}
				cmd.args = args
				break
			}
		}

		if !found {
			println('invalid flag: ${cmd.args[0]}')
			exit(1)
		}
	}
}

fn (cmd &Command) parse_commands() {
	flags := cmd.flags
	global_flags := flags.filter(it.global) // TODO: fix once filter can be applied to struct variable

	cmd.check_help_flag()
	cmd.check_version_flag()

	for i in 0..cmd.args.len {
		arg := cmd.args[i]
		for j in 0..cmd.commands.len {
			mut command := cmd.commands[j]
			if command.name == arg {
				for flag in global_flags {
					command.add_flag(flag)
				}
				command.parse(cmd.args[i..])
				return
			}
		}
	}

	// if no further command was found execute current command
	if int(cmd.execute) == 0 {
		if !cmd.disable_help {
			help_cmd := cmd.commands.get('help') or { return } // ignore error and handle command normally
			execute := help_cmd.execute
			execute(help_cmd)
		}
	} else {
		cmd.check_required_flags()

		if int(cmd.pre_execute) > 0 {
			pre_execute := cmd.pre_execute
			pre_execute(cmd)
		}

		execute := cmd.execute
		execute(cmd) // TODO: fix once higher order function can be execute on struct variable

		if int(cmd.post_execute) > 0 {
			post_execute := cmd.post_execute
			post_execute(cmd)
		}
	}
}

fn (cmd &Command) check_help_flag() {
	if cmd.disable_help {
		return
	}
	if cmd.flags.contains('help') {
		help_flag := cmd.flags.get_bool('help') or { return } // ignore error and handle command normally
		if help_flag {
			help_cmd := cmd.commands.get('help') or { return } // ignore error and handle command normally
			execute := help_cmd.execute
			execute(help_cmd)
			exit(0)
		}
	}
}

fn (cmd &Command) check_version_flag() {
	if cmd.disable_version {
		return
	}
	if cmd.version != '' && cmd.flags.contains('version') {
		version_flag := cmd.flags.get_bool('version') or { return } // ignore error and handle command normally
		if version_flag {
			version_cmd := cmd.commands.get('version') or { return } // ignore error and handle command normally
			execute := version_cmd.execute
			execute(version_cmd)
			exit(0)
		}
	}
}

fn (cmd &Command) check_required_flags() {
	for flag in cmd.flags {
		if flag.required && flag.value == '' {
			full_name := cmd.full_name()
			println('flag \'${flag.name}\' is required by \'${full_name}\'')
			exit(1)
		}
	}
}

fn (cmds []Command) contains(name string) bool {
	for cmd in cmds {
		if cmd.name == name {
			return true
		}
	}
	return false
}

fn (cmds []Command) get(name string) ?Command {
	for cmd in cmds {
		if cmd.name == name {
			return cmd
		}
	}
	return error('command \'${name}\' not found.')
}
import cli

fn test_if_command_parses_empty_args() {
	mut cmd := cli.Command{
		name: 'command', 
		execute: empty_func,
	}
	cmd.parse(['command'])
	assert cmd.name == 'command'
		&& compare_arrays(cmd.args, [])
}

fn test_if_command_parses_args() {
	mut cmd := cli.Command{
		name: 'command', 
		execute: empty_func,
	}
	cmd.parse(['command', 'arg0', 'arg1'])

	assert cmd.name == 'command'
		&& compare_arrays(cmd.args, ['arg0', 'arg1'])
}

fn test_if_subcommands_parse_args() {
	mut cmd := cli.Command{
		name: 'command',
	}
	subcmd := cli.Command{
		name: 'subcommand',
		execute: empty_func,
	}
	cmd.add_command(subcmd)
	cmd.parse(['command', 'subcommand', 'arg0', 'arg1'])
}

fn if_subcommands_parse_args_func(cmd cli.Command) {
	assert cmd.name == 'subcommand'
		&& compare_arrays(cmd.args, ['arg0', 'arg1'])
}

fn test_if_command_has_default_help_subcommand() {
	mut cmd := cli.Command{
		name: 'command',
	}
	cmd.parse(['command'])

	assert has_command(cmd, 'help')
}

fn test_if_command_has_default_version_subcommand_if_version_is_set() {
	mut cmd := cli.Command{
		name: 'command',
		version: '1.0.0',
	}
	cmd.parse(['command'])

	assert has_command(cmd, 'version')
}

fn test_if_flag_gets_set() {
	mut cmd := cli.Command{
		name: 'command',
		execute: if_flag_gets_set_func,
	}
	cmd.add_flag(cli.Flag{
		flag: .string
		name: 'flag'
	})
	cmd.parse(['command', '--flag', 'value'])
}

fn if_flag_gets_set_func(cmd cli.Command) {
	flag := cmd.flags.get_string('flag') or { panic(err) }
	assert flag == 'value'
}

fn test_if_flag_gets_set_with_abbrev() {
	mut cmd := cli.Command{
		name: 'command',
		execute: if_flag_gets_set_with_abbrev_func,
	}
	cmd.add_flag(cli.Flag{
		flag: .string,
		name: 'flag',
		abbrev: 'f',
	})
	cmd.parse(['command', '-f', 'value'])
}

fn if_flag_gets_set_with_abbrev_func(cmd cli.Command) {
	flag := cmd.flags.get_string('flag') or { panic(err) }
	assert flag == 'value'
}

fn test_if_multiple_flags_get_set() {
	mut cmd := cli.Command{
		name: 'command',
		execute: if_multiple_flags_get_set_func,
	}
	cmd.add_flag(cli.Flag{
		flag: .string
		name: 'flag'
	})
	cmd.add_flag(cli.Flag{
		flag: .int
		name: 'value'
	})
	cmd.parse(['command', '--flag', 'value', '--value', '42'])
}

fn if_multiple_flags_get_set_func(cmd cli.Command) {
	flag := cmd.flags.get_string('flag') or { panic(err) }
	value := cmd.flags.get_int('value') or { panic(err) }
	assert flag == 'value'
		&& value == 42
}

fn test_if_flag_gets_set_in_subcommand() {
	mut cmd := cli.Command{
		name: 'command',
		execute: empty_func,
	}
	mut subcmd := cli.Command{
		name: 'subcommand',
		execute: if_flag_gets_set_in_subcommand_func
	}
	subcmd.add_flag(cli.Flag{
		flag: .string
		name: 'flag'
	})
	cmd.add_command(subcmd)
	cmd.parse(['command', 'subcommand', '--flag', 'value'])
}

fn if_flag_gets_set_in_subcommand_func(cmd cli.Command) {
	flag := cmd.flags.get_string('flag') or { panic(err) }
	assert flag == 'value'
}

fn test_if_global_flag_gets_set_in_subcommand() {
	mut cmd := cli.Command{
		name: 'command',
		execute: empty_func,
	}
	cmd.add_flag(cli.Flag{
		flag: .string,
		name: 'flag',
		global: true,
	})
	subcmd := cli.Command{
		name: 'subcommand',
		execute: if_global_flag_gets_set_in_subcommand_func,
	}
	cmd.add_command(subcmd)
	cmd.parse(['command', '--flag', 'value', 'subcommand'])
}

fn if_global_flag_gets_set_in_subcommand_func(cmd cli.Command) {
	flag := cmd.flags.get_string('flag') or { panic(err) }
	assert flag == 'value'
}


// helper functions

fn empty_func(cmd cli.Command) {}

fn has_command(cmd cli.Command, name string) bool {
	for subcmd in cmd.commands {
		if subcmd.name == name {
			return true
		}
	}
	return false
}

fn compare_arrays(array0 []string, array1 []string) bool {
	if array0.len != array1.len {
		return false
	}
	for i in 0..array0.len {
		if array0[i] != array1[i] {
			return false
		}
	}
	return true
}
module cli

pub enum FlagType {
	bool
	int
	float
	string
}

pub struct Flag {
pub mut:
	flag FlagType
	name string
	abbrev string
	description string
	global bool
	required bool

	value string
}

pub fn (flags []Flag) get_bool(name string) ?bool {
	flag := flags.get(name) or { return error(err) }
	if flag.flag != .bool { return error('invalid flag type') }
	return flag.value == 'true'
}

pub fn (flags []Flag) get_bool_or(name string, or_value bool) bool {
	value := flags.get_bool(name) or { return or_value }
	return value
}

pub fn (flags []Flag) get_int(name string) ?int {
	flag := flags.get(name) or { return error(err) }
	if flag.flag != .int { return error('invalid flag type') }
	return flag.value.int()
}

pub fn (flags []Flag) get_int_or(name string, or_value int) int {
	value := flags.get_int(name) or { return or_value }
	return value
}

pub fn (flags []Flag) get_float(name string) ?f32 {
	flag := flags.get(name) or { return error(err) }
	if flag.flag != .float { return error('invalid flag type') }
	return flag.value.f32()
}

pub fn (flags []Flag) get_float_or(name string, or_value f32) f32 {
	value := flags.get_float(name) or { return or_value }
	return value
}

pub fn (flags []Flag) get_string(name string) ?string {
	flag := flags.get(name) or { return error(err) }
	if flag.flag != .string { return error('invalid flag type') }
	return flag.value
}

pub fn (flags []Flag) get_string_or(name string, or_value string) string {
	value := flags.get_string(name) or { return or_value }
	return value
}

// parse flag value from arguments and return arguments with all consumed element removed
fn (mut flag Flag) parse(args []string) ?[]string {
	if flag.matches(args) {
		if flag.flag == .bool {
			new_args := flag.parse_bool(args) or { return error(err) }
			return new_args
		} else {
			new_args := flag.parse_raw(args) or { return error(err) }
			return new_args
		}
	} else {
		return args
	}
}

// check if first arg matches flag
fn (flag &Flag) matches(args []string) bool {
	return
		(flag.name != '' && args[0].starts_with('--${flag.name}')) ||
		(flag.abbrev != '' && args[0].starts_with('-${flag.abbrev}'))
}

fn (mut flag Flag) parse_raw(args []string) ?[]string {
	if args[0].len > flag.name.len && args[0].contains('=') {
		flag.value = args[0].split('=')[1]
		return args[1..]
	} else if args.len >= 2 {
		flag.value = args[1]
		return args[2..]
	}
	return error('missing argument for ${flag.name}')
}

fn (mut flag Flag) parse_bool(args []string) ?[]string {
	if args[0].len > flag.name.len && args[0].contains('=') {
		flag.value = args[0].split('=')[1]
		return args[1..]
	} else if args.len >= 2 {
		if args[1] in ['true', 'false'] {
			flag.value = args[1]
			return args[2..]
		}
	}
	flag.value = 'true'
	return args[1..]
}

fn (flags []Flag) get(name string) ?Flag {
	for flag in flags {
		if flag.name == name {
			return flag
		}
	}
	return error('flag ${name} not found.')
}

fn (flags []Flag) contains(name string) bool {
	for flag in flags {
		if flag.name == name || flag.abbrev == name {
			return true
		}
	}
	return false
}
import cli

fn test_if_string_flag_parses() {
	mut flag := cli.Flag{
		flag: .string,
		name: 'flag',
	}

	flag.parse(['--flag', 'value']) or { panic(err) }
	assert flag.value == 'value'

	flag.parse(['--flag=value']) or { panic(err) }
	assert flag.value == 'value'
}

fn test_if_bool_flag_parses() {
	mut flag := cli.Flag{
		flag: .bool,
		name: 'flag',
	}

	flag.parse(['--flag']) or { panic(err) }
	assert flag.value == 'true'

	flag.parse(['--flag', 'true']) or { panic(err) }
	assert flag.value == 'true'

	flag.parse(['--flag=true']) or { panic(err) }
	assert flag.value == 'true'
}

fn test_if_int_flag_parses() {
	mut flag := cli.Flag{
		flag: .int,
		name: 'flag',
	}

	flag.parse(['--flag', '42']) or { panic(err) }
	assert flag.value.int() == 42

	flag.parse(['--flag=42']) or { panic(err) }
	assert flag.value.int() == 42
}

fn test_if_float_flag_parses() {
	mut flag := cli.Flag{
		flag: .float,
		name: 'flag',
	}

	flag.parse(['--flag', '3.14159']) or { panic(err) }
	assert flag.value.f64() == 3.14159

	flag.parse(['--flag=3.14159']) or { panic(err) }
	assert flag.value.f64() == 3.14159
}
module cli

import term
import strings

const (
	c_base_indent = 2
	c_abbrev_indent = 5
	c_description_indent = 20
)

fn help_flag() Flag {
	return Flag{
		flag: .bool,
		name: 'help',
		abbrev: 'h',
		description: 'Prints help information',
	}
}

fn help_cmd() Command {
	return Command{
		name: 'help',
		description: 'Prints help information',
		execute: help_func,
		parent: 0
	}
}

fn help_func(help_cmd Command) {
	cmd := help_cmd.parent
	full_name := cmd.full_name()

	mut help := ''
	help += 'Usage: ${full_name}'
	if cmd.flags.len > 0 { help += ' [FLAGS]'}
	if cmd.commands.len > 0 { help += ' [COMMANDS]'}
	help += '\n\n'

	if cmd.description != '' {
		help += '${cmd.description}\n\n'
	}
	if cmd.flags.len > 0 {
		help += 'Flags:\n'
		for flag in cmd.flags {
			mut flag_name := ''
			if flag.abbrev != '' {
				abbrev_indent := ' '.repeat(max(c_abbrev_indent-(flag.abbrev.len+1), 1))
				flag_name = '-${flag.abbrev}${abbrev_indent}--${flag.name}'
			} else {
				abbrev_indent := ' '.repeat(max(c_abbrev_indent-(flag.abbrev.len), 1))
				flag_name = '${abbrev_indent}--${flag.name}'
			}
			mut required := ''
			if flag.required {
				required = ' (required)'
			}

			base_indent := ' '.repeat(c_base_indent)
			description_indent := ' '.repeat(max(c_description_indent-flag_name.len, 1))
			help += '${base_indent}${flag_name}${description_indent}' +
				pretty_description(flag.description + required) + '\n'
		}
		help += '\n'
	}
	if cmd.commands.len > 0 {
		help += 'Commands:\n'
		for command in cmd.commands {
			base_indent := ' '.repeat(c_base_indent)
			description_indent := ' '.repeat(max(c_description_indent-command.name.len, 1))

			help += '${base_indent}${command.name}${description_indent}' +
				pretty_description(command.description) + '\n'
		}
		help += '\n'
	}

	print(help)
}

// pretty_description resizes description text depending on terminal width.
// Essentially, smart wrap-around
fn pretty_description(s string) string {
	width, _ := term.get_terminal_size()
	// Don't prettify if the terminal is that small, it won't be pretty anyway.
	if s.len + c_description_indent < width || c_description_indent > width {
		return s
	}
	indent := ' '.repeat(c_description_indent + 1)
	chars_per_line := width - c_description_indent
	// Give us enough room, better a little bigger than smaller
	mut acc := strings.new_builder(((s.len / chars_per_line) + 1) * (width + 1))

	mut i := chars_per_line - 2
	mut j := 0
	for ; i < s.len ; i += chars_per_line - 2 {
		for s.str[i] != ` ` { i-- }
		// indent was already done the first iteration
		if j != 0 { acc.write(indent) }
		acc.writeln(s[j..i])
		j = i
	}
	// We need this even though it should never happen
	if j != 0 {
		acc.write(indent)
	}
	acc.write(s[j..])
	return acc.str()
}

fn max(a, b int) int {
	return if a > b {a} else {b}
}
module cli

fn version_flag() Flag {
	return Flag{
		flag: .bool,
		name: 'version',
		abbrev: 'v',
		description: 'Prints version information',
	}
}

fn version_cmd() Command {
	return Command{
		name: 'version'
		description: 'Prints version information',
		execute: version_func,
		parent: 0
	}
}

fn version_func(version_cmd Command) {
	cmd := version_cmd.parent
	version := '${cmd.name} v${cmd.version}'
	println(version)
}
module clipboard

// create a new clipboard
pub fn new() &Clipboard {
	return new_clipboard()
}

// copy some text into the clipboard
pub fn (mut cb Clipboard) copy(text string) bool {
	return cb.set_text(text)
}

// get the text from the clipboard
pub fn (mut cb Clipboard) paste() string {
	return cb.get_text()
}

// clear the clipboard
pub fn (mut cb Clipboard) clear_all() {
	cb.clear()
}

// destroy the clipboard
pub fn (mut cb Clipboard) destroy() {
	cb.free()
}

// check if we own the clipboard
pub fn (cb Clipboard) check_ownership() bool {
	return cb.has_ownership()
}

// check if clipboard can be used
pub fn (cb &Clipboard) is_available() bool {
	return cb.check_availability()
}
module clipboard

#include <libkern/OSAtomic.h>
#include <Cocoa/Cocoa.h>

#flag -framework Cocoa

pub struct Clipboard {
    pb voidptr
    last_cb_serial i64
mut:
	foo int // TODO remove, for mut hack
}

fn new_clipboard() &Clipboard{
	pb := voidptr(0)
	#pb = [NSPasteboard generalPasteboard];
	cb := &Clipboard{
		pb: pb
	}
	return cb
}

fn (cb &Clipboard) check_availability() bool {
	return cb.pb != C.NULL
}

fn (mut cb Clipboard) clear(){
	cb.foo = 0
	#[cb->pb clearContents];
}

fn (mut cb Clipboard) free(){
	cb.foo = 0
	//nothing to free
}

fn (cb &Clipboard) has_ownership() bool {
	if cb.last_cb_serial == 0 {return false}
	#return [cb->pb changeCount] == cb->last_cb_serial;
	return false
}

fn C.OSAtomicCompareAndSwapLong()

fn (mut cb Clipboard) set_text(text string) bool {
	cb.foo = 0
	#NSString *ns_clip;
	ret := false

	#ns_clip = [[ NSString alloc ] initWithBytesNoCopy:text.str length:text.len encoding:NSUTF8StringEncoding freeWhenDone: false];
	#[cb->pb declareTypes:[NSArray arrayWithObject:NSStringPboardType] owner:nil];
	#ret = [cb->pb setString:ns_clip forType:NSStringPboardType];
	#[ns_clip release];

	mut serial := 0
	#serial = [cb->pb changeCount];
	C.OSAtomicCompareAndSwapLong(cb.last_cb_serial, serial, &cb.last_cb_serial)
	return ret
}

fn (mut cb Clipboard) get_text() string {
	cb.foo = 0
	#NSString *ns_clip;
	utf8_clip := byteptr(0)

	#ns_clip = [cb->pb stringForType:NSStringPboardType]; //NSPasteboardTypeString
	#if (ns_clip == nil) {
	#	return tos3(""); //in case clipboard is empty
	#}

	#utf8_clip = [ns_clip UTF8String];
	return string(utf8_clip)
}

pub fn new_primary() &Clipboard {
	panic('Primary clipboard is not supported on non-Linux systems.')
}
// Currently there is only X11 Selections support and no way to handle Wayland
// but since Wayland isn't extremely adopted, we are covering almost all Linux distros.
module clipboard

import time
import sync
import math

#flag -lX11
#include <X11/Xlib.h>

// X11
[typedef]
struct C.Display

[typedef]
struct C.Atom

[typedef]
struct C.Window

fn C.XInitThreads() int
fn C.XCloseDisplay(d &Display)
fn C.XFlush(d &Display)
fn C.XDestroyWindow(d &Display, w C.Window)
fn C.XNextEvent(d C.Display, e &XEvent)
fn C.XSetSelectionOwner(d &Display, a C.Atom, w C.Window, time int)
fn C.XGetSelectionOwner(d &Display, a C.Atom) C.Window
fn C.XChangeProperty(d &Display, requestor C.Window, property C.Atom, typ C.Atom, format int, mode int, data voidptr, nelements int) int
fn C.XSendEvent(d &Display, requestor C.Window, propogate int, mask i64, event &XEvent)
fn C.XInternAtom(d &Display, typ byteptr, only_if_exists int) C.Atom
fn C.XCreateSimpleWindow(d &Display, root C.Window, x int, y int, width u32, height u32, border_width u32,
	border u64, background u64) C.Window
fn C.XOpenDisplay(name byteptr) &C.Display
fn C.XConvertSelection(d &Display, selection C.Atom, target C.Atom, property C.Atom, requestor Window, time int) int
fn C.XSync(d &Display, discard int) int
fn C.XGetWindowProperty(d &Display, w Window, property C.Atom, offset i64, length i64, delete int, req_type C.Atom, actual_type_return &C.Atom, actual_format_return &int, nitems &u64, bytes_after_return &u64, prop_return &byteptr) int
fn C.XDeleteProperty(d &Display, w Window, property C.Atom) int
fn C.DefaultScreen() int
fn C.RootWindow() voidptr
fn C.BlackPixel() voidptr
fn C.WhitePixel() voidptr
fn C.XFree()

fn todo_del(){}

[typedef]
struct C.XSelectionRequestEvent{
	mut:
	display &C.Display	/* Display the event was read from */
	owner C.Window
	requestor C.Window
	selection C.Atom
	target C.Atom
	property C.Atom
	time int
}

[typedef]
struct C.XSelectionEvent{
	mut:
	@type int
	display &C.Display	/* Display the event was read from */
	requestor C.Window
	selection C.Atom
	target C.Atom
	property C.Atom
	time int
}

[typedef]
struct C.XSelectionClearEvent{
	mut:
	window C.Window
	selection C.Atom
}

[typedef]
struct C.XDestroyWindowEvent {
	mut:
	window C.Window
}

[typedef]
union C.XEvent{
	mut:
	@type int
	xdestroywindow C.XDestroyWindowEvent
	xselectionclear C.XSelectionClearEvent
	xselectionrequest C.XSelectionRequestEvent
	xselection C.XSelectionEvent
}

const (
	atom_names = ["TARGETS", "CLIPBOARD", "PRIMARY", "SECONDARY", "TEXT", "UTF8_STRING", "text/plain", "text/html"]
)
//UNSUPPORTED TYPES: MULTIPLE, INCR, TIMESTAMP, image/bmp, image/jpeg, image/tiff, image/png

// all the atom types we need
// currently we only support text
// in the future, maybe we can extend this
// to support other mime types
enum AtomType {
	xa_atom = 0 //value 4
	xa_string = 1 //value 31
	targets = 2
	clipboard = 3
	primary = 4
	secondary = 5
	text = 6
	utf8_string = 7
	text_plain = 8
	text_html = 9
}

pub struct Clipboard {
	display &C.Display
	mut:
	selection C.Atom //the selection atom
	window C.Window
	atoms []C.Atom
	mutex &sync.Mutex
	text string // text data sent or received
	got_text bool // used to confirm that we have got the text
	is_owner bool // to save selection owner state
}

struct Property{
	actual_type C.Atom
	actual_format int
	nitems u64
	data byteptr
}

fn new_clipboard() &Clipboard {
	return new_x11_clipboard(.clipboard)
}

// Initialize a new clipboard of the given selection type.
// We can initialize multiple clipboard instances and use them separately
fn new_x11_clipboard(selection AtomType) &Clipboard {
	if selection !in [.clipboard, .primary, .secondary] {
		panic("Wrong AtomType. Must be one of .primary, .secondary or .clipboard.")
	}

	//init x11 thread support
	status := C.XInitThreads()
	if status == 0 {
		println("WARN: this system does not support threads; clipboard will cause the program to lock.")
	}

	display := new_display()

	if display == C.NULL {
		println("ERROR: No X Server running. Clipboard cannot be used.")
		return &Clipboard{ display: 0 mutex: sync.new_mutex() }
	}

	mut cb := &Clipboard{
		display: display
		window: create_xwindow(display)
		mutex: sync.new_mutex()
	}
	cb.intern_atoms()
	cb.selection = cb.get_atom(selection)
	// start the listener on another thread or
	// we will be locked and will have to hard exit
	go cb.start_listener()
	return cb
}

fn (cb &Clipboard) check_availability() bool {
	return cb.display != C.NULL
}

fn (mut cb Clipboard) free() {
	C.XDestroyWindow(cb.display, cb.window)
	cb.window = C.Window(C.None)
	//FIX ME: program hangs when closing display
	//XCloseDisplay(cb.display)
}

fn (mut cb Clipboard) clear(){
	cb.mutex.lock()
	C.XSetSelectionOwner(cb.display, cb.selection, C.Window(C.None), C.CurrentTime)
	C.XFlush(cb.display)
	cb.is_owner = false
	cb.text = ""
	cb.mutex.unlock()
}

fn (cb &Clipboard) has_ownership() bool {
	return cb.is_owner
}

fn (cb &Clipboard) take_ownership(){
	C.XSetSelectionOwner(cb.display, cb.selection, cb.window, C.CurrentTime)
	C.XFlush(cb.display)
}

fn (mut cb Clipboard) set_text(text string) bool {
	if cb.window == C.Window(C.None) {return false}
	cb.mutex.lock()
	cb.text = text
	cb.is_owner = true
	cb.take_ownership()
	C.XFlush(cb.display)
	cb.mutex.unlock()
	// sleep a little bit
	time.sleep(1)
	return cb.is_owner
}

fn (mut cb Clipboard) get_text() string {
	if cb.window == C.Window(C.None) {return ""}
	if cb.is_owner {
		return cb.text
	}
	cb.got_text = false

	//Request a list of possible conversions, if we're pasting.
	C.XConvertSelection(cb.display, cb.selection, cb.get_atom(.targets), cb.selection, cb.window, C.CurrentTime)

	//wait for the text to arrive
	mut retries := 5
	for {
		if cb.got_text || retries == 0 {break}
		time.usleep(50000)
		retries--
	}
	return cb.text
}

// this function is crucial to handling all the different data types
// if we ever support other mimetypes they should be handled here
fn (mut cb Clipboard) transmit_selection(xse &C.XSelectionEvent) bool {
	if xse.target == cb.get_atom(.targets) {
		targets := cb.get_supported_targets()
		C.XChangeProperty(xse.display, xse.requestor, xse.property, cb.get_atom(.xa_atom), 32, C.PropModeReplace, targets.data, targets.len)
	} else if cb.is_supported_target(xse.target) && cb.is_owner && cb.text != "" {
		cb.mutex.lock()
		C.XChangeProperty(xse.display, xse.requestor, xse.property, xse.target, 8, C.PropModeReplace, cb.text.str, cb.text.len)
		cb.mutex.unlock()
	} else {
		return false
	}
	return true
}

fn (mut cb Clipboard) start_listener(){
	event := C.XEvent{}
	mut sent_request := false
	mut to_be_requested := C.Atom(0)
	for {
		C.XNextEvent(cb.display, &event)
		if event.@type == 0 {
			println("error")
           	continue
        }
		match event.@type {
			C.DestroyNotify {
				if event.xdestroywindow.window == cb.window {
					return // we are done
				}
			}
			C.SelectionClear {
				if event.xselectionclear.window == cb.window && event.xselectionclear.selection == cb.selection {
					cb.mutex.lock()
					cb.is_owner = false
					cb.text = ""
					cb.mutex.unlock()
				}
			}
			C.SelectionRequest {
				if event.xselectionrequest.selection == cb.selection {
					mut xsre := &C.XSelectionRequestEvent{ display: 0 }
					xsre = &event.xselectionrequest

					mut xse := C.XSelectionEvent{
						@type: C.SelectionNotify // 31
						display: xsre.display
						requestor: xsre.requestor
						selection: xsre.selection
						time: xsre.time
						target: xsre.target
						property: xsre.property
					}
					if !cb.transmit_selection(&xse) {
						xse.property = new_atom(C.None)
					}
					C.XSendEvent(cb.display, xse.requestor, 0, C.PropertyChangeMask, voidptr(&xse))
					C.XFlush(cb.display)
				}
			}
			C.SelectionNotify {
				if event.xselection.selection == cb.selection && event.xselection.property != C.Atom(C.None) {
					if event.xselection.target == cb.get_atom(.targets) && !sent_request {
						sent_request = true
						prop := read_property(cb.display, cb.window, cb.selection)
						to_be_requested = cb.pick_target(prop)
						if to_be_requested != C.Atom(0) {
							C.XConvertSelection(cb.display, cb.selection, to_be_requested, cb.selection, cb.window, C.CurrentTime)
						}
					} else if event.xselection.target == to_be_requested {
						sent_request = false
						to_be_requested = C.Atom(0)
						cb.mutex.lock()
						prop := read_property(event.xselection.display, event.xselection.requestor, event.xselection.property)
						C.XDeleteProperty(event.xselection.display, event.xselection.requestor, event.xselection.property)
						if cb.is_supported_target(prop.actual_type) {
							cb.got_text = true
							cb.text = string(prop.data) //TODO: return byteptr to support other mimetypes
						}
						cb.mutex.unlock()
					}
				}
			}
			C.PropertyNotify {}
			else {}
		}
	}
}



// Helpers

// Initialize all the atoms we need
fn (mut cb Clipboard) intern_atoms(){
	cb.atoms << C.Atom(4) //XA_ATOM
	cb.atoms << C.Atom(31) //XA_STRING
	for i, name in atom_names{
		only_if_exists := if i == int(AtomType.utf8_string) {1} else {0}
		cb.atoms << C.XInternAtom(cb.display, name.str, only_if_exists)
		if i == int(AtomType.utf8_string) && cb.atoms[i] == C.Atom(C.None) {
			cb.atoms[i] = cb.get_atom(.xa_string)
		}
	}
}

fn read_property(d &C.Display, w C.Window, p C.Atom) Property {
	actual_type := C.Atom(0)
	actual_format := 0
	nitems := u64(0)
	bytes_after := u64(0)
	ret := byteptr(0)
	mut read_bytes := 1024
	for {
		if ret != 0 {
			C.XFree(ret)
		}
		C.XGetWindowProperty(d, w, p, 0, read_bytes, 0, C.AnyPropertyType, &actual_type, &actual_format, &nitems, &bytes_after, &ret)
		read_bytes *= 2
		if bytes_after == 0 {break}
	}
	return Property{actual_type, actual_format, nitems, ret}
}

// Finds the best target given a local copy of a property.
fn (cb &Clipboard) pick_target(prop Property) C.Atom {
	//The list of targets is a list of atoms, so it should have type XA_ATOM
	//but it may have the type TARGETS instead.
	if (prop.actual_type != cb.get_atom(.xa_atom) && prop.actual_type != cb.get_atom(.targets)) || prop.actual_format != 32
	{
		//This would be really broken. Targets have to be an atom list
		//and applications should support this. Nevertheless, some
		//seem broken (MATLAB 7, for instance), so ask for STRING
		//next instead as the lowest common denominator
		return cb.get_atom(.xa_string)
	}
	else
	{
		atom_list := &C.Atom(prop.data)

		mut to_be_requested := C.Atom(0)

		//This is higher than the maximum priority.
		mut priority := math.max_i32

		for i in 0..prop.nitems {
			//See if this data type is allowed and of higher priority (closer to zero)
			//than the present one.

			if cb.is_supported_target(atom_list[i]) {
				index := cb.get_target_index(atom_list[i])
				if priority > index && index >= 0
				{
					priority = index
					to_be_requested = atom_list[i]
				}
			}
		}
		return to_be_requested
	}
}

fn (cb &Clipboard) get_atoms(types ...AtomType) []C.Atom {
	mut atoms := []C.Atom{}
	for typ in types {
		atoms << cb.atoms[typ]
	}
	return atoms
}

fn (cb &Clipboard) get_atom(typ AtomType) C.Atom {
	return cb.atoms[typ]
}

fn (cb &Clipboard) is_supported_target(target C.Atom) bool {
	return cb.get_target_index(target) >= 0
}

fn (cb &Clipboard) get_target_index(target C.Atom) int {
	for i, atom in cb.get_supported_targets() {
		if atom == target {return i}
	}
	return -1
}

fn (cb &Clipboard) get_supported_targets() []C.Atom {
	return cb.get_atoms(AtomType.utf8_string, .xa_string, .text, .text_plain, .text_html)
}

fn new_atom(value int) &C.Atom {
	mut atom := &C.Atom{}
	atom = value
	return atom
}

fn create_xwindow(display &C.Display) C.Window {
	n := C.DefaultScreen(display)
	return C.XCreateSimpleWindow(display, C.RootWindow(display, n), 0, 0, 1, 1,
		0, C.BlackPixel(display, n), C.WhitePixel(display, n))
}

fn new_display() &C.Display {
	return C.XOpenDisplay(C.NULL)
}

// create a new PRIMARY clipboard (only supported on Linux)
pub fn new_primary() &Clipboard {
	return new_x11_clipboard(.primary)
}
module clipboard

pub struct Clipboard {
	mut:
	text string // text data sent or received
	got_text bool // used to confirm that we have got the text
	is_owner bool // to save selection owner state
}

fn new_clipboard() &Clipboard {
   eprintln('TODO: support clipboard on solaris')
   return &Clipboard{}
}

pub fn new_primary() &Clipboard {
   eprintln('TODO: support clipboard on solaris')
   return &Clipboard{}
}

fn (mut cb Clipboard) set_text(text string) bool {
   cb.text = text
   cb.is_owner = true
   cb.got_text = true
   return true
}

fn (mut cb Clipboard) get_text() string {
   return cb.text
}

fn (mut cb Clipboard) clear(){
   cb.text = ''
   cb.is_owner = false
}

fn (mut cb Clipboard) free(){
}

fn (cb &Clipboard) has_ownership() bool {
   return cb.is_owner
}

fn (cb &Clipboard) check_availability() bool {
   // This is a dummy clipboard implementation,
   // which can be always used, although it does not do much...
   return true
}
import clipboard

fn run_test(is_primary bool){
	mut cb := if is_primary {clipboard.new_primary()}else{clipboard.new()}
	if !cb.is_available() {return}
	assert cb.check_ownership() == false
	assert cb.copy("I am a good boy!") == true
	assert cb.check_ownership() == true
	assert cb.paste() == "I am a good boy!"
	cb.clear_all()
	assert cb.paste().len <= 0
	cb.destroy()
}

fn test_primary(){
	$if linux {
		return
		//run_test(true)
	}
}

fn test_clipboard(){
	$if linux {
		return
	}
	run_test(false)
}
module clipboard

import time

struct WndClassEx {
	cb_size         u32
	style           u32
	lpfn_wnd_proc   voidptr
	cb_cls_extra    int
	cb_wnd_extra    int
	h_instance      C.HINSTANCE
	h_icon          C.HICON
	h_cursor        C.HCURSOR
	hbr_background  C.HBRUSH
	lpsz_menu_name  &u16 // LPCWSTR
    lpsz_class_name &u16
	h_icon_sm       &u16
}

fn C.RegisterClassEx(class WndClassEx) int

fn C.GetClipboardOwner() &C.HWND

fn C.CreateWindowEx(dwExStyle i64, lpClassName, lpWindowName &u16, dwStyle i64, x, y, nWidth, nHeight int, hWndParent i64, hMenu, h_instance, lpParam voidptr) &C.HWND

// fn C.MultiByteToWideChar(CodePage u32, dw_flags u16, lpMultiByteStr byteptr, cbMultiByte int, lpWideCharStr u16, cchWideChar int) int
fn C.EmptyClipboard()

fn C.CloseClipboard()

fn C.GlobalAlloc(uFlag u32, size i64) C.HGLOBAL

fn C.GlobalFree(buf C.HGLOBAL)

fn C.GlobalLock(buf C.HGLOBAL)

fn C.GlobalUnlock(buf C.HGLOBAL)

fn C.SetClipboardData(uFormat u32, data voidptr) C.HANDLE

fn C.GetClipboardData(uFormat u32) C.HANDLE

fn C.DefWindowProc(hwnd C.HWND, msg u32, wParam C.WPARAM, lParam C.LPARAM) C.LRESULT

fn C.SetLastError(error i64)

fn C.OpenClipboard(hwnd C.HWND) int

fn C.DestroyWindow(hwnd C.HWND)

struct Clipboard {
    max_retries int
    retry_delay int
    mut:
	hwnd        C.HWND
	foo         int // TODO remove
}

fn (cb &Clipboard) get_clipboard_lock() bool {
	mut retries := cb.max_retries
	mut last_error := u32(0)
	for {
		retries--
		if retries < 0 {
			break
		}
        last_error = C.GetLastError()
        if C.OpenClipboard(cb.hwnd) > 0 {
            return true
        } else if last_error != u32(C.ERROR_ACCESS_DENIED) {
            return false
        }
		time.sleep(cb.retry_delay)
	}
    C.SetLastError(last_error)
    return false
}

fn new_clipboard() &Clipboard {
	mut cb := &Clipboard{
        max_retries: 5
        retry_delay: 5
    }
	class_name := 'clipboard'
	wndclass := WndClassEx{
        cb_size: sizeof(WndClassEx)
        lpfn_wnd_proc: voidptr(&C.DefWindowProc)
        lpsz_class_name: class_name.to_wide()
		lpsz_menu_name: 0
		h_icon_sm: 0
    }
    if C.RegisterClassEx(&wndclass) == 0 && C.GetLastError() != u32(C.ERROR_CLASS_ALREADY_EXISTS) {
		println('Failed registering class.')
    }
	hwnd := C.CreateWindowEx(0, wndclass.lpsz_class_name, wndclass.lpsz_class_name, 0, 0, 0,
		0, 0, C.HWND_MESSAGE, C.NULL, C.NULL, C.NULL)
    if hwnd == C.NULL {
		println('Error creating window!')
    }
    cb.hwnd = hwnd
    return cb
}

fn (cb &Clipboard) check_availability() bool {
	return cb.hwnd != C.HWND(C.NULL)
}

fn (cb &Clipboard) has_ownership() bool {
    return C.GetClipboardOwner() == cb.hwnd
}

fn (mut cb Clipboard) clear() {
	if !cb.get_clipboard_lock() {
		return
	}
    C.EmptyClipboard()
    C.CloseClipboard()
	cb.foo = 0
}

fn (mut cb Clipboard) free() {
    C.DestroyWindow(cb.hwnd)
	cb.foo = 0
}

// the string.to_wide doesn't work with SetClipboardData, don't know why
fn to_wide(text string) &C.HGLOBAL {
	len_required := C.MultiByteToWideChar(C.CP_UTF8, C.MB_ERR_INVALID_CHARS, text.str, text.len +
		1, C.NULL, 0)
    buf := C.GlobalAlloc(C.GMEM_MOVEABLE, sizeof(u16) * len_required)
    if buf != C.HGLOBAL(C.NULL) {
        mut locked := &u16(C.GlobalLock(buf))
        C.MultiByteToWideChar(C.CP_UTF8, C.MB_ERR_INVALID_CHARS, text.str, text.len + 1, locked, len_required)
        locked[len_required - 1] = u16(0)
        C.GlobalUnlock(buf)
    }
    return buf
}

fn (mut cb Clipboard) set_text(text string) bool {
	cb.foo = 0
    buf := to_wide(text)
    if !cb.get_clipboard_lock() {
        C.GlobalFree(buf)
        return false
    } else {
        // EmptyClipboard must be called to properly update clipboard ownership
        C.EmptyClipboard()
        if C.SetClipboardData(C.CF_UNICODETEXT, buf) == C.HANDLE(C.NULL) {
			println('SetClipboardData: Failed.')
            C.CloseClipboard()
            C.GlobalFree(buf)
            return false
        }
    }
    // CloseClipboard appears to change the sequence number...
    C.CloseClipboard()
    return true
}

fn (mut cb Clipboard) get_text() string {
	cb.foo = 0
    if !cb.get_clipboard_lock() {
		return ''
    }
    h_data := C.GetClipboardData(C.CF_UNICODETEXT)
    if h_data == C.HANDLE(C.NULL) {
        C.CloseClipboard()
		return ''
    }
    str := string_from_wide(&u16(C.GlobalLock(h_data)))
    C.GlobalUnlock(h_data)
    return str
}

pub fn new_primary() &Clipboard {
	panic('Primary clipboard is not supported on non-Linux systems.')
}
module crypto

pub enum Hash {
	md4
	md5
	sha1
	sha224
	sha256
	sha384
	sha512
	md5sha1
	ripemd160
	sha3_224
	sha3_256
	sha3_384
	sha3_512
	sha512_224
	sha512_256
	blake2s_256
	blake2b_256
	blake2b_384
	blake2b_512
}

Based on Go's crypto packages.

Copyright (c) 2009 The Go Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Based off:   https://github.com/golang/go/blob/master/src/crypto/aes
// Last commit: https://github.com/golang/go/commit/691a2d457ab1bf03bd46d4b69e0f93b8993c0055

module aes

import crypto.internal.subtle

pub const (
	// The AES block size in bytes.
	block_size = 16
)

// A cipher is an instance of AES encryption using a particular key.
struct AesCipher {
	enc []u32
	dec []u32
}

// new_cipher creates and returns a new cipher.Block.
// The key argument should be the AES key,
// either 16, 24, or 32 bytes to select
// AES-128, AES-192, or AES-256.
pub fn new_cipher(key []byte) AesCipher {
	k := key.len
	match k {
	16, 24, 32 {
		// break
	} else {
		panic('crypto.aes: invalid key size ' + k.str())
		// return error('crypto.aes: invalid key size ' + k.str())
	}
	}
	// for now use generic version
	return new_cipher_generic(key)
}

pub fn (c &AesCipher) block_size() int { return block_size }

pub fn (c &AesCipher) encrypt(dst, src []byte) {
	if src.len < block_size {
		panic('crypto.aes: input not full block')
	}
	if dst.len < block_size {
		panic('crypto.aes: output not full block')
	}
	// if subtle.inexact_overlap(dst[:block_size], src[:block_size]) {
	if subtle.inexact_overlap(dst[..block_size], src[..block_size]) {
		panic('crypto.aes: invalid buffer overlap')
	}
	// for now use generic version
	encrypt_block_generic(c.enc, dst, src)
}

pub fn (c &AesCipher) decrypt(dst, src []byte) {
	if src.len < block_size {
		panic('crypto.aes: input not full block')
	}
	if dst.len < block_size {
		panic('crypto.aes: output not full block')
	}
	if subtle.inexact_overlap(dst[..block_size], src[..block_size]) {
		panic('crypto.aes: invalid buffer overlap')
	}
	// for now use generic version
	decrypt_block_generic(c.dec, dst, src)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Cipher block chaining (CBC) mode.

// CBC provides confidentiality by xoring (chaining) each plaintext block
// with the previous ciphertext block before applying the block cipher.

// See NIST SP 800-38A, pp 10-11

// NOTE this will be moved to crypto.cipher interface (joe-c)

module aes

import crypto.cipher
import crypto.internal.subtle

struct AesCbc {
mut:
	b          AesCipher
	block_size int
	iv         []byte
	tmp        []byte
}

// internal
fn new_aes_cbc(b AesCipher, iv []byte) AesCbc {
	return AesCbc{
		b:          b,
		block_size: b.block_size(),
		iv:         iv.clone(),
		tmp:        [byte(0)].repeat(b.block_size()),
	}
}

// new_cbc_encrypter returns a BlockMode which encrypts in cipher block chaining
// mode, using the given Block. The length of iv must be the same as the
// Block's block size.
pub fn new_cbc(b AesCipher, iv []byte) AesCbc {
	if iv.len != b.block_size() {
		panic('crypto.cipher.new_cbc_encrypter: IV length must equal block size')
	}
	return new_aes_cbc(b, iv)
}

pub fn (x &AesCbc) block_size() int { return x.block_size }

pub fn (x &AesCbc) encrypt_blocks(dst mut []byte, src_ []byte) {
	mut src := src_
	if src.len%x.block_size != 0 {
		panic('crypto.cipher: input not full blocks')
	}
	if dst.len < src.len {
		panic('crypto.cipher: output smaller than input')
	}
	if subtle.inexact_overlap((*dst)[..src.len], src) {
		panic('crypto.cipher: invalid buffer overlap')
	}

	mut iv := x.iv

	for src.len > 0 {
		// Write the xor to dst, then encrypt in place.
		cipher.xor_bytes(mut (*dst)[..x.block_size], src[..x.block_size], iv)
		x.b.encrypt((*dst)[..x.block_size], (*dst)[..x.block_size])

		// Move to the next block with this block as the next iv.
		iv = (*dst)[..x.block_size]
		if x.block_size >= src.len {
			src = []
		} else {
			src = src[x.block_size..]
		}
		(*dst) = (*dst)[x.block_size..]
	}

	// Save the iv for the next crypt_blocks call.
	copy(x.iv, iv)
}

pub fn (mut x AesCbc) decrypt_blocks(dst mut []byte, src []byte) {
	if src.len%x.block_size != 0 {
		panic('crypto.cipher: input not full blocks')
	}
	if dst.len < src.len {
		panic('crypto.cipher: output smaller than input')
	}
	if subtle.inexact_overlap((*dst)[..src.len], src) {
		panic('crypto.cipher: invalid buffer overlap')
	}
	if src.len == 0 {
		return
	}

	// For each block, we need to xor the decrypted data with the previous block's ciphertext (the iv).
	// To avoid making a copy each time, we loop over the blocks BACKWARDS.
	mut end := src.len
	mut start := end - x.block_size
	mut prev := start - x.block_size

	// Copy the last block of ciphertext in preparation as the new iv.
	copy(x.tmp, src.slice(start, end))

	// Loop over all but the first block.
	for start > 0 {
		x.b.decrypt((*dst).slice(start, end), src.slice(start, end))
		cipher.xor_bytes(mut (*dst).slice(start, end), (*dst).slice(start, end), src.slice(prev, start))

		end = start
		start = prev
		prev -= x.block_size
	}

	// The first block is special because it uses the saved iv.
	x.b.decrypt((*dst).slice(start, end), src.slice(start, end))
	cipher.xor_bytes(mut (*dst).slice(start, end), (*dst).slice(start, end), x.iv)


	// Set the new iv to the first block we copied earlier.
	x.iv = x.tmp
	x.tmp = x.iv
}

fn (x &AesCbc) set_iv(iv []byte) {
	if iv.len != x.iv.len {
		panic('cipher: incorrect length IV')
	}
	copy(x.iv, iv)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

import crypto.aes

fn test_crypto_aes() {
	// TEST CBC
	key := '6368616e676520746869732070617373'.bytes()
	mut ciphertext := '73c86d43a9d700a253a96c85b0f6b03ac9792e0e757f869cca306bd3cba1c62b'.bytes()
	block := aes.new_cipher(key)
	// The IV needs to be unique, but not secure. Therefore it's common to
	// include it at the beginning of the ciphertext.
	if ciphertext.len < aes.block_size {
		panic('ciphertext too short')
	}
	iv := ciphertext[..aes.block_size]
	ciphertext = ciphertext[aes.block_size..]
	// CBC mode always works in whole blocks.
	if ciphertext.len%aes.block_size != 0 {
		panic('ciphertext is not a multiple of the block size')
	}
	mode := aes.new_cbc(block, iv)
	mode.encrypt_blocks(mut ciphertext, ciphertext)

	assert ciphertext.hex() == 'c210459b514668ddc44674885e4979215265a6c44431a248421254ef357a8c2a308a8bddf5623af9df91737562041cf1'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// This implementation is derived from the golang implementation
// which itself is derived in part from the reference
// ANSI C implementation, which carries the following notice:
//
//	rijndael-alg-fst.c
//
//	@version 3.0 (December 2000)
//
//	Optimised ANSI C code for the Rijndael cipher (now AES)
//
//	@author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
//	@author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>
//	@author Paulo Barreto <paulo.barreto@Terra.com.br>
//
//	This code is hereby placed in the public domain.
//
//	THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
//	OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//	ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
//	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
//	CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
//	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
//	OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//	EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// See FIPS 197 for specification, and see Daemen and Rijmen's Rijndael submission
// for implementation details.
//	https://csrc.nist.gov/csrc/media/publications/fips/197/final/documents/fips-197.pdf
//	https://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf

module aes

import encoding.binary

// Encrypt one block from src into dst, using the expanded key xk.
fn encrypt_block_generic(xk []u32, dst, src []byte) {
	_ = src[15] // early bounds check
	mut s0 := binary.big_endian_u32(src[..4])
	mut s1 := binary.big_endian_u32(src.slice(4, 8))
	mut s2 := binary.big_endian_u32(src.slice(8, 12))
	mut s3 := binary.big_endian_u32(src.slice(12, 16))

	// First round just XORs input with key.
	s0 ^= xk[0]
	s1 ^= xk[1]
	s2 ^= xk[2]
	s3 ^= xk[3]

	// Middle rounds shuffle using tables.
	// Number of rounds is set by length of expanded key.
	nr := xk.len/4 - 2 // - 2: one above, one more below
	mut k := 4
	mut t0 := u32(0)
	mut t1 := u32(0)
	mut t2 := u32(0)
	mut t3 := u32(0)
	for _ in 0..nr {
		t0 = xk[k+0] ^ te0[byte(s0>>24)] ^ te1[byte(s1>>16)] ^ te2[byte(s2>>8)] ^ u32(te3[byte(s3)])
		t1 = xk[k+1] ^ te0[byte(s1>>24)] ^ te1[byte(s2>>16)] ^ te2[byte(s3>>8)] ^ u32(te3[byte(s0)])
		t2 = xk[k+2] ^ te0[byte(s2>>24)] ^ te1[byte(s3>>16)] ^ te2[byte(s0>>8)] ^ u32(te3[byte(s1)])
		t3 = xk[k+3] ^ te0[byte(s3>>24)] ^ te1[byte(s0>>16)] ^ te2[byte(s1>>8)] ^ u32(te3[byte(s2)])
		k += 4
		s0 = t0
		s1 = t1
		s2 = t2
		s3 = t3
	}

	// Last round uses s-box directly and XORs to produce output.
	s0 = s_box0[t0>>24]<<24 | s_box0[t1>>16&0xff]<<16 | u32(s_box0[t2>>8&0xff]<<8) | s_box0[t3&u32(0xff)]
	s1 = s_box0[t1>>24]<<24 | s_box0[t2>>16&0xff]<<16 | u32(s_box0[t3>>8&0xff]<<8) | s_box0[t0&u32(0xff)]
	s2 = s_box0[t2>>24]<<24 | s_box0[t3>>16&0xff]<<16 | u32(s_box0[t0>>8&0xff]<<8) | s_box0[t1&u32(0xff)]
	s3 = s_box0[t3>>24]<<24 | s_box0[t0>>16&0xff]<<16 | u32(s_box0[t1>>8&0xff]<<8) | s_box0[t2&u32(0xff)]

	s0 ^= xk[k+0]
	s1 ^= xk[k+1]
	s2 ^= xk[k+2]
	s3 ^= xk[k+3]

	_ = dst[15] // early bounds check
	binary.big_endian_put_u32(mut dst[..4], s0)
	binary.big_endian_put_u32(mut dst.slice(4, 8), s1)
	binary.big_endian_put_u32(mut dst.slice(8, 12), s2)
	binary.big_endian_put_u32(mut dst.slice(12, 16), s3)
}

// Decrypt one block from src into dst, using the expanded key xk.
fn decrypt_block_generic(xk []u32, dst, src []byte) {
	_ = src[15] // early bounds check
	mut s0 := binary.big_endian_u32(src[..4])
	mut s1 := binary.big_endian_u32(src.slice(4, 8))
	mut s2 := binary.big_endian_u32(src.slice(8, 12))
	mut s3 := binary.big_endian_u32(src.slice(12, 16))

	// First round just XORs input with key.
	s0 ^= xk[0]
	s1 ^= xk[1]
	s2 ^= xk[2]
	s3 ^= xk[3]

	// Middle rounds shuffle using tables.
	// Number of rounds is set by length of expanded key.
	nr := xk.len/4 - 2 // - 2: one above, one more below
	mut k := 4
	mut t0 := u32(0)
	mut t1 := u32(0)
	mut t2 := u32(0)
	mut t3 := u32(0)
	for _ in 0..nr {
		t0 = xk[k+0] ^ td0[byte(s0>>24)] ^ td1[byte(s3>>16)] ^ td2[byte(s2>>8)] ^ u32(td3[byte(s1)])
		t1 = xk[k+1] ^ td0[byte(s1>>24)] ^ td1[byte(s0>>16)] ^ td2[byte(s3>>8)] ^ u32(td3[byte(s2)])
		t2 = xk[k+2] ^ td0[byte(s2>>24)] ^ td1[byte(s1>>16)] ^ td2[byte(s0>>8)] ^ u32(td3[byte(s3)])
		t3 = xk[k+3] ^ td0[byte(s3>>24)] ^ td1[byte(s2>>16)] ^ td2[byte(s1>>8)] ^ u32(td3[byte(s0)])
		k += 4
		s0 = t0
		s1 = t1
		s2 = t2
		s3 = t3
	}

	// Last round uses s-box directly and XORs to produce output.
	s0 = u32(s_box1[t0>>24])<<24 | u32(s_box1[t3>>16&0xff])<<16 | u32(s_box1[t2>>8&0xff]<<8) | u32(s_box1[t1&u32(0xff)])
	s1 = u32(s_box1[t1>>24])<<24 | u32(s_box1[t0>>16&0xff])<<16 | u32(s_box1[t3>>8&0xff]<<8) | u32(s_box1[t2&u32(0xff)])
	s2 = u32(s_box1[t2>>24])<<24 | u32(s_box1[t1>>16&0xff])<<16 | u32(s_box1[t0>>8&0xff]<<8) | u32(s_box1[t3&u32(0xff)])
	s3 = u32(s_box1[t3>>24])<<24 | u32(s_box1[t2>>16&0xff])<<16 | u32(s_box1[t1>>8&0xff]<<8) | u32(s_box1[t0&u32(0xff)])

	s0 ^= xk[k+0]
	s1 ^= xk[k+1]
	s2 ^= xk[k+2]
	s3 ^= xk[k+3]

	_ = dst[15] // early bounds check
	binary.big_endian_put_u32(mut dst[..4], s0)
	binary.big_endian_put_u32(mut dst.slice(4, 8), s1)
	binary.big_endian_put_u32(mut dst.slice(8, 12), s2)
	binary.big_endian_put_u32(mut dst.slice(12, 16), s3)
}

// Apply s_box0 to each byte in w.
fn subw(w u32) u32 {
	return u32(s_box0[w>>24])<<24 |
		   u32(s_box0[w>>16&0xff]<<16) |
		   u32(s_box0[w>>8&0xff]<<8) |
		   u32(s_box0[w&u32(0xff)])
}

// Rotate
fn rotw(w u32) u32 { return (w<<8) | (w>>24) }

// Key expansion algorithm. See FIPS-197, Figure 11.
// Their rcon[i] is our powx[i-1] << 24.
fn expand_key_generic(key []byte, enc mut []u32, dec mut []u32) {
	// Encryption key setup.
	mut i := 0
	nk := key.len / 4
	for i = 0; i < nk; i++ {
		if 4*i >= key.len {
			break
		}
		enc[i] = binary.big_endian_u32(key[4*i..])
	}

	for i < enc.len {
		mut t := enc[i-1]
		if i%nk == 0 {
			t = subw(rotw(t)) ^ u32(pow_x[i/nk-1]) << 24
		} else if nk > 6 && i%nk == 4 {
			t = subw(t)
		}
		enc[i] = enc[i-nk] ^ t
		i++
	}

	// Derive decryption key from encryption key.
	// Reverse the 4-word round key sets from enc to produce dec.
	// All sets but the first and last get the MixColumn transform applied.
	if dec.len == 0 {
		return
	}
	n := enc.len
	for i = 0; i < n; i += 4 {
		ei := n - i - 4
		for j in 0..4 {
			mut x := enc[ei+j]
			if i > 0 && i+4 < n {
				x = td0[s_box0[x>>24]] ^ td1[s_box0[x>>16&0xff]] ^ td2[s_box0[x>>8&0xff]] ^ td3[s_box0[x&u32(0xff)]]
			}
			dec[i+j] = x
		}
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Package aes implements AES encryption (formerly Rijndael), as defined in
// U.S. Federal Information Processing Standards Publication 197.
//
// The AES operations in this package are not implemented using constant-time algorithms.
// An exception is when running on systems with enabled hardware support for AES
// that makes these operations constant-time. Examples include amd64 systems using AES-NI
// extensions and s390x systems using Message-Security-Assist extensions.
// On such systems, when the result of NewCipher is passed to cipher.NewGCM,
// the GHASH operation used by GCM is also constant-time.
module aes

// This file contains AES constants - 8720 bytes of initialized data.

// https://csrc.nist.gov/publications/fips/fips197/fips-197.pdf

// AES is based on the mathematical behavior of binary polynomials
// (polynomials over GF(2)) modulo the irreducible polynomial x + x + x + x + 1.
// Addition of these binary polynomials corresponds to binary xor.
// Reducing mod poly corresponds to binary xor with poly every
// time a 0x100 bit appears.
const (
	poly = (1<<8) | (1<<4) | (1<<3) | (1<<1) | (1<<0) // x + x + x + x + 1
)

// Powers of x mod poly in GF(2).
const (
	pow_x = [
		byte(0x01),
		0x02,
		0x04,
		0x08,
		0x10,
		0x20,
		0x40,
		0x80,
		0x1b,
		0x36,
		0x6c,
		0xd8,
		0xab,
		0x4d,
		0x9a,
		0x2f,
	]
)

// FIPS-197 Figure 7. S-box substitution values in hexadecimal format.
const (
	s_box0 = [
		byte(0x63), 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
	]
)

// FIPS-197 Figure 14.  Inverse S-box substitution values in hexadecimal format.
const (
	s_box1 = [
		byte(0x52), 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
		0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
		0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
		0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
		0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
		0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
		0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
		0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
		0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
		0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
		0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
		0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
		0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
		0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
		0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
		0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
	]
)

// Lookup tables for encryption.

const (
	te0 = [
		u32(0xc66363a5), 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554,
		0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a,
		0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,
		0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b,
		0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f,
		0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,
		0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5,
		0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f,
		0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,
		0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497,
		0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed,
		0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,
		0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594,
		0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3,
		0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,
		0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d,
		0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739,
		0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,
		0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883,
		0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76,
		0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4,
		0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b,
		0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0,
		0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,
		0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651,
		0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85,
		0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12,
		0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9,
		0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7,
		0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,
		0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8,
		0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a,
	]
	te1 = [
		u32(0xa5c66363), 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5,
		0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676,
		0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0,
		0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0,
		0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc,
		0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515,
		0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a,
		0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575,
		0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0,
		0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484,
		0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b,
		0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf,
		0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585,
		0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8,
		0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5,
		0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2,
		0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717,
		0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373,
		0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888,
		0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb,
		0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c,
		0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979,
		0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9,
		0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808,
		0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6,
		0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a,
		0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e,
		0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e,
		0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494,
		0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf,
		0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868,
		0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616,
	]
	te2 = [
		u32(0x63a5c663), 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5,
		0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76,
		0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0,
		0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0,
		0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc,
		0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15,
		0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a,
		0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75,
		0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0,
		0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384,
		0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b,
		0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf,
		0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185,
		0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8,
		0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5,
		0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2,
		0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17,
		0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673,
		0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88,
		0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb,
		0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c,
		0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279,
		0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9,
		0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008,
		0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6,
		0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a,
		0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e,
		0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e,
		0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394,
		0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df,
		0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068,
		0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16,
	]
	te3 = [
		u32(0x6363a5c6), 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491,
		0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec,
		0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb,
		0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b,
		0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83,
		0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a,
		0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f,
		0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea,
		0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b,
		0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713,
		0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6,
		0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85,
		0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411,
		0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b,
		0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1,
		0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf,
		0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e,
		0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6,
		0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b,
		0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad,
		0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8,
		0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2,
		0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049,
		0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810,
		0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197,
		0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f,
		0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c,
		0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927,
		0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733,
		0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5,
		0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0,
		0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c,
	]
)

// Lookup tables for decryption.
const (
	td0 = [
		u32(0x51f4a750), 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393,
		0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f,
		0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6,
		0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844,
		0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4,
		0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94,
		0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a,
		0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c,
		0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a,
		0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051,
		0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff,
		0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb,
		0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e,
		0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a,
		0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16,
		0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8,
		0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34,
		0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120,
		0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0,
		0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef,
		0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4,
		0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5,
		0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b,
		0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6,
		0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0,
		0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f,
		0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f,
		0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713,
		0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c,
		0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86,
		0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541,
		0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742,
	]
	td1 = [
		u32(0x5051f4a7), 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303,
		0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3,
		0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9,
		0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8,
		0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a,
		0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b,
		0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab,
		0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682,
		0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe,
		0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10,
		0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015,
		0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee,
		0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72,
		0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e,
		0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a,
		0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9,
		0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e,
		0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611,
		0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3,
		0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390,
		0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf,
		0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af,
		0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb,
		0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8,
		0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266,
		0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6,
		0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551,
		0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647,
		0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1,
		0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db,
		0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95,
		0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857,
	]
	td2 = [
		u32(0xa75051f4), 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3,
		0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562,
		0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3,
		0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9,
		0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce,
		0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908,
		0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655,
		0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16,
		0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6,
		0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e,
		0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050,
		0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8,
		0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a,
		0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436,
		0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12,
		0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e,
		0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb,
		0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6,
		0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1,
		0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233,
		0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad,
		0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3,
		0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b,
		0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15,
		0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2,
		0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791,
		0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665,
		0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6,
		0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47,
		0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844,
		0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d,
		0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8,
	]
	td3 = [
		u32(0xf4a75051), 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b,
		0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5,
		0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b,
		0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e,
		0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d,
		0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9,
		0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66,
		0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced,
		0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4,
		0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd,
		0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60,
		0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79,
		0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c,
		0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24,
		0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c,
		0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814,
		0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b,
		0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084,
		0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077,
		0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22,
		0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f,
		0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582,
		0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb,
		0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef,
		0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035,
		0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17,
		0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46,
		0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d,
		0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a,
		0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678,
		0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff,
		0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0,
	]
)
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module aes

// new_cipher_generic creates and returns a new cipher.Block
// this is the generiv v version, no arch optimisations
fn new_cipher_generic(key []byte) AesCipher {
	n := key.len + 28
	mut c := AesCipher{
		enc: [u32(0)].repeat(n)
		dec: [u32(0)].repeat(n)
	}
	expand_key_generic(key, mut c.enc, mut c.dec)
	return c
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module cipher

// NOTE: Implement other versions (joe-c)

// xor_bytes xors the bytes in a and b. The destination should have enough
// space, otherwise xor_bytes will panic. Returns the number of bytes xor'd.
pub fn xor_bytes(dst mut []byte, a, b []byte) int {
	mut n := a.len
	if b.len < n {
		n = b.len
	}
	if n == 0 {
		return 0
	}

	safe_xor_bytes(mut dst, a, b, n)

	return n
}

// n needs to be smaller or equal than the length of a and b.
pub fn safe_xor_bytes(dst mut []byte, a, b []byte, n int) {
	for i in 0..n {
		dst[i] = a[i] ^ b[i]
	}
}

// fast_xor_words XORs multiples of 4 or 8 bytes (depending on architecture.)
// The slice arguments a and b are assumed to be of equal length.
pub fn xor_words(dst mut []byte, a, b []byte) {
	safe_xor_bytes(mut dst, a, b, b.len)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Package subtle implements functions that are often useful in cryptographic
// code but require careful thought to use correctly.

module subtle

// NOTE: require unsafe in future

// any_overlap reports whether x and y share memory at any (not necessarily
// corresponding) index. The memory beyond the slice length is ignored.
pub fn any_overlap(x, y []byte) bool {
	// NOTE: Remember to come back to this (joe-c)
	return x.len > 0 && y.len > 0 &&
		// &x.data[0] <= &y.data[y.len-1] &&
		// &y.data[0] <= &x.data[x.len-1]
		&x[0] <= &y[y.len-1] &&
		&y[0] <= &x[x.len-1]
}

// inexact_overlap reports whether x and y share memory at any non-corresponding
// index. The memory beyond the slice length is ignored. Note that x and y can
// have different lengths and still not have any inexact overlap.
//
// inexact_overlap can be used to implement the requirements of the crypto/cipher
// AEAD, Block, BlockMode and Stream interfaces.
pub fn inexact_overlap(x, y []byte) bool {
	if x.len == 0 || y.len == 0 || &x[0] == &y[0] {
		return false
	}
	return any_overlap(x, y)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Package md5 implements the MD5 hash algorithm as defined in RFC 1321.

// MD5 is cryptographically broken and should not be used for secure
// applications.

// Based off:   https://github.com/golang/go/blob/master/src/crypto/md5
// Last commit: https://github.com/golang/go/commit/ed7f323c8f4f6bc61a75146bf34f5b8f73063a17

module md5

import encoding.binary

pub const (
	// The size of an MD5 checksum in bytes.
	size = 16
	// The blocksize of MD5 in bytes.
	block_size = 64
)

const (
	init0 = 0x67452301
	init1 = 0xEFCDAB89
	init2 = 0x98BADCFE
	init3 = 0x10325476
)

// Digest represents the partial evaluation of a checksum.
struct Digest {
mut:
	s   []u32
	x   []byte
	nx  int
	len u64
}

fn (mut d Digest) reset() {
	d.s = [u32(0)].repeat(4)
	d.x = [byte(0)].repeat(block_size)
    d.s[0] = u32(init0)
	d.s[1] = u32(init1)
	d.s[2] = u32(init2)
	d.s[3] = u32(init3)
	d.nx = 0
	d.len = 0
}

// new returns a new Digest (implementing hash.Hash) computing the MD5 checksum.
pub fn new() &Digest {
	mut d := &Digest{}
	d.reset()
	return d
}

pub fn (mut d Digest) write(p_ []byte) int {
	mut p := p_
	nn := p.len
	d.len += u64(nn)
	if d.nx > 0 {
		n := copy(d.x[d.nx..], p)
		d.nx += n
		if d.nx == block_size {
            block(mut d, d.x)
			d.nx = 0
		}
		if n >= p.len {
			p = []
		} else {
			p = p[n..]
		}
	}
	if p.len >= block_size {
		n := p.len &~ (block_size - 1)
		block(mut d, p[..n])
		if n >= p.len {
			p = []
		} else {
			p = p[n..]
		}
	}
	if p.len > 0 {
		d.nx = copy(d.x, p)
	}
	return nn
}

pub fn (d &Digest) sum(b_in []byte) []byte {
	// Make a copy of d so that caller can keep writing and summing.
	mut d0 := *d
	hash := d0.checksum()
	mut b_out := b_in.clone()
	for b in hash {
		b_out << b
	}
	return b_out
}

pub fn (mut d Digest) checksum() []byte {
	// Append 0x80 to the end of the message and then append zeros
	// until the length is a multiple of 56 bytes. Finally append
	// 8 bytes representing the message length in bits.
	//
	// 1 byte end marker :: 0-63 padding bytes :: 8 byte length
	// tmp := [1 + 63 + 8]byte{0x80}
    mut tmp := [byte(0)].repeat(1 + 63 + 8)
	tmp[0] = 0x80
	pad := ((55 - d.len) % 64) // calculate number of padding bytes
	binary.little_endian_put_u64(mut tmp[1+pad..], d.len<<3) // append length in bits
    d.write(tmp[..1+pad+8])

	// The previous write ensures that a whole number of
	// blocks (i.e. a multiple of 64 bytes) have been hashed.
	if d.nx != 0 {
		panic('d.nx != 0')
	}

    digest := [byte(0)].repeat(size)

	binary.little_endian_put_u32(mut digest, d.s[0])
	binary.little_endian_put_u32(mut digest[4..], d.s[1])
	binary.little_endian_put_u32(mut digest[8..], d.s[2])
	binary.little_endian_put_u32(mut digest[12..], d.s[3])
	return digest
}

// sum returns the MD5 checksum of the data.
pub fn sum(data []byte) []byte {
	mut d := new()
	d.write(data)
	return d.checksum()
}

fn block(dig mut Digest, p []byte) {
    // For now just use block_generic until we have specific
	// architecture optimized versions
    block_generic(mut dig, p)
}

pub fn (d &Digest) size() int { return size }

pub fn (d &Digest) block_size() int { return block_size }

pub fn hexhash(s string) string { return sum(s.bytes()).hex() }
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// This is the generic version with no architecture optimizations.
// In its own file so that an architecture
// optimized verision can be substituted

module md5

import math.bits
import encoding.binary

fn block_generic(dig mut Digest, p []byte) {
	// load state
	mut a := dig.s[0]
	mut b := dig.s[1]
	mut c := dig.s[2]
	mut d := dig.s[3]

	for i := 0; i <= p.len-block_size; i += block_size {
		mut q := p[i..]
		q = q[..block_size]
		// save current state
		aa := a
		bb := b
		cc := c
		dd := d

		// load input block
		x0 := binary.little_endian_u32(q[4*0x0..])
		x1 := binary.little_endian_u32(q[4*0x1..])
		x2 := binary.little_endian_u32(q[4*0x2..])
		x3 := binary.little_endian_u32(q[4*0x3..])
		x4 := binary.little_endian_u32(q[4*0x4..])
		x5 := binary.little_endian_u32(q[4*0x5..])
		x6 := binary.little_endian_u32(q[4*0x6..])
		x7 := binary.little_endian_u32(q[4*0x7..])
		x8 := binary.little_endian_u32(q[4*0x8..])
		x9 := binary.little_endian_u32(q[4*0x9..])
		xa := binary.little_endian_u32(q[4*0xa..])
		xb := binary.little_endian_u32(q[4*0xb..])
		xc := binary.little_endian_u32(q[4*0xc..])
		xd := binary.little_endian_u32(q[4*0xd..])
		xe := binary.little_endian_u32(q[4*0xe..])
		xf := binary.little_endian_u32(q[4*0xf..])

		// round 1
		a = b + bits.rotate_left_32((((c^d)&b)^d)+a+x0+u32(0xd76aa478), 7)
		d = a + bits.rotate_left_32((((b^c)&a)^c)+d+x1+u32(0xe8c7b756), 12)
		c = d + bits.rotate_left_32((((a^b)&d)^b)+c+x2+u32(0x242070db), 17)
		b = c + bits.rotate_left_32((((d^a)&c)^a)+b+x3+u32(0xc1bdceee), 22)
		a = b + bits.rotate_left_32((((c^d)&b)^d)+a+x4+u32(0xf57c0faf), 7)
		d = a + bits.rotate_left_32((((b^c)&a)^c)+d+x5+u32(0x4787c62a), 12)
		c = d + bits.rotate_left_32((((a^b)&d)^b)+c+x6+u32(0xa8304613), 17)
		b = c + bits.rotate_left_32((((d^a)&c)^a)+b+x7+u32(0xfd469501), 22)
		a = b + bits.rotate_left_32((((c^d)&b)^d)+a+x8+u32(0x698098d8), 7)
		d = a + bits.rotate_left_32((((b^c)&a)^c)+d+x9+u32(0x8b44f7af), 12)
		c = d + bits.rotate_left_32((((a^b)&d)^b)+c+xa+u32(0xffff5bb1), 17)
		b = c + bits.rotate_left_32((((d^a)&c)^a)+b+xb+u32(0x895cd7be), 22)
		a = b + bits.rotate_left_32((((c^d)&b)^d)+a+xc+u32(0x6b901122), 7)
		d = a + bits.rotate_left_32((((b^c)&a)^c)+d+xd+u32(0xfd987193), 12)
		c = d + bits.rotate_left_32((((a^b)&d)^b)+c+xe+u32(0xa679438e), 17)
		b = c + bits.rotate_left_32((((d^a)&c)^a)+b+xf+u32(0x49b40821), 22)

		// round 2
		a = b + bits.rotate_left_32((((b^c)&d)^c)+a+x1+u32(0xf61e2562), 5)
		d = a + bits.rotate_left_32((((a^b)&c)^b)+d+x6+u32(0xc040b340), 9)
		c = d + bits.rotate_left_32((((d^a)&b)^a)+c+xb+u32(0x265e5a51), 14)
		b = c + bits.rotate_left_32((((c^d)&a)^d)+b+x0+u32(0xe9b6c7aa), 20)
		a = b + bits.rotate_left_32((((b^c)&d)^c)+a+x5+u32(0xd62f105d), 5)
		d = a + bits.rotate_left_32((((a^b)&c)^b)+d+xa+u32(0x02441453), 9)
		c = d + bits.rotate_left_32((((d^a)&b)^a)+c+xf+u32(0xd8a1e681), 14)
		b = c + bits.rotate_left_32((((c^d)&a)^d)+b+x4+u32(0xe7d3fbc8), 20)
		a = b + bits.rotate_left_32((((b^c)&d)^c)+a+x9+u32(0x21e1cde6), 5)
		d = a + bits.rotate_left_32((((a^b)&c)^b)+d+xe+u32(0xc33707d6), 9)
		c = d + bits.rotate_left_32((((d^a)&b)^a)+c+x3+u32(0xf4d50d87), 14)
		b = c + bits.rotate_left_32((((c^d)&a)^d)+b+x8+u32(0x455a14ed), 20)
		a = b + bits.rotate_left_32((((b^c)&d)^c)+a+xd+u32(0xa9e3e905), 5)
		d = a + bits.rotate_left_32((((a^b)&c)^b)+d+x2+u32(0xfcefa3f8), 9)
		c = d + bits.rotate_left_32((((d^a)&b)^a)+c+x7+u32(0x676f02d9), 14)
		b = c + bits.rotate_left_32((((c^d)&a)^d)+b+xc+u32(0x8d2a4c8a), 20)

		// round 3
		a = b + bits.rotate_left_32((b^c^d)+a+x5+u32(0xfffa3942), 4)
		d = a + bits.rotate_left_32((a^b^c)+d+x8+u32(0x8771f681), 11)
		c = d + bits.rotate_left_32((d^a^b)+c+xb+u32(0x6d9d6122), 16)
		b = c + bits.rotate_left_32((c^d^a)+b+xe+u32(0xfde5380c), 23)
		a = b + bits.rotate_left_32((b^c^d)+a+x1+u32(0xa4beea44), 4)
		d = a + bits.rotate_left_32((a^b^c)+d+x4+u32(0x4bdecfa9), 11)
		c = d + bits.rotate_left_32((d^a^b)+c+x7+u32(0xf6bb4b60), 16)
		b = c + bits.rotate_left_32((c^d^a)+b+xa+u32(0xbebfbc70), 23)
		a = b + bits.rotate_left_32((b^c^d)+a+xd+u32(0x289b7ec6), 4)
		d = a + bits.rotate_left_32((a^b^c)+d+x0+u32(0xeaa127fa), 11)
		c = d + bits.rotate_left_32((d^a^b)+c+x3+u32(0xd4ef3085), 16)
		b = c + bits.rotate_left_32((c^d^a)+b+x6+u32(0x04881d05), 23)
		a = b + bits.rotate_left_32((b^c^d)+a+x9+u32(0xd9d4d039), 4)
		d = a + bits.rotate_left_32((a^b^c)+d+xc+u32(0xe6db99e5), 11)
		c = d + bits.rotate_left_32((d^a^b)+c+xf+u32(0x1fa27cf8), 16)
		b = c + bits.rotate_left_32((c^d^a)+b+x2+u32(0xc4ac5665), 23)

		// round 4
		a = b + bits.rotate_left_32((c^(b|~d))+a+x0+u32(0xf4292244), 6)
		d = a + bits.rotate_left_32((b^(a|~c))+d+x7+u32(0x432aff97), 10)
		c = d + bits.rotate_left_32((a^(d|~b))+c+xe+u32(0xab9423a7), 15)
		b = c + bits.rotate_left_32((d^(c|~a))+b+x5+u32(0xfc93a039), 21)
		a = b + bits.rotate_left_32((c^(b|~d))+a+xc+u32(0x655b59c3), 6)
		d = a + bits.rotate_left_32((b^(a|~c))+d+x3+u32(0x8f0ccc92), 10)
		c = d + bits.rotate_left_32((a^(d|~b))+c+xa+u32(0xffeff47d), 15)
		b = c + bits.rotate_left_32((d^(c|~a))+b+x1+u32(0x85845dd1), 21)
		a = b + bits.rotate_left_32((c^(b|~d))+a+x8+u32(0x6fa87e4f), 6)
		d = a + bits.rotate_left_32((b^(a|~c))+d+xf+u32(0xfe2ce6e0), 10)
		c = d + bits.rotate_left_32((a^(d|~b))+c+x6+u32(0xa3014314), 15)
		b = c + bits.rotate_left_32((d^(c|~a))+b+xd+u32(0x4e0811a1), 21)
		a = b + bits.rotate_left_32((c^(b|~d))+a+x4+u32(0xf7537e82), 6)
		d = a + bits.rotate_left_32((b^(a|~c))+d+xb+u32(0xbd3af235), 10)
		c = d + bits.rotate_left_32((a^(d|~b))+c+x2+u32(0x2ad7d2bb), 15)
		b = c + bits.rotate_left_32((d^(c|~a))+b+x9+u32(0xeb86d391), 21)

		// add saved state
		a += aa
		b += bb
		c += cc
		d += dd
	}

	// save state
	dig.s[0] = a
	dig.s[1] = b
	dig.s[2] = c
	dig.s[3] = d
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

import crypto.md5

fn test_crypto_md5() {	 
	assert md5.sum('this is a md5 checksum.'.bytes()).hex() == '6fb421ff99036547655984da12973431'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module rand

const (
	read_error = error('crypto.rand.read() error reading random bytes')
)

// NOTE: temp until we have []bytes(buff)
fn c_array_to_bytes_tmp(len int, buffer voidptr) []byte {

	mut arr := []byte{len:len, cap:1}
	arr.data = buffer
	/*

	arr = array {
		len: len
		cap: 1
		element_size: 1
		data: buffer
	}
	*/
	return arr
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module rand

#include <Security/SecRandom.h>

#flag darwin -framework Security

fn C.SecRandomCopyBytes() int

pub fn read(bytes_needed int) ?[]byte {
	mut buffer := malloc(bytes_needed)
	status := C.SecRandomCopyBytes(0, bytes_needed, buffer)
	if status != 0 {
		return read_error
	}
	return c_array_to_bytes_tmp(bytes_needed, buffer)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module rand

import math

#include <sys/syscall.h>

const (
	read_batch_size = 256
)

pub fn read(bytes_needed int) ?[]byte {	
	buffer := malloc(bytes_needed)
	mut bytes_read := 0
	// getrandom syscall wont block if requesting <= 256 bytes
	if bytes_needed > read_batch_size {
		no_batches := int(math.floor(f64(bytes_needed/read_batch_size)))
		for i:=0; i < no_batches; i++ {
			if getrandom(read_batch_size, buffer+bytes_read) == -1 {
				return read_error
			}
			bytes_read += read_batch_size
		}
	}
	if getrandom(bytes_needed-bytes_read, buffer+bytes_read) == -1 {
		return read_error
	}
	
	return c_array_to_bytes_tmp(bytes_needed, buffer)
}

fn getrandom(bytes_needed int, buffer voidptr) int {
	if bytes_needed > read_batch_size {
		panic('getrandom() dont request more than $read_batch_size bytes at once.')
	}
	return C.syscall(C.SYS_getrandom, buffer, bytes_needed, 0)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module rand

import math

#include <sys/random.h>

fn C.getrandom(p byteptr, n size_t, flags u32) int

const (
	read_batch_size = 256
)

pub fn read(bytes_needed int) ?[]byte {	
	mut buffer := &byte(0)
	unsafe {
	   buffer = malloc(bytes_needed)
	}
	mut bytes_read := 0
	// getrandom syscall wont block if requesting <= 256 bytes
	if bytes_needed > read_batch_size {
		no_batches := int(math.floor(f64(bytes_needed/read_batch_size)))
		for i:=0; i<no_batches; i++ {
			if v_getrandom(read_batch_size, buffer+bytes_read) == -1 {
				return read_error
			}
			bytes_read += read_batch_size
		}
	}
	if v_getrandom(bytes_needed-bytes_read, buffer+bytes_read) == -1 {
		return read_error
	}
	
	return c_array_to_bytes_tmp(bytes_needed, buffer)
}

fn v_getrandom(bytes_needed int, buffer voidptr) int {
	if bytes_needed > read_batch_size {
		panic('getrandom() dont request more than $read_batch_size bytes at once.')
	}
	return C.getrandom(buffer, bytes_needed, 0)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

import crypto.rand

fn test_crypto_rand_read() {
	no_bytes := 100
	max_percentage_diff := 20

	r1 := rand.read(no_bytes) or {
		assert false
		return
	}
	assert r1.len == no_bytes
	r2 := rand.read(no_bytes) or {
		assert false
		return
	}
	assert r2.len == no_bytes

	mut difference := 0
	for i, _ in r1 {
		difference += if r1[i] == r2[i] {0} else {1}
	}

	diff_percentage := f32(100) - (f32(difference)/f32(no_bytes)*100)

	assert diff_percentage <= max_percentage_diff
}

fn test_crypto_rand_int_u64() {
	max := u64(160)
	mut unique := []int{}
	for _ in 0..80 {
		r := rand.int_u64(max) or {
			assert false
			return
		}
		if r >= max {
			assert false
			return
		}
		n := int(r)
		if n !in unique {
			unique << n
		}
	}
	assert unique.len >= 40
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module rand

#flag windows -Llibraries/bcrypt
#flag windows -lbcrypt
#include <bcrypt.h>

const (
	status_success                  = 0x00000000
	bcrypt_use_system_preferred_rng = 0x00000002
)

pub fn read(bytes_needed int) ?[]byte {
	mut buffer := malloc(bytes_needed)
	// use bcrypt_use_system_preferred_rng because we passed null as algo
	status := C.BCryptGenRandom(0, buffer, bytes_needed, bcrypt_use_system_preferred_rng)
	if status != status_success {
		return read_error
	}
	return c_array_to_bytes_tmp(bytes_needed, buffer)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module rand

import math.bits
import encoding.binary

pub fn int_u64(max u64) ?u64 {
	bitlen := bits.len_64(max)
	if bitlen == 0 {
		return u64(0)
	}
	k := (bitlen + 7) / 8
	mut b := u64(bitlen % 8)
	if b == u64(0) {
		b = u64(8)
	}
	mut n := u64(0)
	for {
		mut bytes := read(k) or {
			return error(err)
		}
		bytes[0] &= byte(int(u64(1)<<b) - 1)
		x := bytes_to_u64(bytes)
		n = x[0]
		// NOTE: maybe until we have bigint could do it another way?
		// if x.len > 1 {
		// 	n = u64(u32(x[1])<<u32(32)) | n
		// }
		if n < max {
			return n
		}
	}
	return n
}

fn bytes_to_u64(b []byte) []u64 {
	ws := 64/8
	mut z := [u64(0)].repeat((b.len + ws - 1) / ws)
	mut i := b.len
	for k := 0; i >= ws; k++ {
		z[k] = binary.big_endian_u64(b[i-ws..i])
		i -= ws
	}
	if i > 0 {
		mut d := u64(0)
		for s := u64(0); i > 0; s += u64(8) {
			d |= u64(b[i-1]) << s
			i--
		}
		z[z.len-1] = d
	}
	return z
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Package rc4 implements RC4 encryption, as defined in Bruce Schneier's
// Applied Cryptography.
//
// RC4 is cryptographically broken and should not be used for secure
// applications.

// Based off:   https://github.com/golang/go/blob/master/src/crypto/rc4
// Last commit: https://github.com/golang/go/commit/b35dacaac57b039205d9b07ea24098e2c3fcb12e

module rc4

import crypto.internal.subtle

// A Cipher is an instance of RC4 using a particular key.
struct Cipher {
mut:
	s []u32
	i byte
	j byte
}

// new_cipher creates and returns a new Cipher. The key argument should be the
// RC4 key, at least 1 byte and at most 256 bytes.
pub fn new_cipher(key []byte) ?Cipher {
	if key.len < 1 || key.len > 256 {
		return error('crypto.rc4: invalid key size ' + key.len.str())
	}
	mut c := Cipher{
		s: [u32(0)].repeat(256)
	}
	for i in 0..256 {
		c.s[i] = u32(i)
	}
	mut j := byte(0)
	for i in 0..256 {
		j += byte(c.s[i]) + key[i%key.len]
		tmp := c.s[i]
		c.s[i] = c.s[j]
		c.s[j] = tmp
	}
	return c
}

// reset zeros the key data and makes the Cipher unusable.good to com
//
// Deprecated: Reset can't guarantee that the key will be entirely removed from
// the process's memory.
pub fn (mut c Cipher) reset() {
	for i in c.s {
		c.s[i] = 0
	}
	c.i = 0
	c.j = 0
}

// xor_key_stream sets dst to the result of XORing src with the key stream.
// Dst and src must overlap entirely or not at all.
pub fn (mut c Cipher) xor_key_stream(dst mut []byte, src []byte) {
	if src.len == 0 {
		return
	}
	if subtle.inexact_overlap(dst, src) {
		panic('crypto.rc4: invalid buffer overlap')
	}
	mut i := c.i
	mut j := c.j
	for k, v in src {
		i += byte(1)
		x := c.s[i]
		j += byte(x)
		y := c.s[j]
		c.s[i] = y
		c.s[j] = x
		dst[k] = v ^ byte(c.s[byte(x+y)])
	}
	c.i = i
	c.j = j
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

import crypto.rc4

fn test_crypto_rc4() {	 
	key := 'tthisisourrc4key'.bytes()
	
	mut c := rc4.new_cipher(key) or {
		println(err)
		return
	}
	
	mut src := 'toencrypt'.bytes()
	
	// src & dst same, encrypt in place
	c.xor_key_stream(mut src, src) // encrypt data
	
	c.reset()

	assert src.hex() == '189a39a91aea8afa65'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.

// SHA-1 is cryptographically broken and should not be used for secure
// applications.

// Based off:   https://github.com/golang/go/blob/master/src/crypto/sha1
// Last commit: https://github.com/golang/go/commit/3ce865d7a0b88714cc433454ae2370a105210c01

module sha1

import encoding.binary

pub const(
	// The size of a SHA-1 checksum in bytes.
	size     = 20
	// The blocksize of SHA-1 in bytes.
	block_size = 64
)

const (
	chunk = 64
	init0 = 0x67452301
	init1 = 0xEFCDAB89
	init2 = 0x98BADCFE
	init3 = 0x10325476
	init4 = 0xC3D2E1F0
)

// digest represents the partial evaluation of a checksum.
struct Digest {
mut:
	h   []u32
	x   []byte
	nx  int
	len u64
}

fn (mut d Digest) reset() {
	d.x = [byte(0)].repeat(chunk)
	d.h = [u32(0)].repeat(5)
	d.h[0] = u32(init0)
	d.h[1] = u32(init1)
	d.h[2] = u32(init2)
	d.h[3] = u32(init3)
	d.h[4] = u32(init4)
	d.nx = 0
	d.len = 0
}

// new returns a new Digest (implementing hash.Hash) computing the SHA1 checksum.
pub fn new() &Digest {
	mut d := &Digest{}
	d.reset()
	return d
}

pub fn (mut d Digest) write(p_ []byte) int {
	mut p := p_
	nn := p.len
	d.len += u64(nn)

	if d.nx > 0 {
		n := copy(d.x[d.nx..], p)
		d.nx += n
		if d.nx == chunk {
			block(d, d.x)
			d.nx = 0
		}
		if n >= p.len {
			p = []
		} else {
			p = p[n..]
		}
	}
	if p.len >= chunk {
		n := p.len &~ (chunk - 1)
		block(d, p[..n])
		if n >= p.len {
			p = []
		} else {
			p = p[n..]
		}
	}
	if p.len > 0 {
		d.nx = copy(d.x, p)
	}
	return nn
}

pub fn (d &Digest) sum(b_in []byte) []byte {
	// Make a copy of d so that caller can keep writing and summing.
	mut d0 := *d
	hash := d0.checksum()
	mut b_out := b_in.clone()
	for b in hash {
		b_out << b
	}
	return b_out
}

fn (mut d Digest) checksum() []byte {
	mut len := d.len
	// Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.
	mut tmp := [byte(0)].repeat(64)

	tmp[0] = 0x80

	if int(len)%64 < 56 {
		d.write(tmp[..56-int(len)%64])
	} else {
		d.write(tmp[..64+56-int(len)%64])
	}

	// Length in bits.
	len <<= 3
	binary.big_endian_put_u64(mut tmp, len)
	d.write(tmp[..8])

	mut digest := [byte(0)].repeat(size)

	binary.big_endian_put_u32(mut digest, d.h[0])
	binary.big_endian_put_u32(mut digest[4..], d.h[1])
	binary.big_endian_put_u32(mut digest[8..], d.h[2])
	binary.big_endian_put_u32(mut digest[12..], d.h[3])
	binary.big_endian_put_u32(mut digest[16..], d.h[4])

	return digest
}

// Sum returns the SHA-1 checksum of the data.
pub fn sum(data []byte) []byte {
	mut d := new()
	d.write(data)
	return d.checksum()
}

fn block(dig &Digest, p []byte) {
	// For now just use block_generic until we have specific
	// architecture optimized versions
	block_generic(mut dig, p)
}

pub fn (d &Digest) size() int { return size }

pub fn (d &Digest) block_size() int { return block_size }

pub fn hexhash(s string) string { return sum(s.bytes()).hex() }
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// This is the generic version with no architecture optimizations.
// In its own file so that an architecture
// optimized verision can be substituted

module sha1

import math.bits

const (
	_k0 = 0x5A827999
	_k1 = 0x6ED9EBA1
	_k2 = 0x8F1BBCDC
	_k3 = 0xCA62C1D6
)

fn block_generic(dig mut Digest, p_ []byte) {
	mut p := p_
	mut w := [u32(0)].repeat(16)
	mut h0 := dig.h[0]
	mut h1 := dig.h[1]
	mut h2 := dig.h[2]
	mut h3 := dig.h[3]
	mut h4 := dig.h[4]
	for p.len >= chunk {
		// Can interlace the computation of w with the
		// rounds below if needed for speed.
		for i in 0..16 {
			j := i * 4
			w[i] = u32(p[j]<<24) | u32(p[j+1]<<16) | u32(p[j+2]<<8) | u32(p[j+3])
		}

		mut a := h0
		mut b := h1
		mut c := h2
		mut d := h3
		mut e := h4

		// Each of the four 20-iteration rounds
		// differs only in the computation of f and
		// the choice of K (_k0, _k1, etc).
		mut i := 0
		for i < 16 {
			f := b&c | (~b)&d
			t := bits.rotate_left_32(a, 5) + f + e + w[i&0xf] + u32(_k0)
			e = d
			d = c
			c = bits.rotate_left_32(b, 30)
			b = a
			a = t
			i++
		}
		for i < 20 {
			tmp := w[(i-3)&0xf] ^ w[(i-8)&0xf] ^ w[(i-14)&0xf] ^ w[(i)&0xf]
			w[i&0xf] = (tmp<<1) | (tmp>>(32-1))
			f := b&c | (~b)&d
			t := bits.rotate_left_32(a, 5) + f + e + w[i&0xf] + u32(_k0)
			e = d
			d = c
			c = bits.rotate_left_32(b, 30)
			b = a
			a = t
			i++
		}
		for i < 40 {
			tmp := w[(i-3)&0xf] ^ w[(i-8)&0xf] ^ w[(i-14)&0xf] ^ w[(i)&0xf]
			w[i&0xf] = (tmp<<1) | (tmp>>(32-1))
			f := b ^ c ^ d
			t := bits.rotate_left_32(a, 5) + f + e + w[i&0xf] + u32(_k1)
			e = d
			d = c
			c = bits.rotate_left_32(b, 30)
			b = a
			a = t
			i++
		}
		for i < 60 {
			tmp := w[(i-3)&0xf] ^ w[(i-8)&0xf] ^ w[(i-14)&0xf] ^ w[(i)&0xf]
			w[i&0xf] = (tmp<<1) | (tmp>>(32-1))
			f := ((b | c) & d) | (b & c)
			t := bits.rotate_left_32(a, 5) + f + e + w[i&0xf] + u32(_k2)
			e = d
			d = c
			c = bits.rotate_left_32(b, 30)
			b = a
			a = t
			i++
		}
		for i < 80 {
			tmp := w[(i-3)&0xf] ^ w[(i-8)&0xf] ^ w[(i-14)&0xf] ^ w[(i)&0xf]
			w[i&0xf] = (tmp<<1) | (tmp>>(32-1))
			f := b ^ c ^ d
			t := bits.rotate_left_32(a, 5) + f + e + w[i&0xf] + u32(_k3)
			e = d
			d = c
			c = bits.rotate_left_32(b, 30)
			b = a
			a = t
			i++
		}

		h0 += a
		h1 += b
		h2 += c
		h3 += d
		h4 += e

		if chunk >= p.len {
			p = []
		} else {
			p = p[chunk..]
		}
		
	}

	dig.h[0] = h0
	dig.h[1] = h1
	dig.h[2] = h2
	dig.h[3] = h3
	dig.h[4] = h4
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

import crypto.sha1

fn test_crypto_sha1() {	 
	assert sha1.sum('This is a sha1 checksum.'.bytes()).hex() == 'e100d74442faa5dcd59463b808983c810a8eb5a1'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Package sha256 implements the SHA224 and SHA256 hash algorithms as defined
// in FIPS 180-4.

// Based off:   https://github.com/golang/go/tree/master/src/crypto/sha256
// Last commit: https://github.com/golang/go/commit/3ce865d7a0b88714cc433454ae2370a105210c01

module sha256

import encoding.binary

pub const (
	// The size of a SHA256 checksum in bytes.
	size = 32
	// The size of a SHA224 checksum in bytes.
	size224 = 28
	// The blocksize of SHA256 and SHA224 in bytes.
	block_size = 64
)

const (
	chunk     = 64
	init0     = 0x6A09E667
	init1     = 0xBB67AE85
	init2     = 0x3C6EF372
	init3     = 0xA54FF53A
	init4     = 0x510E527F
	init5     = 0x9B05688C
	init6     = 0x1F83D9AB
	init7     = 0x5BE0CD19
	init0_224 = 0xC1059ED8
	init1_224 = 0x367CD507
	init2_224 = 0x3070DD17
	init3_224 = 0xF70E5939
	init4_224 = 0xFFC00B31
	init5_224 = 0x68581511
	init6_224 = 0x64F98FA7
	init7_224 = 0xBEFA4FA4
)

// digest represents the partial evaluation of a checksum.
struct Digest {
mut:
	h     []u32
	x     []byte
	nx    int
	len   u64
	is224 bool // mark if this digest is SHA-224
}

fn (mut d Digest) reset() {
	d.h = [u32(0)].repeat(8)
	d.x = [byte(0)].repeat(chunk)
	if !d.is224 {
		d.h[0] = u32(init0)
		d.h[1] = u32(init1)
		d.h[2] = u32(init2)
		d.h[3] = u32(init3)
		d.h[4] = u32(init4)
		d.h[5] = u32(init5)
		d.h[6] = u32(init6)
		d.h[7] = u32(init7)
	} else {
		d.h[0] = u32(init0_224)
		d.h[1] = u32(init1_224)
		d.h[2] = u32(init2_224)
		d.h[3] = u32(init3_224)
		d.h[4] = u32(init4_224)
		d.h[5] = u32(init5_224)
		d.h[6] = u32(init6_224)
		d.h[7] = u32(init7_224)
	}
	d.nx = 0
	d.len = 0
}

// new returns a new Digest (implementing hash.Hash) computing the SHA256 checksum.
pub fn new() &Digest {
	mut d := &Digest{}
	d.reset()
	return d
}

// new224 returns a new Digest (implementing hash.Hash) computing the SHA224 checksum.
pub fn new224() &Digest {
	mut d := &Digest{}
	d.is224 = true
	d.reset()
	return d
}

fn (mut d Digest) write(p_ []byte) int {
	mut p := p_
	nn := p.len
	d.len += u64(nn)
	if d.nx > 0 {
		n := copy(d.x[d.nx..], p)
		d.nx += n
		if d.nx == chunk {
			block(mut d, d.x)
			d.nx = 0
		}
		if n >= p.len {
			p = []
		} else {
			p = p[n..]
		}
	}
	if p.len >= chunk {
		n := p.len &~ (chunk - 1)
		block(mut d, p[..n])
		if n >= p.len {
			p = []
		} else {
			p = p[n..]
		}
	}
	if p.len > 0 {
		d.nx = copy(d.x, p)
	}
	return nn
}

fn (d &Digest) sum(b_in []byte) []byte {
	// Make a copy of d so that caller can keep writing and summing.
	mut d0 := *d
	hash := d0.checksum()
	mut b_out := b_in.clone()
	if d0.is224 {
		for b in hash[..size224] {
			b_out << b
		}
	} else {
		for b in hash {
			b_out << b
		}
	}
	return b_out
}

fn (mut d Digest) checksum() []byte {
	mut len := d.len
	// Padding. Add a 1 bit and 0 bits until 56 bytes mod 64.
	mut tmp := [byte(0)].repeat(64)
	tmp[0] = 0x80
	if int(len)%64 < 56 {
		d.write(tmp[..56-int(len)%64])
	} else {
		d.write(tmp[..64+56-int(len)%64])
	}

	// Length in bits.
	len <<= u64(3)
	binary.big_endian_put_u64(mut tmp, len)
	d.write(tmp[..8])

	if d.nx != 0 {
		panic('d.nx != 0')
	}

	digest := [byte(0)].repeat(size)

	binary.big_endian_put_u32(mut digest, d.h[0])
	binary.big_endian_put_u32(mut digest[4..], d.h[1])
	binary.big_endian_put_u32(mut digest[8..], d.h[2])
	binary.big_endian_put_u32(mut digest[12..], d.h[3])
	binary.big_endian_put_u32(mut digest[16..], d.h[4])
	binary.big_endian_put_u32(mut digest[20..], d.h[5])
	binary.big_endian_put_u32(mut digest[24..], d.h[6])
	if !d.is224 {
		binary.big_endian_put_u32(mut digest[28..], d.h[7])
	}

	return digest
}

// sum256 returns the SHA256 checksum of the data.
pub fn sum(data []byte) []byte {
	return sum256(data)
}

// sum256 returns the SHA256 checksum of the data.
pub fn sum256(data []byte) []byte {
	mut d := new()
	d.write(data)
	return d.checksum()
}

// sum224 returns the SHA224 checksum of the data.
pub fn sum224(data []byte) []byte {
	mut d := new224()
	d.write(data)
	sum := d.checksum()
	sum224 := [byte(0)].repeat(size224)
	copy(sum224, sum[..size224])
	return sum224
}

fn block(dig mut Digest, p []byte) {
	// For now just use block_generic until we have specific
	// architecture optimized versions
	block_generic(mut dig, p)
}

pub fn (d &Digest) size() int {
	if !d.is224 {
		return size
	}
	return size224
}

pub fn (d &Digest) block_size() int { return block_size }

pub fn hexhash(s string) string { return sum256(s.bytes()).hex() }
pub fn hexhash_224(s string) string { return sum224(s.bytes()).hex() }
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// SHA256 block step.
// This is the generic version with no architecture optimizations.
// In its own file so that an architecture
// optimized verision can be substituted

module sha256

import math.bits

const (
	_k = [
		0x428a2f98,
		0x71374491,
		0xb5c0fbcf,
		0xe9b5dba5,
		0x3956c25b,
		0x59f111f1,
		0x923f82a4,
		0xab1c5ed5,
		0xd807aa98,
		0x12835b01,
		0x243185be,
		0x550c7dc3,
		0x72be5d74,
		0x80deb1fe,
		0x9bdc06a7,
		0xc19bf174,
		0xe49b69c1,
		0xefbe4786,
		0x0fc19dc6,
		0x240ca1cc,
		0x2de92c6f,
		0x4a7484aa,
		0x5cb0a9dc,
		0x76f988da,
		0x983e5152,
		0xa831c66d,
		0xb00327c8,
		0xbf597fc7,
		0xc6e00bf3,
		0xd5a79147,
		0x06ca6351,
		0x14292967,
		0x27b70a85,
		0x2e1b2138,
		0x4d2c6dfc,
		0x53380d13,
		0x650a7354,
		0x766a0abb,
		0x81c2c92e,
		0x92722c85,
		0xa2bfe8a1,
		0xa81a664b,
		0xc24b8b70,
		0xc76c51a3,
		0xd192e819,
		0xd6990624,
		0xf40e3585,
		0x106aa070,
		0x19a4c116,
		0x1e376c08,
		0x2748774c,
		0x34b0bcb5,
		0x391c0cb3,
		0x4ed8aa4a,
		0x5b9cca4f,
		0x682e6ff3,
		0x748f82ee,
		0x78a5636f,
		0x84c87814,
		0x8cc70208,
		0x90befffa,
		0xa4506ceb,
		0xbef9a3f7,
		0xc67178f2,
	]
)

fn block_generic(dig mut Digest, p_ []byte) {
	mut p := p_

	mut w := [u32(0)].repeat(64)
	
	mut h0 := dig.h[0]
	mut h1 := dig.h[1]
	mut h2 := dig.h[2]
	mut h3 := dig.h[3]
	mut h4 := dig.h[4]
	mut h5 := dig.h[5]
	mut h6 := dig.h[6]
	mut h7 := dig.h[7]

	for p.len >= chunk {
		// Can interlace the computation of w with the
		// rounds below if needed for speed.
		for i in 0..16 {
			j := i * 4
			w[i] = u32(p[j]<<24) | u32(p[j+1]<<16) | u32(p[j+2]<<8) | u32(p[j+3])
		}
		for i := 16; i < 64; i++ {
			v1 := w[i-2]
			t1 := (bits.rotate_left_32(v1, -17)) ^ (bits.rotate_left_32(v1, -19)) ^ (v1 >> 10)
			v2 := w[i-15]
			t2 := (bits.rotate_left_32(v2, -7)) ^ (bits.rotate_left_32(v2, -18)) ^ (v2 >> 3)
			w[i] = t1 + w[i-7] + t2 + w[i-16]
		}

		mut a := h0
		mut b := h1
		mut c := h2
		mut d := h3
		mut e := h4
		mut f := h5
		mut g := h6
		mut h := h7

		for i in 0..64 {
			t1 := h + ((bits.rotate_left_32(e, -6)) ^ (bits.rotate_left_32(e, -11)) ^ (bits.rotate_left_32(e, -25))) + ((e & f) ^ (~e & g)) + u32(_k[i]) + w[i]
			t2 := ((bits.rotate_left_32(a, -2)) ^ (bits.rotate_left_32(a, -13)) ^ (bits.rotate_left_32(a, -22))) + ((a & b) ^ (a & c) ^ (b & c))

			h = g
			g = f
			f = e
			e = d + t1
			d = c
			c = b
			b = a
			a = t1 + t2
		}

		h0 += a
		h1 += b
		h2 += c
		h3 += d
		h4 += e
		h5 += f
		h6 += g
		h7 += h

		if chunk >= p.len {
			p = []
		} else {
			p = p[chunk..]
		}
	}

	dig.h[0] = h0
	dig.h[1] = h1
	dig.h[2] = h2
	dig.h[3] = h3
	dig.h[4] = h4
	dig.h[5] = h5
	dig.h[6] = h6
	dig.h[7] = h7
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

import crypto.sha256

fn test_crypto_sha256() {
	assert sha256.sum('This is a sha256 checksum.'.bytes()).hex() ==
		'dc7163299659529eae29683eb1ffec50d6c8fc7275ecb10c145fde0e125b8727'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
// Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256
// hash algorithms as defined in FIPS 180-4.
// Based off:   https://github.com/golang/go/tree/master/src/crypto/sha512
// Last commit: https://github.com/golang/go/commit/3ce865d7a0b88714cc433454ae2370a105210c01
module sha512

import crypto
import encoding.binary

pub const (
// size is the size, in bytes, of a SHA-512 checksum.
	size = 64
	// size224 is the size, in bytes, of a SHA-512/224 checksum.
	size224 = 28
	// size256 is the size, in bytes, of a SHA-512/256 checksum.
	size256 = 32
	// size384 is the size, in bytes, of a SHA-384 checksum.
	size384 = 48
	// block_size is the block size, in bytes, of the SHA-512/224,
	// SHA-512/256, SHA-384 and SHA-512 hash functions.
	block_size = 128
)

const (
	chunk = 128
	init0 = u64(0x6a09e667f3bcc908)
	init1 = u64(0xbb67ae8584caa73b)
	init2 = u64(0x3c6ef372fe94f82b)
	init3 = u64(0xa54ff53a5f1d36f1)
	init4 = u64(0x510e527fade682d1)
	init5 = u64(0x9b05688c2b3e6c1f)
	init6 = u64(0x1f83d9abfb41bd6b)
	init7 = u64(0x5be0cd19137e2179)
	init0_224 = u64(0x8c3d37c819544da2)
	init1_224 = u64(0x73e1996689dcd4d6)
	init2_224 = u64(0x1dfab7ae32ff9c82)
	init3_224 = u64(0x679dd514582f9fcf)
	init4_224 = u64(0x0f6d2b697bd44da8)
	init5_224 = u64(0x77e36f7304c48942)
	init6_224 = u64(0x3f9d85a86a1d36c8)
	init7_224 = u64(0x1112e6ad91d692a1)
	init0_256 = u64(0x22312194fc2bf72c)
	init1_256 = u64(0x9f555fa3c84c64c2)
	init2_256 = u64(0x2393b86b6f53b151)
	init3_256 = u64(0x963877195940eabd)
	init4_256 = u64(0x96283ee2a88effe3)
	init5_256 = u64(0xbe5e1e2553863992)
	init6_256 = u64(0x2b0199fc2c85b8aa)
	init7_256 = u64(0x0eb72ddc81c52ca2)
	init0_384 = u64(0xcbbb9d5dc1059ed8)
	init1_384 = u64(0x629a292a367cd507)
	init2_384 = u64(0x9159015a3070dd17)
	init3_384 = u64(0x152fecd8f70e5939)
	init4_384 = u64(0x67332667ffc00b31)
	init5_384 = u64(0x8eb44a8768581511)
	init6_384 = u64(0xdb0c2e0d64f98fa7)
	init7_384 = u64(0x47b5481dbefa4fa4)
)
// digest represents the partial evaluation of a checksum.
struct Digest {
mut:
	h        []u64
	x        []byte
	nx       int
	len      u64
	function crypto.Hash
}

fn (mut d Digest) reset() {
	d.h = [u64(0)].repeat(8)
	d.x = [byte(0)].repeat(chunk)
	match d.function {
		.sha384 {
			d.h[0] = init0_384
			d.h[1] = init1_384
			d.h[2] = init2_384
			d.h[3] = init3_384
			d.h[4] = init4_384
			d.h[5] = init5_384
			d.h[6] = init6_384
			d.h[7] = init7_384
		}
		.sha512_224 {
			d.h[0] = init0_224
			d.h[1] = init1_224
			d.h[2] = init2_224
			d.h[3] = init3_224
			d.h[4] = init4_224
			d.h[5] = init5_224
			d.h[6] = init6_224
			d.h[7] = init7_224
		}
		.sha512_256 {
			d.h[0] = init0_256
			d.h[1] = init1_256
			d.h[2] = init2_256
			d.h[3] = init3_256
			d.h[4] = init4_256
			d.h[5] = init5_256
			d.h[6] = init6_256
			d.h[7] = init7_256
		}
		else {
			d.h[0] = init0
			d.h[1] = init1
			d.h[2] = init2
			d.h[3] = init3
			d.h[4] = init4
			d.h[5] = init5
			d.h[6] = init6
			d.h[7] = init7
		}}
	d.nx = 0
	d.len = 0
}

// internal
fn new_digest(hash crypto.Hash) &Digest {
	mut d := &Digest{
		function: hash
	}
	d.reset()
	return d
}

// new returns a new Digest (implementing hash.Hash) computing the SHA-512 checksum.
pub fn new() &Digest {
	return new_digest(.sha512)
}

// new512_224 returns a new Digest (implementing hash.Hash) computing the SHA-512/224 checksum.
fn new512_224() &Digest {
	return new_digest(.sha512_224)
}

// new512_256 returns a new Digest (implementing hash.Hash) computing the SHA-512/256 checksum.
fn new512_256() &Digest {
	return new_digest(.sha512_256)
}

// new384 returns a new Digest (implementing hash.Hash) computing the SHA-384 checksum.
fn new384() &Digest {
	return new_digest(.sha384)
}

fn (mut d Digest) write(p_ []byte) int {
	mut p := p_
	nn := p.len
	d.len += u64(nn)
	if d.nx > 0 {
		n := copy(d.x[d.nx..], p)
		d.nx += n
		if d.nx == chunk{
			block(mut d, d.x)
			d.nx = 0
		}
		if n >= p.len {
			p = []
		}
		else {
			p = p[n..]
		}
	}
	if p.len >= chunk{
		n := p.len & ~(chunk- 1)
		block(mut d, p[..n])
		if n >= p.len {
			p = []
		}
		else {
			p = p[n..]
		}
	}
	if p.len > 0 {
		d.nx = copy(d.x, p)
	}
	return nn
}

fn (d &Digest) sum(b_in []byte) []byte {
	// Make a copy of d so that caller can keep writing and summing.
	mut d0 := *d
	hash := d0.checksum()
	mut b_out := b_in.clone()
	match d0.function {
		.sha384 {
			for b in hash[..size384] {
				b_out << b
			}
		}
		.sha512_224 {
			for b in hash[..size224] {
				b_out << b
			}
		}
		.sha512_256 {
			for b in hash[..size256] {
				b_out << b
			}
		}
		else {
			for b in hash {
				b_out << b
			}
		}}
	return b_out
}

fn (mut d Digest) checksum() []byte {
	// Padding. Add a 1 bit and 0 bits until 112 bytes mod 128.
	mut len := d.len
	mut tmp := [byte(0)].repeat(128)
	tmp[0] = 0x80
	if int(len) % 128 < 112 {
		d.write(tmp[..112 - int(len) % 128])
	}
	else {
		d.write(tmp[..128 + 112 - int(len) % 128])
	}
	// Length in bits.
	len <<= u64(3)
	binary.big_endian_put_u64(mut tmp, u64(0)) // upper 64 bits are always zero, because len variable has type u64
	binary.big_endian_put_u64(mut tmp[8..], len)
	d.write(tmp[..16])
	if d.nx != 0 {
		panic('d.nx != 0')
	}
	mut digest := [byte(0)].repeat(size)
	binary.big_endian_put_u64(mut digest, d.h[0])
	binary.big_endian_put_u64(mut digest[8..], d.h[1])
	binary.big_endian_put_u64(mut digest[16..], d.h[2])
	binary.big_endian_put_u64(mut digest[24..], d.h[3])
	binary.big_endian_put_u64(mut digest[32..], d.h[4])
	binary.big_endian_put_u64(mut digest[40..], d.h[5])
	if d.function != .sha384 {
		binary.big_endian_put_u64(mut digest[48..], d.h[6])
		binary.big_endian_put_u64(mut digest[56..], d.h[7])
	}
	return digest
}

// sum512 returns the SHA512 checksum of the data.
pub fn sum512(data []byte) []byte {
	mut d := new_digest(.sha512)
	d.write(data)
	return d.checksum()
}

// sum384 returns the SHA384 checksum of the data.
pub fn sum384(data []byte) []byte {
	mut d := new_digest(.sha384)
	d.write(data)
	sum := d.checksum()
	sum384 := [byte(0)].repeat(size384)
	copy(sum384, sum[..size384])
	return sum384
}

// sum512_224 returns the Sum512/224 checksum of the data.
pub fn sum512_224(data []byte) []byte {
	mut d := new_digest(.sha512_224)
	d.write(data)
	sum := d.checksum()
	sum224 := [byte(0)].repeat(size224)
	copy(sum224, sum[..size224])
	return sum224
}

// Sum512_256 returns the Sum512/256 checksum of the data.
pub fn sum512_256(data []byte) []byte {
	mut d := new_digest(.sha512_256)
	d.write(data)
	sum := d.checksum()
	sum256 := [byte(0)].repeat(size256)
	copy(sum256, sum[..size256])
	return sum256
}

fn block(dig mut Digest, p []byte) {
	// For now just use block_generic until we have specific
	// architecture optimized versions
	block_generic(mut dig, p)
}

pub fn (d &Digest) size() int {
	match d.function {
		.sha512_224 {
			return size224
		}
		.sha512_256 {
			return size256
		}
		.sha384 {
			return size384
		}
		else {
			return size
		}}
}

pub fn (d &Digest) block_size() int {
	return block_size
}

pub fn hexhash(s string) string {
	return sum512(s.bytes()).hex()
}

pub fn hexhash_384(s string) string {
	return sum384(s.bytes()).hex()
}

pub fn hexhash_512_224(s string) string {
	return sum512_224(s.bytes()).hex()
}

pub fn hexhash_512_256(s string) string {
	return sum512_256(s.bytes()).hex()
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
// SHA512 block step.
// This is the generic version with no architecture optimizations.
// In its own file so that an architecture
// optimized verision can be substituted
module sha512

import math.bits

const (
	_k = [u64(0x428a2f98d728ae22),
		  u64(0x7137449123ef65cd),
		  u64(0xb5c0fbcfec4d3b2f),
		  u64(0xe9b5dba58189dbbc),
		  u64(0x3956c25bf348b538),
		  u64(0x59f111f1b605d019),
		  u64(0x923f82a4af194f9b),
		  u64(0xab1c5ed5da6d8118),
		  u64(0xd807aa98a3030242),
		  u64(0x12835b0145706fbe),
		  u64(0x243185be4ee4b28c),
		  u64(0x550c7dc3d5ffb4e2),
		  u64(0x72be5d74f27b896f),
		  u64(0x80deb1fe3b1696b1),
		  u64(0x9bdc06a725c71235),
		  u64(0xc19bf174cf692694),
		  u64(0xe49b69c19ef14ad2),
		  u64(0xefbe4786384f25e3),
		  u64(0x0fc19dc68b8cd5b5),
		  u64(0x240ca1cc77ac9c65),
		  u64(0x2de92c6f592b0275),
		  u64(0x4a7484aa6ea6e483),
		  u64(0x5cb0a9dcbd41fbd4),
		  u64(0x76f988da831153b5),
		  u64(0x983e5152ee66dfab),
		  u64(0xa831c66d2db43210),
		  u64(0xb00327c898fb213f),
		  u64(0xbf597fc7beef0ee4),
		  u64(0xc6e00bf33da88fc2),
		  u64(0xd5a79147930aa725),
		  u64(0x06ca6351e003826f),
		  u64(0x142929670a0e6e70),
		  u64(0x27b70a8546d22ffc),
		  u64(0x2e1b21385c26c926),
		  u64(0x4d2c6dfc5ac42aed),
		  u64(0x53380d139d95b3df),
		  u64(0x650a73548baf63de),
		  u64(0x766a0abb3c77b2a8),
		  u64(0x81c2c92e47edaee6),
		  u64(0x92722c851482353b),
		  u64(0xa2bfe8a14cf10364),
		  u64(0xa81a664bbc423001),
		  u64(0xc24b8b70d0f89791),
		  u64(0xc76c51a30654be30),
		  u64(0xd192e819d6ef5218),
		  u64(0xd69906245565a910),
		  u64(0xf40e35855771202a),
		  u64(0x106aa07032bbd1b8),
		  u64(0x19a4c116b8d2d0c8),
		  u64(0x1e376c085141ab53),
	 	  u64(0x2748774cdf8eeb99),
		  u64(0x34b0bcb5e19b48a8),
		  u64(0x391c0cb3c5c95a63),
		  u64(0x4ed8aa4ae3418acb),
		  u64(0x5b9cca4f7763e373),
		  u64(0x682e6ff3d6b2b8a3),
	 	  u64(0x748f82ee5defb2fc),
		  u64(0x78a5636f43172f60),
		  u64(0x84c87814a1f0ab72),
		  u64(0x8cc702081a6439ec),
		  u64(0x90befffa23631e28),
		  u64(0xa4506cebde82bde9),
		  u64(0xbef9a3f7b2c67915),
		  u64(0xc67178f2e372532b),
		  u64(0xca273eceea26619c),
		  u64(0xd186b8c721c0c207),
		  u64(0xeada7dd6cde0eb1e),
		  u64(0xf57d4f7fee6ed178),
		  u64(0x06f067aa72176fba),
		  u64(0x0a637dc5a2c898a6),
		  u64(0x113f9804bef90dae),
		  u64(0x1b710b35131c471b),
		  u64(0x28db77f523047d84),
		  u64(0x32caab7b40c72493),
		  u64(0x3c9ebe0a15c9bebc),
		  u64(0x431d67c49c100d4c),
		  u64(0x4cc5d4becb3e42b6),
		  u64(0x597f299cfc657e2a),
		  u64(0x5fcb6fab3ad6faec),
		  u64(0x6c44198c4a475817),
	]
)

fn block_generic(dig mut Digest, p_ []byte) {
	mut p := p_
	mut w := [u64(0)].repeat(80)
	mut h0 := dig.h[0]
	mut h1 := dig.h[1]
	mut h2 := dig.h[2]
	mut h3 := dig.h[3]
	mut h4 := dig.h[4]
	mut h5 := dig.h[5]
	mut h6 := dig.h[6]
	mut h7 := dig.h[7]
	for p.len >= chunk {
		for i in 0..16 {
			j := i * 8
			w[i] = (u64(p[j])<<56) | (u64(p[j + 1])<<48) | (u64(p[j + 2])<<40) | (u64(p[j + 3])<<32) | (u64(p[j + 4])<<24) | (u64(p[j + 5])<<16) | (u64(p[j + 6])<<8) | u64(p[j + 7])
		}
		for i := 16; i < 80; i++ {
			v1 := w[i - 2]
			t1 := bits.rotate_left_64(v1, -19) ^ bits.rotate_left_64(v1, -61) ^ (v1>>6)
			v2 := w[i - 15]
			t2 := bits.rotate_left_64(v2, -1) ^ bits.rotate_left_64(v2, -8) ^ (v2>>7)
			w[i] = t1 + w[i - 7] + t2 + w[i - 16]
		}
		mut a := h0
		mut b := h1
		mut c := h2
		mut d := h3
		mut e := h4
		mut f := h5
		mut g := h6
		mut h := h7
		for i in 0..80 {
			t1 := h + (bits.rotate_left_64(e, -14) ^ bits.rotate_left_64(e, -18) ^ bits.rotate_left_64(e, -41)) + ((e & f) ^ (~e & g)) + _k[i] + w[i]
			t2 := (bits.rotate_left_64(a, -28) ^ bits.rotate_left_64(a, -34) ^ bits.rotate_left_64(a, -39)) + ((a & b) ^ (a & c) ^ (b & c))
			h = g
			g = f
			f = e
			e = d + t1
			d = c
			c = b
			b = a
			a = t1 + t2
		}
		h0 += a
		h1 += b
		h2 += c
		h3 += d
		h4 += e
		h5 += f
		h6 += g
		h7 += h
		if chunk >= p.len {
			p = []
		}
		else {
			p = p[chunk..]
		}
	}
	dig.h[0] = h0
	dig.h[1] = h1
	dig.h[2] = h2
	dig.h[3] = h3
	dig.h[4] = h4
	dig.h[5] = h5
	dig.h[6] = h6
	dig.h[7] = h7
}

// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
import crypto.sha512

fn test_crypto_sha512() {
	assert sha512.sum512('This is a sha512 checksum.'.bytes()).hex() == '4143e55fcba7e39b20f62a1368e5eb28f64a8859458886117ac66027832e0f9f5263daec688c439d2d0fa07059334668d39e59543039703dbb7e03ec9da7f8d7'
}

module darwin

#include <Cocoa/Cocoa.h>
#include <CoreFoundation/CoreFoundation.h>

#flag -framework Cocoa
#flag -framework Carbon

struct C.NSString { }

// macOS and iOS helpers
//pub fn nsstring(s string) *C.NSString {
pub fn nsstring(s string) voidptr {
	// println('ns $s len=$s.len')
	# return [ [ NSString alloc ] initWithBytesNoCopy:s.str  length:s.len
	# encoding:NSUTF8StringEncoding freeWhenDone: false];
	return 0

	//ns := C.alloc_NSString()
	//return ns.initWithBytesNoCopy(s.str, length: s.len,
		//encoding: NSUTF8StringEncoding,		freeWhenDone: false)
}

// returns absolute path to folder where your resources should / will reside
// for .app packages: .../my.app/Contents/Resources
// for cli: .../parent_folder/Resources

fn C.CFBundleCopyResourcesDirectoryURL() byteptr
fn C.CFBundleGetMainBundle() voidptr
fn C.CFURLGetFileSystemRepresentation() int
fn C.CFRelease()

pub fn resource_path() string {

	main_bundle := C.CFBundleGetMainBundle()
	resource_dir_url := C.CFBundleCopyResourcesDirectoryURL(main_bundle)
	if isnil(resource_dir_url) {
		panic('CFBundleCopyResourcesDirectoryURL failed')
	}
	buffer_size := 4096
	mut buffer := malloc(buffer_size)
	buffer[0] = 0
	conv_result := C.CFURLGetFileSystemRepresentation(resource_dir_url, true, buffer, buffer_size)
	if conv_result == 0 {
		panic('CFURLGetFileSystemRepresentation failed')
	}
	result := string(buffer)
	C.CFRelease(resource_dir_url)
	return result
}
module dl

pub const (
	version = 1
)
module dl

#include <dlfcn.h>

pub const (
	rtld_now = C.RTLD_NOW
	rtld_lazy = C.RTLD_LAZY
	dl_ext   = '.so'
)

fn C.dlopen(filename charptr, flags int) voidptr

fn C.dlsym(handle voidptr, symbol charptr) voidptr

fn C.dlclose(handle voidptr) int

// open loads the dynamic shared object.
pub fn open(filename string, flags int) voidptr {
	return C.dlopen(filename.str, flags)
}

// close frees a given shared object.
pub fn close(handle voidptr) bool {
	return C.dlclose(handle) == 0
}

// sym returns an address of a symbol in a given shared object.
pub fn sym(handle voidptr, symbol string) voidptr {
	return C.dlsym(handle, symbol.str)
}
import dl

fn test_dl() {
	$if linux {
		run_test_invalid_lib_linux()
		return
	}
	$if windows {
		run_test_invalid_lib_windows()
		run_test_valid_lib_windows()
		run_test_invalid_sym_windows()
		run_test_valid_sym_windows()
		return
	} $else {
		eprint('currently not implemented on this platform')
	}
}

fn run_test_invalid_lib_linux() {
	// ensure a not-existing dl won't be loaded
	h := dl.open('not-existing-dynamic-link-library', dl.rtld_now)
	assert h == 0
}

fn run_test_invalid_lib_windows() {
	// ensure a not-existing dl won't be loaded
	h := dl.open('not-existing-dynamic-link-library', dl.rtld_now)
	assert h == 0
}

fn run_test_valid_lib_windows() {
	h := dl.open('shell32', dl.rtld_now)
	assert h != 0
}

fn run_test_invalid_sym_windows() {
	h := dl.open('shell32', dl.rtld_now)
	proc := dl.sym(h, 'CommandLineToArgvW2')
	assert proc == 0
}

fn run_test_valid_sym_windows() {
	h := dl.open('shell32', dl.rtld_now)
	proc := dl.sym(h, 'CommandLineToArgvW')
	assert proc != 0
}
module dl

pub const (
	rtld_now = 0
	rtld_lazy = 0
	dl_ext   = '.dll'
)

fn C.LoadLibrary(libfilename C.LPCWSTR) voidptr

fn C.GetProcAddress(handle voidptr, procname C.LPCSTR) voidptr

fn C.FreeLibrary(handle voidptr) bool

// open loads a given module into the address space of the calling process.
pub fn open(filename string, flags int) voidptr {
	res := C.LoadLibrary(filename.to_wide())
	return res
}

// close frees the loaded a given module.
pub fn close(handle voidptr) bool {
	return C.FreeLibrary(handle)
}

// sym returns an address of an exported function or variable from a given module.
pub fn sym(handle voidptr, symbol string) voidptr {
	return C.GetProcAddress(handle, symbol.str)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module base64

const (
	index = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	62, 63, 62, 62, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0,
	0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
	17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 63, 0, 26, 27, 28, 29,
	30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,
	47, 48, 49, 50, 51]

	ending_table = [0, 2, 1]
	enc_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
)

/**
 * decode - expects a base64 encoded string. Returns its decoded version.
 * @param data - the encoded input string.
 * @return the decoded version of the input string data.
 * NB: if you need to decode many strings repeatedly, take a look at decode_in_buffer too.
 */
pub fn decode(data string) string {
	size := data.len * 3 / 4
	if size <= 0 {
		return ''
	}
	buffer := malloc(size)
	return tos(buffer, decode_in_buffer(data, buffer) )
}

/**
 * decode - expects a string. Returns its base64 encoded version.
 * @param data - the input string.
 * @return the base64 encoded version of the input string.
 * NB: base64 encoding returns a string that is ~ 4/3 larger than the input.
 * NB: if you need to encode many strings repeatedly, take a look at encode_in_buffer too.
 */
pub fn encode(data string) string {
	size := 4 * ((data.len + 2) / 3)
	if size <= 0 {
		return ''
	}
	buffer := malloc(size)
	return tos(buffer, encode_in_buffer(data, buffer))
}

/**
 * decode_in_buffer - expects a string reference, and a buffer in which to store its decoded version.
 * @param data - a reference/pointer to the input string that will be decoded.
 * @param buffer - a reference/pointer to the buffer that will hold the result.
 * The buffer should be large enough (i.e. 3/4 of the data.len, or larger) to hold the decoded data.
 * @return the actual size of the decoded data in the buffer.
 * NB: this function does NOT allocate new memory, and is suitable for handling very large strings.
 */
pub fn decode_in_buffer(data &string, buffer byteptr) int {
	mut padding := 0
	if data.ends_with('=') {
		if data.ends_with('==') {
			padding = 2
		} else {
			padding = 1
		}
	}
	//input_length is the length of meaningful data
	input_length := data.len - padding
	output_length := input_length * 3 / 4

	mut i := 0
	mut j := 0
	mut b := &byte(0)
	mut d := &byte(0)
	unsafe{
		d = byteptr(data.str)
		b = byteptr(buffer)
	}

	for i < input_length {
		mut char_a := 0
		mut char_b := 0
		mut char_c := 0
		mut char_d := 0
		if i < input_length {
			char_a = index[d[i]]
			i++
		}
		if i < input_length {
			char_b = index[d[i]]
			i++
		}
		if i < input_length {
			char_c = index[d[i]]
			i++
		}
		if i < input_length {
			char_d = index[d[i]]
			i++
		}

		decoded_bytes := (char_a << 18) | (char_b << 12) | (char_c << 6) | (char_d << 0)
		b[j]   = byte(decoded_bytes >> 16)
		b[j+1] = byte((decoded_bytes >> 8) & 0xff)
		b[j+2] = byte((decoded_bytes >> 0) & 0xff)
		j += 3
	}
	return output_length
}

/**
 * encode_in_buffer - expects a string reference, and a buffer in which to store its base64 encoded version.
 * @param data - a reference/pointer to the input string.
 * @param buffer - a reference/pointer to the buffer that will hold the result.
 * The buffer should be large enough (i.e. 4/3 of the data.len, or larger) to hold the encoded data.
 * @return the actual size of the encoded data in the buffer.
 * NB: this function does NOT allocate new memory, and is suitable for handling very large strings.
 */
pub fn encode_in_buffer(data &string, buffer byteptr) int {
	input_length := data.len
	output_length := 4 * ((input_length + 2) / 3)

	mut i := 0
	mut j := 0

	mut d	   := byteptr(0)
	mut b	   := byteptr(0)
	mut etable := byteptr(0)
	unsafe{
		d = data.str
		b = buffer
		etable = enc_table.str
	}

	for i < input_length {
		mut octet_a := 0
		mut octet_b := 0
		mut octet_c := 0

		if i < input_length {
			octet_a = int(d[i])
			i++
		}
		if i < input_length {
			octet_b = int(d[i])
			i++
		}
		if i < input_length {
			octet_c = int(d[i])
			i++
		}

		triple := ((octet_a << 0x10) + (octet_b << 0x08) + octet_c)

		b[j]   = etable[ (triple >> 3 * 6) & 63 ]  // 63 is 0x3F
		b[j+1] = etable[ (triple >> 2 * 6) & 63 ]
		b[j+2] = etable[ (triple >> 1 * 6) & 63 ]
		b[j+3] = etable[ (triple >> 0 * 6) & 63 ]
		j += 4
	}

	padding_length := ending_table[input_length % 3]
	for i = 0; i < padding_length; i++ {
		b[output_length - 1 - i] = `=`
	}
	return output_length
}
import encoding.base64

fn test_long_encoding(){
	repeats := 1000
	input_size := 3000

	s_original := 'a'.repeat(input_size)
	s_encoded := base64.encode(s_original)
	s_decoded := base64.decode(s_encoded)

	assert s_encoded.len > s_original.len
	assert s_original == s_decoded

	mut s := 0

	ebuffer := malloc( s_encoded.len )
	for _ in 0..repeats {
		resultsize := base64.encode_in_buffer(s_original, ebuffer)
		s += resultsize
		assert resultsize == s_encoded.len
	}

	dbuffer := malloc( s_decoded.len )
	for _ in 0..repeats {
		resultsize := base64.decode_in_buffer(s_encoded, dbuffer)
		s += resultsize
		assert resultsize == s_decoded.len
	}

	println( 'Final s: $s' )
	//	assert s == 39147008
}
import encoding.base64

struct TestPair {
	decoded string
	encoded string
}

const (
	pairs = [
		// RFC 3548 examples
		TestPair{'\x14\xfb\x9c\x03\xd9\x7e', 'FPucA9l+'},
		TestPair{'\x14\xfb\x9c\x03\xd9', 'FPucA9k='},
		TestPair{'\x14\xfb\x9c\x03', 'FPucAw=='},

		// RFC 4648 examples
		TestPair{'', ''},
		TestPair{'f', 'Zg=='},
		TestPair{'fo', 'Zm8='},
		TestPair{'foo', 'Zm9v'},
		TestPair{'foob', 'Zm9vYg=='},
		TestPair{'fooba', 'Zm9vYmE='},
		TestPair{'foobar', 'Zm9vYmFy'},

		// Wikipedia examples
		TestPair{'sure.', 'c3VyZS4='},
		TestPair{'sure', 'c3VyZQ=='},
		TestPair{'sur', 'c3Vy'},
		TestPair{'su', 'c3U='},
		TestPair{'leasure.', 'bGVhc3VyZS4='},
		TestPair{'easure.', 'ZWFzdXJlLg=='},
		TestPair{'asure.', 'YXN1cmUu'},
		TestPair{'sure.', 'c3VyZS4='},
	]
	
	man_pair = TestPair{
		'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.',
		'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4='
	}
		
)

fn test_decode() {
	assert base64.decode(man_pair.encoded) == man_pair.decoded

	// Test for incorrect padding.
	assert base64.decode('aGk') == 'hi'
	assert base64.decode('aGk=') == 'hi'
	assert base64.decode('aGk==') == 'hi'

	for i, p in pairs {
		got := base64.decode(p.encoded)
		if got != p.decoded {
			eprintln('pairs[${i}]: expected = ${p.decoded}, got = ${got}')
			assert false
		}
	}
}

fn test_encode() {
	assert base64.encode(man_pair.decoded) == man_pair.encoded

	for i, p in pairs {
		got := base64.encode(p.decoded)
		if got != p.encoded {
			eprintln('pairs[${i}]: expected = ${p.encoded}, got = ${got}')
			assert false
		}
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module binary
// Little Endian
[inline]
pub fn little_endian_u16(b []byte) u16 {
	_ = b[1] // bounds check
	return u16(b[0]) | (u16(b[1])<<u16(8))
}

[inline]
pub fn little_endian_put_u16(b mut []byte, v u16) {
	_ = b[1] // bounds check
	b[0] = byte(v)
	b[1] = byte(v>>u16(8))
}

[inline]
pub fn little_endian_u32(b []byte) u32 {
	_ = b[3] // bounds check
	return u32(b[0]) | (u32(b[1])<<u32(8)) | (u32(b[2])<<u32(16)) | (u32(b[3])<<u32(24))
}

[inline]
pub fn little_endian_put_u32(b mut []byte, v u32) {
	_ = b[3] // bounds check
	b[0] = byte(v)
	b[1] = byte(v>>u32(8))
	b[2] = byte(v>>u32(16))
	b[3] = byte(v>>u32(24))
}

[inline]
pub fn little_endian_u64(b []byte) u64 {
	_ = b[7] // bounds check
	return u64(b[0]) | (u64(b[1])<<u64(8)) | (u64(b[2])<<u64(16)) | (u64(b[3])<<u64(24)) | (u64(b[4])<<u64(32)) | (u64(b[5])<<u64(40)) | (u64(b[6])<<u64(48)) | (u64(b[7])<<u64(56))
}

[inline]
pub fn little_endian_put_u64(b mut []byte, v u64) {
	_ = b[7] // bounds check
	b[0] = byte(v)
	b[1] = byte(v>>u64(8))
	b[2] = byte(v>>u64(16))
	b[3] = byte(v>>u64(24))
	b[4] = byte(v>>u64(32))
	b[5] = byte(v>>u64(40))
	b[6] = byte(v>>u64(48))
	b[7] = byte(v>>u64(56))
}

// Big Endian
[inline]
pub fn big_endian_u16(b []byte) u16 {
	_ = b[1] // bounds check
	return u16(b[1]) | (u16(b[0])<<u16(8))
}

[inline]
pub fn big_endian_put_u16(b mut []byte, v u16) {
	_ = b[1] // bounds check
	b[0] = byte(v>>u16(8))
	b[1] = byte(v)
}

[inline]
pub fn big_endian_u32(b []byte) u32 {
	_ = b[3] // bounds check
	return u32(b[3]) | (u32(b[2])<<u32(8)) | (u32(b[1])<<u32(16)) | (u32(b[0])<<u32(24))
}

[inline]
pub fn big_endian_put_u32(b mut []byte, v u32) {
	_ = b[3] // bounds check
	b[0] = byte(v>>u32(24))
	b[1] = byte(v>>u32(16))
	b[2] = byte(v>>u32(8))
	b[3] = byte(v)
}

[inline]
pub fn big_endian_u64(b []byte) u64 {
	_ = b[7] // bounds check
	return u64(b[7]) | (u64(b[6])<<u64(8))| (u64(b[5])<<u64(16)) | (u64(b[4])<<u64(24)) | (u64(b[3])<<u64(32)) | (u64(b[2])<<u64(40)) | (u64(b[1])<<u64(48)) | (u64(b[0])<<u64(56))
}

[inline]
pub fn big_endian_put_u64(b mut []byte, v u64) {
	_ = b[7] // bounds check
	b[0] = byte(v>>u64(56))
	b[1] = byte(v>>u64(48))
	b[2] = byte(v>>u64(40))
	b[3] = byte(v>>u64(32))
	b[4] = byte(v>>u64(24))
	b[5] = byte(v>>u64(16))
	b[6] = byte(v>>u64(8))
	b[7] = byte(v)
}

// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module csv

// Once interfaces are further along the idea would be to have something similar to
// go's io.reader & bufio.reader rather than reading the whole file into string, this
// would then satisfy that interface. I designed it this way to be easily adapted.

const (
	err_comment_is_delim = error('encoding.csv: comment cannot be the same as delimiter')
	err_invalid_delim    = error('encoding.csv: invalid delimiter')
	err_eof              = error('encoding.csv: end of file')
	err_invalid_le       = error('encoding.csv: could not find any valid line endings')
)


struct Reader  {
	// not used yet
	// has_header        bool
	// headings          []string
	data              string
pub mut:
	delimiter         byte
	comment           byte
	is_mac_pre_osx_le bool
	row_pos           int
}

pub fn new_reader(data string) &Reader {
	return &Reader{
		delimiter: `,`,
		comment: `#`,
		data: data
	}
}

// read() reads one row from the csv file
pub fn (mut r Reader) read() ?[]string {
	l := r.read_record() or {
		return error(err)
	}
	return l
}

// Once we have multi dimensional array
// pub fn (mut r Reader) read_all() ?[][]string {
// 	mut records := []string{}
// 	for {
// 		record := r.read_record() or {
// 			if error(err).error == err_eof.error {
// 				return records
// 			} else {
// 				return error(err)
// 			}
// 		}
// 		records << record
// 	}
// 	return records
// }

fn (mut r Reader) read_line() ?string {
	// last record
	if r.row_pos == r.data.len {
		return err_eof
	}
	le := if r.is_mac_pre_osx_le { '\r' } else { '\n' }
	mut i := r.data.index_after(le, r.row_pos)
	if i == -1 {
		if r.row_pos == 0 {
			// check for pre osx mac line endings
			i = r.data.index_after('\r', r.row_pos)
			if i != -1 {
				r.is_mac_pre_osx_le = true
			} else {
				// no valid line endings found
				return err_invalid_le
			}
		} else {
			// No line ending on file
			i = r.data.len-1
		}
	}
	mut line := r.data[r.row_pos..i]
	r.row_pos = i+1
	// normalize win line endings (remove extra \r)
	if !r.is_mac_pre_osx_le && (line.len >= 1 && line[line.len-1] == `\r`) {
		line = line[..line.len-1]
	}
	return line
}

fn (mut r Reader) read_record() ?[]string {
	if r.delimiter == r.comment {
		return err_comment_is_delim
	}
	if !valid_delim(r.delimiter) {
		return err_invalid_delim
	}
	mut need_read := true
	mut keep_raw := false
	mut line := ''
	mut fields := []string{}
	mut i := -1

	for {
		if need_read {
			l := r.read_line() or {
				return error(err)
			}
			if l.len <= 0 {
				if keep_raw { line += '\n'}
				continue
			} else if l[0] == r.comment {
				if keep_raw { line += '\n' + l }
				continue
			} else {
				if keep_raw { line += '\n'}
				line += l
			}
			need_read = false
			keep_raw = false
		}

		if line[0] != `"` {		// not quoted
			j := line.index(r.delimiter.str()) or {
				// last
				fields << line[..line.len]
				break
			}
			i = j
			fields << line[..i]
			line = line[i+1..]
			continue
		} else {		// quoted
			j := line[1..].index('"') or {
				need_read = true
				keep_raw = true
				continue
			}
			line = line[1..]
			if j+1 == line.len {
				// last record
				fields << line[..j]
				break
			}
			next := line[j+1]
			if next == r.delimiter {
				fields << line[..j]
				line = line[j..]
				continue
			}
			line = line[1..]
		}
		if i <= -1 && fields.len == 0 {
			return err_invalid_delim
		}
	}
	return fields
}

fn valid_delim(b byte) bool {
	return b != 0 &&
		   b != `"` &&
		   b != `\r` &&
		   b != `\n`
}
import encoding.csv

fn test_encoding_csv_reader() {
	data := 'name,email,phone,other\njoe,joe@blow.com,0400000000,test\nsam,sam@likesham.com,0433000000,"test quoted field"\n#chris,chris@nomail.com,94444444,"commented row"\n'
	mut csv_reader := csv.new_reader(data)

	mut row_count := 0
	for {
		row := csv_reader.read() or {
			break
		}
		row_count++
		if row_count == 1 {
			assert row[0] == 'name'
			assert row[1] == 'email'
			assert row[2] == 'phone'
			assert row[3] == 'other'
		}
		if row_count == 2 {
			assert row[0] == 'joe'
			assert row[1] == 'joe@blow.com'
			assert row[2] == '0400000000'
			assert row[3] == 'test'
		}
		if row_count == 3 {
			assert row[0] == 'sam'
			assert row[1] == 'sam@likesham.com'
			assert row[2] == '0433000000'
			// quoted field
			assert row[3] == 'test quoted field'
		}
	}

	assert row_count == 3
}

fn test_line_break_lf() {
	lf_data := 'name,email\njoe,joe@blow.com\n'

	mut csv_reader := csv.new_reader(lf_data)

	mut row_count := 0
	for {
		row := csv_reader.read() or {
			break
		}
		row_count++
		if row_count == 1 {
			assert row[0] == 'name'
			assert row[1] == 'email'
		}
		if row_count == 2 {
			assert row[0] == 'joe'
			assert row[1] == 'joe@blow.com'
		}
	}

	assert row_count == 2
}

fn test_line_break_cr() {
	cr_data := 'name,email\rjoe,joe@blow.com\r'

	mut csv_reader := csv.new_reader(cr_data)

	mut row_count := 0
	for {
		row := csv_reader.read() or {
			break
		}
		row_count++
		if row_count == 1 {
			assert row[0] == 'name'
			assert row[1] == 'email'
		}
		if row_count == 2 {
			assert row[0] == 'joe'
			assert row[1] == 'joe@blow.com'
		}
	}

	assert row_count == 2
}

fn test_line_break_crlf() {
	crlf_data := 'name,email\r\njoe,joe@blow.com\r\n'

	mut csv_reader := csv.new_reader(crlf_data)

	mut row_count := 0
	for {
		row := csv_reader.read() or {
			break
		}
		row_count++
		if row_count == 1 {
			assert row[0] == 'name'
			assert row[1] == 'email'
		}
		if row_count == 2 {
			assert row[0] == 'joe'
			assert row[1] == 'joe@blow.com'
		}
	}

	assert row_count == 2
}

fn test_no_line_ending() {
	data := 'name,email,phone,other\njoe,joe@blow.com,0400000000,test'
	mut csv_reader := csv.new_reader(data)

	mut row_count := 0
	for {
		csv_reader.read() or {
			break
		}
		row_count++
	}

	assert row_count == 2
}

fn test_last_field_empty() {
	data := '"name","description","value"\n"one","first","1"\n"two","second",\n'
	mut csv_reader := csv.new_reader(data)

	mut row_count := 0
	for {
    	row := csv_reader.read() or {
        	break
    	}
    	row_count++
		if row_count == 1 {
			assert row[0] == 'name'
			assert row[1] == 'description'
			assert row[2] == 'value'
		}
		if row_count == 2 {
			assert row[0] == 'one'
			assert row[1] == 'first'
			assert row[2] == '1'
		}
		if row_count == 3 {
			assert row[0] == 'two'
			assert row[1] == 'second'
		}
	}
}

fn test_empty_line() {
	data := '"name","description","value"\n\n\n"one","first","1"\n\n"two","second",\n'
	mut csv_reader := csv.new_reader(data)

	mut row_count := 0
	for {
    	row := csv_reader.read() or {
        	break
    	}
    	row_count++
		if row_count == 1 {
			assert row[0] == 'name'
			assert row[1] == 'description'
			assert row[2] == 'value'
		}
		if row_count == 2 {
			assert row[0] == 'one'
			assert row[1] == 'first'
			assert row[2] == '1'
		}
		if row_count == 3 {
			assert row[0] == 'two'
			assert row[1] == 'second'
		}
	}
}

fn test_field_multiple_line() {
	data := '"name","multiple

 line","value"\n"one","first","1"'
	mut csv_reader := csv.new_reader(data)

	mut row_count := 0
	for {
    	row := csv_reader.read() or {
        	break
    	}
    	row_count++
		if row_count == 1 {
			assert row[0] == 'name'
			assert row[1] == 'multiple\n\n line'
			assert row[2] == 'value'
		}
		if row_count == 2 {
			assert row[0] == 'one'
			assert row[1] == 'first'
			assert row[2] == '1'
		}
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module csv

import strings

struct Writer {
	sb strings.Builder
pub mut:
	use_crlf bool
	delimiter byte
}

pub fn new_writer() &Writer {
	return &Writer{
		delimiter: `,`,
		sb: strings.new_builder(200)
	}
}

// write writes a single record
pub fn (mut w Writer) write(record []string) ?bool {
	if !valid_delim(w.delimiter) {
		return err_invalid_delim
	}
	le := if w.use_crlf { '\r\n' } else { '\n' }
	for n, _field in record {
		mut field := _field
		if n > 0 {
			w.sb.write(w.delimiter.str())
		}

		if !w.field_needs_quotes(field) {
			w.sb.write(field)
			continue
		}

		w.sb.write('"')

		for field.len > 0 {
			mut i := field.index_any('"\r\n')
			if i < 0 {
				i = field.len
			}

			w.sb.write(field[..i])
			field = field[i..]

			if field.len > 0 {
				z := field[0]
				match z {
					`"` {
						w.sb.write('""')
					}
					`\r`, `\n` {
						w.sb.write(le)
					}
					else {}
				}
				field = field[1..]
			}
		}
		w.sb.write('"')
	}

	w.sb.write(le)
	return true
}

// Once we have multi dimensional array
// pub fn (w &Writer) write_all(records [][]string) {
// 	for _, record in records {
// 		w.write(record)
// 	}
// }

fn (w &Writer) field_needs_quotes(field string) bool {
	if field == '' {
		return false
	}
	if field.contains(w.delimiter.str()) || (field.index_any('"\r\n') != -1) {
		return true
	}
	return false
}

pub fn (mut w Writer) str() string {
	return w.sb.str()
}
import encoding.csv

fn test_encoding_csv_writer() {
	mut csv_writer := csv.new_writer()

	csv_writer.write(['name', 'email', 'phone', 'other']) or {}
	csv_writer.write(['joe', 'joe@blow.com', '0400000000', 'test']) or {}
	csv_writer.write(['sam', 'sam@likesham.com', '0433000000', 'needs, quoting']) or {}

	assert csv_writer.str() == 'name,email,phone,other\njoe,joe@blow.com,0400000000,test\nsam,sam@likesham.com,0433000000,"needs, quoting"\n'
}
/**********************************************************************
*
* utf-8 util
*
* Copyright (c) 2019 Dario Deledda. All rights reserved.
* Use of this source code is governed by an MIT license
* that can be found in the LICENSE file.
*
* This file contains utilities for utf8 strings
*
**********************************************************************/
module utf8

/**********************************************************************
*
* Utility functions
*
**********************************************************************/

// len return the leght as number of unicode chars from a string
pub fn len(s string) int {
	mut count := 0
	mut index := 0

	for {
		ch_len := utf8util_char_len(s.str[index])
		index += ch_len
		if index > s.len {
			break
		}
		count++
	}
	return count
}

// u_len return the leght as number of unicode chars from a ustring
pub fn u_len(s ustring) int {
	return len(s.s)
}

// get_uchar convert a unicode glyph in string[index] into a int unicode char
pub fn get_uchar(s string, index int) int {
	mut res := 0
	mut ch_len := 0
	if s.len > 0  {
		ch_len = utf8util_char_len(s.str[index])

		if ch_len == 1 {
			return u16(s.str[0])
		}if ch_len > 1 && ch_len < 5{
			mut lword := 0
			for i:=0; i < ch_len ; i++ {
				lword = (lword << 8 ) | int( s.str[index + i] )
			}

			// 2 byte utf-8
			// byte format: 110xxxxx 10xxxxxx
			//
			if ch_len == 2 {
				res = (lword & 0x1f00) >> 2 | (lword & 0x3f)
			}
			// 3 byte utf-8
			// byte format: 1110xxxx 10xxxxxx 10xxxxxx
			//
			else if ch_len == 3 {
				res = ( lword & 0x0f0000 ) >> 4 | ( lword & 0x3f00 ) >> 2 | ( lword & 0x3f )
			}
			// 4 byte utf-8
			// byte format: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
			//
			else if ch_len == 4 {
				res = (( lword & 0x07000000 ) >> 6)  | (( lword & 0x003f0000 ) >> 4) |
						(( lword & 0x00003F00 ) >> 2 ) | ( lword & 0x0000003f )
			}


		}

	}
	return res
}


/**********************************************************************
*
* Conversion functions
*
**********************************************************************/

// to_upper return an uppercase string from a string
pub fn to_upper(s string) string {
	return up_low(s, true)
}

// u_to_upper return an uppercase string from a ustring
pub fn u_to_upper(s ustring) ustring {
	tmp := up_low(s.s, true)
	return tmp.ustring()
}

// to_lower return an lowercase string from a string
pub fn to_lower(s string) string {
	return up_low(s, false)
}

// u_to_lower return an lowercase string from a ustring
pub fn u_to_lower(s ustring) ustring {
	tmp := up_low(s.s, false)
	return tmp.ustring()
}


/**********************************************************************
*
* Punctuation functions
*
* The "western" function search on a small table, that is quicker than
* the global unicode table search. **Use only for western chars**.
*
**********************************************************************/

//
// Western
//

// is_punct return true if the string[index] byte is the start of a unicode western punctuation
pub fn is_punct( s string , index int) bool {
	return is_uchar_punct(get_uchar(s, index))
}

// is_uchar_punct return true if the input unicode is a western unicode punctuation
pub fn is_uchar_punct( uchar int ) bool {
	return find_punct_in_table(uchar, unicode_punct_western ) != 0
}

//
// Global
//

// is_global_punct return true if the string[index] byte of is the start of a global unicode punctuation
pub fn is_global_punct( s string , index int) bool {
	return is_uchar_global_punct(get_uchar(s, index))
}

// is_uchar_global_punct return true if the input unicode is a global unicode punctuation
pub fn is_uchar_global_punct( uchar int ) bool {
	return find_punct_in_table( uchar , unicode_punct ) != 0
}


/**********************************************************************
*
* Private functions
*
**********************************************************************/
// utf8util_char_len calculate the length in bytes of a utf8 char
fn utf8util_char_len(b byte) int {
	return (( 0xe5000000 >> (( b >> 3 ) & 0x1e )) & 3 ) + 1
}

//
// if upper_flag == true  then make low ==> upper conversion
// if upper_flag == false then make upper ==> low conversion
//
// up_low make the dirt job
fn up_low(s string, upper_flag bool) string {
	mut index := 0
	mut str_res := malloc(s.len + 1)

	for {
		ch_len := utf8util_char_len(s.str[index])

		if ch_len == 1 {
			if upper_flag==true {
				str_res[index] = byte(C.toupper(s.str[index]))
			}else{
				str_res[index] = byte(C.tolower(s.str[index]))
			}
		}
		else if ch_len > 1 && ch_len < 5{
			mut lword := 0

			for i:=0; i < ch_len ; i++ {
				lword = (lword << 8 ) | int( s.str[index + i] )
			}

			//C.printf(" #%d (%x) ", index, lword)

			mut res := 0

			// 2 byte utf-8
			// byte format: 110xxxxx 10xxxxxx
			//
			if ch_len == 2 {
				res = (lword & 0x1f00) >> 2 | (lword & 0x3f)
			}
			// 3 byte utf-8
			// byte format: 1110xxxx 10xxxxxx 10xxxxxx
			//
			else if ch_len == 3 {
				res = ( lword & 0x0f0000 ) >> 4 | ( lword & 0x3f00 ) >> 2 | ( lword & 0x3f )
			}
			// 4 byte utf-8
			// byte format: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
			//
			else if ch_len == 4 {
				res = (( lword & 0x07000000 ) >> 6)  | (( lword & 0x003f0000 ) >> 4) |
						(( lword & 0x00003F00 ) >> 2 ) | ( lword & 0x0000003f )
			}

			//C.printf("len: %d code: %04x ",ch_len,res)
			ch_index := find_char_in_table(u16(res), upper_flag)
			//C.printf(" utf8 index: %d ",ch_index)

			// char not in table, no need of conversion
			if ch_index == 0 {
				for i in 0..ch_len {
					str_res[index + i] = s.str[index + i]
				}
				//C.printf("\n")
			}else{
				tab_char := unicode_con_table_up_to_low[ch_index]
				//C.printf("tab_char: %04x ",tab_char)

				if ch_len == 2 {
					ch0 := byte( (tab_char >> 6) & 0x1f ) | 0xc0  	/*110x xxxx*/
					ch1 := byte( (tab_char >> 0) & 0x3f ) | 0x80		/*10xx xxxx*/
					//C.printf("[%02x%02x] \n",ch0,ch1)

					str_res[ index + 0 ] = ch0
					str_res[ index + 1 ] = ch1

					//****************************************************************
					//  BUG: doesn't compile, workaround use shitf to right of 0 bit
					//****************************************************************
					//str_res[index + 1 ] = byte( tab_char & 0xbf )			/*1011 1111*/

				}
				else if ch_len == 3 {
					ch0 := byte( (tab_char >> 12) & 0x0f ) | 0xe0  	/*1110 xxxx*/
					ch1 := byte( (tab_char >> 6) & 0x3f ) | 0x80		/*10xx xxxx*/
					ch2 := byte( (tab_char >> 0) & 0x3f ) | 0x80		/*10xx xxxx*/
					//C.printf("[%02x%02x%02x] \n",ch0,ch1,ch2)

					str_res[index + 0 ] = ch0
					str_res[index + 1 ] = ch1
					str_res[index + 2 ] = ch2
				}
				// TODO: write if needed
				else if ch_len == 4 {
					// place holder!!
					// at the present time simply copy the utf8 char
					for i in 0..ch_len {
						str_res[index + i] = s.str[index + i]
					}
				}
			}

		}
		// other cases, just copy the string
		else{
			for i in 0..ch_len {
				str_res[index + i] = s.str[index + i]
			}
		}

		index += ch_len

		// we are done, exit the loop
		if index >= s.len {
			break
		}
	}

	// for c compatibility set the ending 0
	str_res[index]=0

	//C.printf("str_res: %s\n--------------\n",str_res)

	return tos(str_res, s.len)
}

// find_char_in_table utility function for up_low, search utf8 chars in the conversion table
fn find_char_in_table( in_code u16, upper_flag bool) int {
	//
	// We will use a simple binary search
	//

	mut first_index := 0 										// first index of our utf8 char range
	mut last_index := (unicode_con_table_up_to_low.len >> 1)		// last+1 index of our utf8 char range
	mut index := 0
	mut x := u16(0)

	mut offset:=0 		// up to low
	mut i_step:=1		// up to low
	if upper_flag==true {
		offset=1		// low to up
		i_step=0		// low to up
	}

	//C.printf("looking for [%04x] in (%d..%d).\n",in_code,first_index,last_index)
	for {
		index = (first_index+last_index) >> 1
		x = unicode_con_table_up_to_low[ (index<<1)+offset ]

		//C.printf("(%d..%d) index:%d base[%04x]==>[%04x]\n",first_index,last_index,index,in_code,x)

		if x == in_code {
			//C.printf(" Found!\n")
			return ( (index<<1) + i_step)
		}
		else if x>in_code {
			last_index=index
		}else {
			first_index=index
		}

		if (last_index-first_index)<=1 {
			break
		}
	}
	//C.printf("not found.\n")
	return 0
}

// find punct in lockup table
fn find_punct_in_table( in_code int , in_table []int ) int {
	//
	// We will use a simple binary search
	//

	mut first_index := 0
	mut last_index := (in_table.len)
	mut index := 0
	mut x := 0

	for {
		index = (first_index+last_index) >> 1
		x = in_table[ index ]
		//C.printf("(%d..%d) index:%d base[%08x]==>[%08x]\n",first_index,last_index,index,in_code,x)

		if x == in_code {
			return index
		}
		else if x>in_code {
			last_index=index
		}else {
			first_index=index
		}

		if (last_index-first_index)<=1 {
			break
		}
	}
	//C.printf("not found.\n")
	return 0
}


/*****************************************************************************
*
*  universal character set 2 level 1 (UCS-2 level-1) between uppercase and lowercase
*  [Lowercase code point,	Uppercase code point,	Lowercase character description,	Uppercase character description]
*
*  source: https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_73/nls/rbagslowtoupmaptable.htm?view=embed
*  term of use: https://www.ibm.com/legal?lnk=flg-tous-usen
*  license: not stated, general fair use license applied
*
*  regex expresion => replace from html table to V :
*  src: ([A-F\d]+)\s+([A-F\d]+)\s+(.*)
*  dst: 0x$1, 0x$2, // $3
*
*****************************************************************************/

const(

unicode_con_table_up_to_low=[
u16(0x0041), 0x0061, //LATIN CAPITAL LETTER A	LATIN SMALL LETTER A
0x0042, 0x0062, //LATIN CAPITAL LETTER B	LATIN SMALL LETTER B
0x0043, 0x0063, //LATIN CAPITAL LETTER C	LATIN SMALL LETTER C
0x0044, 0x0064, //LATIN CAPITAL LETTER D	LATIN SMALL LETTER D
0x0045, 0x0065, //LATIN CAPITAL LETTER E	LATIN SMALL LETTER E
0x0046, 0x0066, //LATIN CAPITAL LETTER F	LATIN SMALL LETTER F
0x0047, 0x0067, //LATIN CAPITAL LETTER G	LATIN SMALL LETTER G
0x0048, 0x0068, //LATIN CAPITAL LETTER H	LATIN SMALL LETTER H
0x0049, 0x0069, //LATIN CAPITAL LETTER I	LATIN SMALL LETTER I
0x004A, 0x006A, //LATIN CAPITAL LETTER J	LATIN SMALL LETTER J
0x004B, 0x006B, //LATIN CAPITAL LETTER K	LATIN SMALL LETTER K
0x004C, 0x006C, //LATIN CAPITAL LETTER L	LATIN SMALL LETTER L
0x004D, 0x006D, //LATIN CAPITAL LETTER M	LATIN SMALL LETTER M
0x004E, 0x006E, //LATIN CAPITAL LETTER N	LATIN SMALL LETTER N
0x004F, 0x006F, //LATIN CAPITAL LETTER O	LATIN SMALL LETTER O
0x0050, 0x0070, //LATIN CAPITAL LETTER P	LATIN SMALL LETTER P
0x0051, 0x0071, //LATIN CAPITAL LETTER Q	LATIN SMALL LETTER Q
0x0052, 0x0072, //LATIN CAPITAL LETTER R	LATIN SMALL LETTER R
0x0053, 0x0073, //LATIN CAPITAL LETTER S	LATIN SMALL LETTER S
0x0054, 0x0074, //LATIN CAPITAL LETTER T	LATIN SMALL LETTER T
0x0055, 0x0075, //LATIN CAPITAL LETTER U	LATIN SMALL LETTER U
0x0056, 0x0076, //LATIN CAPITAL LETTER V	LATIN SMALL LETTER V
0x0057, 0x0077, //LATIN CAPITAL LETTER W	LATIN SMALL LETTER W
0x0058, 0x0078, //LATIN CAPITAL LETTER X	LATIN SMALL LETTER X
0x0059, 0x0079, //LATIN CAPITAL LETTER Y	LATIN SMALL LETTER Y
0x005A, 0x007A, //LATIN CAPITAL LETTER Z	LATIN SMALL LETTER Z
0x00C0, 0x00E0, //LATIN CAPITAL LETTER A GRAVE	LATIN SMALL LETTER A GRAVE
0x00C1, 0x00E1, //LATIN CAPITAL LETTER A ACUTE	LATIN SMALL LETTER A GRAVE
0x00C2, 0x00E2, //LATIN CAPITAL LETTER A CIRCUMFLEX	LATIN SMALL LETTER A GRAVE
0x00C3, 0x00E3, //LATIN CAPITAL LETTER A TILDE	LATIN SMALL LETTER A GRAVE
0x00C4, 0x00E4, //LATIN CAPITAL LETTER A DIAERESIS	LATIN SMALL LETTER A GRAVE
0x00C5, 0x00E5, //LATIN CAPITAL LETTER A RING	LATIN SMALL LETTER A GRAVE
0x00C6, 0x00E6, //LATIN CAPITAL LETTER A E	LATIN SMALL LETTER A GRAVE
0x00C7, 0x00E7, //LATIN CAPITAL LETTER C CEDILLA	LATIN SMALL LETTER A GRAVE
0x00C8, 0x00E8, //LATIN CAPITAL LETTER E GRAVE	LATIN SMALL LETTER A GRAVE
0x00C9, 0x00E9, //LATIN CAPITAL LETTER E ACUTE	LATIN SMALL LETTER A GRAVE
0x00CA, 0x00EA, //LATIN CAPITAL LETTER E CIRCUMFLEX	LATIN SMALL LETTER E CIRCUMFLEX
0x00CB, 0x00EB, //LATIN CAPITAL LETTER E DIAERESIS	LATIN SMALL LETTER E DIAERESIS
0x00CC, 0x00EC, //LATIN CAPITAL LETTER I GRAVE	LATIN SMALL LETTER I GRAVE
0x00CD, 0x00ED, //LATIN CAPITAL LETTER I ACUTE	LATIN SMALL LETTER I ACUTE
0x00CE, 0x00EE, //LATIN CAPITAL LETTER I CIRCUMFLEX	LATIN SMALL LETTER I CIRCUMFLEX
0x00CF, 0x00EF, //LATIN CAPITAL LETTER I DIAERESIS	LATIN SMALL LETTER I DIAERESIS
0x00D0, 0x00F0, //LATIN CAPITAL LETTER ETH	LATIN SMALL LETTER ETH
0x00D1, 0x00F1, //LATIN CAPITAL LETTER N TILDE	LATIN SMALL LETTER N TILDE
0x00D2, 0x00F2, //LATIN CAPITAL LETTER O GRAVE	LATIN SMALL LETTER O GRAVE
0x00D3, 0x00F3, //LATIN CAPITAL LETTER O ACUTE	LATIN SMALL LETTER O ACUTE
0x00D4, 0x00F4, //LATIN CAPITAL LETTER O CIRCUMFLEX	LATIN SMALL LETTER O CIRCUMFLEX
0x00D5, 0x00F5, //LATIN CAPITAL LETTER O TILDE	LATIN SMALL LETTER O TILDE
0x00D6, 0x00F6, //LATIN CAPITAL LETTER O DIAERESIS	LATIN SMALL LETTER O DIAERESIS
0x00D8, 0x00F8, //LATIN CAPITAL LETTER O SLASH	LATIN SMALL LETTER O SLASH
0x00D9, 0x00F9, //LATIN CAPITAL LETTER U GRAVE	LATIN SMALL LETTER U GRAVE
0x00DA, 0x00FA, //LATIN CAPITAL LETTER U ACUTE	LATIN SMALL LETTER U ACUTE
0x00DB, 0x00FB, //LATIN CAPITAL LETTER U CIRCUMFLEX	LATIN SMALL LETTER U CIRCUMFLEX
0x00DC, 0x00FC, //LATIN CAPITAL LETTER U DIAERESIS	LATIN SMALL LETTER U DIAERESIS
0x00DD, 0x00FD, //LATIN CAPITAL LETTER Y ACUTE	LATIN SMALL LETTER Y ACUTE
0x00DE, 0x00FE, //LATIN CAPITAL LETTER THORN	LATIN SMALL LETTER THORN
0x0100, 0x0101, //LATIN CAPITAL LETTER A WITH MACRON	LATIN SMALL LETTER A WITH MACRON
0x0102, 0x0103, //LATIN CAPITAL LETTER A WITH BREVE	LATIN SMALL LETTER A WITH BREVE
0x0104, 0x0105, //LATIN CAPITAL LETTER A WITH OGONEK	LATIN SMALL LETTER A WITH OGONEK
0x0106, 0x0107, //LATIN CAPITAL LETTER C WITH ACUTE	LATIN SMALL LETTER C WITH ACUTE
0x0108, 0x0109, //LATIN CAPITAL LETTER C WITH CIRCUMFLEX	LATIN SMALL LETTER C WITH CIRCUMFLEX
0x010A, 0x010B, //LATIN CAPITAL LETTER C WITH DOT ABOVE	LATIN SMALL LETTER C WITH DOT ABOVE
0x010C, 0x010D, //LATIN CAPITAL LETTER C WITH CARON	LATIN SMALL LETTER C WITH CARON
0x010E, 0x010F, //LATIN CAPITAL LETTER D WITH CARON	LATIN SMALL LETTER D WITH CARON
0x0110, 0x0111, //LATIN CAPITAL LETTER D WITH STROKE	LATIN SMALL LETTER D WITH STROKE
0x0112, 0x0113, //LATIN CAPITAL LETTER E WITH MACRON	LATIN SMALL LETTER E WITH MACRON
0x0114, 0x0115, //LATIN CAPITAL LETTER E WITH BREVE	LATIN SMALL LETTER E WITH BREVE
0x0116, 0x0117, //LATIN CAPITAL LETTER E WITH DOT ABOVE	LATIN SMALL LETTER E WITH DOT ABOVE
0x0118, 0x0119, //LATIN CAPITAL LETTER E WITH OGONEK	LATIN SMALL LETTER E WITH OGONEK
0x011A, 0x011B, //LATIN CAPITAL LETTER E WITH CARON	LATIN SMALL LETTER E WITH CARON
0x011C, 0x011D, //LATIN CAPITAL LETTER G WITH CIRCUMFLEX	LATIN SMALL LETTER G WITH CIRCUMFLEX
0x011E, 0x011F, //LATIN CAPITAL LETTER G WITH BREVE	LATIN SMALL LETTER G WITH BREVE
0x0120, 0x0121, //LATIN CAPITAL LETTER G WITH DOT ABOVE	LATIN SMALL LETTER G WITH DOT ABOVE
0x0122, 0x0123, //LATIN CAPITAL LETTER G WITH CEDILLA	LATIN SMALL LETTER G WITH CEDILLA
0x0124, 0x0125, //LATIN CAPITAL LETTER H WITH CIRCUMFLEX	LATIN SMALL LETTER H WITH CIRCUMFLEX
0x0126, 0x0127, //LATIN CAPITAL LETTER H WITH STROKE	LATIN SMALL LETTER H WITH STROKE
0x0128, 0x0129, //LATIN CAPITAL LETTER I WITH TILDE	LATIN SMALL LETTER I WITH TILDE
0x012A, 0x012B, //LATIN CAPITAL LETTER I WITH MACRON	LATIN SMALL LETTER I WITH MACRON
0x012C, 0x012D, //LATIN CAPITAL LETTER I WITH BREVE	LATIN SMALL LETTER I WITH BREVE
0x012E, 0x012F, //LATIN CAPITAL LETTER I WITH OGONEK	LATIN SMALL LETTER I WITH OGONEK
0x0130, 0x0069, //LATIN CAPITAL LETTER I WITH DOT ABOVE	LATIN SMALL LETTER I
0x0132, 0x0133, //LATIN CAPITAL LIGATURE IJ	LATIN SMALL LIGATURE IJ
0x0134, 0x0135, //LATIN CAPITAL LETTER J WITH CIRCUMFLEX	LATIN SMALL LETTER J WITH CIRCUMFLEX
0x0136, 0x0137, //LATIN CAPITAL LETTER K WITH CEDILLA	LATIN SMALL LETTER K WITH CEDILLA
0x0139, 0x013A, //LATIN CAPITAL LETTER L WITH ACUTE	LATIN SMALL LETTER L WITH ACUTE
0x013B, 0x013C, //LATIN CAPITAL LETTER L WITH CEDILLA	LATIN SMALL LETTER L WITH CEDILLA
0x013D, 0x013E, //LATIN CAPITAL LETTER L WITH CARON	LATIN SMALL LETTER L WITH CARON
0x013F, 0x0140, //LATIN CAPITAL LETTER L WITH MIDDLE DOT	LATIN SMALL LETTER L WITH MIDDLE DOT
0x0141, 0x0142, //LATIN CAPITAL LETTER L WITH STROKE	LATIN SMALL LETTER L WITH STROKE
0x0143, 0x0144, //LATIN CAPITAL LETTER N WITH ACUTE	LATIN SMALL LETTER N WITH ACUTE
0x0145, 0x0146, //LATIN CAPITAL LETTER N WITH CEDILLA	LATIN SMALL LETTER N WITH CEDILLA
0x0147, 0x0148, //LATIN CAPITAL LETTER N WITH CARON	LATIN SMALL LETTER N WITH CARON
0x014A, 0x014B, //LATIN CAPITAL LETTER ENG (SAMI)	LATIN SMALL LETTER ENG (SAMI)
0x014C, 0x014D, //LATIN CAPITAL LETTER O WITH MACRON	LATIN SMALL LETTER O WITH MACRON
0x014E, 0x014F, //LATIN CAPITAL LETTER O WITH BREVE	LATIN SMALL LETTER O WITH BREVE
0x0150, 0x0151, //LATIN CAPITAL LETTER O WITH DOUBLE ACUTE	LATIN SMALL LETTER O WITH DOUBLE ACUTE
0x0152, 0x0153, //LATIN CAPITAL LIGATURE OE	LATIN SMALL LIGATURE OE
0x0154, 0x0155, //LATIN CAPITAL LETTER R WITH ACUTE	LATIN SMALL LETTER R WITH ACUTE
0x0156, 0x0157, //LATIN CAPITAL LETTER R WITH CEDILLA	LATIN SMALL LETTER R WITH CEDILLA
0x0158, 0x0159, //LATIN CAPITAL LETTER R WITH CARON	LATIN SMALL LETTER R WITH CARON
0x015A, 0x015B, //LATIN CAPITAL LETTER S WITH ACUTE	LATIN SMALL LETTER S WITH ACUTE
0x015C, 0x015D, //LATIN CAPITAL LETTER S WITH CIRCUMFLEX	LATIN SMALL LETTER S WITH CIRCUMFLEX
0x015E, 0x015F, //LATIN CAPITAL LETTER S WITH CEDILLA	LATIN SMALL LETTER S WITH CEDILLA
0x0160, 0x0161, //LATIN CAPITAL LETTER S WITH CARON	LATIN SMALL LETTER S WITH CARON
0x0162, 0x0163, //LATIN CAPITAL LETTER T WITH CEDILLA	LATIN SMALL LETTER T WITH CEDILLA
0x0164, 0x0165, //LATIN CAPITAL LETTER T WITH CARON	LATIN SMALL LETTER T WITH CARON
0x0166, 0x0167, //LATIN CAPITAL LETTER T WITH STROKE	LATIN SMALL LETTER T WITH STROKE
0x0168, 0x0169, //LATIN CAPITAL LETTER U WITH TILDE	LATIN SMALL LETTER U WITH TILDE
0x016A, 0x016B, //LATIN CAPITAL LETTER U WITH MACRON	LATIN SMALL LETTER U WITH MACRON
0x016C, 0x016D, //LATIN CAPITAL LETTER U WITH BREVE	LATIN SMALL LETTER U WITH BREVE
0x016E, 0x016F, //LATIN CAPITAL LETTER U WITH RING ABOVE	LATIN SMALL LETTER U WITH RING ABOVE
0x0170, 0x0171, //LATIN CAPITAL LETTER U WITH DOUBLE ACUTE	LATIN SMALL LETTER U WITH DOUBLE ACUTE
0x0172, 0x0173, //LATIN CAPITAL LETTER U WITH OGONEK	LATIN SMALL LETTER U WITH OGONEK
0x0174, 0x0175, //LATIN CAPITAL LETTER W WITH CIRCUMFLEX	LATIN SMALL LETTER W WITH CIRCUMFLEX
0x0176, 0x0177, //LATIN CAPITAL LETTER Y WITH CIRCUMFLEX	LATIN SMALL LETTER Y WITH CIRCUMFLEX
0x0178, 0x00FF, //LATIN CAPITAL LETTER Y WITH DIAERESIS	LATIN SMALL LETTER Y DIAERESIS
0x0179, 0x017A, //LATIN CAPITAL LETTER Z WITH ACUTE	LATIN SMALL LETTER Z WITH ACUTE
0x017B, 0x017C, //LATIN CAPITAL LETTER Z WITH DOT ABOVE	LATIN SMALL LETTER Z WITH DOT ABOVE
0x017D, 0x017E, //LATIN CAPITAL LETTER Z WITH CARON	LATIN SMALL LETTER Z WITH CARON
0x0181, 0x0253, //LATIN CAPITAL LETTER B WITH HOOK	LATIN SMALL LETTER B WITH HOOK
0x0182, 0x0183, //LATIN CAPITAL LETTER B WITH TOPBAR	LATIN SMALL LETTER B WITH TOPBAR
0x0184, 0x0185, //LATIN CAPITAL LETTER TONE SIX	LATIN SMALL LETTER TONE SIX
0x0186, 0x0254, //LATIN CAPITAL LETTER OPEN O	LATIN SMALL LETTER OPEN O
0x0187, 0x0188, //LATIN CAPITAL LETTER C WITH HOOK	LATIN SMALL LETTER C WITH HOOK
0x018A, 0x0257, //LATIN CAPITAL LETTER D WITH HOOK	LATIN SMALL LETTER D WITH HOOK
0x018B, 0x018C, //LATIN CAPITAL LETTER D WITH TOPBAR	LATIN SMALL LETTER D WITH TOPBAR
0x018E, 0x0258, //LATIN CAPITAL LETTER REVERSED E	LATIN SMALL LETTER REVERSED E
0x018F, 0x0259, //LATIN CAPITAL LETTER SCHWA	LATIN SMALL LETTER SCHWA
0x0190, 0x025B, //LATIN CAPITAL LETTER OPEN E	LATIN SMALL LETTER OPEN E
0x0191, 0x0192, //LATIN CAPITAL LETTER F WITH HOOK	LATIN SMALL LETTER F WITH HOOK
0x0193, 0x0260, //LATIN CAPITAL LETTER G WITH HOOK	LATIN SMALL LETTER G WITH HOOK
0x0194, 0x0263, //LATIN CAPITAL LETTER GAMMA	LATIN SMALL LETTER GAMMA
0x0196, 0x0269, //LATIN CAPITAL LETTER IOTA	LATIN SMALL LETTER IOTA
0x0197, 0x0268, //LATIN CAPITAL LETTER I WITH STROKE	LATIN SMALL LETTER I WITH STROKE
0x0198, 0x0199, //LATIN CAPITAL LETTER K WITH HOOK	LATIN SMALL LETTER K WITH HOOK
0x019C, 0x026f, //LATIN CAPITAL LETTER TURNED M	LATIN SMALL LETTER TURNED M
0x019D, 0x0272, //LATIN CAPITAL LETTER N WITH LEFT HOOK	LATIN SMALL LETTER N WITH LEFT HOOK
0x019F, 0x0275, //LATIN CAPITAL LETTER O WITH MIDDLE TILDE	LATIN SMALL LETTER BARRED O
0x01A0, 0x01A1, //LATIN CAPITAL LETTER O WITH HORN	LATIN SMALL LETTER O WITH HORN
0x01A2, 0x01A3, //LATIN CAPITAL LETTER OI	LATIN SMALL LETTER OI
0x01A4, 0x01A5, //LATIN CAPITAL LETTER P WITH HOOK	LATIN SMALL LETTER P WITH HOOK
0x01A7, 0x01A8, //LATIN CAPITAL LETTER TONE TWO	LATIN SMALL LETTER TONE TWO
0x01A9, 0x0283, //LATIN CAPITAL LETTER ESH	LATIN SMALL LETTER ESH
0x01AC, 0x01AD, //LATIN CAPITAL LETTER T WITH HOOK	LATIN SMALL LETTER T WITH HOOK
0x01AE, 0x0288, //LATIN CAPITAL LETTER T WITH RETROFLEX HOOK	LATIN SMALL LETTER T WITH RETROFLEX HOOK
0x01AF, 0x01B0, //LATIN CAPITAL LETTER U WITH HORN	LATIN SMALL LETTER U WITH HORN
0x01B1, 0x028A, //LATIN CAPITAL LETTER UPSILON	LATIN SMALL LETTER UPSILON
0x01B2, 0x028B, //LATIN CAPITAL LETTER V WITH HOOK	LATIN SMALL LETTER V WITH HOOK
0x01B3, 0x01B4, //LATIN CAPITAL LETTER Y WITH HOOK	LATIN SMALL LETTER Y WITH HOOK
0x01B5, 0x01B6, //LATIN CAPITAL LETTER Z WITH STROKE	LATIN SMALL LETTER Z WITH STROKE
0x01B7, 0x0292, //LATIN CAPITAL LETTER EZH	LATIN SMALL LETTER EZH
0x01B8, 0x01B9, //LATIN CAPITAL LETTER EZH REVERSED	LATIN SMALL LETTER EZH REVERSED
0x01BC, 0x01BD, //LATIN CAPITAL LETTER TONE FIVE	LATIN SMALL LETTER TONE FIVE
0x01C4, 0x01C6, //LATIN CAPITAL LETTER DZ WITH CARON	LATIN SMALL LETTER DZ WITH CARON
0x01C5, 0x01C6, //LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON	LATIN SMALL LETTER DZ WITH CARON
0x01C7, 0x01C9, //LATIN CAPITAL LETTER LJ	LATIN SMALL LETTER LJ
0x01C8, 0x01C9, //LATIN CAPITAL LETTER L WITH SMALL LETTER J	LATIN SMALL LETTER LJ
0x01CA, 0x01CC, //LATIN CAPITAL LETTER NJ	LATIN SMALL LETTER NJ
0x01CB, 0x01CC, //LATIN CAPITAL LETTER N WITH SMALL LETTER J	LATIN SMALL LETTER NJ
0x01CD, 0x01CE, //LATIN CAPITAL LETTER A WITH CARON	LATIN SMALL LETTER A WITH CARON
0x01CF, 0x01D0, //LATIN CAPITAL LETTER I WITH CARON	LATIN SMALL LETTER I WITH CARON
0x01D1, 0x01D2, //LATIN CAPITAL LETTER O WITH CARON	LATIN SMALL LETTER O WITH CARON
0x01D3, 0x01D4, //LATIN CAPITAL LETTER U WITH CARON	LATIN SMALL LETTER U WITH CARON
0x01D5, 0x01D6, //LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON	LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
0x01D7, 0x01D8, //LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE	LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
0x01D9, 0x01DA, //LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON	LATIN SMALL LETTER U WITH DIAERESIS AND CARON
0x01DB, 0x01DC, //LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE	LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
0x01DE, 0x01DF, //LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON	LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
0x01E0, 0x01E1, //LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON	LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
0x01E2, 0x01E3, //LATIN CAPITAL LIGATURE AE WITH MACRON	LATIN SMALL LIGATURE AE WITH MACRON
0x01E4, 0x01E5, //LATIN CAPITAL LETTER G WITH STROKE	LATIN SMALL LETTER G WITH STROKE
0x01E6, 0x01E7, //LATIN CAPITAL LETTER G WITH CARON	LATIN SMALL LETTER G WITH CARON
0x01E8, 0x01E9, //LATIN CAPITAL LETTER K WITH CARON	LATIN SMALL LETTER K WITH CARON
0x01EA, 0x01EB, //LATIN CAPITAL LETTER O WITH OGONEK	LATIN SMALL LETTER O WITH OGONEK
0x01EC, 0x01ED, //LATIN CAPITAL LETTER O WITH OGONEK AND MACRON	LATIN SMALL LETTER O WITH OGONEK AND MACRON
0x01EE, 0x01EF, //LATIN CAPITAL LETTER EZH WITH CARON	LATIN SMALL LETTER EZH WITH CARON
0x01F1, 0x01F3, //LATIN CAPITAL LETTER DZ	LATIN SMALL LETTER DZ
0x01F4, 0x01F5, //LATIN CAPITAL LETTER G WITH ACUTE	LATIN SMALL LETTER G WITH ACUTE
0x01FA, 0x01FB, //LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE	LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
0x01FC, 0x01FD, //LATIN CAPITAL LIGATURE AE WITH ACUTE	LATIN SMALL LIGATURE AE WITH ACUTE
0x01FE, 0x01FF, //LATIN CAPITAL LETTER O WITH STROKE AND ACUTE	LATIN SMALL LETTER O WITH STROKE AND ACUTE
0x0200, 0x0201, //LATIN CAPITAL LETTER A WITH DOUBLE GRAVE	LATIN SMALL LETTER A WITH DOUBLE GRAVE
0x0202, 0x0203, //LATIN CAPITAL LETTER A WITH INVERTED BREVE	LATIN SMALL LETTER A WITH INVERTED BREVE
0x0204, 0x0205, //LATIN CAPITAL LETTER E WITH DOUBLE GRAVE	LATIN SMALL LETTER E WITH DOUBLE GRAVE
0x0206, 0x0207, //LATIN CAPITAL LETTER E WITH INVERTED BREVE	LATIN SMALL LETTER E WITH INVERTED BREVE
0x0208, 0x0209, //LATIN CAPITAL LETTER I WITH DOUBLE GRAVE	LATIN SMALL LETTER I WITH DOUBLE GRAVE
0x020A, 0x020B, //LATIN CAPITAL LETTER I WITH INVERTED BREVE	LATIN SMALL LETTER I WITH INVERTED BREVE
0x020C, 0x020D, //LATIN CAPITAL LETTER O WITH DOUBLE GRAVE	LATIN SMALL LETTER O WITH DOUBLE GRAVE
0x020E, 0x020F, //LATIN CAPITAL LETTER O WITH INVERTED BREVE	LATIN SMALL LETTER O WITH INVERTED BREVE
0x0210, 0x0211, //LATIN CAPITAL LETTER R WITH DOUBLE GRAVE	LATIN SMALL LETTER R WITH DOUBLE GRAVE
0x0212, 0x0213, //LATIN CAPITAL LETTER R WITH INVERTED BREVE	LATIN SMALL LETTER R WITH INVERTED BREVE
0x0214, 0x0215, //LATIN CAPITAL LETTER U WITH DOUBLE GRAVE	LATIN SMALL LETTER U WITH DOUBLE GRAVE
0x0216, 0x0217, //LATIN CAPITAL LETTER U WITH INVERTED BREVE	LATIN SMALL LETTER U WITH INVERTED BREVE
0x0386, 0x03AC, //GREEK CAPITAL LETTER ALPHA WITH TONOS	GREEK SMALL LETTER ALPHA WITH TONOS
0x0388, 0x03AD, //GREEK CAPITAL LETTER EPSILON WITH TONOS	GREEK SMALL LETTER EPSILON WITH TONOS
0x0389, 0x03AE, //GREEK CAPITAL LETTER ETA WITH TONOS	GREEK SMALL LETTER ETA WITH TONOS
0x038A, 0x03AF, //GREEK CAPITAL LETTER IOTA WITH TONOS	GREEK SMALL LETTER IOTA WITH TONOS
0x038C, 0x03CC, //GREEK CAPITAL LETTER OMICRON WITH TONOS	GREEK SMALL LETTER OMICRON WITH TONOS
0x038E, 0x03CD, //GREEK CAPITAL LETTER UPSILON WITH TONOS	GREEK SMALL LETTER UPSILON WITH TONOS
0x038F, 0x03CE, //GREEK CAPITAL LETTER OMEGA WITH TONOS	GREEK SMALL LETTER OMEGA WITH TONOS
0x0391, 0x03B1, //GREEK CAPITAL LETTER ALPHA	GREEK SMALL LETTER ALPHA
0x0392, 0x03B2, //GREEK CAPITAL LETTER BETA	GREEK SMALL LETTER BETA
0x0393, 0x03B3, //GREEK CAPITAL LETTER GAMMA	GREEK SMALL LETTER GAMMA
0x0394, 0x03B4, //GREEK CAPITAL LETTER DELTA	GREEK SMALL LETTER DELTA
0x0395, 0x03B5, //GREEK CAPITAL LETTER EPSILON	GREEK SMALL LETTER EPSILON
0x0396, 0x03B6, //GREEK CAPITAL LETTER ZETA	GREEK SMALL LETTER ZETA
0x0397, 0x03B7, //GREEK CAPITAL LETTER ETA	GREEK SMALL LETTER ETA
0x0398, 0x03B8, //GREEK CAPITAL LETTER THETA	GREEK SMALL LETTER THETA
0x0399, 0x03B9, //GREEK CAPITAL LETTER IOTA	GREEK SMALL LETTER IOTA
0x039A, 0x03BA, //GREEK CAPITAL LETTER KAPPA	GREEK SMALL LETTER KAPPA
0x039B, 0x03BB, //GREEK CAPITAL LETTER LAMDA	GREEK SMALL LETTER LAMDA
0x039C, 0x03BC, //GREEK CAPITAL LETTER MU	GREEK SMALL LETTER MU
0x039D, 0x03BD, //GREEK CAPITAL LETTER NU	GREEK SMALL LETTER NU
0x039E, 0x03BE, //GREEK CAPITAL LETTER XI	GREEK SMALL LETTER XI
0x039F, 0x03BF, //GREEK CAPITAL LETTER OMICRON	GREEK SMALL LETTER OMICRON
0x03A0, 0x03C0, //GREEK CAPITAL LETTER PI	GREEK SMALL LETTER PI
0x03A1, 0x03C1, //GREEK CAPITAL LETTER RHO	GREEK SMALL LETTER RHO
0x03A3, 0x03C3, //GREEK CAPITAL LETTER SIGMA	GREEK SMALL LETTER SIGMA
0x03A4, 0x03C4, //GREEK CAPITAL LETTER TAU	GREEK SMALL LETTER TAU
0x03A5, 0x03C5, //GREEK CAPITAL LETTER UPSILON	GREEK SMALL LETTER UPSILON
0x03A6, 0x03C6, //GREEK CAPITAL LETTER PHI	GREEK SMALL LETTER PHI
0x03A7, 0x03C7, //GREEK CAPITAL LETTER CHI	GREEK SMALL LETTER CHI
0x03A8, 0x03C8, //GREEK CAPITAL LETTER PSI	GREEK SMALL LETTER PSI
0x03A9, 0x03C9, //GREEK CAPITAL LETTER OMEGA	GREEK SMALL LETTER OMEGA
0x03AA, 0x03CA, //GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	GREEK SMALL LETTER IOTA WITH DIALYTIKA
0x03AB, 0x03CB, //GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA	GREEK SMALL LETTER UPSILON WITH DIALYTIKA
0x03E2, 0x03E3, //COPTIC CAPITAL LETTER SHEI	COPTIC SMALL LETTER SHEI
0x03E4, 0x03E5, //COPTIC CAPITAL LETTER FEI	COPTIC SMALL LETTER FEI
0x03E6, 0x03E7, //COPTIC CAPITAL LETTER KHEI	COPTIC SMALL LETTER KHEI
0x03E8, 0x03E9, //COPTIC CAPITAL LETTER HORI	COPTIC SMALL LETTER HORI
0x03EA, 0x03EB, //COPTIC CAPITAL LETTER GANGIA	COPTIC SMALL LETTER GANGIA
0x03EC, 0x03ED, //COPTIC CAPITAL LETTER SHIMA	COPTIC SMALL LETTER SHIMA
0x03EE, 0x03EF, //COPTIC CAPITAL LETTER DEI	COPTIC SMALL LETTER DEI
0x0401, 0x0451, //CYRILLIC CAPITAL LETTER IO	CYRILLIC SMALL LETTER IO
0x0402, 0x0452, //CYRILLIC CAPITAL LETTER DJE (SERBOCROATIAN)	CYRILLIC SMALL LETTER DJE (SERBOCROATIAN)
0x0403, 0x0453, //CYRILLIC CAPITAL LETTER GJE	CYRILLIC SMALL LETTER GJE
0x0404, 0x0454, //CYRILLIC CAPITAL LETTER UKRAINIAN IE	CYRILLIC SMALL LETTER UKRAINIAN IE
0x0405, 0x0455, //CYRILLIC CAPITAL LETTER DZE	CYRILLIC SMALL LETTER DZE
0x0406, 0x0456, //CYRILLIC CAPITAL LETTER BYELORUSSIAN_UKRAINIAN I	CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I
0x0407, 0x0457, //CYRILLIC CAPITAL LETTER YI (UKRAINIAN)	CYRILLIC SMALL LETTER YI (UKRAINIAN)
0x0408, 0x0458, //CYRILLIC CAPITAL LETTER JE	CYRILLIC SMALL LETTER JE
0x0409, 0x0459, //CYRILLIC CAPITAL LETTER LJE	CYRILLIC SMALL LETTER LJE
0x040A, 0x045A, //CYRILLIC CAPITAL LETTER NJE	CYRILLIC SMALL LETTER NJE
0x040B, 0x045B, //CYRILLIC CAPITAL LETTER TSHE (SERBOCROATIAN)	CYRILLIC SMALL LETTER TSHE (SERBOCROATIAN)
0x040C, 0x045C, //CYRILLIC CAPITAL LETTER KJE	CYRILLIC SMALL LETTER KJE
0x040E, 0x045E, //CYRILLIC CAPITAL LETTER SHORT U (BYELORUSSIAN)	CYRILLIC SMALL LETTER SHORT U (BYELORUSSIAN)
0x040F, 0x045F, //CYRILLIC CAPITAL LETTER DZHE	CYRILLIC SMALL LETTER DZHE
0x0410, 0x0430, //CYRILLIC CAPITAL LETTER A	CYRILLIC SMALL LETTER A
0x0411, 0x0431, //CYRILLIC CAPITAL LETTER BE	CYRILLIC SMALL LETTER BE
0x0412, 0x0432, //CYRILLIC CAPITAL LETTER VE	CYRILLIC SMALL LETTER VE
0x0413, 0x0433, //CYRILLIC CAPITAL LETTER GHE	CYRILLIC SMALL LETTER GHE
0x0414, 0x0434, //CYRILLIC CAPITAL LETTER DE	CYRILLIC SMALL LETTER DE
0x0415, 0x0435, //CYRILLIC CAPITAL LETTER IE	CYRILLIC SMALL LETTER IE
0x0416, 0x0436, //CYRILLIC CAPITAL LETTER ZHE	CYRILLIC SMALL LETTER ZHE
0x0417, 0x0437, //CYRILLIC CAPITAL LETTER ZE	CYRILLIC SMALL LETTER ZE
0x0418, 0x0438, //CYRILLIC CAPITAL LETTER I	CYRILLIC SMALL LETTER I
0x0419, 0x0439, //CYRILLIC CAPITAL LETTER SHORT I	CYRILLIC SMALL LETTER SHORT I
0x041A, 0x043A, //CYRILLIC CAPITAL LETTER KA	CYRILLIC SMALL LETTER KA
0x041B, 0x043B, //CYRILLIC CAPITAL LETTER EL	CYRILLIC SMALL LETTER EL
0x041C, 0x043C, //CYRILLIC CAPITAL LETTER EM	CYRILLIC SMALL LETTER EM
0x041D, 0x043D, //CYRILLIC CAPITAL LETTER EN	CYRILLIC SMALL LETTER EN
0x041E, 0x043E, //CYRILLIC CAPITAL LETTER O	CYRILLIC SMALL LETTER O
0x041F, 0x043F, //CYRILLIC CAPITAL LETTER PE	CYRILLIC SMALL LETTER PE
0x0420, 0x0440, //CYRILLIC CAPITAL LETTER ER	CYRILLIC SMALL LETTER ER
0x0421, 0x0441, //CYRILLIC CAPITAL LETTER ES	CYRILLIC SMALL LETTER ES
0x0422, 0x0442, //CYRILLIC CAPITAL LETTER TE	CYRILLIC SMALL LETTER TE
0x0423, 0x0443, //CYRILLIC CAPITAL LETTER U	CYRILLIC SMALL LETTER U
0x0424, 0x0444, //CYRILLIC CAPITAL LETTER EF	CYRILLIC SMALL LETTER EF
0x0425, 0x0445, //CYRILLIC CAPITAL LETTER HA	CYRILLIC SMALL LETTER HA
0x0426, 0x0446, //CYRILLIC CAPITAL LETTER TSE	CYRILLIC SMALL LETTER TSE
0x0427, 0x0447, //CYRILLIC CAPITAL LETTER CHE	CYRILLIC SMALL LETTER CHE
0x0428, 0x0448, //CYRILLIC CAPITAL LETTER SHA	CYRILLIC SMALL LETTER SHA
0x0429, 0x0449, //CYRILLIC CAPITAL LETTER SHCHA	CYRILLIC SMALL LETTER SHCHA
0x042A, 0x044A, //CYRILLIC CAPITAL LETTER HARD SIGN	CYRILLIC SMALL LETTER HARD SIGN
0x042B, 0x044B, //CYRILLIC CAPITAL LETTER YERU	CYRILLIC SMALL LETTER YERU
0x042C, 0x044C, //CYRILLIC CAPITAL LETTER SOFT SIGN	CYRILLIC SMALL LETTER SOFT SIGN
0x042D, 0x044D, //CYRILLIC CAPITAL LETTER E	CYRILLIC SMALL LETTER E
0x042E, 0x044E, //CYRILLIC CAPITAL LETTER YU	CYRILLIC SMALL LETTER YU
0x042F, 0x044F, //CYRILLIC CAPITAL LETTER YA	CYRILLIC SMALL LETTER YA
0x0460, 0x0461, //CYRILLIC CAPITAL LETTER OMEGA	CYRILLIC SMALL LETTER OMEGA
0x0462, 0x0463, //CYRILLIC CAPITAL LETTER YAT	CYRILLIC SMALL LETTER YAT
0x0464, 0x0465, //CYRILLIC CAPITAL LETTER IOTIFIED E	CYRILLIC SMALL LETTER IOTIFIED E
0x0466, 0x0467, //CYRILLIC CAPITAL LETTER LITTLE YUS	CYRILLIC SMALL LETTER LITTLE YUS
0x0468, 0x0469, //CYRILLIC CAPITAL LETTER IOTIFIED LITTLE YUS	CYRILLIC SMALL LETTER IOTIFIED LITTLE YUS
0x046A, 0x046B, //CYRILLIC CAPITAL LETTER BIG YUS	CYRILLIC SMALL LETTER BIG YUS
0x046C, 0x046D, //CYRILLIC CAPITAL LETTER IOTIFIED BIG YUS	CYRILLIC SMALL LETTER IOTIFIED BIG YUS
0x046E, 0x046F, //CYRILLIC CAPITAL LETTER KSI	CYRILLIC SMALL LETTER KSI
0x0470, 0x0471, //CYRILLIC CAPITAL LETTER PSI	CYRILLIC SMALL LETTER PSI
0x0472, 0x0473, //CYRILLIC CAPITAL LETTER FITA	CYRILLIC SMALL LETTER FITA
0x0474, 0x0475, //CYRILLIC CAPITAL LETTER IZHITSA	CYRILLIC SMALL LETTER IZHITSA
0x0476, 0x0477, //CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT	CYRILLIC SMALL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT
0x0478, 0x0479, //CYRILLIC CAPITAL LETTER UK	CYRILLIC SMALL LETTER UK
0x047A, 0x047B, //CYRILLIC CAPITAL LETTER ROUND OMEGA	CYRILLIC SMALL LETTER ROUND OMEGA
0x047C, 0x047D, //CYRILLIC CAPITAL LETTER OMEGA WITH TITLO	CYRILLIC SMALL LETTER OMEGA WITH TITLO
0x047E, 0x047F, //CYRILLIC CAPITAL LETTER OT	CYRILLIC SMALL LETTER OT
0x0480, 0x0481, //CYRILLIC CAPITAL LETTER KOPPA	CYRILLIC SMALL LETTER KOPPA
0x0490, 0x0491, //CYRILLIC CAPITAL LETTER GHE WITH UPTURN	CYRILLIC SMALL LETTER GHE WITH UPTURN
0x0492, 0x0493, //CYRILLIC CAPITAL LETTER GHE WITH STROKE	CYRILLIC SMALL LETTER GHE WITH STROKE
0x0494, 0x0495, //CYRILLIC CAPITAL LETTER GHE WITH MIDDLE HOOK	CYRILLIC SMALL LETTER GHE WITH MIDDLE HOOK
0x0496, 0x0497, //CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER	CYRILLIC SMALL LETTER ZHE WITH DESCENDER
0x0498, 0x0499, //CYRILLIC CAPITAL LETTER ZE WITH DESCENDER	CYRILLIC SMALL LETTER ZE WITH DESCENDER
0x049A, 0x049B, //CYRILLIC CAPITAL LETTER KA WITH DESCENDER	CYRILLIC SMALL LETTER KA WITH DESCENDER
0x049C, 0x049D, //CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE	CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE
0x049E, 0x049F, //CYRILLIC CAPITAL LETTER KA WITH STROKE	CYRILLIC SMALL LETTER KA WITH STROKE
0x04A0, 0x04A1, //CYRILLIC CAPITAL LETTER BASHKIR KA	CYRILLIC SMALL LETTER EASHKIR KA
0x04A2, 0x04A3, //CYRILLIC CAPITAL LETTER EN WITH DESCENDER	CYRILLIC SMALL LETTER EN WITH DESCENDER
0x04A4, 0x04A5, //CYRILLIC CAPITAL LIGATURE EN GHF	CYRILLIC SMALL LIGATURE EN GHE
0x04A6, 0x04A7, //CYRILLIC CAPITAL LETTER PE WITH MIDDLE HOOK (ABKHASIAN)	CYRILLIC SMALL LETTER PE WITH MIDDLE HOOK (ABKHASIAN)
0x04A8, 0x04A9, //CYRILLIC CAPITAL LETTER ABKHASIAN HA	CYRILLIC SMALL LETTER ABKHASIAN HA
0x04AA, 0x04AB, //CYRILLIC CAPITAL LETTER ES WITH DESCENDER	CYRILLIC SMALL LETTER ES WITH DESCENDER
0x04AC, 0x04AD, //CYRILLIC CAPITAL LETTER TE WITH DESCENDER	CYRILLIC SMALL LETTER TE WITH DESCENDER
0x04AE, 0x04AF, //CYRILLIC CAPITAL LETTER STRAIGHT U	CYRILLIC SMALL LETTER STRAIGHT U
0x04B0, 0x04B1, //CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE	CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE
0x04B2, 0x04B3, //CYRILLIC CAPITAL LETTER HA WITH DESCENDER	CYRILLIC SMALL LETTER HA WITH DESCENDER
0x04B4, 0x04B5, //CYRILLIC CAPITAL LIGATURE TE TSE (ABKHASIAN)	CYRILLIC SMALL LIGATURE TE TSE (ABKHASIAN)
0x04B6, 0x04B7, //CYRILLIC CAPITAL LETTER CHE WITH DESCENDER	CYRILLIC SMALL LETTER CHE WITH DESCENDER
0x04B8, 0x04B9, //CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE	CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE
0x04BA, 0x04BB, //CYRILLIC CAPITAL LETTER SHHA	CYRILLIC SMALL LETTER SHHA
0x04BC, 0x04BD, //CYRILLIC CAPITAL LETTER ABKHASIAN CHE	CYRILLIC SMALL LETTER ABKHASIAN CHE
0x04BE, 0x04BF, //CYRILLIC CAPITAL LETTER ABKHASIAN CHE WITH DESCENDER	CYRILLIC SMALL LETTER ABKHASIAN CHE WITH DESCENDER
0x04C1, 0x04C2, //CYRILLIC CAPITAL LETTER ZHE WITH BREVE	CYRILLIC SMALL LETTER ZHE WITH BREVE
0x04C3, 0x04C4, //CYRILLIC CAPITAL LETTER KA WITH HOOK	CYRILLIC SMALL LETTER KA WITH HOOK
0x04C7, 0x04C8, //CYRILLIC CAPITAL LETTER EN WITH HOOK	CYRILLIC SMALL LETTER EN WITH HOOK
0x04CB, 0x04CC, //CYRILLIC CAPITAL LETTER KHAKASSIAN CHE	CYRILLIC SMALL LETTER KHAKASSIAN CHE
0x04D0, 0x04D1, //CYRILLIC CAPITAL LETTER A WITH BREVE	CYRILLIC SMALL LETTER A WITH BREVE
0x04D2, 0x04D3, //CYRILLIC CAPITAL LETTER A WITH DIAERESIS	CYRILLIC SMALL LETTER A WITH DIAERESIS
0x04D4, 0x04D5, //CYRILLIC CAPITAL LIGATURE A IE	CYRILLIC SMALL LIGATURE A IE
0x04D6, 0x04D7, //CYRILLIC CAPITAL LETTER IE WITH BREVE	CYRILLIC SMALL LETTER IE WITH BREVE
0x04D8, 0x04D9, //CYRILLIC CAPITAL LETTER SCHWA	CYRILLIC SMALL LETTER SCHWA
0x04DA, 0x04DB, //CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS	CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS
0x04DC, 0x04DD, //CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS	CYRILLIC SMALL LETTER ZHE WITH DIAERESIS
0x04DE, 0x04DF, //CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS	CYRILLIC SMALL LETTER ZE WITH DIAERESIS
0x04E0, 0x04E1, //CYRILLIC CAPITAL LETTER ABKHASIAN DZE	CYRILLIC SMALL LETTER ABKHASIAN DZE
0x04E2, 0x04E3, //CYRILLIC CAPITAL LETTER I WITH MACRON	CYRILLIC SMALL LETTER I WITH MACRON
0x04E4, 0x04E5, //CYRILLIC CAPITAL LETTER I WITH DIAERESIS	CYRILLIC SMALL LETTER I WITH DIAERESIS
0x04E6, 0x04E7, //CYRILLIC CAPITAL LETTER O WITH DIAERESIS	CYRILLIC SMALL LETTER O WITH DIAERESIS
0x04E8, 0x04E9, //CYRILLIC CAPITAL LETTER BARRED O	CYRILLIC SMALL LETTER BARRED O
0x04EA, 0x04EB, //CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS	CYRILLIC SMALL LETTER BARRED 0 WITH DIAERESIS
0x04EE, 0x04EF, //CYRILLIC CAPITAL LETTER U WITH MACRON	CYRILLIC SMALL LETTER U WITH MACRON
0x04F0, 0x04F1, //CYRILLIC CAPITAL LETTER U WITH DIAERESIS	CYRILLIC SMALL LETTER U WITH DIAERESIS
0x04F2, 0x04F3, //CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE	CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE
0x04F4, 0x04F5, //CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS	CYRILLIC SMALL LETTER CHE WITH DIAERESIS
0x04F8, 0x04F9, //CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS	CYRILLIC SMALL LETTER YERU WITH DIAERESIS
0x0531, 0x0561, //ARMENIAN CAPITAL LETTER AYB	ARMENIAN SMALL LETTER AYB
0x0532, 0x0562, //ARMENIAN CAPITAL LETTER BEN	ARMENIAN SMALL LETTER BEN
0x0533, 0x0563, //ARMENIAN CAPITAL LETTER GIM	ARMENIAN SMALL LETTER GIM
0x0534, 0x0564, //ARMENIAN CAPITAL LETTER DA	ARMENIAN SMALL LETTER DA
0x0535, 0x0565, //ARMENIAN CAPITAL LETTER ECH	ARMENIAN SMALL LETTER ECH
0x0536, 0x0566, //ARMENIAN CAPITAL LETTER ZA	ARMENIAN SMALL LETTER ZA
0x0537, 0x0567, //ARMENIAN CAPITAL LETTER EH	ARMENIAN SMALL LETTER EH
0x0538, 0x0568, //ARMENIAN CAPITAL LETTER ET	ARMENIAN SMALL LETTER ET
0x0539, 0x0569, //ARMENIAN CAPITAL LETTER TO	ARMENIAN SMALL LETTER TO
0x053A, 0x056A, //ARMENIAN CAPITAL LETTER ZHE	ARMENIAN SMALL LETTER ZHE
0x053B, 0x056B, //ARMENIAN CAPITAL LETTER INI	ARMENIAN SMALL LETTER INI
0x053C, 0x056C, //ARMENIAN CAPITAL LETTER LIWN	ARMENIAN SMALL LETTER LIWN
0x053D, 0x056D, //ARMENIAN CAPITAL LETTER XEH	ARMENIAN SMALL LETTER XEH
0x053E, 0x056E, //ARMENIAN CAPITAL LETTER CA	ARMENIAN SMALL LETTER CA
0x053F, 0x056F, //ARMENIAN CAPITAL LETTER KEN	ARMENIAN SMALL LETTER KEN
0x0540, 0x0570, //ARMENIAN CAPITAL LETTER HO	ARMENIAN SMALL LETTER HO
0x0541, 0x0571, //ARMENIAN CAPITAL LETTER JA	ARMENIAN SMALL LETTER JA
0x0542, 0x0572, //ARMENIAN CAPITAL LETTER GHAD	ARMENIAN SMALL LETTER GHAD
0x0543, 0x0573, //ARMENIAN CAPITAL LETTER CHEH	ARMENIAN SMALL LETTER CHEH
0x0544, 0x0574, //ARMENIAN CAPITAL LETTER MEN	ARMENIAN SMALL LETTER MEN
0x0545, 0x0575, //ARMENIAN CAPITAL LETTER YI	ARMENIAN SMALL LETTER YI
0x0546, 0x0576, //ARMENIAN CAPITAL LETTER NOW	ARMENIAN SMALL LETTER NOW
0x0547, 0x0577, //ARMENIAN CAPITAL LETTER SHA	ARMENIAN SMALL LETTER SNA
0x0548, 0x0578, //ARMENIAN CAPITAL LETTER VO	ARMENIAN SMALL LETTER VO
0x0549, 0x0579, //ARMENIAN CAPITAL LETTER CHA	ARMENIAN SMALL LETTER CHA
0x054A, 0x057A, //ARMENIAN CAPITAL LETTER PEH	ARMENIAN SMALL LETTER PEH
0x054B, 0x057B, //ARMENIAN CAPITAL LETTER JHEH	ARMENIAN SMALL LETTER JHEH
0x054C, 0x057C, //ARMENIAN CAPITAL LETTER RA	ARMENIAN SMALL LETTER RA
0x054D, 0x057D, //ARMENIAN CAPITAL LETTER SEH	ARMENIAN SMALL LETTER SEH
0x054E, 0x057E, //ARMENIAN CAPITAL LETTER VEW	ARMENIAN SMALL LETTER VEW
0x054F, 0x057F, //ARMENIAN CAPITAL LETTER TIWN	ARMENIAN SMALL LETTER TIWN
0x0550, 0x0580, //ARMENIAN CAPITAL LETTER REH	ARMENIAN SMALL LETTER REH
0x0551, 0x0581, //ARMENIAN CAPITAL LETTER CO	ARMENIAN SMALL LETTER CO
0x0552, 0x0582, //ARMENIAN CAPITAL LETTER YIWN	ARMENIAN SMALL LETTER YIWN
0x0553, 0x0583, //ARMENIAN CAPITAL LETTER PIWR	ARMENIAN SMALL LETTER PIWP
0x0554, 0x0584, //ARMENIAN CAPITAL LETTER KEH	ARMENIAN SMALL LETTER KEH
0x0555, 0x0585, //ARMENIAN CAPITAL LETTER OH	ARMENIAN SMALL LETTER OH
0x0556, 0x0586, //ARMENIAN CAPITAL LETTER FEH	ARMENIAN SMALL LETTER FEH
0x10A0, 0x10D0, //GEORGIAN CAPITAL LETTER AN (KHUTSURI)	GEORGIAN LETTER AN
0x10A1, 0x10D1, //GEORGIAN CAPITAL LETTER BAN (KHUTSURI)	GEORGIAN LETTER BAN
0x10A2, 0x10D2, //GEORGIAN CAPITAL LETTER GAN (KHUTSURI)	GEORGIAN LETTER GAN
0x10A3, 0x10D3, //GEORGIAN CAPITAL LETTER DON (KHUTSURI)	GEORGIAN LETTER DON
0x10A4, 0x10D4, //GEORGIAN CAPITAL LETTER EN (KHUTSURI)	GEORGIAN LETTER EN
0x10A5, 0x10D5, //GEORGIAN CAPITAL LETTER VIN (KHUTSURI)	GEORGIAN LETTER VIN
0x10A6, 0x10D6, //GEORGIAN CAPITAL LETTER ZEN (KHUTSURI)	GEORGIAN LETTER ZEN
0x10A7, 0x10D7, //GEORGIAN CAPITAL LETTER TAN (KHUTSURI)	GEORGIAN LETTER TAN
0x10A8, 0x10D8, //GEORGIAN CAPITAL LETTER IN (KHUTSURI)	GEORGIAN LETTER IN
0x10A9, 0x10D9, //GEORGIAN CAPITAL LETTER KAN (KHUTSURI)	GEORGIAN LETTER KAN
0x10AA, 0x10DA, //GEORGIAN CAPITAL LETTER LAS (KHUTSURI)	GEORGIAN LETTER LAS
0x10AB, 0x10DB, //GEORGIAN CAPITAL LETTER MAN (KHUTSURI)	GEORGIAN LETTER MAN
0x10AC, 0x10DC, //GEORGIAN CAPITAL LETTER NAR (KHUTSURI)	GEORGIAN LETTER NAR
0x10AD, 0x10DD, //GEORGIAN CAPITAL LETTER ON (KHUTSURI)	GEORGIAN LETTER ON
0x10AE, 0x10DE, //GEORGIAN CAPITAL LETTER PAR (KHUTSURI)	GEORGIAN LETTER PAR
0x10AF, 0x10DF, //GEORGIAN CAPITAL LETTER ZHAR (KHUTSURI)	GEORGIAN LETTER ZHAR
0x10B0, 0x10E0, //GEORGIAN CAPITAL LETTER RAE (KHUTSURI)	GEORGIAN LETTER RAE
0x10B1, 0x10E1, //GEORGIAN CAPITAL LETTER SAN (KHUTSURI)	GEORGIAN LETTER SAN
0x10B2, 0x10E2, //GEORGIAN CAPITAL LETTER TAR (KHUTSURI)	GEORGIAN LETTER TAR
0x10B3, 0x10E3, //GEORGIAN CAPITAL LETTER UN (KHUTSURI)	GEORGIAN LETTER UN
0x10B4, 0x10E4, //GEORGIAN CAPITAL LETTER PHAR (KHUTSURI)	GEORGIAN LETTER PHAR
0x10B5, 0x10E5, //GEORGIAN CAPITAL LETTER KHAR (KHUTSURI)	GEORGIAN LETTER KHAR
0x10B6, 0x10E6, //GEORGIAN CAPITAL LETTER GHAN (KHUTSURI)	GEORGIAN LETTER GHAN
0x10B7, 0x10E7, //GEORGIAN CAPITAL LETTER QAR (KHUTSURI)	GEORGIAN LETTER QAR
0x10B8, 0x10E8, //GEORGIAN CAPITAL LETTER SHIN (KHUTSURI)	GEORGIAN LETTER SHIN
0x10B9, 0x10E9, //GEORGIAN CAPITAL LETTER CHIN (KHUTSURI)	GEORGIAN LETTER CHIN
0x10BA, 0x10EA, //GEORGIAN CAPITAL LETTER CAN (KHUTSURI)	GEORGIAN LETTER CAN
0x10BB, 0x10EB, //GEORGIAN CAPITAL LETTER JIL (KHUTSURI)	GEORGIAN LETTER JIL
0x10BC, 0x10EC, //GEORGIAN CAPITAL LETTER CIL (KHUTSURI)	GEORGIAN LETTER CIL
0x10BD, 0x10ED, //GEORGIAN CAPITAL LETTER CHAR (KHUTSURI)	GEORGIAN LETTER CHAR
0x10BE, 0x10EE, //GEORGIAN CAPITAL LETTER XAN (KHUTSURI)	GEORGIAN LETTER XAN
0x10BF, 0x10EF, //GEORGIAN CAPITAL LETTER JHAN (KHUTSURI)	GEORGIAN LETTER JHAN
0x10C0, 0x10F0, //GEORGIAN CAPITAL LETTER HAE (KHUTSURI)	GEORGIAN LETTER HAE
0x10C1, 0x10F1, //GEORGIAN CAPITAL LETTER HE (KHUTSURI)	GEORGIAN LETTER HE
0x10C2, 0x10F2, //GEORGIAN CAPITAL LETTER HIE (KHUTSURI)	GEORGIAN LETTER HIE
0x10C3, 0x10F3, //GEORGIAN CAPITAL LETTER WE (KHUTSURI)	GEORGIAN LETTER WE
0x10C4, 0x10F4, //GEORGIAN CAPITAL LETTER HAR (KHUTSURI)	GEORGIAN LETTER HAR
0x10C5, 0x10F5, //GEORGIAN CAPITAL LETTER HOE (KHUTSURI)	GEORGIAN LETTER HOE
0x1E00, 0x1E01, //LATIN CAPITAL LETTER A WITH RING BELOW	LATIN SMALL LETTER A WITH RING BELOW
0x1E02, 0x1E03, //LATIN CAPITAL LETTER B WITH DOT ABOVE	LATIN SMALL LETTER B WITH DOT ABOVE
0x1E04, 0x1E05, //LATIN CAPITAL LETTER B WITH DOT BELOW	LATIN SMALL LETTER B WITH DOT BELOW
0x1E06, 0x1E07, //LATIN CAPITAL LETTER B WITH LINE BELOW	LATIN SMALL LETTER B WITH LINE BELOW
0x1E08, 0x1E09, //LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE	LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
0x1E0A, 0x1E0B, //LATIN CAPITAL LETTER D WITH DOT ABOVE	LATIN SMALL LETTER D WITH DOT ABOVE
0x1E0C, 0x1E0D, //LATIN CAPITAL LETTER D WITH DOT BELOW	LATIN SMALL LETTER D WITH DOT BELOW
0x1E0E, 0x1E0F, //LATIN CAPITAL LETTER D WITH LINE BELOW	LATIN SMALL LETTER D WITH LINE BELOW
0x1E10, 0x1E11, //LATIN CAPITAL LETTER D WITH CEDILLA	LATIN SMALL LETTER D WITH CEDILLA
0x1E12, 0x1E13, //LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW	LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW
0x1E14, 0x1E15, //LATIN CAPITAL LETTER E WITH MACRON AND GRAVE	LATIN SMALL LETTER E WITH MACRON AND GRAVE
0x1E16, 0x1E17, //LATIN CAPITAL LETTER E WITH MACRON AND ACUTE	LATIN SMALL LETTER E WITH MACRON AND ACUTE
0x1E18, 0x1E19, //LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW	LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW
0x1E1A, 0x1E1B, //LATIN CAPITAL LETTER E WITH TILDE BELOW	LATIN SMALL LETTER E WITH TILDE BELOW
0x1E1C, 0x1E1D, //LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE	LATIN SMALL LETTER E WITH CEDILLA AND BREVE
0x1E1E, 0x1E1F, //LATIN CAPITAL LETTER F WITH DOT ABOVE	LATIN SMALL LETTER F WITH DOT ABOVE
0x1E20, 0x1E21, //LATIN CAPITAL LETTER G WITH MACRON	LATIN SMALL LETTER G WITH MACRON
0x1E22, 0x1E23, //LATIN CAPITAL LETTER H WITH DOT ABOVE	LATIN SMALL LETTER H WITH DOT ABOVE
0x1E24, 0x1E25, //LATIN CAPITAL LETTER H WITH DOT BELOW	LATIN SMALL LETTER H WITH DOT BELOW
0x1E26, 0x1E27, //LATIN CAPITAL LETTER H WITH DIAERESIS	LATIN SMALL LETTER H WITH DIAERESIS
0x1E28, 0x1E29, //LATIN CAPITAL LETTER H WITH CEDILLA	LATIN SMALL LETTER H WITH CEDILLA
0x1E2A, 0x1E2B, //LATIN CAPITAL LETTER H WITH BREVE BELOW	LATIN SMALL LETTER H WITH BREVE BELOW
0x1E2C, 0x1E2D, //LATIN CAPITAL LETTER I WITH TILDE BELOW	LATIN SMALL LETTER I WITH TILDE BELOW
0x1E2E, 0x1E2F, //LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE	LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
0x1E30, 0x1E31, //LATIN CAPITAL LETTER K WITH ACUTE	LATIN SMALL LETTER K WITH ACUTE
0x1E32, 0x1E33, //LATIN CAPITAL LETTER K WITH DOT BELOW	LATIN SMALL LETTER K WITH DOT BELOW
0x1E34, 0x1E35, //LATIN CAPITAL LETTER K WITH LINE BELOW	LATIN SMALL LETTER K WITH LINE BELOW
0x1E36, 0x1E37, //LATIN CAPITAL LETTER L WITH DOT BELOW	LATIN SMALL LETTER L WITH DOT BELOW
0x1E38, 0x1E39, //LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON	LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
0x1E3A, 0x1E3B, //LATIN CAPITAL LETTER L WITH LINE BELOW	LATIN SMALL LETTER L WITH LINE BELOW
0x1E3C, 0x1E3D, //LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW	LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW
0x1E3E, 0x1E3F, //LATIN CAPITAL LETTER M WITH ACUTE	LATIN SMALL LETTER M WITH ACUTE
0x1E40, 0x1E41, //LATIN CAPITAL LETTER M WITH DOT ABOVE	LATIN SMALL LETTER M WITH DOT ABOVE
0x1E42, 0x1E43, //LATIN CAPITAL LETTER M WITH DOT BELOW	LATIN SMALL LETTER M WITH DOT BELOW
0x1E44, 0x1E45, //LATIN CAPITAL LETTER N WITH DOT ABOVE	LATIN SMALL LETTER N WITH DOT ABOVE
0x1E46, 0x1E47, //LATIN CAPITAL LETTER N WITH DOT BELOW	LATIN SMALL LETTER N WITH DOT BELOW
0x1E48, 0x1E49, //LATIN CAPITAL LETTER N WITH LINE BELOW	LATIN SMALL LETTER N WITH LINE BELOW
0x1E4A, 0x1E4B, //LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW	LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW
0x1E4C, 0x1E4D, //LATIN CAPITAL LETTER O WITH TILDE AND ACUTE	LATIN SMALL LETTER O WITH TILDE AND ACUTE
0x1E4E, 0x1E4F, //LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS	LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
0x1E50, 0x1E51, //LATIN CAPITAL LETTER O WITH MACRON AND GRAVE	LATIN SMALL LETTER O WITH MACRON AND GRAVE
0x1E52, 0x1E53, //LATIN CAPITAL LETTER O WITH MACRON AND ACUTE	LATIN SMALL LETTER O WITH MACRON AND ACUTE
0x1E54, 0x1E55, //LATIN CAPITAL LETTER P WITH ACUTE	LATIN SMALL LETTER P WITH ACUTE
0x1E56, 0x1E57, //LATIN CAPITAL LETTER P WITH DOT ABOVE	LATIN SMALL LETTER P WITH DOT ABOVE
0x1E58, 0x1E59, //LATIN CAPITAL LETTER R WITH DOT ABOVE	LATIN SMALL LETTER R WITH DOT ABOVE
0x1E5A, 0x1E5B, //LATIN CAPITAL LETTER R WITH DOT BELOW	LATIN SMALL LETTER R WITH DOT BELOW
0x1E5C, 0x1E5D, //LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON	LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
0x1E5E, 0x1E5F, //LATIN CAPITAL LETTER R WITH LINE BELOW	LATIN SMALL LETTER R WITH LINE BELOW
0x1E60, 0x1E61, //LATIN CAPITAL LETTER S WITH DOT ABOVE	LATIN SMALL LETTER S WITH DOT ABOVE
0x1E62, 0x1E63, //LATIN CAPITAL LETTER S WITH DOT BELOW	LATIN SMALL LETTER S WITH DOT BELOW
0x1E64, 0x1E65, //LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE	LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
0x1E66, 0x1E67, //LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE	LATIN SMALL LETTER S WITH CARON AND DOT ABOVE
0x1E68, 0x1E69, //LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE	LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
0x1E6A, 0x1E6B, //LATIN CAPITAL LETTER T WITH DOT ABOVE	LATIN SMALL LETTER T WITH DOT ABOVE
0x1E6C, 0x1E6D, //LATIN CAPITAL LETTER T WITH DOT BELOW	LATIN SMALL LETTER T WITH DOT BELOW
0x1E6E, 0x1E6F, //LATIN CAPITAL LETTER T WITH LINE BELOW	LATIN SMALL LETTER T WITH LINE BELOW
0x1E70, 0x1E71, //LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW	LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW
0x1E72, 0x1E73, //LATIN CAPITAL LETTER U WITH DIAERESIS BELOW	LATIN SMALL LETTER U WITH DIAERESIS BELOW
0x1E74, 0x1E75, //LATIN CAPITAL LETTER U WITH TILDE BELOW	LATIN SMALL LETTER U WITH TILDE BELOW
0x1E76, 0x1E77, //LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW	LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW
0x1E78, 0x1E79, //LATIN CAPITAL LETTER U WITH TILDE AND ACUTE	LATIN SMALL LETTER U WITH TILDE AND ACUTE
0x1E7A, 0x1E7B, //LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS	LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
0x1E7C, 0x1E7D, //LATIN CAPITAL LETTER V WITH TILDE	LATIN SMALL LETTER V WITH TILDE
0x1E7E, 0x1E7F, //LATIN CAPITAL LETTER V WITH DOT BELOW	LATIN SMALL LETTER V WITH DOT BELOW
0x1E80, 0x1E81, //LATIN CAPITAL LETTER W WITH GRAVE	LATIN SMALL LETTER W WITH GRAVE
0x1E82, 0x1E83, //LATIN CAPITAL LETTER W WITH ACUTE	LATIN SMALL LETTER W WITH ACUTE
0x1E84, 0x1E85, //LATIN CAPITAL LETTER W WITH DIAERESIS	LATIN SMALL LETTER W WITH DIAERESIS
0x1E86, 0x1E87, //LATIN CAPITAL LETTER W WITH DOT ABOVE	LATIN SMALL LETTER W WITH DOT ABOVE
0x1E88, 0x1E89, //LATIN CAPITAL LETTER W WITH DOT BELOW	LATIN SMALL LETTER W WITH DOT BELOW
0x1E8A, 0x1E8B, //LATIN CAPITAL LETTER X WITH DOT ABOVE	LATIN SMALL LETTER X WITH DOT ABOVE
0x1E8C, 0x1E8D, //LATIN CAPITAL LETTER X5 WITH DIAERESIS	LATIN SMALL LETTER X WITH DIAERESIS
0x1E8E, 0x1E8F, //LATIN CAPITAL LETTER Y WITH DOT ABOVE	LATIN SMALL LETTER Y WITH DOT ABOVE
0x1E90, 0x1E91, //LATIN CAPITAL LETTER Z WITH CIRCUMFLEX	LATIN SMALL LETTER Z WITH CIRCUMFLEX
0x1E92, 0x1E93, //LATIN CAPITAL LETTER Z WITH DOT BELOW	LATIN SMALL LETTER Z WITH DOT BELOW
0x1E94, 0x1E95, //LATIN CAPITAL LETTER Z WITH LINE BELOW	LATIN SMALL LETTER Z WITH LINE BELOW
0x1EA0, 0x1EA1, //LATIN CAPITAL LETTER A WITH DOT BELOW	LATIN SMALL LETTER A WITH DOT BELOW
0x1EA2, 0x1EA3, //LATIN CAPITAL LETTER A WITH HOOK ABOVE	LATIN SMALL LETTER A WITH HOOK ABOVE
0x1EA4, 0x1EA5, //LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE	LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
0x1EA6, 0x1EA7, //LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE	LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
0x1EA8, 0x1EA9, //LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE	LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
0x1EAA, 0x1EAB, //LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE	LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
0x1EAC, 0x1EAD, //LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW	LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
0x1EAE, 0x1EAF, //LATIN CAPITAL LETTER A WITH BREVE AND ACUTE	LATIN SMALL LETTER A WITH BREVE AND ACUTE
0x1EB0, 0x1EB1, //LATIN CAPITAL LETTER A WITH BREVE AND GRAVE	LATIN SMALL LETTER A WITH BREVE AND GRAVE
0x1EB2, 0x1EB3, //LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE	LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
0x1EB4, 0x1EB5, //LATIN CAPITAL LETTER A WITH BREVE AND TILDE	LATIN SMALL LETTER A WITH BREVE AND TILDE
0x1EB6, 0x1EB7, //LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW	LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
0x1EB8, 0x1EB9, //LATIN CAPITAL LETTER E WITH DOT BELOW	LATIN SMALL LETTER E WITH DOT BELOW
0x1EBA, 0x1EBB, //LATIN CAPITAL LETTER E WITH HOOK ABOVE	LATIN SMALL LETTER E WITH HOOK ABOVE
0x1EBC, 0x1EBD, //LATIN CAPITAL LETTER E WITH TILDE	LATIN SMALL LETTER E WITH TILDE
0x1EBE, 0x1EBF, //LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE	LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
0x1EC0, 0x1EC1, //LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE	LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
0x1EC2, 0x1EC3, //LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE	LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
0x1EC4, 0x1EC5, //LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE	LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
0x1EC6, 0x1EC7, //LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW	LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
0x1EC8, 0x1EC9, //LATIN CAPITAL LETTER I WITH HOOK ABOVE	LATIN SMALL LETTER I WITH HOOK ABOVE
0x1ECA, 0x1ECB, //LATIN CAPITAL LETTER I WITH DOT BELOW	LATIN SMALL LETTER I WITH DOT BELOW
0x1ECC, 0x1ECD, //LATIN CAPITAL LETTER O WITH DOT BELOW	LATIN SMALL LETTER O WITH DOT BELOW
0x1ECE, 0x1ECF, //LATIN CAPITAL LETTER O WITH HOOK ABOVE	LATIN SMALL LETTER O WITH HOOK ABOVE
0x1ED0, 0x1ED1, //LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE	LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
0x1ED2, 0x1ED3, //LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE	LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
0x1ED4, 0x1ED5, //LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE	LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
0x1ED6, 0x1ED7, //LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE	LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
0x1ED8, 0x1ED9, //LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW	LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
0x1EDA, 0x1EDB, //LATIN CAPITAL LETTER O WITH HORN AND ACUTE	LATIN SMALL LETTER O WITH HORN AND ACUTE
0x1EDC, 0x1EDD, //LATIN CAPITAL LETTER O WITH HORN AND GRAVE	LATIN SMALL LETTER O WITH HORN AND GRAVE
0x1EDE, 0x1EDF, //LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE	LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
0x1EE0, 0x1EE1, //LATIN CAPITAL LETTER O WITH HORN AND TILDE	LATIN SMALL LETTER O WITH HORN AND TILDE
0x1EE2, 0x1EE3, //LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW	LATIN SMALL LETTER O WITH HORN AND DOT BELOW
0x1EE4, 0x1EE5, //LATIN CAPITAL LETTER U WITH DOT BELOW	LATIN SMALL LETTER U WITH DOT BELOW
0x1EE6, 0x1EE7, //LATIN CAPITAL LETTER U WITH HOOK ABOVE	LATIN SMALL LETTER U WITH HOOK ABOVE
0x1EE8, 0x1EE9, //LATIN CAPITAL LETTER U WITH HORN AND ACUTE	LATIN SMALL LETTER U WITH HORN AND ACUTE
0x1EEA, 0x1EEB, //LATIN CAPITAL LETTER U WITH HORN AND GRAVE	LATIN SMALL LETTER U WITH HORN AND GRAVE
0x1EEC, 0x1EED, //LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE	LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
0x1EEE, 0x1EEF, //LATIN CAPITAL LETTER U WITH HORN AND TILDE	LATIN SMALL LETTER U WITH HORN AND TILDE
0x1EF0, 0x1EF1, //LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW	LATIN SMALL LETTER U WITH HORN AND DOT BELOW
0x1EF2, 0x1EF3, //LATIN CAPITAL LETTER Y WITH GRAVE	LATIN SMALL LETTER Y WITH GRAVE
0x1EF4, 0x1EF5, //LATIN CAPITAL LETTER Y WITH DOT BELOW	LATIN SMALL LETTER Y WITH DOT BELOW
0x1EF6, 0x1EF7, //LATIN CAPITAL LETTER Y WITH HOOK ABOVE	LATIN SMALL LETTER Y WITH HOOK ABOVE
0x1EF8, 0x1EF9, //LATIN CAPITAL LETTER Y WITH TILDE	LATIN SMALL LETTER Y WITH TILDE
0x1F08, 0x1F00, //GREEK CAPITAL LETTER ALPHA WITH PSILI	GREEK SMALL LETTER ALPHA WITH PSILI
0x1F09, 0x1F01, //GREEK CAPITAL LETTER ALPHA WITH DASIA	GREEK SMALL LETTER ALPHA WITH DASIA
0x1F0A, 0x1F02, //GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA	GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA
0x1F0B, 0x1F03, //GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA	GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA
0x1F0C, 0x1F04, //GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA	GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA
0x1F0D, 0x1F05, //GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA	GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA
0x1F0E, 0x1F06, //GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI	GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI
0x1F0F, 0x1F07, //GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI	GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI
0x1F18, 0x1F10, //GREEK CAPITAL LETTER EPSILON WITH PSILI	GREEK SMALL LETTER EPSILON WITH PSILI
0x1F19, 0x1F11, //GREEK CAPITAL LETTER EPSILON WITH DASIA	GREEK SMALL LETTER EPSILON WITH DASIA
0x1F1A, 0x1F12, //GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA	GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA
0x1F1B, 0x1F13, //GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA	GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA
0x1F1C, 0x1F14, //GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA	GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA
0x1F1D, 0x1F15, //GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA	GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA
0x1F28, 0x1F20, //GREEK CAPITAL LETTER ETA WITH PSILI	GREEK SMALL LETTER ETA WITH PSILI
0x1F29, 0x1F21, //GREEK CAPITAL LETTER ETA WITH DASIA	GREEK SMALL LETTER ETA WITH DASIA
0x1F2A, 0x1F22, //GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA	GREEK SMALL LETTER ETA WITH PSILI AND VARIA
0x1F2B, 0x1F23, //GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA	GREEK SMALL LETTER ETA WITH DASIA AND VARIA
0x1F2C, 0x1F24, //GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA	GREEK SMALL LETTER ETA WITH PSILI AND OXIA
0x1F2D, 0x1F25, //GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA	GREEK SMALL LETTER ETA WITH DASIA AND OXIA
0x1F2E, 0x1F26, //GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI	GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI
0x1F2F, 0x1F27, //GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI	GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI
0x1F38, 0x1F30, //GREEK CAPITAL LETTER IOTA WITH PSILI	GREEK SMALL LETTER IOTA WITH PSILI
0x1F39, 0x1F31, //GREEK CAPITAL LETTER IOTA WITH DASIA	GREEK SMALL LETTER IOTA WITH DASIA
0x1F3A, 0x1F32, //GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	GREEK SMALL LETTER IOTA WITH PSILI AND VARIA
0x1F3B, 0x1F33, //GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	GREEK SMALL LETTER IOTA WITH DASIA AND VARIA
0x1F3C, 0x1F34, //GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	GREEK SMALL LETTER IOTA WITH PSILI AND OXIA
0x1F3D, 0x1F35, //GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	GREEK SMALL LETTER IOTA WITH DASIA AND OXIA
0x1F3E, 0x1F36, //GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI
0x1F3F, 0x1F37, //GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI
0x1F48, 0x1F40, //GREEK CAPITAL LETTER OMICRON WITH PSILI	GREEK SMALL LETTER OMICRON WITH PSILI
0x1F49, 0x1F41, //GREEK CAPITAL LETTER OMICRON WITH DASIA	GREEK SMALL LETTER OMICRON WITH DASIA
0x1F4A, 0x1F42, //GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA	GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA
0x1F4B, 0x1F43, //GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA	GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA
0x1F4C, 0x1F44, //GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA	GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA
0x1F4D, 0x1F45, //GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA	GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA
0x1F59, 0x1F51, //GREEK CAPITAL LETTER UPSILON WITH OASIS	GREEK SMALL LETTER UPSILON WITH DASIA
0x1F5B, 0x1F53, //GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA	GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA
0x1F5D, 0x1F55, //GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA	GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA
0x1F5F, 0x1F57, //GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI	GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI
0x1F68, 0x1F60, //GREEK CAPITAL LETTER OMEGA WITH PSILI	GREEK SMALL LETTER OMEGA WITH PSILI
0x1F69, 0x1F61, //GREEK CAPITAL LETTER OMEGA WITH DASIA	GREEK SMALL LETTER OMEGA WITH DASIA
0x1F6A, 0x1F62, //GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA	GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA
0x1F6B, 0x1F63, //GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA	GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA
0x1F6C, 0x1F64, //GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA	GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA
0x1F6D, 0x1F65, //GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA	GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA
0x1F6E, 0x1F66, //GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI	GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI
0x1F6F, 0x1F67, //GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI	GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI
0x1F88, 0x1F80, //GREEK CAPITAL LETTER ALPHA WITH PSILI AND PROSGEGRAMMENI	GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI
0x1F89, 0x1F81, //GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI	GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI
0x1F8A, 0x1F82, //GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI	GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI
0x1F8B, 0x1F83, //GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI	GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI
0x1F8C, 0x1F84, //GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMEN	GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI
0x1F8D, 0x1F85, //GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMEN	GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI
0x1F8E, 0x1F86, //GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI	GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
0x1F8F, 0x1F87, //GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI	GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
0x1F98, 0x1F90, //GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI	GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI
0x1F99, 0x1F91, //GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI	GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI
0x1F9A, 0x1F92, //GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI	GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI
0x1F9B, 0x1F93, //GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI	GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI
0x1F9C, 0x1F94, //GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI	GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI
0x1F9D, 0x1F95, //GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI	GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI
0x1F9E, 0x1F96, //GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI	GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
0x1F9F, 0x1F97, //GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI	GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI
0x1FA8, 0x1FA0, //GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI	GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI
0x1FA9, 0x1FA1, //GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI	GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI
0x1FAA, 0x1FA2, //GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI	GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI
0x1FAB, 0x1FA3, //GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI	GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI
0x1FAC, 0x1FA4, //GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI	GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI
0x1FAD, 0x1FA5, //GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI	GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI
0x1FAE, 0x1FA6, //GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI	GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI
0x1FAF, 0x1FA7, //GREEK CAPITAL LETTER OMECA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI	GREEK SMALL LETTER OMEGA WITH DASIA AND PEPISPOMENI AND YPOGEGRAMMENI
0x1FB8, 0x1FB0, //GREEK CAPITAL LETTER ALPHA WITH VRACHY	GREEK SMALL LETTER ALPHA WITH VRACHY
0x1FB9, 0x1FB1, //GREEK CAPITAL LETTER ALPHA WITH MACRON	GREEK SMALL LETTER ALPHA WITH MACRON
0x1FD8, 0x1FD0, //GREEK CAPITAL LETTER IOTA WITH VRACHY	GREEK SMALL LETTER IOTA WITH VRACHY
0x1FD9, 0x1FD1, //GREEK CAPITAL LETTER IOTA WITH MACRON	GREEK SMALL LETTER IOTA WITH MACRON
0x1FE8, 0x1FE0, //GREEK CAPITAL LETTER UPSILON WITH VRACHY	GREEK SMALL LETTER UPSILON WITH VRACHY
0x1FE9, 0x1FE1, //GREEK CAPITAL LETTER UPSILON WITH MACRON	GREEK SMALL LETTER UPSILON WITH MACRON
0x24B6, 0x24D0, //CIRCLED LATIN CAPITAL LETTER A	CIRCLED LATIN SMALL LETTER A
0x24B7, 0x24D1, //CIRCLED LATIN CAPITAL LETTER B	CIRCLED LATIN SMALL LETTER B
0x24B8, 0x24D2, //CIRCLED LATIN CAPITAL LETTER C	CIRCLED LATIN SMALL LETTER C
0x24B9, 0x24D3, //CIRCLED LATIN CAPITAL LETTER D	CIRCLED LATIN SMALL LETTER D
0x24BA, 0x24D4, //CIRCLED LATIN CAPITAL LETTER E	CIRCLED LATIN SMALL LETTER E
0x24BB, 0x24D5, //CIRCLED LATIN CAPITAL LETTER F	CIRCLED LATIN SMALL LETTER F
0x24BC, 0x24D6, //CIRCLED LATIN CAPITAL LETTER G	CIRCLED LATIN SMALL LETTER G
0x24BD, 0x24D7, //CIRCLED LATIN CAPITAL LETTER H	CIRCLED LATIN SMALL LETTER H
0x24BE, 0x24D8, //CIRCLED LATIN CAPITAL LETTER I	CIRCLED LATIN SMALL LETTER I
0x24BF, 0x24D9, //CIRCLED LATIN CAPITAL LETTER J	CIRCLED LATIN SMALL LETTER J
0x24C0, 0x24DA, //CIRCLED LATIN CAPITAL LETTER K	CIRCLED LATIN SMALL LETTER K
0x24C1, 0x24DB, //CIRCLED LATIN CAPITAL LETTER L	CIRCLED LATIN SMALL LETTER L
0x24C2, 0x24DC, //CIRCLED LATIN CAPITAL LETTER M	CIRCLED LATIN SMALL LETTER M
0x24C3, 0x24DD, //CIRCLED LATIN CAPITAL LETTER N	CIRCLED LATIN SMALL LETTER N
0x24C4, 0x24DE, //CIRCLED LATIN CAPITAL LETTER O	CIRCLED LATIN SMALL LETTER O
0x24C5, 0x24DF, //CIRCLED LATIN CAPITAL LETTER P	CIRCLED LATIN SMALL LETTER P
0x24C6, 0x24E0, //CIRCLED LATIN CAPITAL LETTER Q	CIRCLED LATIN SMALL LETTER Q
0x24C7, 0x24E1, //CIRCLED LATIN CAPITAL LETTER R	CIRCLED LATIN SMALL LETTER R
0x24C8, 0x24E2, //CIRCLED LATIN CAPITAL LETTER S	CIRCLED LATIN SMALL LETTER S
0x24C9, 0x24E3, //CIRCLED LATIN CAPITAL LETTER T	CIRCLED LATIN SMALL LETTER T
0x24CA, 0x24E4, //CIRCLED LATIN CAPITAL LETTER U	CIRCLED LATIN SMALL LETTER U
0x24CB, 0x24E5, //CIRCLED LATIN CAPITAL LETTER V	CIRCLED LATIN SMALL LETTER V
0x24CC, 0x24E6, //CIRCLED LATIN CAPITAL LETTER W	CIRCLED LATIN SMALL LETTER W
0x24CD, 0x24E7, //CIRCLED LATIN CAPITAL LETTER X	CIRCLED LATIN SMALL LETTER X
0x24CE, 0x24E8, //CIRCLED LATIN CAPITAL LETTER Y	CIRCLED LATIN SMALL LETTER Y
0x24CF, 0x24E9, //CIRCLED LATIN CAPITAL LETTER Z	CIRCLED LATIN SMALL LETTER Z
0xFF21, 0xFF41, //FULLWIDTH LATIN CAPITAL LETTER A	FULLWIDTH LATIN SMALL LETTER A
0xFF22, 0xFF42, //FULLWIDTH LATIN CAPITAL LETTER B	FULLWIDTH LATIN SMALL LETTER B
0xFF23, 0xFF43, //FULLWIDTH LATIN CAPITAL LETTER C	FULLWIDTH LATIN SMALL LETTER C
0xFF24, 0xFF44, //FULLWIDTH LATIN CAPITAL LETTER D	FULLWIDTH LATIN SMALL LETTER D
0xFF25, 0xFF45, //FULLWIDTH LATIN CAPITAL LETTER E	FULLWIDTH LATIN SMALL LETTER E
0xFF26, 0xFF46, //FULLWIDTH LATIN CAPITAL LETTER F	FULLWIDTH LATIN SMALL LETTER F
0xFF27, 0xFF47, //FULLWIDTH LATIN CAPITAL LETTER G	FULLWIDTH LATIN SMALL LETTER G
0xFF28, 0xFF48, //FULLWIDTH LATIN CAPITAL LETTER H	FULLWIDTH LATIN SMALL LETTER H
0xFF29, 0xFF49, //FULLWIDTH LATIN CAPITAL LETTER I	FULLWIDTH LATIN SMALL LETTER I
0xFF2A, 0xFF4A, //FULLWIDTH LATIN CAPITAL LETTER J	FULLWIDTH LATIN SMALL LETTER J
0xFF2B, 0xFF4B, //FULLWIDTH LATIN CAPITAL LETTER K	FULLWIDTH LATIN SMALL LETTER K
0xFF2C, 0xFF4C, //FULLWIDTH LATIN CAPITAL LETTER L	FULLWIDTH LATIN SMALL LETTER L
0xFF2D, 0xFF4D, //FULLWIDTH LATIN CAPITAL LETTER M	FULLWIDTH LATIN SMALL LETTER M
0xFF2E, 0xFF4E, //FULLWIDTH LATIN CAPITAL LETTER N	FULLWIDTH LATIN SMALL LETTER N
0xFF2F, 0xFF4F, //FULLWIDTH LATIN CAPITAL LETTER O	FULLWIDTH LATIN SMALL LETTER O
0xFF30, 0xFF50, //FULLWIDTH LATIN CAPITAL LETTER P	FULLWIDTH LATIN SMALL LETTER P
0xFF31, 0xFF51, //FULLWIDTH LATIN CAPITAL LETTER Q	FULLWIDTH LATIN SMALL LETTER Q
0xFF32, 0xFF52, //FULLWIDTH LATIN CAPITAL LETTER R	FULLWIDTH LATIN SMALL LETTER R
0xFF33, 0xFF53, //FULLWIDTH LATIN CAPITAL LETTER S	FULLWIDTH LATIN SMALL LETTER S
0xFF34, 0xFF54, //FULLWIDTH LATIN CAPITAL LETTER T	FULLWIDTH LATIN SMALL LETTER T
0xFF35, 0xFF55, //FULLWIDTH LATIN CAPITAL LETTER U	FULLWIDTH LATIN SMALL LETTER U
0xFF36, 0xFF56, //FULLWIDTH LATIN CAPITAL LETTER V	FULLWIDTH LATIN SMALL LETTER V
0xFF37, 0xFF57, //FULLWIDTH LATIN CAPITAL LETTER W	FULLWIDTH LATIN SMALL LETTER W
0xFF38, 0xFF58, //FULLWIDTH LATIN CAPITAL LETTER X	FULLWIDTH LATIN SMALL LETTER X
0xFF39, 0xFF59, //FULLWIDTH LATIN CAPITAL LETTER Y	FULLWIDTH LATIN SMALL LETTER Y
0xFF3A, 0xFF5A, //FULLWIDTH LATIN CAPITAL LETTER Z	FULLWIDTH LATIN SMALL LETTER Z
]
)

/*****************************************************************************
*
*  Unicode punctuation chars
*
*  source: http://www.unicode.org/faq/punctuation_symbols.html
*
*****************************************************************************/
const(

// Western punctuation mark
// Character	Name	Browser	Image
unicode_punct_western=[
0x0021, // EXCLAMATION MARK	!
0x0022, // QUOTATION MARK	"
0x0027, // APOSTROPHE	'
0x002A, // ASTERISK	*
0x002C, // COMMA	,
0x002E, // FULL STOP	.
0x002F, // SOLIDUS	/
0x003A, // COLON	:
0x003B, // SEMICOLON	;
0x003F, // QUESTION MARK	?
0x00A1, // INVERTED EXCLAMATION MARK	
0x00A7, // SECTION SIGN	
0x00B6, // PILCROW SIGN	
0x00B7, // MIDDLE DOT	
0x00BF, // INVERTED QUESTION MARK	
0x037E, // GREEK QUESTION MARK	
0x0387, // GREEK ANO TELEIA	
0x055A, // ARMENIAN APOSTROPHE	
0x055B, // ARMENIAN EMPHASIS MARK	
0x055C, // ARMENIAN EXCLAMATION MARK	
0x055D, // ARMENIAN COMMA	
0x055E, // ARMENIAN QUESTION MARK	
0x055F, // ARMENIAN ABBREVIATION MARK	
0x0589, // ARMENIAN FULL STOP	
0x05C0, // HEBREW PUNCTUATION PASEQ	
0x05C3, // HEBREW PUNCTUATION SOF PASUQ	
0x05C6, // HEBREW PUNCTUATION NUN HAFUKHA	
0x05F3, // HEBREW PUNCTUATION GERESH	
0x05F4, // HEBREW PUNCTUATION GERSHAYIM	
]

// Unicode Characters in the 'Punctuation, Other' Category
// Character	Name	Browser	Image
unicode_punct=[
0x0021, // EXCLAMATION MARK	!
0x0022, // QUOTATION MARK	"
0x0023, // NUMBER SIGN	#
0x0025, // PERCENT SIGN	%
0x0026, // AMPERSAND	&
0x0027, // APOSTROPHE	'
0x002A, // ASTERISK	*
0x002C, // COMMA	,
0x002E, // FULL STOP	.
0x002F, // SOLIDUS	/
0x003A, // COLON	:
0x003B, // SEMICOLON	;
0x003F, // QUESTION MARK	?
0x0040, // COMMERCIAL AT	@
0x005C, // REVERSE SOLIDUS	\
0x00A1, // INVERTED EXCLAMATION MARK	
0x00A7, // SECTION SIGN	
0x00B6, // PILCROW SIGN	
0x00B7, // MIDDLE DOT	
0x00BF, // INVERTED QUESTION MARK	
0x037E, // GREEK QUESTION MARK	
0x0387, // GREEK ANO TELEIA	
0x055A, // ARMENIAN APOSTROPHE	
0x055B, // ARMENIAN EMPHASIS MARK	
0x055C, // ARMENIAN EXCLAMATION MARK	
0x055D, // ARMENIAN COMMA	
0x055E, // ARMENIAN QUESTION MARK	
0x055F, // ARMENIAN ABBREVIATION MARK	
0x0589, // ARMENIAN FULL STOP	
0x05C0, // HEBREW PUNCTUATION PASEQ	
0x05C3, // HEBREW PUNCTUATION SOF PASUQ	
0x05C6, // HEBREW PUNCTUATION NUN HAFUKHA	
0x05F3, // HEBREW PUNCTUATION GERESH	
0x05F4, // HEBREW PUNCTUATION GERSHAYIM	
0x0609, // ARABIC-INDIC PER MILLE SIGN	
0x060A, // ARABIC-INDIC PER TEN THOUSAND SIGN	
0x060C, // ARABIC COMMA	
0x060D, // ARABIC DATE SEPARATOR	
0x061B, // ARABIC SEMICOLON	
0x061E, // ARABIC TRIPLE DOT PUNCTUATION MARK	
0x061F, // ARABIC QUESTION MARK	
0x066A, // ARABIC PERCENT SIGN	
0x066B, // ARABIC DECIMAL SEPARATOR	
0x066C, // ARABIC THOUSANDS SEPARATOR	
0x066D, // ARABIC FIVE POINTED STAR	
0x06D4, // ARABIC FULL STOP	
0x0700, // SYRIAC END OF PARAGRAPH	
0x0701, // SYRIAC SUPRALINEAR FULL STOP	
0x0702, // SYRIAC SUBLINEAR FULL STOP	
0x0703, // SYRIAC SUPRALINEAR COLON	
0x0704, // SYRIAC SUBLINEAR COLON	
0x0705, // SYRIAC HORIZONTAL COLON	
0x0706, // SYRIAC COLON SKEWED LEFT	
0x0707, // SYRIAC COLON SKEWED RIGHT	
0x0708, // SYRIAC SUPRALINEAR COLON SKEWED LEFT	
0x0709, // SYRIAC SUBLINEAR COLON SKEWED RIGHT	
0x070A, // SYRIAC CONTRACTION	
0x070B, // SYRIAC HARKLEAN OBELUS	
0x070C, // SYRIAC HARKLEAN METOBELUS	
0x070D, // SYRIAC HARKLEAN ASTERISCUS	
0x07F7, // NKO SYMBOL GBAKURUNEN	
0x07F8, // NKO COMMA	
0x07F9, // NKO EXCLAMATION MARK	
0x0830, // SAMARITAN PUNCTUATION NEQUDAA	
0x0831, // SAMARITAN PUNCTUATION AFSAAQ	
0x0832, // SAMARITAN PUNCTUATION ANGED	
0x0833, // SAMARITAN PUNCTUATION BAU	
0x0834, // SAMARITAN PUNCTUATION ATMAAU	
0x0835, // SAMARITAN PUNCTUATION SHIYYAALAA	
0x0836, // SAMARITAN ABBREVIATION MARK	
0x0837, // SAMARITAN PUNCTUATION MELODIC QITSA	
0x0838, // SAMARITAN PUNCTUATION ZIQAA	
0x0839, // SAMARITAN PUNCTUATION QITSA	
0x083A, // SAMARITAN PUNCTUATION ZAEF	
0x083B, // SAMARITAN PUNCTUATION TURU	
0x083C, // SAMARITAN PUNCTUATION ARKAANU	
0x083D, // SAMARITAN PUNCTUATION SOF MASHFAAT	
0x083E, // SAMARITAN PUNCTUATION ANNAAU	
0x085E, // MANDAIC PUNCTUATION	
0x0964, // DEVANAGARI DANDA	
0x0965, // DEVANAGARI DOUBLE DANDA	
0x0970, // DEVANAGARI ABBREVIATION SIGN	
0x09FD, // BENGALI ABBREVIATION SIGN	
0x0A76, // GURMUKHI ABBREVIATION SIGN	
0x0AF0, // GUJARATI ABBREVIATION SIGN	
0x0C77, // TELUGU SIGN SIDDHAM	
0x0C84, // KANNADA SIGN SIDDHAM	
0x0DF4, // SINHALA PUNCTUATION KUNDDALIYA	
0x0E4F, // THAI CHARACTER FONGMAN	
0x0E5A, // THAI CHARACTER ANGKHANKHU	
0x0E5B, // THAI CHARACTER KHOMUT	
0x0F04, // TIBETAN MARK INITIAL YIG MGO MDUN MA	
0x0F05, // TIBETAN MARK CLOSING YIG MGO SGAB MA	
0x0F06, // TIBETAN MARK CARET YIG MGO PHUR SHAD MA	
0x0F07, // TIBETAN MARK YIG MGO TSHEG SHAD MA	
0x0F08, // TIBETAN MARK SBRUL SHAD	
0x0F09, // TIBETAN MARK BSKUR YIG MGO	
0x0F0A, // TIBETAN MARK BKA- SHOG YIG MGO	
0x0F0B, // TIBETAN MARK INTERSYLLABIC TSHEG	
0x0F0C, // TIBETAN MARK DELIMITER TSHEG BSTAR	
0x0F0D, // TIBETAN MARK SHAD	
0x0F0E, // TIBETAN MARK NYIS SHAD	
0x0F0F, // TIBETAN MARK TSHEG SHAD	
0x0F10, // TIBETAN MARK NYIS TSHEG SHAD	
0x0F11, // TIBETAN MARK RIN CHEN SPUNGS SHAD	
0x0F12, // TIBETAN MARK RGYA GRAM SHAD	
0x0F14, // TIBETAN MARK GTER TSHEG	
0x0F85, // TIBETAN MARK PALUTA	
0x0FD0, // TIBETAN MARK BSKA- SHOG GI MGO RGYAN	
0x0FD1, // TIBETAN MARK MNYAM YIG GI MGO RGYAN	
0x0FD2, // TIBETAN MARK NYIS TSHEG	
0x0FD3, // TIBETAN MARK INITIAL BRDA RNYING YIG MGO MDUN MA	
0x0FD4, // TIBETAN MARK CLOSING BRDA RNYING YIG MGO SGAB MA	
0x0FD9, // TIBETAN MARK LEADING MCHAN RTAGS	
0x0FDA, // TIBETAN MARK TRAILING MCHAN RTAGS	
0x104A, // MYANMAR SIGN LITTLE SECTION	
0x104B, // MYANMAR SIGN SECTION	
0x104C, // MYANMAR SYMBOL LOCATIVE	
0x104D, // MYANMAR SYMBOL COMPLETED	
0x104E, // MYANMAR SYMBOL AFOREMENTIONED	
0x104F, // MYANMAR SYMBOL GENITIVE	
0x10FB, // GEORGIAN PARAGRAPH SEPARATOR	
0x1360, // ETHIOPIC SECTION MARK	
0x1361, // ETHIOPIC WORDSPACE	
0x1362, // ETHIOPIC FULL STOP	
0x1363, // ETHIOPIC COMMA	
0x1364, // ETHIOPIC SEMICOLON	
0x1365, // ETHIOPIC COLON	
0x1366, // ETHIOPIC PREFACE COLON	
0x1367, // ETHIOPIC QUESTION MARK	
0x1368, // ETHIOPIC PARAGRAPH SEPARATOR	
0x166E, // CANADIAN SYLLABICS FULL STOP	
0x16EB, // RUNIC SINGLE PUNCTUATION	
0x16EC, // RUNIC MULTIPLE PUNCTUATION	
0x16ED, // RUNIC CROSS PUNCTUATION	
0x1735, // PHILIPPINE SINGLE PUNCTUATION	
0x1736, // PHILIPPINE DOUBLE PUNCTUATION	
0x17D4, // KHMER SIGN KHAN	
0x17D5, // KHMER SIGN BARIYOOSAN	
0x17D6, // KHMER SIGN CAMNUC PII KUUH	
0x17D8, // KHMER SIGN BEYYAL	
0x17D9, // KHMER SIGN PHNAEK MUAN	
0x17DA, // KHMER SIGN KOOMUUT	
0x1800, // MONGOLIAN BIRGA	
0x1801, // MONGOLIAN ELLIPSIS	
0x1802, // MONGOLIAN COMMA	
0x1803, // MONGOLIAN FULL STOP	
0x1804, // MONGOLIAN COLON	
0x1805, // MONGOLIAN FOUR DOTS	
0x1807, // MONGOLIAN SIBE SYLLABLE BOUNDARY MARKER	
0x1808, // MONGOLIAN MANCHU COMMA	
0x1809, // MONGOLIAN MANCHU FULL STOP	
0x180A, // MONGOLIAN NIRUGU	
0x1944, // LIMBU EXCLAMATION MARK	
0x1945, // LIMBU QUESTION MARK	
0x1A1E, // BUGINESE PALLAWA	
0x1A1F, // BUGINESE END OF SECTION	
0x1AA0, // TAI THAM SIGN WIANG	
0x1AA1, // TAI THAM SIGN WIANGWAAK	
0x1AA2, // TAI THAM SIGN SAWAN	
0x1AA3, // TAI THAM SIGN KEOW	
0x1AA4, // TAI THAM SIGN HOY	
0x1AA5, // TAI THAM SIGN DOKMAI	
0x1AA6, // TAI THAM SIGN REVERSED ROTATED RANA	
0x1AA8, // TAI THAM SIGN KAAN	
0x1AA9, // TAI THAM SIGN KAANKUU	
0x1AAA, // TAI THAM SIGN SATKAAN	
0x1AAB, // TAI THAM SIGN SATKAANKUU	
0x1AAC, // TAI THAM SIGN HANG	
0x1AAD, // TAI THAM SIGN CAANG	
0x1B5A, // BALINESE PANTI	
0x1B5B, // BALINESE PAMADA	
0x1B5C, // BALINESE WINDU	
0x1B5D, // BALINESE CARIK PAMUNGKAH	
0x1B5E, // BALINESE CARIK SIKI	
0x1B5F, // BALINESE CARIK PAREREN	
0x1B60, // BALINESE PAMENENG	
0x1BFC, // BATAK SYMBOL BINDU NA METEK	
0x1BFD, // BATAK SYMBOL BINDU PINARBORAS	
0x1BFE, // BATAK SYMBOL BINDU JUDUL	
0x1BFF, // BATAK SYMBOL BINDU PANGOLAT	
0x1C3B, // LEPCHA PUNCTUATION TA-ROL	
0x1C3C, // LEPCHA PUNCTUATION NYET THYOOM TA-ROL	
0x1C3D, // LEPCHA PUNCTUATION CER-WA	
0x1C3E, // LEPCHA PUNCTUATION TSHOOK CER-WA	
0x1C3F, // LEPCHA PUNCTUATION TSHOOK	
0x1C7E, // OL CHIKI PUNCTUATION MUCAAD	
0x1C7F, // OL CHIKI PUNCTUATION DOUBLE MUCAAD	
0x1CC0, // SUNDANESE PUNCTUATION BINDU SURYA	
0x1CC1, // SUNDANESE PUNCTUATION BINDU PANGLONG	
0x1CC2, // SUNDANESE PUNCTUATION BINDU PURNAMA	
0x1CC3, // SUNDANESE PUNCTUATION BINDU CAKRA	
0x1CC4, // SUNDANESE PUNCTUATION BINDU LEU SATANGA	
0x1CC5, // SUNDANESE PUNCTUATION BINDU KA SATANGA	
0x1CC6, // SUNDANESE PUNCTUATION BINDU DA SATANGA	
0x1CC7, // SUNDANESE PUNCTUATION BINDU BA SATANGA	
0x1CD3, // VEDIC SIGN NIHSHVASA	
0x2016, // DOUBLE VERTICAL LINE	
0x2017, // DOUBLE LOW LINE	
0x2020, // DAGGER	
0x2021, // DOUBLE DAGGER	
0x2022, // BULLET	
0x2023, // TRIANGULAR BULLET	
0x2024, // ONE DOT LEADER	
0x2025, // TWO DOT LEADER	
0x2026, // HORIZONTAL ELLIPSIS	
0x2027, // HYPHENATION POINT	
0x2030, // PER MILLE SIGN	
0x2031, // PER TEN THOUSAND SIGN	
0x2032, // PRIME	
0x2033, // DOUBLE PRIME	
0x2034, // TRIPLE PRIME	
0x2035, // REVERSED PRIME	
0x2036, // REVERSED DOUBLE PRIME	
0x2037, // REVERSED TRIPLE PRIME	
0x2038, // CARET	
0x203B, // REFERENCE MARK	
0x203C, // DOUBLE EXCLAMATION MARK	
0x203D, // INTERROBANG	
0x203E, // OVERLINE	
0x2041, // CARET INSERTION POINT	
0x2042, // ASTERISM	
0x2043, // HYPHEN BULLET	
0x2047, // DOUBLE QUESTION MARK	
0x2048, // QUESTION EXCLAMATION MARK	
0x2049, // EXCLAMATION QUESTION MARK	
0x204A, // TIRONIAN SIGN ET	
0x204B, // REVERSED PILCROW SIGN	
0x204C, // BLACK LEFTWARDS BULLET	
0x204D, // BLACK RIGHTWARDS BULLET	
0x204E, // LOW ASTERISK	
0x204F, // REVERSED SEMICOLON	
0x2050, // CLOSE UP	
0x2051, // TWO ASTERISKS ALIGNED VERTICALLY	
0x2053, // SWUNG DASH	
0x2055, // FLOWER PUNCTUATION MARK	
0x2056, // THREE DOT PUNCTUATION	
0x2057, // QUADRUPLE PRIME	
0x2058, // FOUR DOT PUNCTUATION	
0x2059, // FIVE DOT PUNCTUATION	
0x205A, // TWO DOT PUNCTUATION	
0x205B, // FOUR DOT MARK	
0x205C, // DOTTED CROSS	
0x205D, // TRICOLON	
0x205E, // VERTICAL FOUR DOTS	
0x2CF9, // COPTIC OLD NUBIAN FULL STOP	
0x2CFA, // COPTIC OLD NUBIAN DIRECT QUESTION MARK	
0x2CFB, // COPTIC OLD NUBIAN INDIRECT QUESTION MARK	
0x2CFC, // COPTIC OLD NUBIAN VERSE DIVIDER	
0x2CFE, // COPTIC FULL STOP	
0x2CFF, // COPTIC MORPHOLOGICAL DIVIDER	
0x2D70, // TIFINAGH SEPARATOR MARK	
0x2E00, // RIGHT ANGLE SUBSTITUTION MARKER	
0x2E01, // RIGHT ANGLE DOTTED SUBSTITUTION MARKER	
0x2E06, // RAISED INTERPOLATION MARKER	
0x2E07, // RAISED DOTTED INTERPOLATION MARKER	
0x2E08, // DOTTED TRANSPOSITION MARKER	
0x2E0B, // RAISED SQUARE	
0x2E0E, // EDITORIAL CORONIS	
0x2E0F, // PARAGRAPHOS	
0x2E10, // FORKED PARAGRAPHOS	
0x2E11, // REVERSED FORKED PARAGRAPHOS	
0x2E12, // HYPODIASTOLE	
0x2E13, // DOTTED OBELOS	
0x2E14, // DOWNWARDS ANCORA	
0x2E15, // UPWARDS ANCORA	
0x2E16, // DOTTED RIGHT-POINTING ANGLE	
0x2E18, // INVERTED INTERROBANG	
0x2E19, // PALM BRANCH	
0x2E1B, // TILDE WITH RING ABOVE	
0x2E1E, // TILDE WITH DOT ABOVE	
0x2E1F, // TILDE WITH DOT BELOW	
0x2E2A, // TWO DOTS OVER ONE DOT PUNCTUATION	
0x2E2B, // ONE DOT OVER TWO DOTS PUNCTUATION	
0x2E2C, // SQUARED FOUR DOT PUNCTUATION	
0x2E2D, // FIVE DOT MARK	
0x2E2E, // REVERSED QUESTION MARK	
0x2E30, // RING POINT	
0x2E31, // WORD SEPARATOR MIDDLE DOT	
0x2E32, // TURNED COMMA	
0x2E33, // RAISED DOT	
0x2E34, // RAISED COMMA	
0x2E35, // TURNED SEMICOLON	
0x2E36, // DAGGER WITH LEFT GUARD	
0x2E37, // DAGGER WITH RIGHT GUARD	
0x2E38, // TURNED DAGGER	
0x2E39, // TOP HALF SECTION SIGN	
0x2E3C, // STENOGRAPHIC FULL STOP	
0x2E3D, // VERTICAL SIX DOTS	
0x2E3E, // WIGGLY VERTICAL LINE	
0x2E3F, // CAPITULUM	
0x2E41, // REVERSED COMMA	
0x2E43, // DASH WITH LEFT UPTURN	
0x2E44, // DOUBLE SUSPENSION MARK	
0x2E45, // INVERTED LOW KAVYKA	
0x2E46, // INVERTED LOW KAVYKA WITH KAVYKA ABOVE	
0x2E47, // LOW KAVYKA	
0x2E48, // LOW KAVYKA WITH DOT	
0x2E49, // DOUBLE STACKED COMMA	
0x2E4A, // DOTTED SOLIDUS	
0x2E4B, // TRIPLE DAGGER	
0x2E4C, // MEDIEVAL COMMA	
0x2E4D, // PARAGRAPHUS MARK	
0x2E4E, // PUNCTUS ELEVATUS MARK	
0x2E4F, // CORNISH VERSE DIVIDER	
0x3001, // IDEOGRAPHIC COMMA	
0x3002, // IDEOGRAPHIC FULL STOP	
0x3003, // DITTO MARK	
0x303D, // PART ALTERNATION MARK	
0x30FB, // KATAKANA MIDDLE DOT	
0xA4FE, // LISU PUNCTUATION COMMA	
0xA4FF, // LISU PUNCTUATION FULL STOP	
0xA60D, // VAI COMMA	
0xA60E, // VAI FULL STOP	
0xA60F, // VAI QUESTION MARK	
0xA673, // SLAVONIC ASTERISK	
0xA67E, // CYRILLIC KAVYKA	
0xA6F2, // BAMUM NJAEMLI	
0xA6F3, // BAMUM FULL STOP	
0xA6F4, // BAMUM COLON	
0xA6F5, // BAMUM COMMA	
0xA6F6, // BAMUM SEMICOLON	
0xA6F7, // BAMUM QUESTION MARK	
0xA874, // PHAGS-PA SINGLE HEAD MARK	
0xA875, // PHAGS-PA DOUBLE HEAD MARK	
0xA876, // PHAGS-PA MARK SHAD	
0xA877, // PHAGS-PA MARK DOUBLE SHAD	
0xA8CE, // SAURASHTRA DANDA	
0xA8CF, // SAURASHTRA DOUBLE DANDA	
0xA8F8, // DEVANAGARI SIGN PUSHPIKA	
0xA8F9, // DEVANAGARI GAP FILLER	
0xA8FA, // DEVANAGARI CARET	
0xA8FC, // DEVANAGARI SIGN SIDDHAM	
0xA92E, // KAYAH LI SIGN CWI	
0xA92F, // KAYAH LI SIGN SHYA	
0xA95F, // REJANG SECTION MARK	
0xA9C1, // JAVANESE LEFT RERENGGAN	
0xA9C2, // JAVANESE RIGHT RERENGGAN	
0xA9C3, // JAVANESE PADA ANDAP	
0xA9C4, // JAVANESE PADA MADYA	
0xA9C5, // JAVANESE PADA LUHUR	
0xA9C6, // JAVANESE PADA WINDU	
0xA9C7, // JAVANESE PADA PANGKAT	
0xA9C8, // JAVANESE PADA LINGSA	
0xA9C9, // JAVANESE PADA LUNGSI	
0xA9CA, // JAVANESE PADA ADEG	
0xA9CB, // JAVANESE PADA ADEG ADEG	
0xA9CC, // JAVANESE PADA PISELEH	
0xA9CD, // JAVANESE TURNED PADA PISELEH	
0xA9DE, // JAVANESE PADA TIRTA TUMETES	
0xA9DF, // JAVANESE PADA ISEN-ISEN	
0xAA5C, // CHAM PUNCTUATION SPIRAL	
0xAA5D, // CHAM PUNCTUATION DANDA	
0xAA5E, // CHAM PUNCTUATION DOUBLE DANDA	
0xAA5F, // CHAM PUNCTUATION TRIPLE DANDA	
0xAADE, // TAI VIET SYMBOL HO HOI	
0xAADF, // TAI VIET SYMBOL KOI KOI	
0xAAF0, // MEETEI MAYEK CHEIKHAN	
0xAAF1, // MEETEI MAYEK AHANG KHUDAM	
0xABEB, // MEETEI MAYEK CHEIKHEI	
0xFE10, // PRESENTATION FORM FOR VERTICAL COMMA	
0xFE11, // PRESENTATION FORM FOR VERTICAL IDEOGRAPHIC COMMA	
0xFE12, // PRESENTATION FORM FOR VERTICAL IDEOGRAPHIC FULL STOP	
0xFE13, // PRESENTATION FORM FOR VERTICAL COLON	
0xFE14, // PRESENTATION FORM FOR VERTICAL SEMICOLON	
0xFE15, // PRESENTATION FORM FOR VERTICAL EXCLAMATION MARK	
0xFE16, // PRESENTATION FORM FOR VERTICAL QUESTION MARK	
0xFE19, // PRESENTATION FORM FOR VERTICAL HORIZONTAL ELLIPSIS	
0xFE30, // PRESENTATION FORM FOR VERTICAL TWO DOT LEADER	
0xFE45, // SESAME DOT	
0xFE46, // WHITE SESAME DOT	
0xFE49, // DASHED OVERLINE	
0xFE4A, // CENTRELINE OVERLINE	
0xFE4B, // WAVY OVERLINE	
0xFE4C, // DOUBLE WAVY OVERLINE	
0xFE50, // SMALL COMMA	
0xFE51, // SMALL IDEOGRAPHIC COMMA	
0xFE52, // SMALL FULL STOP	
0xFE54, // SMALL SEMICOLON	
0xFE55, // SMALL COLON	
0xFE56, // SMALL QUESTION MARK	
0xFE57, // SMALL EXCLAMATION MARK	
0xFE5F, // SMALL NUMBER SIGN	
0xFE60, // SMALL AMPERSAND	
0xFE61, // SMALL ASTERISK	
0xFE68, // SMALL REVERSE SOLIDUS	
0xFE6A, // SMALL PERCENT SIGN	
0xFE6B, // SMALL COMMERCIAL AT	
0xFF01, // FULLWIDTH EXCLAMATION MARK	
0xFF02, // FULLWIDTH QUOTATION MARK	
0xFF03, // FULLWIDTH NUMBER SIGN	
0xFF05, // FULLWIDTH PERCENT SIGN	
0xFF06, // FULLWIDTH AMPERSAND	
0xFF07, // FULLWIDTH APOSTROPHE	
0xFF0A, // FULLWIDTH ASTERISK	
0xFF0C, // FULLWIDTH COMMA	
0xFF0E, // FULLWIDTH FULL STOP	
0xFF0F, // FULLWIDTH SOLIDUS	
0xFF1A, // FULLWIDTH COLON	
0xFF1B, // FULLWIDTH SEMICOLON	
0xFF1F, // FULLWIDTH QUESTION MARK	
0xFF20, // FULLWIDTH COMMERCIAL AT	
0xFF3C, // FULLWIDTH REVERSE SOLIDUS	
0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP	
0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA	
0xFF65, // HALFWIDTH KATAKANA MIDDLE DOT	
0x10100, // AEGEAN WORD SEPARATOR LINE	
0x10101, // AEGEAN WORD SEPARATOR DOT	
0x10102, // AEGEAN CHECK MARK	
0x1039F, // UGARITIC WORD DIVIDER	
0x103D0, // OLD PERSIAN WORD DIVIDER	
0x1056F, // CAUCASIAN ALBANIAN CITATION MARK	
0x10857, // IMPERIAL ARAMAIC SECTION SIGN	
0x1091F, // PHOENICIAN WORD SEPARATOR	
0x1093F, // LYDIAN TRIANGULAR MARK	
0x10A50, // KHAROSHTHI PUNCTUATION DOT	
0x10A51, // KHAROSHTHI PUNCTUATION SMALL CIRCLE	
0x10A52, // KHAROSHTHI PUNCTUATION CIRCLE	
0x10A53, // KHAROSHTHI PUNCTUATION CRESCENT BAR	
0x10A54, // KHAROSHTHI PUNCTUATION MANGALAM	
0x10A55, // KHAROSHTHI PUNCTUATION LOTUS	
0x10A56, // KHAROSHTHI PUNCTUATION DANDA	
0x10A57, // KHAROSHTHI PUNCTUATION DOUBLE DANDA	
0x10A58, // KHAROSHTHI PUNCTUATION LINES	
0x10A7F, // OLD SOUTH ARABIAN NUMERIC INDICATOR	
0x10AF0, // MANICHAEAN PUNCTUATION STAR	
0x10AF1, // MANICHAEAN PUNCTUATION FLEURON	
0x10AF2, // MANICHAEAN PUNCTUATION DOUBLE DOT WITHIN DOT	
0x10AF3, // MANICHAEAN PUNCTUATION DOT WITHIN DOT	
0x10AF4, // MANICHAEAN PUNCTUATION DOT	
0x10AF5, // MANICHAEAN PUNCTUATION TWO DOTS	
0x10AF6, // MANICHAEAN PUNCTUATION LINE FILLER	
0x10B39, // AVESTAN ABBREVIATION MARK	
0x10B3A, // TINY TWO DOTS OVER ONE DOT PUNCTUATION	
0x10B3B, // SMALL TWO DOTS OVER ONE DOT PUNCTUATION	
0x10B3C, // LARGE TWO DOTS OVER ONE DOT PUNCTUATION	
0x10B3D, // LARGE ONE DOT OVER TWO DOTS PUNCTUATION	
0x10B3E, // LARGE TWO RINGS OVER ONE RING PUNCTUATION	
0x10B3F, // LARGE ONE RING OVER TWO RINGS PUNCTUATION	
0x10B99, // PSALTER PAHLAVI SECTION MARK	
0x10B9A, // PSALTER PAHLAVI TURNED SECTION MARK	
0x10B9B, // PSALTER PAHLAVI FOUR DOTS WITH CROSS	
0x10B9C, // PSALTER PAHLAVI FOUR DOTS WITH DOT	
0x10F55, // SOGDIAN PUNCTUATION TWO VERTICAL BARS	
0x10F56, // SOGDIAN PUNCTUATION TWO VERTICAL BARS WITH DOTS	
0x10F57, // SOGDIAN PUNCTUATION CIRCLE WITH DOT	
0x10F58, // SOGDIAN PUNCTUATION TWO CIRCLES WITH DOTS	
0x10F59, // SOGDIAN PUNCTUATION HALF CIRCLE WITH DOT	
0x11047, // BRAHMI DANDA	
0x11048, // BRAHMI DOUBLE DANDA	
0x11049, // BRAHMI PUNCTUATION DOT	
0x1104A, // BRAHMI PUNCTUATION DOUBLE DOT	
0x1104B, // BRAHMI PUNCTUATION LINE	
0x1104C, // BRAHMI PUNCTUATION CRESCENT BAR	
0x1104D, // BRAHMI PUNCTUATION LOTUS	
0x110BB, // KAITHI ABBREVIATION SIGN	
0x110BC, // KAITHI ENUMERATION SIGN	
0x110BE, // KAITHI SECTION MARK	
0x110BF, // KAITHI DOUBLE SECTION MARK	
0x110C0, // KAITHI DANDA	
0x110C1, // KAITHI DOUBLE DANDA	
0x11140, // CHAKMA SECTION MARK	
0x11141, // CHAKMA DANDA	
0x11142, // CHAKMA DOUBLE DANDA	
0x11143, // CHAKMA QUESTION MARK	
0x11174, // MAHAJANI ABBREVIATION SIGN	
0x11175, // MAHAJANI SECTION MARK	
0x111C5, // SHARADA DANDA	
0x111C6, // SHARADA DOUBLE DANDA	
0x111C7, // SHARADA ABBREVIATION SIGN	
0x111C8, // SHARADA SEPARATOR	
0x111CD, // SHARADA SUTRA MARK	
0x111DB, // SHARADA SIGN SIDDHAM	
0x111DD, // SHARADA CONTINUATION SIGN	
0x111DE, // SHARADA SECTION MARK-1	
0x111DF, // SHARADA SECTION MARK-2	
0x11238, // KHOJKI DANDA	
0x11239, // KHOJKI DOUBLE DANDA	
0x1123A, // KHOJKI WORD SEPARATOR	
0x1123B, // KHOJKI SECTION MARK	
0x1123C, // KHOJKI DOUBLE SECTION MARK	
0x1123D, // KHOJKI ABBREVIATION SIGN	
0x112A9, // MULTANI SECTION MARK	
0x1144B, // NEWA DANDA	
0x1144C, // NEWA DOUBLE DANDA	
0x1144D, // NEWA COMMA	
0x1144E, // NEWA GAP FILLER	
0x1144F, // NEWA ABBREVIATION SIGN	
0x1145B, // NEWA PLACEHOLDER MARK	
0x1145D, // NEWA INSERTION SIGN	
0x114C6, // TIRHUTA ABBREVIATION SIGN	
0x115C1, // SIDDHAM SIGN SIDDHAM	
0x115C2, // SIDDHAM DANDA	
0x115C3, // SIDDHAM DOUBLE DANDA	
0x115C4, // SIDDHAM SEPARATOR DOT	
0x115C5, // SIDDHAM SEPARATOR BAR	
0x115C6, // SIDDHAM REPETITION MARK-1	
0x115C7, // SIDDHAM REPETITION MARK-2	
0x115C8, // SIDDHAM REPETITION MARK-3	
0x115C9, // SIDDHAM END OF TEXT MARK	
0x115CA, // SIDDHAM SECTION MARK WITH TRIDENT AND U-SHAPED ORNAMENTS	
0x115CB, // SIDDHAM SECTION MARK WITH TRIDENT AND DOTTED CRESCENTS	
0x115CC, // SIDDHAM SECTION MARK WITH RAYS AND DOTTED CRESCENTS	
0x115CD, // SIDDHAM SECTION MARK WITH RAYS AND DOTTED DOUBLE CRESCENTS	
0x115CE, // SIDDHAM SECTION MARK WITH RAYS AND DOTTED TRIPLE CRESCENTS	
0x115CF, // SIDDHAM SECTION MARK DOUBLE RING	
0x115D0, // SIDDHAM SECTION MARK DOUBLE RING WITH RAYS	
0x115D1, // SIDDHAM SECTION MARK WITH DOUBLE CRESCENTS	
0x115D2, // SIDDHAM SECTION MARK WITH TRIPLE CRESCENTS	
0x115D3, // SIDDHAM SECTION MARK WITH QUADRUPLE CRESCENTS	
0x115D4, // SIDDHAM SECTION MARK WITH SEPTUPLE CRESCENTS	
0x115D5, // SIDDHAM SECTION MARK WITH CIRCLES AND RAYS	
0x115D6, // SIDDHAM SECTION MARK WITH CIRCLES AND TWO ENCLOSURES	
0x115D7, // SIDDHAM SECTION MARK WITH CIRCLES AND FOUR ENCLOSURES	
0x11641, // MODI DANDA	
0x11642, // MODI DOUBLE DANDA	
0x11643, // MODI ABBREVIATION SIGN	
0x11660, // MONGOLIAN BIRGA WITH ORNAMENT	
0x11661, // MONGOLIAN ROTATED BIRGA	
0x11662, // MONGOLIAN DOUBLE BIRGA WITH ORNAMENT	
0x11663, // MONGOLIAN TRIPLE BIRGA WITH ORNAMENT	
0x11664, // MONGOLIAN BIRGA WITH DOUBLE ORNAMENT	
0x11665, // MONGOLIAN ROTATED BIRGA WITH ORNAMENT	
0x11666, // MONGOLIAN ROTATED BIRGA WITH DOUBLE ORNAMENT	
0x11667, // MONGOLIAN INVERTED BIRGA	
0x11668, // MONGOLIAN INVERTED BIRGA WITH DOUBLE ORNAMENT	
0x11669, // MONGOLIAN SWIRL BIRGA	
0x1166A, // MONGOLIAN SWIRL BIRGA WITH ORNAMENT	
0x1166B, // MONGOLIAN SWIRL BIRGA WITH DOUBLE ORNAMENT	
0x1166C, // MONGOLIAN TURNED SWIRL BIRGA WITH DOUBLE ORNAMENT	
0x1173C, // AHOM SIGN SMALL SECTION	
0x1173D, // AHOM SIGN SECTION	
0x1173E, // AHOM SIGN RULAI	
0x1183B, // DOGRA ABBREVIATION SIGN	
0x119E2, // NANDINAGARI SIGN SIDDHAM	
0x11A3F, // ZANABAZAR SQUARE INITIAL HEAD MARK	
0x11A40, // ZANABAZAR SQUARE CLOSING HEAD MARK	
0x11A41, // ZANABAZAR SQUARE MARK TSHEG	
0x11A42, // ZANABAZAR SQUARE MARK SHAD	
0x11A43, // ZANABAZAR SQUARE MARK DOUBLE SHAD	
0x11A44, // ZANABAZAR SQUARE MARK LONG TSHEG	
0x11A45, // ZANABAZAR SQUARE INITIAL DOUBLE-LINED HEAD MARK	
0x11A46, // ZANABAZAR SQUARE CLOSING DOUBLE-LINED HEAD MARK	
0x11A9A, // SOYOMBO MARK TSHEG	
0x11A9B, // SOYOMBO MARK SHAD	
0x11A9C, // SOYOMBO MARK DOUBLE SHAD	
0x11A9E, // SOYOMBO HEAD MARK WITH MOON AND SUN AND TRIPLE FLAME	
0x11A9F, // SOYOMBO HEAD MARK WITH MOON AND SUN AND FLAME	
0x11AA0, // SOYOMBO HEAD MARK WITH MOON AND SUN	
0x11AA1, // SOYOMBO TERMINAL MARK-1	
0x11AA2, // SOYOMBO TERMINAL MARK-2	
0x11C41, // BHAIKSUKI DANDA	
0x11C42, // BHAIKSUKI DOUBLE DANDA	
0x11C43, // BHAIKSUKI WORD SEPARATOR	
0x11C44, // BHAIKSUKI GAP FILLER-1	
0x11C45, // BHAIKSUKI GAP FILLER-2	
0x11C70, // MARCHEN HEAD MARK	
0x11C71, // MARCHEN MARK SHAD	
0x11EF7, // MAKASAR PASSIMBANG	
0x11EF8, // MAKASAR END OF SECTION	
0x11FFF, // TAMIL PUNCTUATION END OF TEXT	
0x12470, // CUNEIFORM PUNCTUATION SIGN OLD ASSYRIAN WORD DIVIDER	
0x12471, // CUNEIFORM PUNCTUATION SIGN VERTICAL COLON	
0x12472, // CUNEIFORM PUNCTUATION SIGN DIAGONAL COLON	
0x12473, // CUNEIFORM PUNCTUATION SIGN DIAGONAL TRICOLON	
0x12474, // CUNEIFORM PUNCTUATION SIGN DIAGONAL QUADCOLON	
0x16A6E, // MRO DANDA	
0x16A6F, // MRO DOUBLE DANDA	
0x16AF5, // BASSA VAH FULL STOP	
0x16B37, // PAHAWH HMONG SIGN VOS THOM	
0x16B38, // PAHAWH HMONG SIGN VOS TSHAB CEEB	
0x16B39, // PAHAWH HMONG SIGN CIM CHEEM	
0x16B3A, // PAHAWH HMONG SIGN VOS THIAB	
0x16B3B, // PAHAWH HMONG SIGN VOS FEEM	
0x16B44, // PAHAWH HMONG SIGN XAUS	
0x16E97, // MEDEFAIDRIN COMMA	
0x16E98, // MEDEFAIDRIN FULL STOP	
0x16E99, // MEDEFAIDRIN SYMBOL AIVA	
0x16E9A, // MEDEFAIDRIN EXCLAMATION OH	
0x16FE2, // OLD CHINESE HOOK MARK	
0x1BC9F, // DUPLOYAN PUNCTUATION CHINOOK FULL STOP	
0x1DA87, // SIGNWRITING COMMA	
0x1DA88, // SIGNWRITING FULL STOP	
0x1DA89, // SIGNWRITING SEMICOLON	
0x1DA8A, // SIGNWRITING COLON	
0x1DA8B, // SIGNWRITING PARENTHESIS	
0x1E95E, // ADLAM INITIAL EXCLAMATION MARK	
0x1E95F, // ADLAM INITIAL QUESTION MARK
]
)
import encoding.utf8

fn test_utf8_util() {

	// string test
	src:="  testo "//_\u1E5A\u1E5B<=>\u1F49\u1F41<=>\u0128\u012a\u012c" // len 29 runes, raw 49 bytes
	src_upper:="  TESTO "//_\u1E5A\u1E5A<=>\u1F49\u1F49<=>\u0128\u012A\u012C"
	src_lower:="  testo "//_\u1E5B\u1E5B<=>\u1F41\u1F41<=>\u0129\u012B\u012D"
	upper:=utf8.to_upper(src)
	lower:=utf8.to_lower(src)
	assert upper==src_upper
	assert lower==src_lower

	// ustring test
	src1:=src.ustring()
	upper1:=utf8.u_to_upper(src1)
	lower1:=utf8.u_to_lower(src1)
	assert upper1==( src_upper.ustring() )
	assert lower1==( src_lower.ustring() )

	// test len function
	assert utf8.len("pippo")==5
	assert utf8.len(src)==15 //29
	assert src.len==24 //49
	// test u_len function
	assert utf8.u_len(src1)==15 //29
	assert utf8.u_len("pippo".ustring())==5

	// western punctuation
	a := '.abc?abc.'  	
  	assert utf8.is_punct(a,0)==true
  	assert utf8.is_punct('b',0)==false
  	assert utf8.is_uchar_punct(0x002E)==true 
  	assert utf8.is_punct(a,4)==true		// ?
  	assert utf8.is_punct(a,14)==true		// last .
  	assert utf8.is_punct(a,12)==false	// 
  	println("OK western")
  	
  	// global punctuation
  	b := '.a.  TESTO '
  	assert utf8.is_global_punct(b,0)==true
  	assert utf8.is_global_punct('.',0)==true
  	assert utf8.is_uchar_punct(0x002E)==true
  	assert utf8.is_global_punct(b,6)==true	// .
  	assert utf8.is_global_punct(b,1)==false	// a

  	// test utility functions
  	assert utf8.get_uchar(b,0)==0x002E
}
module eventbus

pub type EventHandlerFn fn(voidptr, voidptr, voidptr)

pub struct Publisher {
mut:
	registry &Registry
}

pub struct Subscriber {
mut:
	registry &Registry
}

struct Registry {
mut:
	events []EventHandler
}

struct EventHandler {
	name string
	handler EventHandlerFn
	receiver voidptr
	once bool
}

pub struct EventBus {
pub mut:
	registry   &Registry
	publisher  &Publisher
pub:
	subscriber &Subscriber
}

pub fn new() &EventBus {
	registry := &Registry{
		events: []
	}
	return &EventBus{
		registry,&Publisher{
			registry},&Subscriber{
			registry}
	}
}

// EventBus Methods
pub fn (eb &EventBus) publish(name string, sender voidptr, args voidptr) {
	mut publisher := eb.publisher
	publisher.publish(name, sender, args)
}

pub fn (eb &EventBus) clear_all() {
	mut publisher := eb.publisher
	publisher.clear_all()
}

pub fn (eb &EventBus) has_subscriber(name string) bool {
	return eb.registry.check_subscriber(name)
}

// Publisher Methods
fn (mut pb Publisher) publish(name string, sender voidptr, args voidptr) {
	for i, event in pb.registry.events {
		if event.name == name {
			if event.once {
				pb.registry.events.delete(i)
			}
			if event.receiver != 0 {
				event.handler(event.receiver, args, sender)
			} else {
				event.handler(sender, args, voidptr(0))
			}
		}
	}
}

fn (mut p Publisher) clear_all() {
	if p.registry.events.len == 0 {
		return
	}
	for i := p.registry.events.len - 1; i >= 0; i-- {
		p.registry.events.delete(i)
	}
}

// Subscriber Methods
pub fn (mut s Subscriber) subscribe(name string, handler EventHandlerFn) {
	s.registry.events << EventHandler {
		name: name
		handler: handler
		receiver: voidptr(0)
	}
}

pub fn (mut s Subscriber) subscribe_method(name string, handler EventHandlerFn, receiver voidptr) {
	s.registry.events << EventHandler {
		name: name
		handler: handler
		receiver: receiver
	}
}

pub fn (mut s Subscriber) subscribe_once(name string, handler EventHandlerFn) {
	s.registry.events << EventHandler {
		name: name
		handler: handler
		receiver: voidptr(0)
		once: true
	}
}

pub fn (s &Subscriber) is_subscribed(name string) bool {
	return s.registry.check_subscriber(name)
}

pub fn (mut s Subscriber) unsubscribe(name string, handler EventHandlerFn) {
	// v := voidptr(handler)
	for i, event in s.registry.events {
		if event.name == name {
			if event.handler == handler {
				s.registry.events.delete(i)
			}
		}
	}
}

// Registry Methods
fn (r &Registry) check_subscriber(name string) bool {
	for event in r.events {
		if event.name == name {
			return true
		}
	}
	return false
}
import eventbus

struct EventData {
	data	string
}

fn test_eventbus(){
	ev_data := &EventData{'hello'}
	mut eb := eventbus.new()
	eb.subscriber.subscribe_once("on_test", on_test)

	assert eb.has_subscriber("on_test")
	assert eb.subscriber.is_subscribed("on_test")

	eb.publish("on_test", eb, ev_data)

	assert !eb.has_subscriber("on_test")
	assert !eb.subscriber.is_subscribed("on_test")

	eb.subscriber.subscribe("on_test", on_test)

	assert eb.has_subscriber("on_test")
	assert eb.subscriber.is_subscribed("on_test")

	eb.clear_all()

	assert !eb.has_subscriber("on_test")
	assert !eb.subscriber.is_subscribed("on_test")
}

fn on_test(sender voidptr, ev &EventData, x voidptr) {
	assert ev.data == "hello"
}
# Event Bus

A module to provide eventing capabilities using pub/sub.

## API

1. `new()` - create a new `EventBus`

### Structs:

**EventBus:**

1. `publish(name string, sender voidptr, args voidptr)` - publish an event with provided Params & name
2. `clear_all()` - clear all subscribers
3. `has_subscriber(name string)` - check if a subscriber to an event exists

**Subscriber:**

1. `subscribe(name string, handler EventHandlerFn)` - subscribe to an event
2. `subscribe_once(name string, handler EventHandlerFn)` - subscribe only once to an event
3. `subscribe_method(name string, handler EventHandlerFn, reciever voidptr)` - subscribe to an event and also recieve the `reciever` as a parameter. Since it's not yet possible to send methods as parameters, this is the workaround.
4. `is_subscribed(name string)` - check if we are subscribed to an event
5. `unsubscribe(name string)` - unsubscribe from an event

**Event Handler Signature:**

The function given to `subscribe`, `subscribe_method` and `subscribe_once` must match this:

```v
fn(voidptr, voidptr, voidptr){

}

// Since V can map structs to voidptr, this also works
struct ClickEvent {
    x int
    y int
}

// Example case where publisher sends ClickEvent as args.
fn onPress(sender voidptr, e &ClickEvent){
    println(e.x)
    //your code here...
}
```

## Usage

For **usage across modules** [check the example](https://github.com/vlang/v/tree/master/examples/eventbus).

_Note: As a general rule, you will need to **subscribe before publishing**._

**main.v**

```v
module main
import eventbus

// initialize it globally
const (
    eb = eventbus.new()
)

fn main(){
    // get a mutable reference to the subscriber
	mut sub := eb.subscriber
    // subscribe to the 'error' event
	sub.subscribe("error", on_error)
    // start the work
	do_work()
}

// the event handler
fn on_error(work &Work, e &Error) {
	println('error occured on ${work.hours}. Error: ${e.message}')
}
```

**work.v**

```v
module main

struct Work{
    hours int
}

struct Error {
    message string
}

fn do_work(){
    work := Work{20}
    // get a mutable Params instance & put some data into it
	error := &Error{"Error: no internet connection."}
    // publish the event
    eb.publish("error", work, error)
}
```

### Notes:

1. Each `EventBus` instance has it's own registry (i.e. there is no global event registry so you can't just subscribe to an event wherever you are.
2. Each `EventBus` has a `Subscriber` instance which will need to be either exposed or you can make small public helper functions specific to your module like (`onPress`, `onError`) and etc.
3. The `eventbus` module has some helpers to ease getting/setting of Params (since V doesn't support empty interfaces yet or reflection) so use them (see usage above).

**The rationale behind separating Subscriber & Publisher:**

This is mainly for security because the if publisher & subscriber are both passed around, a client can easily publish events acting as the server. So a client should only be able to use the Subscriber methods.
module flag

// module flag for command-line flag parsing
//
// - parsing flags like '--flag' or '--stuff=things' or '--things stuff'
// - handles bool, int, float and string args
// - is able to print usage
// - handled unknown arguments as error
//
// Usage example:
//
//  ```v
//  module main
//
//  import os
//  import flag
//
//  fn main() {
//  	mut fp := flag.new_flag_parser(os.args)
//  	fp.application('flag_example_tool')
//  	fp.version('v0.0.0')
//  	fp.description('This tool is only designed to show how the flag lib is working')
//
//  	fp.skip_executable()
//
//  	an_int := fp.int('an_int', 0, 0o666, 'some int to define 0o666 is default')
//  	a_bool := fp.bool('a_bool', 0, false, 'some \'real\' flag')
//  	a_float := fp.float('a_float', 0, 1.0, 'also floats')
//  	a_string := fp.string('a_string', `a`, 'no text', 'finally, some text with "a" an abbreviation')
//
//  	additional_args := fp.finalize() or {
//  		eprintln(err)
//  		println(fp.usage())
//  		return
//  	}
//
//  	println('
//  		  an_int: $an_int
//  		  a_bool: $a_bool
//  		 a_float: $a_float
//  		a_string: \'$a_string\'
//  	')
//  	println(additional_args.join_lines())
//  }
//  ```

// data object storing information about a defined flag
pub struct Flag {
	pub:
	name     string // name as it appears on command line
	abbr     byte   // shortcut
	usage    string // help message
	val_desc string // something like '<arg>' that appears in usage,
	// and also the default value, when the flag is not given
}

pub fn (f Flag) str() string {
	return ''
	+'    flag:\n'
	+'            name: $f.name\n'
	+'            abbr: $f.abbr\n'
	+'            usag: $f.usage\n'
	+'            desc: $f.val_desc'
}
pub fn (af []Flag) str() string {
	mut res := []string{}
	res << '\n  []Flag = ['
	for f in af {
		res << f.str()
	}
	res << '  ]'
	return res.join('\n')
}
//
pub struct FlagParser {
	pub mut:
	args  []string                  // the arguments to be parsed
	max_free_args int
	flags []Flag                    // registered flags

	application_name        string
	application_version     string
	application_description string

	min_free_args int
	args_description        string
}

pub const (
	// used for formating usage message
	space = '                            '
	underline = '-----------------------------------------------'
	max_args_number = 4048
)

// create a new flag set for parsing command line arguments
// TODO use INT_MAX some how
pub fn new_flag_parser(args []string) &FlagParser {
	return &FlagParser{args: args.clone(), max_free_args: max_args_number}
}

// change the application name to be used in 'usage' output
pub fn (mut fs FlagParser) application(name string) {
	fs.application_name = name
}

// change the application version to be used in 'usage' output
pub fn (mut fs FlagParser) version(vers string) {
	fs.application_version = vers
}

// change the application version to be used in 'usage' output
pub fn (mut fs FlagParser) description(desc string) {
	fs.application_description = desc
}

// in most cases you do not need the first argv for flag parsing
pub fn (mut fs FlagParser) skip_executable() {
	fs.args.delete(0)
}

// private helper to register a flag
fn (mut fs FlagParser) add_flag(name string, abbr byte, usage string, desc string) {
	fs.flags << Flag{
		name: name,
		abbr: abbr,
		usage: usage,
		val_desc: desc
	}
}

// private: general parsing a single argument
//  - search args for existence
//    if true
//      extract the defined value as string
//    else
//      return an (dummy) error -> argument is not defined
//
//  - the name, usage are registered
//  - found arguments and corresponding values are removed from args list
fn (mut fs FlagParser) parse_value(longhand string, shorthand byte) []string {
	full := '--$longhand'
	mut found_entries := []string{}
	mut to_delete := []int{}
	mut should_skip_one := false
	for i, arg in fs.args {
		if should_skip_one {
			should_skip_one = false
			continue
		}
		if arg == '--' {
			//End of input. We're done here.
			break
		}
		if arg[0] != `-` {
			continue
		}
		if (arg.len == 2 && arg[0] == `-` && arg[1] == shorthand ) || arg == full {
			if i+1 >= fs.args.len {
				panic("Missing argument for '$longhand'")
			}
			nextarg := fs.args[i+1]
			if nextarg.len > 2 && nextarg[..2] == '--' {
				//It could be end of input (--) or another argument (--abc).
				//Both are invalid so die.
				panic("Missing argument for '$longhand'")
			}
			found_entries << fs.args[i+1]
			to_delete << i
			to_delete << i+1
			should_skip_one = true
			continue
		}
		if arg.len > full.len+1 && arg[..full.len+1] == '$full=' {
			found_entries << arg[full.len+1..]
			to_delete << i
			continue
		}
	}
	for i, del in to_delete {
		//i entrys are deleted so it's shifted left i times.
		fs.args.delete(del - i)
	}
	return found_entries
}

// special parsing for bool values
// see also: parse_value
//
// special: it is allowed to define bool flags without value
// -> '--flag' is parsed as true
// -> '--flag' is equal to '--flag=true'
fn (mut fs FlagParser) parse_bool_value(longhand string, shorthand byte) ?string {
	full := '--$longhand'
	for i, arg in fs.args {
		if arg == '--' {
			//End of input. We're done.
			break
		}
		if arg.len == 0 {
			continue
		}
		if arg[0] != `-` {
			continue
		}
		if ( arg.len == 2 && arg[0] == `-` && arg[1] == shorthand ) || arg == full {
			if fs.args.len > i+1 && (fs.args[i+1] in ['true', 'false'])  {
				val := fs.args[i+1]
				fs.args.delete(i+1)
				fs.args.delete(i)
				return val
			} else {
				fs.args.delete(i)
				return 'true'
			}
		}
		if arg.len > full.len+1 && arg[..full.len+1] == '$full=' {
			// Flag abc=true
			val := arg[full.len+1..]
			fs.args.delete(i)
			return val
		}
		if arg[0] == `-` && arg[1] != `-` && arg.index_byte(shorthand) != -1 {
			// -abc is equivalent to -a -b -c
			return 'true'
		}
	}
	return error("parameter '$longhand' not found")
}

// bool_opt returns an optional that returns the value associated with the flag.
// In the situation that the flag was not provided, it returns null.
pub fn (mut fs FlagParser) bool_opt(name string, abbr byte, usage string) ?bool {
	fs.add_flag(name, abbr, usage, '<bool>')
	parsed := fs.parse_bool_value(name, abbr) or {
		return error("parameter '$name' not provided")
	}
	return parsed == 'true'
}

// defining and parsing a bool flag
//  if defined
//      the value is returned (true/false)
//  else
//      the default value is returned
// version with abbr
//TODO error handling for invalid string to bool conversion
pub fn (mut fs FlagParser) bool(name string, abbr byte, bdefault bool, usage string) bool {
	value := fs.bool_opt(name, abbr, usage) or {
		return bdefault
	}
	return value
}

// int_multi returns all instances of values associated with the flags provided
// In the case that none were found, it returns an empty array.
pub fn (mut fs FlagParser) int_multi(name string, abbr byte, usage string) []int {
	fs.add_flag(name, abbr, usage, '<multiple ints>')
	parsed := fs.parse_value(name, abbr)
	mut value := []int{}
	for val in parsed {
		value << val.int()
	}
	return value
}

// int_opt returns an optional that returns the value associated with the flag.
// In the situation that the flag was not provided, it returns null.
pub fn (mut fs FlagParser) int_opt(name string, abbr byte, usage string) ?int {
	fs.add_flag(name, abbr, usage, '<int>')
	parsed := fs.parse_value(name, abbr)
	if parsed.len == 0 {
		return error("parameter '$name' not provided")
	}
	return parsed[0].int()
}

// defining and parsing an int flag
//  if defined
//      the value is returned (int)
//  else
//      the default value is returned
// version with abbr
//TODO error handling for invalid string to int conversion
pub fn (mut fs FlagParser) int(name string, abbr byte, idefault int, usage string) int {
	value := fs.int_opt(name, abbr, usage) or {
		return idefault
	}
	return value
}

// float_multi returns all instances of values associated with the flags provided
// In the case that none were found, it returns an empty array.
pub fn (mut fs FlagParser) float_multi(name string, abbr byte, usage string) []f64 {
	fs.add_flag(name, abbr, usage, '<multiple floats>')
	parsed := fs.parse_value(name, abbr)
	mut value := []f64{}
	for val in parsed {
		value << val.f64()
	}
	return value
}

// float_opt returns an optional that returns the value associated with the flag.
// In the situation that the flag was not provided, it returns null.
pub fn (mut fs FlagParser) float_opt(name string, abbr byte, usage string) ?f64 {
	fs.add_flag(name, abbr, usage, '<float>')
	parsed := fs.parse_value(name, abbr)
	if parsed.len == 0 {
		return error("parameter '$name' not provided")
	}
	return parsed[0].f64()
}

// defining and parsing a float flag
//  if defined
//      the value is returned (float)
//  else
//      the default value is returned
// version with abbr
//TODO error handling for invalid string to float conversion
pub fn (mut fs FlagParser) float(name string, abbr byte, fdefault f64, usage string) f64 {
	value := fs.float_opt(name, abbr, usage) or {
		return fdefault
	}
	return value
}

// string_multi returns all instances of values associated with the flags provided
// In the case that none were found, it returns an empty array.
pub fn (mut fs FlagParser) string_multi(name string, abbr byte, usage string) []string {
	fs.add_flag(name, abbr, usage, '<multiple floats>')
	return fs.parse_value(name, abbr)
}

// string_opt returns an optional that returns the value associated with the flag.
// In the situation that the flag was not provided, it returns null.
pub fn (mut fs FlagParser) string_opt(name string, abbr byte, usage string) ?string {
	fs.add_flag(name, abbr, usage, '<string>')
	parsed := fs.parse_value(name, abbr)
	if parsed.len == 0 {
		return error("parameter '$name' not provided")
	}
	return parsed[0]
}

// defining and parsing a string flag
//  if defined
//      the value is returned (string)
//  else
//      the default value is returned
// version with abbr
pub fn (mut fs FlagParser) string(name string, abbr byte, sdefault string, usage string) string {
	value := fs.string_opt(name, abbr, usage) or {
		return sdefault
	}
	return value
}

pub fn (mut fs FlagParser) limit_free_args_to_at_least(n int) {
	if n > max_args_number {
		panic('flag.limit_free_args_to_at_least expect n to be smaller than $max_args_number')
	}
	if n <= 0 {
		panic('flag.limit_free_args_to_at_least expect n to be a positive number')
	}
	fs.min_free_args = n
}

pub fn (mut fs FlagParser) limit_free_args_to_exactly(n int) {
	if n > max_args_number {
		panic('flag.limit_free_args_to_exactly expect n to be smaller than $max_args_number')
	}
	if n < 0 {
		panic('flag.limit_free_args_to_exactly expect n to be a non negative number')
	}
	fs.min_free_args = n
	fs.max_free_args = n
}

// this will cause an error in finalize() if free args are out of range
// (min, ..., max)
pub fn (mut fs FlagParser) limit_free_args(min, max int) {
	if min > max {
		panic('flag.limit_free_args expect min < max, got $min >= $max')
	}
	fs.min_free_args = min
	fs.max_free_args = max
}

pub fn (mut fs FlagParser) arguments_description(description string){
	fs.args_description = description
}

// collect all given information and
pub fn (fs FlagParser) usage() string {

	positive_min_arg := ( fs.min_free_args > 0 )
	positive_max_arg := ( fs.max_free_args > 0 && fs.max_free_args != max_args_number )
	no_arguments := ( fs.min_free_args == 0 && fs.max_free_args == 0 )

	mut adesc := if fs.args_description.len > 0 { fs.args_description } else { '[ARGS]' }
	if no_arguments { adesc = '' }

	mut use := ''
	if fs.application_version != '' {
		use += '$fs.application_name $fs.application_version\n'
		use += '$underline\n'
	}
	use += 'Usage: ${fs.application_name} [options] $adesc\n'
	use += '\n'
	if fs.application_description != '' {
		use += 'Description:\n'
		use += '$fs.application_description'
		use += '\n\n'
	}

	// show a message about the [ARGS]:
	if positive_min_arg || positive_max_arg || no_arguments {
		if no_arguments {
			use += 'This application does not expect any arguments\n\n'
			goto end_of_arguments_handling
		}
		mut s:= []string{}
		if positive_min_arg { s << 'at least $fs.min_free_args' }
		if positive_max_arg { s << 'at most $fs.max_free_args' }
		if positive_min_arg && positive_max_arg && fs.min_free_args == fs.max_free_args {
			s = ['exactly $fs.min_free_args']
		}
		sargs := s.join(' and ')
		use += 'The arguments should be $sargs in number.\n\n'
	}
	end_of_arguments_handling:

	if fs.flags.len > 0 {
		use += 'Options:\n'
		for f in fs.flags {
			mut onames := []string{}
			if f.abbr != 0 {
				onames << '-${f.abbr.str()}'
			}
			if f.name != '' {
				if !f.val_desc.contains('<bool>') {
					onames << '--${f.name} $f.val_desc'
				}else{
					onames << '--${f.name}'
				}
			}
			option_names := '  ' + onames.join(', ')
			mut xspace := ''
			if option_names.len > space.len-2 {
				xspace = '\n${space}'
			} else {
				xspace = space[option_names.len..]
			}
			use += '${option_names}${xspace}${f.usage}\n'
		}
	}

	return use
}

// finalize argument parsing -> call after all arguments are defined
//
// all remaining arguments are returned in the same order they are defined on
// command line
//
// if additional flag are found (things starting with '--') an error is returned
// error handling is up to the application developer
pub fn (fs FlagParser) finalize() ?[]string {
	for a in fs.args {
		if a.len >= 2 && a[..2] == '--' {
			return error('Unknown argument \'${a[2..]}\'')
		}
	}
	if fs.args.len < fs.min_free_args && fs.min_free_args > 0 {
		return error('Expected at least ${fs.min_free_args} arguments, but given $fs.args.len')
	}
	if fs.args.len > fs.max_free_args && fs.max_free_args > 0 {
		return error('Expected at most ${fs.max_free_args} arguments, but given $fs.args.len')
	}
	if fs.args.len > 0 && fs.max_free_args == 0 && fs.min_free_args == 0 {
		return error('Expected no arguments, but given $fs.args.len')
	}
	return fs.args
}
import flag

fn test_if_flag_not_given_return_default_values() {
	mut fp := flag.new_flag_parser([])

	assert false == fp.bool('a_bool', 0, false, '')
	&& 42 == fp.int('an_int', 0, 42, '')
	&& 1.0 == fp.float('a_float', 0, 1.0, '')
	&& 'stuff' == fp.string('a_string', 0, 'stuff', '')
}


fn test_could_define_application_name_and_version() {
	mut fp := flag.new_flag_parser([])
	fp.application('test app')
	fp.version('0.0.42')
	fp.description('some text')

	assert fp.application_name == 'test app'
	&& fp.application_version == '0.0.42'
	&& fp.application_description == 'some text'
}

fn test_bool_flags_do_not_need_an_value() {
	mut fp := flag.new_flag_parser(['--a_bool'])

	assert true == fp.bool('a_bool', 0, false, '')
}

fn test_flags_could_be_defined_with_eq() {
	mut fp := flag.new_flag_parser([
	'--an_int=42',
	'--a_float=2.0',
	'--bool_without',
	'--a_string=stuff',
	'--a_bool=true'])

	assert 42 == fp.int('an_int', 0, 0o666, '')
	&& true == fp.bool('a_bool', 0, false, '')
	&& true == fp.bool('bool_without', 0, false, '')
	&& 2.0 == fp.float('a_float', 0, 1.0, '')
	&& 'stuff' == fp.string('a_string', 0, 'not_stuff', '')
}

fn test_values_could_be_defined_without_eq() {
	mut fp := flag.new_flag_parser([
	'--an_int', '42',
	'--a_float', '2.0',
	'--bool_without',
	'--a_string', 'stuff',
	'--a_bool', 'true'])

	assert 42 == fp.int('an_int', 0, 0o666, '')
	&& true == fp.bool('a_bool', 0, false, '')
	&& true == fp.bool('bool_without', 0, false, '')
	&& 2.0 == fp.float('a_float', 0, 1.0, '')
	&& 'stuff' == fp.string('a_string', 0, 'not_stuff', '')
}

fn test_values_could_be_defined_mixed() {
	mut fp := flag.new_flag_parser([
	'--an_int', '42',
	'--a_float=2.0',
	'--bool_without',
	'--a_string', 'stuff',
	'--a_bool=true'])

	assert 42 == fp.int('an_int', 0, 0o666, '')
	&& true == fp.bool('a_bool', 0, false, '')
	&& true == fp.bool('bool_without', 0, false, '')
	&& 2.0 == fp.float('a_float', 0, 1.0, '')
	&& 'stuff' == fp.string('a_string', 0, 'not_stuff', '')
}

fn test_beaware_for_argument_names_with_same_prefix() {
	mut fp := flag.new_flag_parser([
	'--short', '5',
	'--shorter=7'
	])

	assert 5 == fp.int('short', 0, 0o666, '')
	&& 7 == fp.int('shorter', 0, 0o666, '')
}

fn test_beaware_for_argument_names_with_same_prefix_inverse() {
	mut fp := flag.new_flag_parser([
	'--shorter=7',
	'--short', '5',
	])

	assert 5 == fp.int('short', 0, 0o666, '')
	&& 7 == fp.int('shorter', 0, 0o666, '')
}

fn test_allow_to_skip_executable_path() {
	mut fp := flag.new_flag_parser(['./path/to/execuable'])

	fp.skip_executable()

	args := fp.finalize() or {
		assert false
		return
	}
	assert !args.contains('./path/to/execuable')
}

fn test_none_flag_arguments_are_allowed() {
	mut fp := flag.new_flag_parser([
	'file1', '--an_int=2', 'file2', 'file3', '--bool_without', 'file4', '--outfile', 'outfile'])

	assert 2 == fp.int('an_int', 0, 0o666, '')
	&& 'outfile' == fp.string('outfile', 0, 'bad', '')
	&& true == fp.bool('bool_without', 0, false, '')
}

fn test_finalize_returns_none_flag_arguments_ordered() {
	mut fp := flag.new_flag_parser(['d', 'b', 'x', 'a', '--outfile', 'outfile'])
	fp.string('outfile', 0, 'bad', '')

	finalized := fp.finalize() or {
		assert false
		return
	}

	expected := ['d', 'b', 'x', 'a']
	mut all_as_expected := true
	for i, v in finalized {
		all_as_expected = all_as_expected && v == expected[i]
	}
	assert all_as_expected
}

fn test_finalize_returns_error_for_unknown_flags() {
	mut fp := flag.new_flag_parser(['--known', '--unknown'])

	fp.bool('known', 0, false, '')

	finalized := fp.finalize() or {
		assert err == 'Unknown argument \'unknown\''
		return
	}
	assert finalized.len < 0 // expect error to be returned
}

fn test_allow_to_build_usage_message() {
	mut fp := flag.new_flag_parser([])
	fp.limit_free_args(1, 4)
	fp.application('flag_tool')
	fp.version('v0.0.0')
	fp.description('some short information about this tool')

	fp.int('an_int', 0, 0o666, 'some int to define')
	fp.bool('a_bool', 0, false, 'some bool to define')
	fp.bool('bool_without_but_really_big', 0, false, 'this should appear on the next line')
	fp.float('a_float', 0, 1.0, 'some float as well')
	fp.string('a_string', 0, 'not_stuff', 'your credit card number')

	usage := fp.usage()
	mut all_strings_found := true
	for s in ['flag_tool', 'v0.0.0',
	'an_int <int>', 'a_bool', 'bool_without', 'a_float <float>', 'a_string <string>',
	'some int to define',
	'some bool to define',
	'this should appear on the next line',
	'some float as well',
	'your credit card number',
	'The arguments should be at least 1 and at most 4 in number.',
	'Usage', 'Options:', 'Description:',
	'some short information about this tool'] {
		if !usage.contains(s) {
			eprintln(' missing \'$s\' in usage message')
			all_strings_found = false
		}
	}
	assert all_strings_found
}

fn test_if_no_description_given_usage_message_does_not_contain_descpription() {
	mut fp := flag.new_flag_parser([])
	fp.application('flag_tool')
	fp.version('v0.0.0')

	fp.bool('a_bool', 0, false, '')

	assert !fp.usage().contains('Description:')
}

fn test_if_no_options_given_usage_message_does_not_contain_options() {
	mut fp := flag.new_flag_parser([])
	fp.application('flag_tool')
	fp.version('v0.0.0')

	assert !fp.usage().contains('Options:')
}

fn test_free_args_could_be_limited() {
	mut fp1 := flag.new_flag_parser(['a', 'b', 'c'])
	fp1.limit_free_args(1, 4)
	args := fp1.finalize() or {
		assert false
		return
	}
	assert args[0] == 'a' && args[1] == 'b' && args[2] == 'c'
}

fn test_error_for_to_few_free_args() {
	mut fp1 := flag.new_flag_parser(['a', 'b', 'c'])
	fp1.limit_free_args(5, 6)
	args := fp1.finalize() or {
		assert err.starts_with('Expected at least 5 arguments')
		return
	}
	assert args.len < 0 // expect an error and need to use args
}

fn test_error_for_to_much_free_args() {
	mut fp1 := flag.new_flag_parser(['a', 'b', 'c'])
	fp1.limit_free_args(1, 2)
	args := fp1.finalize() or {
		assert err.starts_with('Expected at most 2 arguments')
		return
	}
	assert args.len < 0 // expect an error and need to use args
}

fn test_could_expect_no_free_args() {
	mut fp1 := flag.new_flag_parser(['a'])
	fp1.limit_free_args(0, 0)
	args := fp1.finalize() or {
		assert err.starts_with('Expected no arguments')
		return
	}
	assert args.len < 0 // expect an error and need to use args
}

fn test_allow_abreviations() {
	mut fp := flag.new_flag_parser(['-v', '-o', 'some_file', '-i', '42', '-f', '2.0'])

	v := fp.bool('version', `v`, false, '')
	o := fp.string('output', `o`, 'empty', '')
	i := fp.int('count', `i`, 0, '')
	f := fp.float('value', `f`, 0.0, '')

	assert v && o == 'some_file' && i == 42 && f == 2.0

	u := fp.usage()
	assert u.contains(' -v') && u.contains(' -o') && u.contains(' -i') && u.contains(' -f')
	assert u.contains('  -o, --output <string>')
	assert u.contains('  -i, --count <int>')
	assert u.contains('  -f, --value <float>')
}

fn test_allow_kebab_options() {
	default_value := 'this_is_the_default_value_of_long_option'
	long_option_value := 'this_is_a_long_option_value_as_argument'

	mut fp := flag.new_flag_parser(['--my-long-flag', 'true', '--my-long-option', long_option_value ])

	my_flag := fp.bool('my-long-flag', 0, false, 'flag with long-kebab-name')
	my_option := fp.string('my-long-option', 0, default_value, 'string with long-kebab-name')

	assert my_flag == true
	assert my_option == long_option_value

	u := fp.usage()
	assert u.contains(' --my-long-flag')
	assert u.contains(' --my-long-option')
}

fn test_not_provided_option_is_not_returned() {
	mut fp := flag.new_flag_parser([])
	fp.bool_opt('some-flag', `a`, '') or {
		fp.int_opt('some-flag', `a`, '') or {
			fp.float_opt('some-flag', `a`, '') or {
				fp.string_opt('some-flag', `a`, '') or {
					//Everything should not return
					return
				}
				return
			}
			return
		}
		return
	}
	//If we reach here, one of them returned a value.
	assert false
}

fn test_provided_option_is_returned() {
	mut fp := flag.new_flag_parser(['-a', '-b', '3', '-c', 'hello', '-d', '3.14'])
	a := fp.bool_opt('some-flag', `a`, '') or {
		panic('bool_opt did not return a bool')
	}
	b := fp.int_opt('some-flag', `b`, '') or {
		panic('int_opt did not return an int')
	}
	c := fp.string_opt('some-flag', `c`, '') or {
		panic('string_opt did not return a string')
	}
	d := fp.float_opt('some-flag', `d`, '') or {
		panic('float_opt did not return a float')
	}
	assert a && b == 3 && c == 'hello' && d == 3.14
}

fn test_multiple_arguments() {
	mut fp := flag.new_flag_parser([
		'-a', '2', '-a', '3', '-a', '5',
		'-b', 'a', '-b', 'c', '-b', 'b',
		'-c', '1.23', '-c', '2.34', '-c', '3.45'
	])

	//TODO Move to array comparison once it's implemented
	//assert fp.int_multi('some-flag', `a`, '') == [2, 3, 5] &&
	//	fp.string_multi('some-flag', `b`, '') == ['a', 'c', 'b'] &&
	//	fp.float_multi('some-flag', `c`, '') == [1.23, 2.34, 3.45]

	a := fp.int_multi('some-flag', `a`, '')
	b := fp.string_multi('some-flag', `b`, '')
	c := fp.float_multi('some-flag', `c`, '')
	assert a.len == 3 && b.len == 3 && c.len == 3
	assert a[0] == 2 && a[1] == 3 && a[2] == 5
	assert b[0] == 'a' && b[1] == 'c' && b[2] == 'b'
	assert c[0] == 1.23 && c[1] == 2.34 && c[2] == 3.45
}

fn test_long_options_that_start_with_the_same_letter_as_another_short_option() {
	mut fp := flag.new_flag_parser([
		'--vabc', '/abc',
	])
	verbose := fp.bool('verbose', `v`, false, 'Be more verbose.')
	vabc    := fp.string('vabc', `x`, 'default', 'Another option that *may* conflict with v, but *should not*')
	assert verbose == false
	assert vabc == '/abc'
}

fn test_long_options_that_start_with_the_same_letter_as_another_short_option_both_set() {
	mut fp := flag.new_flag_parser([
		'-v',
		'--vabc', '/abc',
	])
	verbose := fp.bool('verbose', `v`, false, 'Be more verbose.')
	vabc    := fp.string('vabc', `x`, 'default', 'Another option that *may* conflict with v, but *should not*')
	assert verbose == true
	assert vabc == '/abc'
}
module fontstash

#flag -I @VROOT/thirdparty/fontstash

#define FONTSTASH_IMPLEMENTATION
#include "fontstash.h"

pub const (
	// TODO: fontstash.used_import is used to keep v from warning about unused imports
	used_import = 1
)

// Contructor and destructor.
[inline]
pub fn create_internal(params &C.FONSparams) &C.FONScontext {
	return C.fonsCreateInternal(params)
}

[inline]
pub fn delete_internal(s &C.FONScontext) {
	C.fonsDeleteInternal(s)
}

[inline]
pub fn (s &C.FONScontext) set_error_callback(callback fn(uptr voidptr, error int, val int), uptr voidptr) {
	C.fonsSetErrorCallback(s, callback, uptr)
}

// Returns current atlas size.
[inline]
pub fn (s &C.FONScontext) get_atlas_size(width &int, height &int) {
	C.fonsGetAtlasSize(s, width, height)
}

// Expands the atlas size.
[inline]
pub fn (s &C.FONScontext) expand_atlas(width int, height int) int {
	return C.fonsExpandAtlas(s, width, height)
}

// Resets the whole stash.
[inline]
pub fn (s &C.FONScontext) reset_atlas(width int, height int) int {
	return C.fonsResetAtlas(s, width, height)
}

// Add fonts
[inline]
pub fn (s &C.FONScontext) get_font_by_name(name byteptr) int {
	return C.fonsGetFontByName(s, name)
}

[inline]
pub fn (s &C.FONScontext) add_fallback_font(base int, fallback int) int {
	return C.fonsAddFallbackFont(s, base, fallback)
}

[inline]
pub fn (s &C.FONScontext) add_font_mem(name byteptr, data byteptr, data_size int, free_data int) int {
	return C.fonsAddFontMem(s, name, data, data_size, free_data)
}

// State handling
[inline]
pub fn (s &C.FONScontext) push_state() {
	C.fonsPushState(s)
}

[inline]
pub fn (s &C.FONScontext) pop_state() {
	C.fonsPopState(s)
}

[inline]
pub fn (s &C.FONScontext) clear_state() {
	C.fonsClearState(s)
}

// State setting
[inline]
pub fn (s &C.FONScontext) set_size(size f32) {
	C.fonsSetSize(s, size)
}

[inline]
pub fn (s &C.FONScontext) set_color(color u32) {
	C.fonsSetColor(s, color)
}

[inline]
pub fn (s &C.FONScontext) set_spacing(spacing f32) {
	C.fonsSetSpacing(s, spacing)
}

[inline]
pub fn (s &C.FONScontext) set_blur(blur f32) {
	C.fonsSetBlur(s, blur)
}

[inline]
pub fn (s &C.FONScontext) set_align(align int) {
	C.fonsSetAlign(s, align)
}

[inline]
pub fn (s &C.FONScontext) set_font(font int) {
	C.fonsSetFont(s, font)
}

// Draw text
[inline]
pub fn (s &C.FONScontext) draw_text(x f32, y f32, str byteptr, end byteptr) f32 {
	return C.fonsDrawText(s, x, y, str, end)
}

// Measure text
[inline]
pub fn (s &C.FONScontext) text_bounds(x f32, y f32, str byteptr, end byteptr, bounds &f32) f32 {
	return C.fonsTextBounds(s, x, y, str, end, bounds)
}

[inline]
pub fn (s &C.FONScontext) line_bounds(y f32, miny &f32, maxy &f32) {
	C.fonsLineBounds(s, y, miny, maxy)
}

[inline]
pub fn (s &C.FONScontext) vert_metrics(ascender &f32, descender &f32, lineh &f32) {
	C.fonsVertMetrics(s, ascender, descender, lineh)
}

// Text iterator
[inline]
pub fn (s &C.FONScontext) text_iter_init(iter &C.FONStextIter, x f32, y f32, str byteptr, end byteptr) int {
	return C.fonsTextIterInit(s, iter, x, y, str, end)
}

[inline]
pub fn (s &C.FONScontext) text_iter_next(iter &C.FONStextIter, quad &C.FONSquad) int {
	return C.fonsTextIterNext(s, iter, quad)
}

// Pull texture changes
[inline]
pub fn (s &C.FONScontext) get_texture_data(width &int, height &int) byteptr {
	return C.fonsGetTextureData(s, width, height)
}

[inline]
pub fn (s &C.FONScontext) validate_texture(dirty &int) int {
	return C.fonsValidateTexture(s, dirty)
}

// Draws the stash texture for debugging
[inline]
pub fn (s &C.FONScontext) draw_debug(x f32, y f32) {
	C.fonsDrawDebug(s, x, y)
}

module fontstash

// Contructor and destructor.
fn C.fonsCreateInternal(params &C.FONSparams) &C.FONScontext
fn C.fonsDeleteInternal(s &C.FONScontext)

fn C.fonsSetErrorCallback(s &C.FONScontext, callback fn(uptr voidptr, error int, val int), uptr voidptr)
// Returns current atlas size.
fn C.fonsGetAtlasSize(s &C.FONScontext, width &int, height &int)
// Expands the atlas size.
fn C.fonsExpandAtlas(s &C.FONScontext, width int, height int) int
// Resets the whole stash.
fn C.fonsResetAtlas(s &C.FONScontext, width int, height int) int

// Add fonts
fn C.fonsGetFontByName(s &C.FONScontext, name byteptr) int
fn C.fonsAddFallbackFont(s &C.FONScontext, base int, fallback int) int
fn C.fonsAddFontMem(s &C.FONScontext, name byteptr, data byteptr, dataSize int, freeData int) int

// State handling
fn C.fonsPushState(s &C.FONScontext)
fn C.fonsPopState(s &C.FONScontext)
fn C.fonsClearState(s &C.FONScontext)

// State setting
fn C.fonsSetSize(s &C.FONScontext, size f32)
fn C.fonsSetColor(s &C.FONScontext, color u32)
fn C.fonsSetSpacing(s &C.FONScontext, spacing f32)
fn C.fonsSetBlur(s &C.FONScontext, blur f32)
fn C.fonsSetAlign(s &C.FONScontext, align int)
fn C.fonsSetFont(s &C.FONScontext, font int)

// Draw text
fn C.fonsDrawText(s &C.FONScontext, x f32, y f32, str byteptr, end byteptr) f32

// Measure text
fn C.fonsTextBounds(s &C.FONScontext, x f32, y f32, str byteptr, end byteptr, bounds &f32) f32
fn C.fonsLineBounds(s &C.FONScontext, y f32, miny &f32, maxy &f32)
fn C.fonsVertMetrics(s &C.FONScontext, ascender &f32, descender &f32, lineh &f32)

// Text iterator
fn C.fonsTextIterInit(s &C.FONScontext, iter &C.FONStextIter, x f32, y f32, str byteptr, end byteptr) int
fn C.fonsTextIterNext(s &C.FONScontext, iter &C.FONStextIter, quad &C.FONSquad) int

// Pull texture changes
fn C.fonsGetTextureData(s &C.FONScontext, width &int, height &int) byteptr
fn C.fonsValidateTexture(s &C.FONScontext, dirty &int) int

// Draws the stash texture for debugging
fn C.fonsDrawDebug(s &C.FONScontext, x f32, y f32)
module fontstash

pub enum FonsFlags {
	top_left = 1
	bottom_left = 2
}

pub enum FonsAlign {
	// Horizontal align
	left 		= 1	// Default
	center 		= 2
	right 		= 4
	// Vertical align
	top 		= 8
	middle		= 16
	bottom		= 32
	baseline	= 64 // Default
}

pub enum FonsErrorCode {
	// Font atlas is full.
	atlas_full = 1
	// Scratch memory used to render glyphs is full, requested size reported in 'val', you may need to bump up FONS_SCRATCH_BUF_SIZE.
	scratch_full = 2
	// Calls to fonsPushState has created too large stack, if you need deep state stack bump up FONS_MAX_STATES.
	states_overflow = 3
	// Trying to pop too many states fonsPopState().
	states_underflow = 4
}

pub struct C.FONSparams {
	width int
	height int
	flags char
	userPtr voidptr
	// int (*renderCreate)(void* uptr, int width, int height)
	renderCreate fn(uptr voidptr, width int, height int) int
	// int (*renderResize)(void* uptr, int width, int height)
	renderResize fn(uptr voidptr, width int, height int) int
	// void (*renderUpdate)(void* uptr, int* rect, const unsigned char* data)
	renderUpdate fn(uptr voidptr, rect &int, data byteptr)
	// void (*renderDraw)(void* uptr, const float* verts, const float* tcoords, const unsigned int* colors, int nverts)
	renderDraw fn(uptr voidptr, verts &f32, tcoords &f32, colors &u32, nverts int)
	// void (*renderDelete)(void* uptr)
	renderDelete fn(uptr voidptr)
}

pub struct C.FONSquad
{
	x0 f32
	y0 f32
	s0 f32
	t0 f32
	x1 f32
	y1 f32
	s1 f32
	t1 f32
}

pub struct C.FONStextIter {
	x f32
	y f32
	nextx f32
	nexty f32
	scale f32
	spacing f32
	codepoint u32
	isize i16
	iblur i16
	font &FONSfont
	prevGlyphIndex int
	str byteptr
	next byteptr
	end byteptr
	utf8state u32
}

pub struct C.FONSfont {}

pub struct C.FONScontext {}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module freetype

import os
import gx
import gg
import glm
import gl

/*
TODO
!!!!!!
Use a font atlas
!!!!!!
*/
#flag windows -I @VROOT/thirdparty/freetype/include
#flag windows -L @VROOT/thirdparty/freetype/win64
#flag solaris -I/opt/local/include/freetype2
#flag solaris -L/opt/local/lib
#flag darwin -I/usr/local/include/freetype2
// MacPorts
#flag darwin -I/opt/local/include/freetype2
#flag darwin -L/opt/local/lib
#flag freebsd -I/usr/local/include/freetype2
#flag freebsd -Wl -L/usr/local/lib
#flag -lfreetype
// #flag -I @VROOT/thirdparty/freetype
// #flag @VROOT/thirdparty/freetype/libfreetype.a
#flag darwin -lpng -lbz2 -lz
#flag linux 	-I/usr/include/freetype2
#flag linux -I.
#include "ft2build.h"
#include FT_FREETYPE_H
fn C.FT_Init_FreeType() voidptr

fn C.FT_New_Face() voidptr

fn C.FT_Set_Pixel_Sizes()

pub const (
	default_font_size = 12
)

struct Character {
	code                  i64
	texture_id            u32
	size                  gg.Vec2
	horizontal_bearing_px gg.Vec2
	horizontal_advance_px u32
	vertical_bearing_px   gg.Vec2
	vertical_advance_px   u32
}

[typedef]
struct C.FT_Library {
}

pub struct FreeType {
	shader    gl.Shader
	width     int
	height    int
	vao       u32
	rect_vao  u32
	rect_vbo  u32
	line_vao  u32
	line_vbo  u32
	vbo       u32
	chars     []Character
	face      &C.FT_FaceRec
	scale     int // retina = 2 , normal = 1
mut:
	utf_runes []string
	utf_chars []Character
}

struct C.Bitmap {
	width  int
	rows   int
	buffer int
}

struct C.Advance {
	x int
	y int
}

[typedef]
struct C.FT_Glyph_Metrics {
	width        int
	height       int
	horiBearingX int
	horiBearingY int
	horiAdvance  int
	vertBearingX int
	vertBearingY int
	vertAdvance  int
}

struct C.Glyph {
	bitmap      C.Bitmap
	bitmap_left int
	bitmap_top  int
	advance     Advance
	metrics     C.FT_Glyph_Metrics
}

[typedef]
struct C.FT_FaceRec {
	glyph       &C.Glyph
	family_name charptr
	style_name  charptr
}

// /type FT_Face &C.FT_FaceRec
fn C.FT_Load_Char(voidptr, i64, int) int

fn ft_load_char(face &C.FT_FaceRec, code i64) Character {
	// println('\nftload_char( code=$code)')
	// C.printf('face=%p\n', face)
	// C.printf('cobj=%p\n', _face.cobj)
	ret := C.FT_Load_Char(face, code, C.FT_LOAD_RENDER | C.FT_LOAD_FORCE_AUTOHINT)
	// println('ret=$ret')
	if ret != 0 {
		println('freetype: failed to load glyph (utf32 code=$code, ' + 'error code=$ret)')
		return Character{
			code: code
	}
	}
	// Generate texture
	mut texture := 0
	C.glGenTextures(1, &texture)
	C.glBindTexture(C.GL_TEXTURE_2D, texture)
	fgwidth := (*face).glyph.bitmap.width
	fgrows := (*face).glyph.bitmap.rows
	C.glTexImage2D(C.GL_TEXTURE_2D, 0, C.GL_RED, fgwidth, fgrows, 0, C.GL_RED, C.GL_UNSIGNED_BYTE,
		(*face).glyph.bitmap.buffer)
	// Set texture options
	C.glTexParameteri(C.GL_TEXTURE_2D, C.GL_TEXTURE_WRAP_S, C.GL_CLAMP_TO_EDGE)
	C.glTexParameteri(C.GL_TEXTURE_2D, C.GL_TEXTURE_WRAP_T, C.GL_CLAMP_TO_EDGE)
	C.glTexParameteri(C.GL_TEXTURE_2D, C.GL_TEXTURE_MIN_FILTER, C.GL_LINEAR)
	C.glTexParameteri(C.GL_TEXTURE_2D, C.GL_TEXTURE_MAG_FILTER, C.GL_LINEAR)
	// Create the character
	return Character {
		code: code
		texture_id: u32(texture)
		size:    gg.vec2(fgwidth, fgrows)

		// Note: advance is number of 1/64 pixels
		// Bitshift by 6 to get value in pixels (2^6 = 64 (divide amount of 1/64th pixels by 64 to get amount of pixels))
		horizontal_bearing_px:  gg.vec2((*face).glyph.metrics.horiBearingX >> 6, (*face).glyph.metrics.horiBearingY >> 6)
		vertical_bearing_px:    gg.vec2((*face).glyph.metrics.vertBearingX >> 6, (*face).glyph.metrics.vertBearingY >> 6) // not used for now

		horizontal_advance_px:  (*face).glyph.metrics.horiAdvance >> 6
		vertical_advance_px:    (*face).glyph.metrics.vertAdvance >> 6
	}
}

pub fn new_context(cfg gg.Cfg) &FreeType {
	scale := cfg.scale
	// Can only have text in ortho mode
	if !cfg.use_ortho {
		return &FreeType{
			face: 0
	}
	}
	width := cfg.width * scale
	height := cfg.height * scale
	font_size := cfg.font_size * scale
	// exit('fs=$font_size')
	// if false {
	// retina
	// width = width * 2// scale// 2
	// height = height * 2// scale// 2
	// font_size *= scale// 2
	// }
	/*
	gl.viewport(0, 0, width, height)
*/
	// gl.enable(GL_CULL_FACE) // TODO NEED CULL?
	gl.enable(C.GL_BLEND)
	C.glBlendFunc(C.GL_SRC_ALPHA, C.GL_ONE_MINUS_SRC_ALPHA)
	shader := gl.new_shader('text')
	shader.use()
	projection := glm.ortho(0, width, 0, height) // 0 at BOT
	shader.set_mat4('projection', projection)
	// FREETYPE
	ft := C.FT_Library{}
	// All functions return a value different than 0 whenever
	// an error occurred
	mut ret := C.FT_Init_FreeType(&ft)
	if ret != 0 {
		panic('freetype: Could not init FreeType Library')
	}
	// Load font as face
	mut font_path := cfg.font_path
	if font_path == '' {
		font_path = 'RobotoMono-Regular.ttf'
	}
	if !os.exists(font_path) {
		font_path = os.resource_abs_path(font_path)
	}
	if !os.exists(font_path) {
		eprintln('freetype: font "$font_path" does not exist')
		return 0
	}
	face := &C.FT_FaceRec{
		glyph: 0
	}
	ret = int(C.FT_New_Face(ft, font_path.str, 0, &face))
	if ret != 0 {
		eprintln('freetype: failed to load font (error=$ret) from path: $font_path')
		exit(1)
	}
	// Set size to load glyphs as
	C.FT_Set_Pixel_Sizes(face, 0, font_size)
	// Disable byte-alignment restriction
	C.glPixelStorei(C.GL_UNPACK_ALIGNMENT, 1)
	// Gen texture
	// Load first 128 characters of ASCII set
	mut chars := []Character{}
	for c in 0 .. 128 {
		ch := ft_load_char(face, i64(c))
		// s := utf32_to_str(uint(0x043f))
		// s := ''
		// ch = ft_load_char(f, s.utf32_code())
		// # unsigned long c = FT_Get_Char_Index(face,              0x043f );
		// # printf("!!!!!!!!! %lu\n", c);
		// # c = FT_Get_Char_Index(face,              0xd0bf );
		// # printf("!!!!!!!!! %lu\n", c);
		// # ch = gg__ft_load_char(f, 0xd0bf) ;  // UTF 8
		chars << ch
	}
	// ch := Character{}
	// Configure VAO
	vao := gl.gen_vertex_array()
	// println('new gg text context vao=$vao')
	vbo := gl.gen_buffer()
	gl.bind_vao(vao)
	gl.bind_buffer(C.GL_ARRAY_BUFFER, vbo)
	// # glBufferData(GL_ARRAY_BUFFER, sizeof(GLf32) * 6 * 4, NULL, GL_DYNAMIC_DRAW);
	gl.enable_vertex_attrib_array(0)
	gl.vertex_attrib_pointer(0, 4, C.GL_FLOAT, false, 4, 0)
	// # glVertexAttribPointer(0, 4, GL_FLOAT,false, 4 * sizeof(GLf32), 0);
	// gl.bind_buffer(GL_ARRAY_BUFFER, uint(0))
	// # glBindVertexArray(0);
	ctx := &FreeType{
		shader: shader
		width: width
		height: height
		scale: scale
		vao: vao
		vbo: vbo
		chars: chars
		face: face
	}
	// ctx.init_utf8_runes()
	return ctx
}

pub fn (mut ctx FreeType) draw_text(_x, _y int, text string, cfg gx.TextCfg) {
	// utext := text.ustring_tmp()
	utext := text.ustring()
	ctx.private_draw_text(_x, _y, utext, cfg)
}

fn (mut ctx FreeType) draw_text_fast(_x, _y int, text ustring, cfg gx.TextCfg) {
	ctx.private_draw_text(_x, _y, text, cfg)
}

fn (mut ctx FreeType) private_draw_text(_x, _y int, utext ustring, cfg gx.TextCfg) {
	/*
	if utext.s.contains('on_seg') {
		println('\nat(0)')
		println(utext.runes)
		firstc := utext.at(0)
		println('drawtext "$utext.s" len=$utext.s.len ulen=$utext.len x=$_x firstc=$firstc')
		if firstc != ' ' {
			exit(1)
		}
	}
*/
	mut x := f32(_x)
	mut y := f32(_y)
	wx, wy := ctx.text_size(utext.s)
	yoffset := if ctx.scale > 1 { 5 } else { -1 } // 5 hidpi, -1 lowdpi
	// println('scale=$ctx.scale size=$cfg.size')
	if cfg.align == gx.align_right {
		// width := utext.len * 7
		width := wx
		x -= width + 10
	}
	x *= ctx.scale
	y *= ctx.scale
	y += yoffset
	y = f32(ctx.height) - y // invert y direction
	color := cfg.color
	// Activate corresponding render state
	ctx.shader.use()
	ctx.shader.set_color('textColor', color)
	C.glActiveTexture(C.GL_TEXTURE0)
	gl.bind_vao(ctx.vao)
	// Iterate through all characters
	// utext := text.ustring()
	for i in 0 .. utext.len {
		rune_ := utext.at(i)
		// println('$i => $rune_')
		mut ch := Character{}
		mut found := false
		if rune_.len == 1 {
			idx := rune_[0]
			if idx < 0 || idx >= ctx.chars.len {
				println('BADE RUNE $rune_')
				continue
			}
			found = true
			ch = ctx.chars[rune_[0]]
		} else if rune_.len > 1 {
			// TODO O(1) use map
			for j in 0 .. ctx.utf_runes.len {
				rune_j := ctx.utf_runes[j]
				if rune_j == rune_ {
					ch = ctx.utf_chars[j]
					found = true
					break
				}
			}
		}
		// A new Unicode character. Load it and cache it.
		if !found && rune_.len > 0 && rune_[0] > 32 {
			// c := rune_[0]
			// println('cant draw rune "$rune_" code=$c, loading')
			// continue
			ch = ft_load_char(ctx.face, rune_.utf32_code())
			// println('done loading')
			ctx.utf_runes << rune_
			ctx.utf_chars << ch
			// exit(1)
			// continue
		}
		xpos := x + f32(ch.horizontal_bearing_px.x) * 1
		ypos := y - f32(ch.size.y + wy - ch.horizontal_bearing_px.y) * 1
		// ypos := y - wy
		w := f32(ch.size.x) * 1
		h := f32(ch.size.y) * 1
		// Update VBO for each character
		vertices := [
			xpos, ypos + h, 0.0, 0.0,
			xpos, ypos, 0.0, 1.0,
			xpos + w, ypos, 1.0, 1.0,
			xpos, ypos + h, 0.0, 0.0,
			xpos + w, ypos, 1.0, 1.0,
			xpos + w, ypos + h, 1.0, 0.0]
		// Render glyph texture over quad
		C.glBindTexture(C.GL_TEXTURE_2D, ch.texture_id)
		// Update content of VBO memory
		gl.bind_buffer(C.GL_ARRAY_BUFFER, ctx.vbo)
		// glBufferSubData(..)
		C.glBufferData(C.GL_ARRAY_BUFFER, 96, vertices.data, C.GL_DYNAMIC_DRAW)
		// Render quad
		gl.draw_arrays(C.GL_TRIANGLES, 0, 6)
		x += f32(ch.horizontal_advance_px)
		// Stop drawing if the limit is reached
		if cfg.max_width > 0 {
			if x >= cfg.max_width {
				// break
			}
		}
	}
	gl.bind_vao(u32(0))
	C.glBindTexture(C.GL_TEXTURE_2D, 0)
}

pub fn (mut ctx FreeType) draw_text_def(x, y int, text string) {
	cfg := gx.TextCfg{
		color: gx.black
		size: default_font_size
		align: gx.align_left
	}
	ctx.draw_text(x, y, text, cfg)
}

pub fn (mut ctx FreeType) text_width(s string) int {
	x, _ := ctx.text_size(s)
	return x
}

pub fn (mut ctx FreeType) text_height(s string) int {
	_, y := ctx.text_size(s)
	return y
}

pub fn (mut ctx FreeType) text_size(s string) (int, int) {
	// t := time.ticks()
	utext := s.ustring()
	mut x := u32(0)
	mut maxy := u32(0)
	mut rune_ := ''
	mut ch := Character{}
	for i in 0 .. utext.len {
		rune_ = utext.at(i)
		ch = Character{}
		mut found := false
		if rune_.len == 1 {
			idx := rune_[0]
			if idx < 0 || idx >= ctx.chars.len {
				println('BADE RUNE $rune_')
				continue
			}
			found = true
			ch = ctx.chars[rune_[0]]
		} else if rune_.len > 1 {
			// TODO O(1) use map
			for j in 0 .. ctx.utf_runes.len {
				rune_j := ctx.utf_runes[j]
				if rune_j == rune_ {
					ch = ctx.utf_chars[j]
					found = true
					break
				}
			}
		}
		if !found && rune_.len > 0 && rune_[0] > 32 {
			ch = ft_load_char(ctx.face, rune_.utf32_code())
			ctx.utf_runes << rune_
			ctx.utf_chars << ch
		}
		x += ch.horizontal_advance_px
		if maxy < ch.vertical_advance_px {
			maxy = ch.vertical_advance_px
		}
	}
	// println('text width "$s" = ${time.ticks() - t} ms')
	// scaled_x := x
	// scaled_y := maxy
	scaled_x := int(f64(x) / ctx.scale)
	scaled_y := int(f64(maxy) / ctx.scale)
	// println('text_size of "${s}" | x,y: $x,$maxy | scaled_x: ${scaled_x:3d} | scaled_y: ${scaled_y:3d} ')
	return scaled_x, scaled_y
}

/*
pub fn (f FT_Face) str() string {
	return 'FT_Face{ style_name: ${ptr_str(f.style_name)} family_name: ${ptr_str(f.family_name)} }'
}
*/
pub fn (ac []Character) str() string {
	mut res := []string{}
	for c in ac {
		res << '  Character{ code: $c.code , texture_id: $c.texture_id }'
	}
	return '[\n' + res.join(',\n') + ']'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module gg

import stbi
import glm
import gl
import gx
import os
import glfw

pub struct Vec2 {
pub:
	x int
	y int
}

pub fn (v Vec2) str() string {
	return 'Vec2{ x: $v.x y: $v.y }'
}

pub fn vec2(x, y int) Vec2 {
	res := Vec2 {
		x: x
		y: y
	}
	return res
}

pub fn init_gg() {
	glfw.init_glfw()
	gl.init_glad()
}


pub struct Cfg {
pub:
	width     int
	height    int
	use_ortho bool
	retina    bool
	resizable bool
	decorated bool = true

	font_size int
	font_path string
	create_window bool
	window_user_ptr voidptr
	window_title string
	always_on_top bool
	scale int
}

pub type RenderFn fn()
pub struct GG {
	shader    gl.Shader
	// use_ortho bool
	vao       u32
	rect_vao  u32
	rect_vbo  u32
	line_vao  u32
	line_vbo  u32
	vbo       u32
	scale     int // retina = 2 , normal = 1
//pub:
pub mut:
	width     int
	height    int
	window &glfw.Window
	render_fn RenderFn
}


// fn new_context(width, height int, use_ortho bool, font_size int) *GG {
pub fn new_context(cfg Cfg) &GG {
	mut window := &glfw.Window(0)
	if cfg.create_window {
		if cfg.resizable {
			glfw.window_hint(C.GLFW_RESIZABLE, 1)
		} else {
			glfw.window_hint(C.GLFW_RESIZABLE, 0)
		}
		if cfg.decorated {
			glfw.window_hint(C.GLFW_DECORATED, 1)
		} else {
			glfw.window_hint(C.GLFW_DECORATED, 0)
		}
		window = glfw.create_window(glfw.WinCfg{
			title: cfg.window_title
			width: cfg.width
			height: cfg.height
			ptr: cfg.window_user_ptr
			always_on_top: cfg.always_on_top
		})
		window.make_context_current()
		init_gg()
	}
	shader := gl.new_shader('simple')
	shader.use()
	if cfg.use_ortho {
		projection := glm.ortho(0, cfg.width, cfg.height, 0)
		shader.set_mat4('projection', projection)
	}
	else {
		// TODO move to function (allow volt functions to return arrays without allocations)
		// i := glm.identity3()
		shader.set_mat4('projection', glm.identity())
	}
	vao := gl.gen_vertex_array()
	//println('new gg context VAO=$VAO')
	vbo := gl.gen_buffer()
	mut scale := 1
	if cfg.retina {
		scale = 2
	}
	gl.enable(C.GL_SCISSOR_TEST)
	//gl.enable(GL_BLEND)
	//# glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	//println('new gg text context VAO=$VAO')
	//gl.bind_vao(VAO)
	//gl.bind_buffer(GL_ARRAY_BUFFER, VBO)
	//gl.enable_vertex_attrib_array(0)
	//gl.vertex_attrib_pointer(0, 4, GL_FLOAT, false, 4, 0)
	todo_remove_me(cfg, scale)
	return &GG {
		shader: shader
		width: cfg.width
		height: cfg.height
		vao: vao
		vbo: vbo
		window: window

		// /line_vao: gl.gen_vertex_array()
		// /line_vbo: gl.gen_buffer()
		//text_ctx: new_context_text(cfg, scale),
		scale: scale
		// use_ortho: use_ortho
	}

	// ctx.init_rect_vao()
	//return ctx
}

/*
pub fn (gg &GG) render_loop() bool {
	for !gg.window.show_close() {
		gg.render_fn()
		gg.window.swap_buffers()
		glfw.wait_events()
	}
}
*/

pub fn clear(color gx.Color) {
	gl.clear_color(color.r, color.g, color.b, 255)
	gl.clear()
}

pub fn (gg &GG) render() {
	gg.window.swap_buffers()
	glfw.wait_events()
}

pub fn (ctx &GG) draw_triangle(x1, y1, x2, y2, x3, y3 f32, c gx.Color) {
	// println('draw_triangle $x1,$y1 $x2,$y2 $x3,$y3')
	ctx.shader.use()
	ctx.shader.set_color('color', c)
	vertices := [
	x1, y1, 0,
	x2, y2, 0,
	x3, y3, 0,
	] !
	// bind the Vertex Array Object first, then bind and set vertex buffer(s),
	// and then configure vertex attributes(s).
	gl.bind_vao(ctx.vao)
	gl.set_vbo(ctx.vbo, vertices, C.GL_STATIC_DRAW)
	gl.vertex_attrib_pointer(0, 3, C.GL_FLOAT, false, 3, 0)
	gl.enable_vertex_attrib_array(0)
	// gl.bind_buffer(GL_ARRAY_BUFFER, uint(0))
	// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO,
	// but this rarely happens. Modifying other
	// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs
	// (nor VBOs) when it's not directly necessary.
	// gl.bind_vertex_array(uint(0))
	// gl.bind_vertex_array(ctx.VAO)
	gl.draw_arrays(C.GL_TRIANGLES, 0, 3)
}

pub fn (ctx &GG) draw_triangle_tex(x1, y1, x2, y2, x3, y3 f32, c gx.Color) {
	ctx.shader.use()
	ctx.shader.set_color('color', c)
	ctx.shader.set_int('has_texture', 1)
	vertices := [
	x1, y1, 0, 0, 0, 0, 1, 1,
	x2, y2, 0, 0, 0, 0, 1, 0,
	x3, y3, 0, 0, 0, 0, 0, 0,
	] !
	gl.bind_vao(ctx.vao)
	gl.set_vbo(ctx.vbo, vertices, C.GL_STATIC_DRAW)
	// position attribute
	gl.vertex_attrib_pointer(0, 3, C.GL_FLOAT, false, 3, 0)
	gl.enable_vertex_attrib_array(0)
	// color attribute
	gl.vertex_attrib_pointer(1, 3, C.GL_FLOAT, false, 8, 3)
	gl.enable_vertex_attrib_array(1)
	// texture attribute
	gl.vertex_attrib_pointer(2, 2, C.GL_FLOAT, false, 8, 6)
	gl.enable_vertex_attrib_array(2)
	// /
	// gl.draw_arrays(GL_TRIANGLES, 0, 3)
	gl.draw_elements(C.GL_TRIANGLES, 6, C.GL_UNSIGNED_INT, 0)
}

pub fn (ctx &GG) draw_rect(x, y, w, h f32, c gx.Color) {
	// println('gg.draw_rect($x,$y,$w,$h)')
	// wrong order
	// // ctx.draw_triangle(x, y, x + w, y, x + w, y + h, c)
	// // ctx.draw_triangle(x, y, x, y + h, x + w, y + h, c)
	// good order. counter clockwise
	// ctx.draw_triangle(x, y, x, y + h, x + w, y + h, c)
	// ctx.draw_triangle(x, y, x + w, y + h, x + w, y, c)
	ctx.draw_rect2(x, y, w, h, c)
}

// Useful for debugging meshes.
pub fn set_mode_wireframe() {
	C.glPolygonMode(C.GL_FRONT_AND_BACK, C.GL_LINE)
}
pub fn set_mode_point() {
	C.glPolygonMode(C.GL_FRONT_AND_BACK, C.GL_POINT)
}
pub fn set_mode_fill() {
	C.glPolygonMode(C.GL_FRONT_AND_BACK, C.GL_FILL)
}

/*
fn (mut ctx GG) init_rect_vao() {

	ctx.rect_vao = gl.gen_vertex_array()
	ctx.rect_vbo = gl.gen_buffer()
	vertices := [
	x + w, y, 0,
	x + w, y + h, 0,
	x, y + h, 0,
	x, y, 0,
	] !
	indices := [
	0, 1, 3,// first triangle
	1, 2, 3// second triangle
	] !
	gl.bind_vao(ctx.rect_vao)
	gl.set_vbo(ctx.rect_vbo, vertices, C.GL_STATIC_DRAW)
	ebo := gl.gen_buffer()
	// ///////
	gl.set_ebo(ebo, indices, C.GL_STATIC_DRAW)
}
*/
pub fn (ctx &GG) draw_rect2(x, y, w, h f32, c gx.Color) {
	C.glDeleteBuffers(1, &ctx.vao)
	C.glDeleteBuffers(1, &ctx.vbo)
	ctx.shader.use()
	ctx.shader.set_color('color', c)
	ctx.shader.set_int('has_texture', 0)
	// 4--1
	// 3--2
	$if linux {
	// y += h
	}
	vertices := [
	x + w, y, 0,
	x + w, y + h, 0,
	x, y + h, 0,
	x, y, 0,
	] !
	indices := [
	0, 1, 3,// first triangle
	1, 2, 3// second triangle
	] !
	gl.bind_vao(ctx.vao)
	gl.set_vbo(ctx.vbo, vertices, C.GL_STATIC_DRAW)
	ebo := gl.gen_buffer()
	// ///////
	gl.set_ebo(ebo, indices, C.GL_STATIC_DRAW)// !!! LEAKS
	// /////
	gl.vertex_attrib_pointer(0, 3, C.GL_FLOAT, false, 3, 0)
	gl.enable_vertex_attrib_array(0)
	// gl.bind_vao(ctx.rect_vao)
	gl.bind_vao(ctx.vao)
	gl.draw_elements(C.GL_TRIANGLES, 6, C.GL_UNSIGNED_INT, 0)
	C.glDeleteBuffers(1, &ebo)
}

fn todo_remove_me(cfg Cfg, scale int) {
	// Can only have text in ortho mode
	if !cfg.use_ortho {
		return
	}
	width := cfg.width * scale
	height := cfg.height * scale
	//font_size := cfg.font_size * scale
	gl.enable(C.GL_BLEND)
	//# glBlendFunc(C.GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	shader := gl.new_shader('text')
	shader.use()
	projection := glm.ortho(0, width, 0, height)// 0 at BOT
	// projection_new := ortho(0, width, 0, height)// 0 at BOT
	// projection := gl.ortho(0, width,height,0)  // 0 at TOP
	shader.set_mat4('projection', projection)
	vao := gl.gen_vertex_array()
	//println('new gg text context VAO=$VAO')
	vbo := gl.gen_buffer()
	gl.bind_vao(vao)
	gl.bind_buffer(C.GL_ARRAY_BUFFER, vbo)
	gl.enable_vertex_attrib_array(0)
	gl.vertex_attrib_pointer(0, 4, C.GL_FLOAT, false, 4, 0)
}

fn update() {
	// # ui__post_empty_event();
}

pub fn post_empty_event() {
	glfw.post_empty_event()
}

pub fn (c GG) circle(x, y, r int) {
}

fn (c GG) fill_color(color gx.Color) {
}

fn (c GG) fill() {
}

fn (c GG) move_to(x, y int) {
}

fn (c GG) line_to(x, y int) {
}

fn (c GG) stroke_width(size int) {
}

fn (c GG) stroke_color(color gx.Color) {
}

fn (c GG) stroke() {
}

fn (c GG) save() {
}

fn (c GG) restore() {
}

fn (c GG) intersect_scissor(x, y, w, h int) {
}

fn (c GG) translate(x, y int) {
}

fn (c GG) create_font(name, file string) int {
	return 0
}

fn (c GG) text(x, y int, text string) {
}

fn (c GG) text_box(x, y, max int, text string) {
}

fn (c GG) font_face(f string) {
}

fn (c GG) font_size(size int) {
}

fn (c GG) text_align(a int) {
}

pub fn (ctx &GG) create_image(file string) u32 {
	return create_image(file)
}

pub fn create_image(file string) u32 {
	//println('gg create image "$file"')
	if file.contains('twitch') {
		return u32(0)// TODO
	}
	if !os.exists(file) {
		println('gg create image no such file "$file"')
		return u32(0)
	}
	texture := gl.gen_texture()
	img := stbi.load(file)
	gl.bind_2d_texture(texture)
	img.tex_image_2d()
	gl.generate_mipmap(C.GL_TEXTURE_2D)
	img.free()
	return texture
}

pub fn create_image_from_memory(buf byteptr) u32 {
	texture := gl.gen_texture()
	img := stbi.load_from_memory(buf)
	// TODO copy pasta
	gl.bind_2d_texture(texture)
	img.tex_image_2d()
	gl.generate_mipmap(C.GL_TEXTURE_2D)
	img.free()
	return texture
}

pub fn (ctx &GG) draw_line(x, y, x2, y2 f32, color gx.Color) {
	ctx.use_color_shader(color)
	vertices := [x, y, x2, y2] !
	ctx.bind_vertices(vertices)
	gl.draw_arrays(C.GL_LINES, 0, 2)
}

pub fn (ctx &GG) draw_arc(x, y, r, start_angle, end_angle f32, segments int, color gx.Color) {
	ctx.use_color_shader(color)
	vertices := arc_vertices(x, y, r, start_angle, end_angle, segments)
	ctx.bind_vertices(vertices)
	gl.draw_arrays(C.GL_LINE_STRIP, 0, segments + 1)
	unsafe { vertices.free() }
}

pub fn (ctx &GG) draw_filled_arc(x, y, r, start_angle, end_angle f32, segments int, color gx.Color) {
	ctx.use_color_shader(color)


	mut vertices := []f32{}
	vertices << [x, y] !
	vertices << arc_vertices(x, y, r, start_angle, end_angle, segments)
	ctx.bind_vertices(vertices)
	gl.draw_arrays(C.GL_TRIANGLE_FAN, 0, segments + 2)
	unsafe { vertices.free() }
}

pub fn (ctx &GG) draw_circle(x, y, r f32, color gx.Color) {
	ctx.draw_filled_arc(x, y, r, 0, 360, 24 + int(r / 2), color)
}

pub fn (ctx &GG) draw_rounded_rect(x, y, w, h, r f32, color gx.Color) {
	ctx.use_color_shader(color)
	mut vertices := []f32{}
	segments := 6 + int(r / 8)

	// Create a rounded rectangle using a triangle fan mesh.
	vertices << [x + (w/2.0), y + (h/2.0)] !
	vertices << arc_vertices(x + w - r, y + h - r, r, 0, 90, segments)
	vertices << arc_vertices(x + r, y + h - r, r, 90, 180, segments)
	vertices << arc_vertices(x + r, y + r, r, 180, 270, segments)
	vertices << arc_vertices(x + w - r, y + r, r, 270, 360, segments)
	// Finish the loop by going back to the first vertex
	vertices << [vertices[2], vertices[3]] !

	ctx.bind_vertices(vertices)
	gl.draw_arrays(C.GL_TRIANGLE_FAN, 0, segments * 4 + 6)
	unsafe { vertices.free() }
}

pub fn (ctx &GG) draw_empty_rounded_rect(x, y, w, h, r f32, color gx.Color) {
	ctx.use_color_shader(color)
	mut vertices := []f32{}
	segments := 6 + int(r / 8)

	vertices << arc_vertices(x + w - r, y + h - r, r, 0, 90, segments)
	vertices << arc_vertices(x + r, y + h - r, r, 90, 180, segments)
	vertices << arc_vertices(x + r, y + r, r, 180, 270, segments)
	vertices << arc_vertices(x + w - r, y + r, r, 270, 360, segments)

	ctx.bind_vertices(vertices)
	gl.draw_arrays(C.GL_LINE_STRIP, 0, segments * 4 + 1)
	unsafe { vertices.free() }
}

/*
pub fn (c &GG) draw_gray_line(x, y, x2, y2 f32) {
	c.draw_line(x, y, x2, y2, gx.gray)
}

pub fn (c &GG) draw_vertical(x, y, height int) {
	c.draw_line(x, y, x, y + height)
}
*/


//ctx.gg.draw_line(center + prev_x, center+prev_y, center + x*10.0, center+y)

// fn (ctx &GG) draw_image(x, y, w, h f32, img stbi.Image) {
pub fn (ctx &GG) draw_image(x, y, w, h f32, tex_id u32) {

	// NB: HACK to ensure same state ... TODO: remove next line
	ctx.draw_empty_rect(0,0,0,0, gx.white)

	last_array_buffer := 0
	last_texture := 0
	C.glGetIntegerv(C.GL_ARRAY_BUFFER_BINDING, &last_array_buffer)
	C.glGetIntegerv(C.GL_TEXTURE_BINDING_2D, &last_texture)

	// println('DRAW IMAGE $x $y $w $h $tex_id')
	ctx.shader.use()
	// ctx.shader.set_color('color', c)
	ctx.shader.set_int('has_texture', 1)
	// 4--1
	// |  |
	// 3--2
	vertices := [
	x + w, y, 0, 1, 0, 0, 1, 1,
	x + w, y + h, 0, 0, 1, 0, 1, 0,
	x, y + h, 0, 0, 0, 1, 0, 0,
	x, y, 0, 1, 1, 0, 0, 1,
	] !
	indices := [
	0, 1, 3,// first triangle
	1, 2, 3// second triangle
	] !
	// VAO := gl.gen_vertex_array()
	// VBO := gl.gen_buffer()
	C.glEnable(C.GL_TEXTURE_2D)
	gl.bind_vao(ctx.vao)
	gl.set_vbo(ctx.vbo, vertices, C.GL_STATIC_DRAW)
	ebo := gl.gen_buffer()
	gl.set_ebo(ebo, indices, C.GL_STATIC_DRAW)
	gl.vertex_attrib_pointer(0, 3, C.GL_FLOAT, false, 8, 0)
	gl.enable_vertex_attrib_array(0)
	gl.vertex_attrib_pointer(1, 3, C.GL_FLOAT, false, 8, 3)
	gl.enable_vertex_attrib_array(1)
	gl.vertex_attrib_pointer(2, 2, C.GL_FLOAT, false, 8, 6)
	gl.enable_vertex_attrib_array(2)
	gl.bind_2d_texture(tex_id)
	gl.bind_vao(ctx.vao)
	gl.draw_elements(C.GL_TRIANGLES, 6, C.GL_UNSIGNED_INT, 0)
	C.glDisable(C.GL_TEXTURE_2D)
	// restore state
	C.glBindBuffer(C.GL_ARRAY_BUFFER, last_array_buffer)
	C.    glBindTexture(C.GL_TEXTURE_2D, last_texture)
}

pub fn (c &GG) draw_empty_rect(x, y, w, h f32, color gx.Color) {
	c.draw_line(x, y, x + w, y, color)
	c.draw_line(x, y, x, y + h, color)
	c.draw_line(x, y + h, x + w, y + h, color)
	c.draw_line(x + w, y, x + w, y + h, color)
}

pub fn scissor(x, y, w, h f32) {
	C.glScissor(x, y, w, h)
}
`gg` will be moved to its own repository:

https://github.com/vlang/gg
module gg

import gl
import gx
import math

fn arc_vertices(x, y, r, start_angle, end_angle f32, segments int) []f32 {
	mut vertices := []f32{}
	start_rads := start_angle * 0.0174533 // deg -> rad approx
	end_rads := end_angle * 0.0174533
	increment := (end_rads - start_rads) / segments
	vertices << [x + f32(math.cos(start_rads)) * r, y + f32(math.sin(start_rads)) * r] !
	mut i := 1
	for i < segments {
		theta := f32(i) * increment + start_rads
		vertices << [x + f32(math.cos(theta)) * r, y + f32(math.sin(theta)) * r] !
		i++
	}
	vertices << [x + f32(math.cos(end_rads)) * r, y + f32(math.sin(end_rads)) * r] !
	return vertices
}

fn (ctx &GG) use_color_shader(color gx.Color) {
	ctx.shader.set_int('has_texture', 0)
	C.glDeleteBuffers(1, &ctx.vao)
	C.glDeleteBuffers(1, &ctx.vbo)
	ctx.shader.use()
	ctx.shader.set_color('color', color)
}

fn (ctx &GG) bind_vertices(vertices []f32) {
	gl.bind_vao(ctx.vao)
	gl.set_vbo(ctx.vbo, vertices, C.GL_STATIC_DRAW)
	gl.vertex_attrib_pointer(0, 2, C.GL_FLOAT, false, 2, 0)
	gl.enable_vertex_attrib_array(0)
	gl.bind_vao(ctx.vao)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module gg2

import glm
import gx
import os
import sokol
import sokol.sapp
import sokol.sgl
import sokol.gfx
import sokol.sfons

const (
	default_font_size = 24
)

pub struct Config {
pub:
	width         int
	height        int
	use_ortho     bool
	retina        bool
	resizable     bool
	user_data     voidptr
	font_size     int
	font_path     string
	create_window bool
	// window_user_ptr voidptr
	window_title  string
	always_on_top bool
	scale         int
	frame_fn      fn(voidptr)
	bg_color      gx.Color
}

pub struct GG {
	scale      int // retina = 2 , normal = 1
pub mut:
	width      int
	height     int
	clear_pass C.sg_pass_action
	window     C.sapp_desc
	render_fn  fn()
	//////////// font fields
	fons &C.FONScontext
	font_normal int
}

// TODO remove globals
__global g_fons &C.FONScontext
__global g_font_normal int
__global g_font_path string

fn init_sokol_window() {
	desc := sg_desc{
		mtl_device: sapp.metal_get_device()
		mtl_renderpass_descriptor_cb: sapp.metal_get_renderpass_descriptor
		mtl_drawable_cb: sapp.metal_get_drawable
		d3d11_device: sapp.d3d11_get_device()
		d3d11_device_context: sapp.d3d11_get_device_context()
		d3d11_render_target_view_cb: sapp.d3d11_get_render_target_view
		d3d11_depth_stencil_view_cb: sapp.d3d11_get_depth_stencil_view
	}
	gfx.setup(&desc)
	sgl_desc := sgl_desc_t{}
	sgl.setup(&sgl_desc)
	g_fons = sfons.create(512, 512, 1)
	if g_font_path.len == 0 || !os.exists(g_font_path) {
		println('failed to load font "$g_font_path"')
		return
	}
	bytes := os.read_bytes(g_font_path) or {
		println('failed to load font "$g_font_path"')
		return
	}
	g_font_normal = C.fonsAddFontMem(g_fons, 'sans', bytes.data, bytes.len, false)
}

pub fn new_context(cfg Config) &GG {
	//C.printf('new_context() %p\n', cfg.user_data)
	window := sapp_desc{
		user_data: cfg.user_data
		init_userdata_cb: init_sokol_window
		frame_userdata_cb: cfg.frame_fn
		window_title: cfg.window_title.str
		html5_canvas_name: cfg.window_title.str
		width: cfg.width
		height: cfg.height
		high_dpi: true
	}
	g_font_path = cfg.font_path
	if cfg.use_ortho {}
	else {}
	return &GG{
		width: cfg.width
		height: cfg.height
		window: window
		clear_pass: gfx.create_clear_pass(f32(cfg.bg_color.r) / 255.0, f32(cfg.bg_color.g) / 255.0, f32(cfg.bg_color.b) / 255.0, 1.0)
		scale: 1 // scale
		fons:0
	}
}

pub fn (gg &GG) draw_text(x, y int, text string, cfg gx.TextCfg) {
	gg.fons.set_font(gg.font_normal)
	gg.fons.set_size(cfg.size)
	ascender := f32(0.0)
	descender := f32(0.0)
	lh := f32(0.0)
	gg.fons.vert_metrics(&ascender, &descender, &lh)
	color:= C.sfons_rgba(cfg.color.r, cfg.color.g, cfg.color.b, 255)
	C.fonsSetColor(gg.fons, color)
	C.fonsDrawText(gg.fons, x, y, text.str, 0)
}

pub fn (ctx &GG) draw_text_def(x, y int, text string) {
	cfg := gx.TextCfg {
		color: gx.black
		size: default_font_size
		align: gx.align_left
	}
	ctx.draw_text(x, y, text, cfg)
}

pub fn (mut gg GG) init_font() {
	// TODO
	gg.fons =g_fons
	gg.font_normal=g_font_normal
}

pub fn (gg &GG) run() {
	sapp.run(&gg.window)
}

pub fn (ctx &GG) draw_rect(x, y, w, h f32, c gx.Color) {
	sgl.c4b(c.r, c.g, c.b, 128)
	sgl.begin_quads()
	sgl.v2f(x, y)
	sgl.v2f(x + w, y)
	sgl.v2f(x + w, y + h)
	sgl.v2f(x, y + h)
	sgl.end()
}

pub fn draw_rect(x, y, w, h f32, c gx.Color) {
	sgl.c4b(c.r, c.g, c.b, 128)
	sgl.begin_quads()
	sgl.v2f(x, y)
	sgl.v2f(x + w, y)
	sgl.v2f(x + w, y + h)
	sgl.v2f(x, y + h)
	sgl.end()
}

pub fn (gg &GG) draw_empty_rect(x, y, w, h f32, c gx.Color) {
	sgl.c4b(c.r, c.g, c.b, 128)
	sgl.begin_line_strip()
	sgl.v2f(x, y)
	sgl.v2f(x + w, y)
	sgl.v2f(x + w, y + h)
	sgl.v2f(x, y + h)
	sgl.v2f(x, y)
	sgl.end()
}

pub fn create_image(file string) u32 {
	// println('gg create image "$file"')
	if !os.exists(file) {
		println('gg create image no such file "$file"')
		return u32(0)
	}
	// img := stbi.load(file)
	// img.free()
	return 0 // texture
}

pub fn create_image_from_memory(buf byteptr) u32 {
	// texture := gl.gen_texture()
	// img := stbi.load_from_memory(buf)
	// img.free()
	return 0 // texture
}

pub fn (gg &GG) begin() {
	sgl.defaults()
	sgl.matrix_mode_projection()
	sgl.ortho(0.0, f32(sapp.width()), f32(sapp.height()), 0.0, -1.0, 1.0)
}

pub fn (gg &GG) end() {
	gfx.begin_default_pass(gg.clear_pass, sapp.width(), sapp.height())
	sgl.draw()
	gfx.end_pass()
	gfx.commit()
	wait_events()
}

pub fn (ctx &GG) draw_line(x, y, x2, y2 f32, color gx.Color) {}

fn C.WaitMessage()

pub fn wait_events() {
	unsafe {
		$if macos  {
		# NSEvent *event = [NSApp nextEventMatchingMask:NSEventMaskAny
		# untilDate:[NSDate distantFuture]
		# inMode:NSDefaultRunLoopMode
		# dequeue:YES];
		# [NSApp sendEvent:event];
		}
		$if windows {
			C.WaitMessage()
		}
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module gl

// import os
import gx
import glm

// import darwin

pub struct Shader {
	program_id int
}
pub fn (s Shader) str() string {
	return 'Shader{ program_id: s.program_id }'
}

pub const (
	text_vert   = '#version 330 core
layout (location = 0) in vec4 vertex; // <vec2 pos, vec2 tex>
out vec2 TexCoords;

uniform mat4 projection;

void main()
{
    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0);
    TexCoords = vertex.zw;
}  '
	text_frag   = '#version 330 core
in vec2 TexCoords;
out vec4 color;

uniform sampler2D text;
uniform vec3 textColor;

void main()
{
    vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r);
    color = vec4(textColor, 1.0) * sampled;
}  '
	simple_vert = ' #version 330 core

layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aTexCoord;


out vec3 ourColor;
out vec2 TexCoord;

uniform mat4 projection;

void main() {
    gl_Position = projection *  vec4(aPos, 1.0);
//    gl_Position = vec4(aPos, 1.0);

 ourColor = aColor;
//TexCoord = vec2(aTexCoord.x, aTexCoord.y);
    TexCoord = aTexCoord;
}
'
	simple_frag = '#version 330 core

out vec4 FragColor;
uniform vec3 color;

uniform bool has_texture;

in vec3 ourColor;
in vec2 TexCoord;

uniform sampler2D ourTexture;


void main()     {
//    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
//    FragColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);
if (has_texture) {
	/*
	vec3 chromaKeyColor = texture(ourTexture,TexCoord.xy).xyz;

float alpha;
bool is_cyan = ((chromaKeyColor.x == 0)); // && chromaKeyColor.x <= 1) && (chromaKeyColor.y <= 255) &&
bool is_pink= ((chromaKeyColor.y == 0));
//bool is_pink= ((chromaKeyColor.x <= 255) && (chromaKeyColor.y == 0) &&(chromaKeyColor.z <= 255));
if (is_cyan || is_pink) {
    alpha = 0.;
}
else
{
    alpha = 1.0;
}
FragColor= vec4(texture(ourTexture,TexCoord.xy).xyz,alpha);
*/

    FragColor = texture(ourTexture, TexCoord);

}  else {
    FragColor = vec4(color, 1.0f);
}
}
'
)

pub fn new_shader(name string) Shader {
	// TODO This is not used, remove
	mut dir := ''
	// Already have absolute path
	if name.starts_with('/') {
		dir = ''
	}
	//vertex_path := '${dir}${name}.vert'
	//fragment_path := '${dir}${name}.frag'
	//println('shader path=$vertex_path,\n fpath="$fragment_path"')
	// vertex_src := os.read_file(vertex_path.trim_space())
	mut vertex_src := ''
	mut fragment_src := ''
	if name == 'text' {
		vertex_src = text_vert
		fragment_src = text_frag
	}
	else if name == 'simple' {
		// println('new shader simple!!!')
		// println(simple_vert)
		vertex_src = simple_vert
		fragment_src = simple_frag
	}
	// ////////////////////////////////////////
	vertex_shader := gl.create_shader(C.GL_VERTEX_SHADER)
	gl.shader_source(vertex_shader, 1, vertex_src, 0)
	gl.compile_shader(vertex_shader)
	if gl.shader_compile_status(vertex_shader) == 0 {
		cerror := gl.shader_info_log(vertex_shader)
		eprintln('vertex ${vertex_shader} shader compilation failed')
		eprintln('shader source = ${vertex_src}')
		eprintln('failed to compile, with error')
		eprintln(cerror)
		exit(1)
	}
	// fragment shader
	// fragment_src := os.read_file(fragment_path.trim_space())
	fragment_shader := gl.create_shader(C.GL_FRAGMENT_SHADER)
	gl.shader_source(fragment_shader, 1, fragment_src, 0)
	gl.compile_shader(fragment_shader)
	if gl.shader_compile_status(fragment_shader) == 0 {
		cerror := gl.shader_info_log(fragment_shader)
		eprintln('fragment ${fragment_shader} shader compilation failed')
		eprintln('shader source = ${fragment_src}')
		eprintln('failed to compile, with error')
		eprintln(cerror)
		exit(1)
	}
	// link shaders
	shader_program := gl.create_program()
	gl.attach_shader(shader_program, vertex_shader)
	gl.attach_shader(shader_program, fragment_shader)
	gl.link_program(shader_program)
	// check for linking errors
	success := gl.get_program_link_status(shader_program)
	if success == 0 {
		cerror := gl.shader_info_log(shader_program)
		eprintln('shader program linking failed')
		eprintln('vertex source = ${vertex_src}')
		eprintln('fragment source = ${fragment_src}')
		eprintln('failed to compile, with error')
		eprintln(cerror)
		exit(1)
	}
	shader := Shader {
		program_id: shader_program,
	}
	return shader
}

pub fn (s Shader) use() {
	gl.use_program(s.program_id)
}

fn C.glUniformMatrix4fv()
fn C.glUniform1i()
fn C.glUniform3f()

pub fn (s Shader) uni_location(key string) int {
	return C.glGetUniformLocation(s.program_id, key.str)
}

// fn (s Shader) set_mat4(str string, f *f32) {
pub fn (s Shader) set_mat4(str string, m glm.Mat4) {
	// TODO cache uniform location
	C.glUniformMatrix4fv(s.uni_location(str), 1, false, m.data)
}

pub fn (s Shader) set_int(str string, n int) {
	C.glUniform1i(s.uni_location(str), n)
}

pub fn (s Shader) set_color(str string, c gx.Color) {
	C.glUniform3f(s.uni_location(str), f32(c.r) / 255.0, f32(c.g) / 255.0, f32(c.b) / 255.0)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module gl

import glm

#flag  -I @VROOT/thirdparty/glad
#include "glad.h"
#flag @VROOT/thirdparty/glad/glad.o


// joe-c: fix & remove
pub enum TmpGlImportHack{ non_empty }

fn C.gladLoadGL() int

fn C.glDisable()
fn C.glEnable()
fn C.glScissor()
fn C.glVertexAttribPointer()
fn C.glGenBuffers()
fn C.glEnableVertexAttribArray()
fn C.glDisableVertexAttribArray()
fn C.glGenVertexArrays()
fn C.glDrawElements()
fn C.glUseProgram()
fn C.glValidateProgram()
fn C.glDrawArrays()
fn C.glBufferData()
fn C.glGenerateMipmap()
fn C.glTexParameteri()
fn C.glDeleteTextures()
fn C.glBindTexture()
fn C.glActiveTexture()
fn C.glGenTextures()
fn C.glBindBuffer()
fn C.glBindVertexArray()
fn C.glGetProgramInfoLog()
fn C.glGetShaderInfoLog()
fn C.glDeleteShader()
fn C.glGetProgramiv()
fn C.glLinkProgram()
fn C.glAttachShader()
fn C.glDetachShader()
fn C.glGetShaderiv()
fn C.glCompileShader()
fn C.glShaderSource()
fn C.glCreateProgram() int
fn C.glDeleteProgram()
fn C.glClear()
fn C.glCreateShader() int
fn C.glClearColor()
fn C.glViewport()
fn C.glTexImage2D()
fn C.glPixelStorei()
fn C.glBlendFunc()
fn C.glPolygonMode()
fn C.glDeleteBuffers()
fn C.glDeleteVertexArrays()
fn C.glGetUniformLocation() int
fn C.glGetAttribLocation() int
fn C.glBindAttribLocation()

//Uniform functions
fn C.glUniform1f()


pub fn init_glad() {
	ok := C.gladLoadGL()
	if ok == 0 {
		println('Failed to initialize glad OpenGL context')
		exit(1)
	}
}

pub fn viewport(a, b, c, d int) {
	C.glViewport(a, b, c, d)
}

pub fn clear_color(r, g, b, a int) {
	C.glClearColor(f32(r)/255.0, f32(g)/255.0, f32(b)/255.0, f32(a)/255.0)
}

pub fn clear() {
	C.glClear(C.GL_COLOR_BUFFER_BIT | C.GL_DEPTH_BUFFER_BIT | C.GL_STENCIL_BUFFER_BIT)
}

pub fn create_shader(typ int) int {
	return C.glCreateShader(typ)
}

pub fn create_program() int {
	return C.glCreateProgram()
}

pub fn delete_program(program int) {
	C.glDeleteProgram(program)
}

pub fn shader_source(shader, a int, source string, b int) {
	C.glShaderSource(shader, a, &source.str, b)
}

pub fn compile_shader(shader int) {
	C.glCompileShader(shader)
}

pub fn shader_compile_status(shader int) int {
	success := 0
	C.glGetShaderiv(shader, C.GL_COMPILE_STATUS, &success)
	return success
}

pub fn attach_shader(program, shader int) {
	// fn (s Shader) attach(program int) {
	C.glAttachShader(program, shader)
}

pub fn detach_shader(program, shader int) {
	C.glDetachShader(program, shader)
}

pub fn link_program(program int) {
	C.glLinkProgram(program)
}

pub fn get_program_link_status(program int) int {
	success := 0
	C.glGetProgramiv(program, C.GL_LINK_STATUS, &success)
	return success
}

pub fn validate_program(program int) {
	C.glValidateProgram(program)
}

pub fn delete_shader(shader int) {
	C.glDeleteShader(shader)
}

pub fn shader_info_log(shader int) string {
	info_log := [512]byte
	C.glGetShaderInfoLog(shader, 512, 0, info_log)
	return tos_clone(info_log)
}

pub fn get_program_info_log(program int) string {
	info_log := [1024]byte
	C.glGetProgramInfoLog(program, 1024, 0, info_log)
	return tos_clone(info_log)
}

pub fn bind_vao(vao u32) {
	C.glBindVertexArray(vao)
}

pub fn bind_buffer(typ int, vbo u32) {
	C.glBindBuffer(typ, vbo)
}

pub fn gen_texture() u32 {
	res := u32(0)
	C.glGenTextures(1, &res)
	return res
}

pub fn active_texture(t int) {
	C.glActiveTexture(t)
}

pub fn bind_2d_texture(texture u32) {
	C.glBindTexture(C.GL_TEXTURE_2D, texture)
}

pub fn delete_texture(texture u32) {
	C.glDeleteTextures(1, &texture)
}

pub fn buffer_data(typ, size int, arr voidptr, draw_typ int) {
	C.glBufferData(typ, size, arr, draw_typ)
}

pub fn buffer_data_int(typ int, vertices []int, draw_typ int) {
	size := sizeof(int) * vertices.len
	C.glBufferData(typ, size, vertices.data, draw_typ)
}

pub fn buffer_data_f32(typ int, vertices []f32, draw_typ int) {
	size := sizeof(f32) * vertices.len
	C.glBufferData(typ, size, vertices.data, draw_typ)
}

pub fn set_vbo(vbo u32, vertices []f32, draw_typ int) {
	gl.bind_buffer(C.GL_ARRAY_BUFFER, vbo)
	gl.buffer_data_f32(C.GL_ARRAY_BUFFER, vertices, draw_typ)
}

pub fn set_ebo(ebo u32, indices []int, draw_typ int) {
	gl.bind_buffer(C.GL_ELEMENT_ARRAY_BUFFER, ebo)
	// gl.buffer_data_int(GL_ELEMENT_ARRAY_BUFFER, indices, draw_typ)
	gl.buffer_data_int(C.GL_ELEMENT_ARRAY_BUFFER, indices, draw_typ)
}

pub fn delete_buffer(vbo u32) {
	C.glDeleteBuffers(1, vbo)
}

pub fn delete_vao(vao u32) {
	C.glDeleteVertexArrays(1, vao)
}

// /////////////////////
// fn gen_vertex_arrays(a int, vao uint) {
// # glGenVertexArrays(a, &VAO);
// }

// gets the uniform location for key
pub fn get_uniform_location(program int, key string) int {
	return C.glGetUniformLocation(program, key.str)
}

//gets the attribute location for key
pub fn get_attrib_location(program int, key string) int {
	return C.glGetAttribLocation(program, key.str)
}

pub fn bind_attrib_location(program int, index int, name string) {
	C.glBindAttribLocation(program, index, name.str)
}

pub fn draw_arrays(typ, start, len int) {
	C.glDrawArrays(typ, start, len)
}

pub fn draw_elements(mode, count, typ, indices int) {
	C.glDrawElements(mode, count, typ, indices)
}

pub fn use_program(program int) {
	C.glUseProgram(program)
}

pub fn gen_vertex_array() u32 {
	vao := u32(0)
	C.glGenVertexArrays(1, &vao)
	return vao
}

pub fn enable_vertex_attrib_array(n int) {
	C.glEnableVertexAttribArray(n)
}

pub fn disable_vertex_attrib_array(n int) {
	C.glDisableVertexAttribArray(n)
}

pub fn gen_buffer() u32 {
	vbo := u32(0)
	C.glGenBuffers(1, &vbo)
	return vbo
}

pub fn vertex_attrib_pointer(index, size int, typ int, normalized bool, _stride int, _ptr int) {
	mut stride := _stride
	mut ptr := _ptr
	if typ == C.GL_FLOAT {
		stride *= sizeof(f32)
		ptr *= sizeof(f32)
	}
	C.glVertexAttribPointer(index, size, typ, normalized, stride, ptr)
}

pub fn tex_param(key, val int) {
	C.glTexParameteri(C.GL_TEXTURE_2D, key, val)
}

pub fn enable(val int) {
	C.glEnable(val)
}

pub fn disable(val int) {
	C.glDisable(val)
}

pub fn scissor(a, b, c, d int) {
	C.glScissor(a, b, c, d)
}

pub fn generate_mipmap(typ int) {
	C.glGenerateMipmap(typ)
}

// set mat4 at uniform location
pub fn set_mat4fv(loc, count int, transpose bool, val glm.Mat4) {
	C.glUniformMatrix4fv(loc, count, transpose, val.data)
}

pub fn set_f32(loc int, val f32) {
	C.glUniform1f(loc, val)
}

pub fn set_vec(loc int, x, y, z f32) {
	C.glUniform3f(loc, x, y, z)
}

pub fn set_bool(loc int, val bool) {
	if val {
		set_f32(loc, 1)
	} else {
		set_f32(loc, 0)
	}
}// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module glfw

// note: we might need special case for this
// see TmpGlImportHack below (joe-c)
import gl

#flag -I @VROOT/thirdparty/glfw
#flag -L @VROOT/thirdparty/glfw

// Debugging a custom build
//-#flag darwin -L/var/tmp/glfw/src/

// MacPorts
#flag darwin -L/opt/local/lib

#flag darwin -lglfw
#flag freebsd -I/usr/local/include
#flag freebsd -Wl,-L/usr/local/lib,-lglfw

#flag solaris -I/opt/local/include
#flag solaris -L/opt/local/lib
#flag solaris -lglfw

#flag linux -lglfw
#flag windows -lgdi32 -lshell32 -lglfw3
#flag mingw -mwindows
#include <GLFW/glfw3.h>
// #flag darwin -framework Carbon
// #flag darwin -framework Cocoa
// #flag darwin -framework CoreVideo
// #flag darwin -framework IOKit
pub const (
	resizable = 1
	decorated = 2
)

pub const (
	key_escape     = 256
	key_space      = 32
	key_left_super = 343

	key_up    = 265
	key_left  = 263
	key_right = 262
	key_down  = 264
)

fn C.glfwGetWindowUserPointer() voidptr
fn C.glfwGetPrimaryMonitor() voidptr
fn C.glfwSetWindowUserPointer()
fn C.glfwSetCursor()
fn C.glfwGetCursorPos()
fn C.glfwSetClipboardString()
fn C.glfwGetWindowContentScale()
fn C.glfwGetClipboardString()
fn C.glfwGetKey()
fn C.glfwGetTime() f64
fn C.glfwSetCharModsCallback()
fn C.glfwSetKeyCallback()
fn C.glfwPostEmptyEvent()
fn C.glfwSetScrollCallback()
fn C.glfwSetWindowSizeCallback()
fn C.glfwSetMouseButtonCallback()
fn C.glfwSetCursorPosCallback()
fn C.glfwSwapBuffers()
fn C.glfwWindowShouldClose() bool
fn C.glfwSetWindowShouldClose()
fn C.glfwWaitEvents()
fn C.glfwPollEvents()
fn C.glfwSwapInterval()
fn C.glfwMakeContextCurrent()
fn C.glfwSetWindowTitle()
fn C.glfwTerminate()
fn C.glfwCreateWindow(w int, h int, title charptr, m voidptr, sh voidptr) voidptr
fn C.glfwWindowHint()
fn C.glfwDestroyWindow()
fn C.glfwInit()
fn C.glGetIntegerv()

// joe-c: fix & remove
struct TmpGlImportHack {
	hack gl.TmpGlImportHack
}

pub struct WinCfg {
	width             int
	height            int
	title             string
	ptr               voidptr
	borderless        bool
	is_modal          int
	is_browser        bool
	url        		  string
	always_on_top     bool
	scale_to_monitor  bool = true
}

// data  *C.GLFWwindow
// TODO change data to cobj
pub struct Window {
	data    voidptr
	title   string
	mx      int
	my      int
	scale_  f32
}

pub struct Size {
pub:
	width  int
	height int
}

pub struct Pos {
pub:
	x int
	y int
}

// type clickpub fn pub fn (window * GLFWwindow, button, action, mods int)
type ClickPubFn fn (window voidptr, button, action, mods int)

/*
 * TODO broken
fn init() {
	init_glfw()
}
*/

pub fn init_glfw() {
	C.glfwInit()
	C.glfwWindowHint(C.GLFW_CONTEXT_VERSION_MAJOR, 3)
	C.glfwWindowHint(C.GLFW_CONTEXT_VERSION_MINOR, 3)
	C.glfwWindowHint(C.GLFW_OPENGL_FORWARD_COMPAT, C.GL_TRUE)
	C.glfwWindowHint(C.GLFW_OPENGL_PROFILE, C.GLFW_OPENGL_CORE_PROFILE)
}

pub fn (w &Window) destroy() {
	C.glfwDestroyWindow(w.data)
}

pub fn terminate() {
	C.glfwTerminate()
}

// pub fn mouse_move(w * GLFWwindow, x, y double) {
pub fn mouse_move(w voidptr, x, y f64) {
	// #printf("%f : %f => %d \n", x,y);
}

pub fn window_hint(key, val int) {
	C.glfwWindowHint(key, val)
}

pub fn create_window(c WinCfg) &Window {
	if c.borderless {
		window_hint(C.GLFW_RESIZABLE, 0)
		window_hint(C.GLFW_DECORATED, 0)
	}
	if c.always_on_top {
		window_hint(C.GLFW_FLOATING, 1)
	}
	if c.scale_to_monitor {
		$if windows {
			window_hint(C.GLFW_SCALE_TO_MONITOR, 1)
		}
	}
	cwindow := C.glfwCreateWindow(c.width, c.height, c.title.str, 0, 0)
	if isnil(cwindow) {
		println('failed to create a glfw window, make sure you have a GPU driver installed')
		C.glfwTerminate()
	}
	// println('create window wnd=$cwindow ptr==$c.ptr')
	C.glfwSetWindowUserPointer(cwindow, c.ptr)

	mut scale := f32(1.0)
	$if windows {
		C.glfwGetWindowContentScale(cwindow, &scale, &scale)
	}
	$else {
		scale = 1.0
	}

	window := &Window {
		data: cwindow,
		title: c.title,
		scale_: scale
	}
	return window
}

pub fn (w &Window) set_title(title string) {
	C.glfwSetWindowTitle(w.data, title.str)
}

pub fn (w &Window) make_context_current() {
	C.glfwMakeContextCurrent(w.data)
}

pub fn (w &Window) scale() f32 {
	return w.scale_
}

pub fn swap_interval(interval int) {
	C.glfwSwapInterval(interval)
}

pub fn wait_events() {
	C.glfwWaitEvents()
}

pub fn poll_events() {
	C.glfwPollEvents()
}

pub fn set_should_close(w voidptr, close bool) {
	C.glfwSetWindowShouldClose(w, close)
}

pub fn (w &Window) set_should_close(close bool) {
	C.glfwSetWindowShouldClose(w.data, close)
}

pub fn (w &Window) should_close() bool {
	return C.glfwWindowShouldClose(w.data)
}

pub fn (w &Window) swap_buffers() {
	C.glfwSwapBuffers(w.data)
}

pub fn (mut w Window) onmousemove(cb voidptr) {
	C.glfwSetCursorPosCallback(w.data, cb)
}

pub fn (mut w Window) set_mouse_button_callback(cb voidptr) {
	C.glfwSetMouseButtonCallback(w.data, cb)
}

pub fn (mut w Window) on_resize(cb voidptr) {
	C.glfwSetWindowSizeCallback(w.data, cb)
}

pub fn (mut w Window) on_click(cb voidptr) {
	C.glfwSetMouseButtonCallback(w.data, cb)
}

pub fn (w &Window) set_scroll_callback(cb voidptr) {
	C.glfwSetScrollCallback(w.data, cb)
}

pub fn (w &Window) on_scroll(cb voidptr) {
	C.glfwSetScrollCallback(w.data, cb)
}

pub fn post_empty_event() {
	C.glfwPostEmptyEvent()
}

pub fn (mut w Window) onkeydown(cb voidptr) {
	C.glfwSetKeyCallback(w.data, cb)
}

pub fn (mut w Window) onchar(cb voidptr) {
	C.glfwSetCharModsCallback(w.data, cb)
}

pub fn get_time() f64 {
	return C.glfwGetTime()
}

pub fn key_pressed(wnd voidptr, key int) bool {
	return int(C.glfwGetKey(wnd, key)) == C.GLFW_PRESS
}

pub fn (w &Window) get_clipboard_text() string {
	return string(byteptr(C.glfwGetClipboardString(w.data)))
}

pub fn (w &Window) set_clipboard_text(s string) {
	C.glfwSetClipboardString(w.data, s.str)
}

pub fn get_cursor_pos(cwindow voidptr) (f64, f64) {
	x := f64(0)
	y := f64(0)
	C.glfwGetCursorPos(cwindow, &x, &y)

	mut scale := f32(1.0)
	$if windows {
		C.glfwGetWindowContentScale(cwindow, &scale, &scale)
	}
	$else {
		scale = 1.0
	}
	return x/scale, y/scale
}

pub fn (w &Window) get_cursor_pos() Pos {
	x := f64(0)
	y := f64(0)
	C.glfwGetCursorPos(w.data, &x, &y)

	return Pos {
		x: int(x/w.scale_)
		y: int(y/w.scale_)
	}
}

enum Cursor {
	arrow
	ibeam
	hand
}

pub fn set_cursor(c Cursor) {
	C.glfwSetCursor(0, C.GLFW_IBEAM_CURSOR)
}

pub fn (w &Window) set_cursor(c Cursor) {
	C.glfwSetCursor(w.data, C.GLFW_IBEAM_CURSOR)

}

pub fn (w &Window) user_ptr() voidptr {
	return C.glfwGetWindowUserPointer(w.data)
}

pub fn (w &Window) set_user_ptr(ptr voidptr) {
	C.glfwSetWindowUserPointer(w.data, ptr)
}

struct C.GLFWvidmode {
	width int
	height int
}

pub fn C.glfwGetVideoMode() &C.GLFWvidmode

pub fn get_monitor_size() Size {
	//# GLFWvidmode* mode = glfwGetVideoMode(glfwGetPrimaryMonitor());
	mode := C.glfwGetVideoMode(C.glfwGetPrimaryMonitor())
	return Size{mode.width, mode.height}
}

fn C.glfwGetWindowSize(window &Window, width &int, height &int) // screen coordinates
fn C.glfwGetFramebufferSize(window &Window, width &int, height &int) // pixels

// get_window_size in screen coordinates
pub fn (w &Window) get_window_size() Size {
	res := Size {0, 0}
	C.glfwGetWindowSize(w.data, &res.width, &res.height)
	return res
}

// get_framebuffer_size in pixels
pub fn (w &Window) get_framebuffer_size() Size {
	res := Size {0, 0}
	C.glfwGetFramebufferSize(w.data, &res.width, &res.height)
	return res
}

pub fn (size Size) str() string {
	return '{$size.width, $size.height}'
}

pub fn get_window_user_pointer(gwnd voidptr) voidptr {
	return C.glfwGetWindowUserPointer(gwnd)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module glm

import math

/*
#flag -lmyglm
# f32* myglm_ortho(f32, f32, f32, f32);
# f32* myglm_translate(f32, f32, f32);
*/
// # f32* myglm_rotate(f32 *m, f32 angle, f32, f32, f32);
// # f32* myglm_perspective(f32, f32, f32, f32);
// # f32* myglm_look_at(glm__Vec3, glm__Vec3, glm__Vec3);
// # glm__Vec3 myglm_mult(glm__Vec3, glm__Vec3);
// # glm__Vec3 myglm_cross(glm__Vec3, glm__Vec3);
// # glm__Vec3 myglm_normalize(glm__Vec3);
pub struct Mat4 {
pub:
	data &f32
}

struct Vec2 {
	x f32
	y f32
}

struct Vec3 {
	x f32
	y f32
	z f32
}

pub fn vec3(x, y, z f32) Vec3 {
	res := Vec3 {
		x: x,
		y: y,
		z: z,
	}
	return res
}

fn mat4(f &f32) Mat4 {
	res := Mat4 {
		data: f
	}
	return res
}

pub fn (v Vec3) str() string {
	return 'Vec3{ $v.x, $v.y, $v.z }'
}

pub fn (v Vec2) str() string {
	return 'Vec3{ $v.x, $v.y }'
}

pub fn (m Mat4) str() string {
	mut s := '[ '
	for i in 0..4 {
		if i != 0 {
			s += '  '
		}
		for j in 0..4 {
			val := m.data[i * 4 + j]
			s += '${val:5.2f} '
		}
		if i != 3 {
			s += '\n'
		}
	}
	s += ']'
	return s
}

fn vec2(x, y int) Vec2 {
	res := Vec2 {
		x: f32(x),
		y: f32(y),
	}
	return res
}

fn (a Vec3) add(b Vec3) Vec3 {
	res := Vec3 {
		x: a.x + b.x,
		y: a.y + b.y,
		z: a.z + b.z,
	}
	return res
}

fn (a Vec3) sub(b Vec3) Vec3 {
	res := Vec3 {
		x: a.x - b.x,
		y: a.y - b.y,
		z: a.z - b.z,
	}
	return res
}

// fn (a Vec3) mult(b Vec3) Vec3 {
// # return myglm_mult(a,b);
// }
fn (a Vec3) mult_scalar(b f32) Vec3 {
	res := Vec3 {
		x: a.x * b,
		y: a.y * b,
		z: a.z * b,
	}
	return res
}

fn (a Vec3) print() {
	x := a.x
	y := a.y
	z := a.z
	C.printf('vec3{%f,%f,%f}\n',x,y,z)
	// println('vec3{$x,$y,$z}')
}

/*
fn rotate(m Mat4, angle f32, vec Vec3) Mat4 {
	// # t_mat4 m;
	// println('rotate done')
	# return glm__mat4( myglm_rotate(m.data, angle, vec.x,vec.y,vec.z) );
	return Mat4{}
}
*/

fn f32_calloc(n int) &f32 {
	return voidptr(vcalloc(n * int(sizeof(f32))))
}
// fn translate(vec Vec3) *f32 {
pub fn translate(m Mat4, v Vec3) Mat4 {
	// # return glm__mat4(myglm_translate(vec.x,vec.y,vec.z)  );
	a := m.data
	mut out := f32_calloc(16)
	x := v.x
	y := v.y
	z := v.z
	a00 := a[0] a01 := a[1] a02 := a[2]  a03 := a[3]
	a10 := a[4] a11 := a[5] a12 := a[6]  a13 := a[7]
	a20 := a[8] a21 := a[9] a22 := a[10] a23 := a[11]
	out[0] = a00 out[1] = a01 out[2] = a02 out[3] = a03
	out[4] = a10 out[5] = a11 out[6] = a12 out[7] = a13
	out[8] = a20 out[9] = a21 out[10] = a22 out[11] = a23
	out[12] = a00 * x + a10 * y + a20 * z + a[12]
	out[13] = a01 * x + a11 * y + a21 * z + a[13]
	out[14] = a02 * x + a12 * y + a22 * z + a[14]
	out[15] = a03 * x + a13 * y + a23 * z + a[15]
	return mat4(out)
}

/*
fn normalize(vec Vec3) Vec3 {
	# return myglm_normalize(vec);
	return Vec3{}
}
*/
// https://github.com/g-truc/glm/blob/0ceb2b755fb155d593854aefe3e45d416ce153a4/glm/ext/matrix_clip_space.inl
pub fn ortho(left, right, bottom, top f32) Mat4 {
	//println('glm ortho($left, $right, $bottom, $top)')
	// mat<4, 4, T, defaultp> Result(static_cast<T>(1));
	n := 16
	mut res := f32_calloc(n)
	res[0] = 2.0 / (right - left)
	res[5] = 2.0 / (top - bottom)
	res[10] = 1.0
	res[12] = - (right + left) / (right - left)
	res[13] = - (top + bottom) / (top - bottom)
	res[15] = 1.0
	return mat4(res)
}

// https://github.com/g-truc/glm/blob/0ceb2b755fb155d593854aefe3e45d416ce153a4/glm/ext/matrix_clip_space.inl
pub fn ortho_zo(left, right, bottom, top, zNear, zFar f32) Mat4 {
	//println('glm ortho($left, $right, $bottom, $top)')
	// mat<4, 4, T, defaultp> Result(static_cast<T>(1));
	n := 16
	mut res := f32_calloc(n)
	res[0] = 2.0 / (right - left)
	res[5] = 2.0 / (top - bottom)
	res[10] = 1.0
	res[12] = - (right + left) / (right - left)
	res[13] = - (top + bottom) / (top - bottom)
	res[14] = - zNear / (zFar - zNear)
	res[15] = 1.0
	return mat4(res)
}

// fn scale(a *f32, v Vec3) *f32 {
pub fn scale(m Mat4, v Vec3) Mat4 {
	a := m.data
	mut out := f32_calloc(16)
	x := v.x
	y := v.y
	z := v.z
	out[0] = a[0] * v.x
	out[1] = a[1] * x
	out[2] = a[2] * x
	out[3] = a[3] * x
	out[4] = a[4] * y
	out[5] = a[5] * y
	out[6] = a[6] * y
	out[7] = a[7] * y
	out[8] = a[8] * z
	out[9] = a[9] * z
	out[10] = a[10] * z
	out[11] = a[11] * z
	out[12] = a[12]
	out[13] = a[13]
	out[14] = a[14]
	out[15] = a[15]
	return mat4(out)
}

// multiplicates two matrices
pub fn mult(a, b Mat4) Mat4 {
	db := b.data
	mut out := f32_calloc(16)
	mut row0 := f32_calloc(4)
	mut row1 := f32_calloc(4)
	mut row2 := f32_calloc(4)
	mut row3 := f32_calloc(4)

	row0[0] = db[0]row0[1] = db[1]row0[2] = db[2]row0[3] = db[3]
	row1[0] = db[4]row1[1] = db[5]row1[2] = db[6]row1[3] = db[7]
	row2[0] = db[8]row2[1] = db[9]row2[2] = db[10]row2[3] = db[11]
	row3[0] = db[12]row3[1] = db[13]row3[2] = db[14]row3[3] = db[15]

	a_ := mult_mat_point(a, mat4(row0))
	b_ := mult_mat_point(a, mat4(row1))
	c_ := mult_mat_point(a, mat4(row2))
	d_ := mult_mat_point(a, mat4(row3))

	res0 := a_.data res1 := b_.data res2 := c_.data res3 := d_.data

	out[0] = res0[0] out[1] = res0[1] out[2] = res0[2] out[3] = res0[3]
	out[4] = res1[0] out[5] = res1[1] out[6] = res1[2] out[7] = res1[3]
	out[8] = res2[0] out[9] = res2[1] out[10] = res2[2] out[11] = res2[3]
	out[12] = res3[0] out[13] = res3[1] out[14] = res3[2] out[15] = res3[3]

	return mat4(out)
}

// helper function for mult
fn mult_mat_point(a Mat4, point Mat4) Mat4 {
	data := a.data
	c0r0 := data[0]c1r0 := data[1]c2r0 := data[2]c3r0 := data[3]
	c0r1 := data[4]c1r1 := data[5]c2r1 := data[6]c3r1 := data[7]
	c0r2 := data[8]c1r2 := data[9]c2r2 := data[10]c3r2 := data[11]
	c0r3 := data[12]c1r3 := data[13]c2r3 := data[14]c3r3 := data[15]

	pdata := point.data
	x := pdata[0]
	y := pdata[1]
	z := pdata[2]
	w := pdata[3]

	mut out := f32_calloc(4)

	rx := (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3)
	ry := (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3)
	rz := (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3)
	rw := (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3)

	out[0] = rx out[1] = ry	out[2] = rz out[3] = rw

	return mat4(out)
}

pub fn rotate(angle f32, axis Vec3, src Mat4) Mat4 {
	c := f32(math.cos(angle))
	s := f32(math.sin(angle))
	oneminusc := f32(1.0) - c

	xy := axis.x * axis.y
	yz := axis.y * axis.z
	xz := axis.x * axis.z
	xs := axis.x * s
	ys := axis.y * s
	zs := axis.z * s

	f00 := axis.x * axis.x * oneminusc + c
	f01 := xy * oneminusc + zs
	f02 := xz * oneminusc - ys

	f10 := xy * oneminusc-zs
	f11 := axis.y * axis.y * oneminusc + c
	f12 := yz * oneminusc + xs

	f20 := xz * oneminusc + ys
	f21 := yz * oneminusc - xs
	f22 := axis.z  *axis.z * oneminusc + c

	data := src.data

	t00 := data[0] * f00 + data[4] * f01 + data[8] * f02
	t01 := data[1] * f00 + data[5] * f01 + data[9] * f02
	t02 := data[2] * f00 + data[6] * f01 + data[10] * f02
	t03 := data[3] * f00 + data[7] * f01 + data[11] * f02

	t10 := data[0] * f10 + data[4] * f11 + data[8] * f12
	t11 := data[1] * f10 + data[5] * f11 + data[9] * f12
	t12 := data[2] * f10 + data[6] * f11 + data[10] * f12
	t13 := data[3] * f10 + data[7] * f11 + data[11] * f12

	mut dest := src.data

	dest[8] = data[0] * f20 + data[4] * f21 + data[8] * f22
	dest[9] = data[1] * f20 + data[5] * f21 + data[9] * f22
	dest[10] = data[2] * f20 + data[6] * f21 + data[10] * f22
	dest[11] = data[3] * f20 + data[7] * f21 + data[11] * f22

	dest[0] = t00	dest[1] = t01	dest[2] = t02	dest[3] = t03 
	dest[4] = t10	dest[5] = t11	dest[6] = t12	dest[7] = t13

	return mat4(dest)
}

// fn rotate_z(a *f32, rad f32) *f32 {
pub fn rotate_z(m Mat4, rad f32) Mat4 {
	a := m.data
	mut out := f32_calloc(16)
	s := f32(math.sin(rad))
	c := f32(math.cos(rad))
	a00 := a[0]
	a01 := a[1]
	a02 := a[2]
	a03 := a[3]
	a10 := a[4]
	a11 := a[5]
	a12 := a[6]
	a13 := a[7]
	out[8] = a[8]
	out[9] = a[9]
	out[10] = a[10]
	out[11] = a[11]
	out[12] = a[12]
	out[13] = a[13]
	out[14] = a[14]
	out[15] = a[15]
	// Perform axis-specific matrix multiplication
	out[0] = a00 * c + a10 * s
	out[1] = a01 * c + a11 * s
	out[2] = a02 * c + a12 * s
	out[3] = a03 * c + a13 * s
	out[4] = a10 * c - a00 * s
	out[5] = a11 * c - a01 * s
	out[6] = a12 * c - a02 * s
	out[7] = a13 * c - a03 * s
	return mat4(out)
}

pub fn identity() Mat4 {
	// 1 0 0 0
	// 0 1 0 0
	// 0 0 1 0
	// 0 0 0 1
	n := 16
	mut res := f32_calloc(int(sizeof(f32)) * n)
	res[0] = 1
	res[5] = 1
	res[10] = 1
	res[15] = 1
	return mat4(res)
}

// returns *f32 without allocation
pub fn identity2(res mut &f32) {
	res[0] = 1
	res[5] = 1
	res[10] = 1
	res[15] = 1
	// # f32 f[16]={0};// for (int i =0;i<16;i++)
	// # printf("!!%d\n", f[0]);
	// # glm__identity2(&f);
	// # gl__Shader_set_mat4(shader, tos2("projection"), f) ;
}

pub fn identity3() []f32 {
	res := [f32(1.0), 0, 0, 0,
	0, 1, 0, 0,
	0, 0, 1, 0,
	0, 0, 0, 1,
	]
	return res
}

// https://github.com/toji/gl-matrix/blob/1549cf21dfa14a2bc845993485343d519cf064fe/src/gl-matrix/mat4.js
fn ortho_js(left, right, bottom, top f32) &f32 {
//	mynear := 1
//	myfar := 1
	lr := 1.0 / (left - right)
	bt := 1.0 / (bottom - top)
	nf := f32(1.0) / 1.0// (mynear -myfar)
	mut out := &f32(0)
	unsafe { out = &f32( malloc (sizeof(f32) * 16)) }
	out[0] = -2.0 * lr
	out[1] = 0
	out[2] = 0
	out[3] = 0
	out[4] = 0
	out[5] = -2.0 * bt
	out[6] = 0
	out[7] = 0
	out[8] = 0
	out[9] = 0
	out[10] = 2.0 * nf
	out[11] = 0
	out[12] = (left + right) * lr
	out[13] = (top + bottom) * bt
	out[14] = 1.0 * nf//(far + near) * nf;
	out[15] = 1
	return out
	//f := 0.0
	//return &f
}

// fn ortho_old(a, b, c, d f32) *f32 {
// # return myglm_ortho(a,b,c,d);
// }
fn cross(a, b Vec3) Vec3 {
	// # return myglm_cross(a,b);
	return Vec3{}
}

/*
fn perspective(degrees f32, ratio f32, a, b f32) Mat4 {
	// println('lang per degrees=$degrees ratio=$ratio a=$a b=$b')
	// # printf("lang pers degrees=%f ratio=%f a=%f b=%f\n", degrees, ratio, a,b);
	# return glm__mat4( myglm_perspective(degrees, ratio, a,b)  ) ;
	return Mat4{}
}

fn look_at(eye, center, up Vec3) Mat4 {
	# return glm__mat4(  myglm_look_at(eye, center, up)  ) ;
	return Mat4{}
}
*/
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// might need special case for this
// import gl
import glm

fn cmp(a, b f32) bool {
	return int(a * 1000) == int(b * 1000)
}

fn test_ortho() {
	projection := glm.ortho(0, 200, 400, 0)
	$if debug {
		println(projection.data[0])
	}
	assert cmp(projection.data[0], 0.01)
	assert cmp(projection.data[1], 0.000000)
	assert cmp(projection.data[2], 0.000000)
	assert cmp(projection.data[3], 0.000000)
	assert cmp(projection.data[4], 0.000000)
	assert cmp(projection.data[5], - 0.005000)
	assert cmp(projection.data[6], 0.000000)
	assert cmp(projection.data[7], 0.000000)
	assert cmp(projection.data[8], 0.000000)
	assert cmp(projection.data[9], 0.000000)
	assert cmp(projection.data[10], 1.000000)
	assert cmp(projection.data[11], 0.000000)
	assert cmp(projection.data[12], - 1.000000)
	assert cmp(projection.data[13], 1.000000)
	assert cmp(projection.data[14], 0.000000)
	assert cmp(projection.data[15], 1.000000)
	// f := gg.ortho(1,2,3,4)

		/* 
		// for debugging broken tetris in gg.o
		# projection.data[0]=0.010000;
		# projection.data[1]=0.000000;
		# projection.data[2]=0.000000;
		# projection.data[3]=0.000000;
		# projection.data[4]=0.000000;
		# projection.data[5]=-0.005000;
		# projection.data[6]=0.000000;
		# projection.data[7]=0.000000;
		# projection.data[8]=0.000000;
		# projection.data[9]=0.000000;
		# projection.data[10]=1.000000;
		# projection.data[11]=0.000000;
		# projection.data[12]=-1.000000;
		# projection.data[13]=1.000000;
		# projection.data[14]=0.000000;
		# projection.data[15]=1.000000;
*/
}

fn test_rotate() {
	$if debug {
		println('rotate')
	}
	mut m := glm.identity()
	m = glm.scale(m, glm.vec3(2, 2, 2))
	$if debug {
		println(m)
	}
	m = glm.rotate_z(m, 1)
	$if debug {
		println(m)
	}

	mut m1 := glm.identity()
	mut m2 := glm.identity()

	m1 = glm.rotate(1, glm.vec3(1, 0, 0), m1)
	m2 = glm.rotate(1, glm.vec3(0, 1, 0), m2)

	mut same := true
	for i in 0..15 {
		if m1.data[i] != m2.data[i] {
			same = false
		}
	}
	assert !same
}

fn test_translate() {
	mut m := glm.identity()
	m = glm.translate(m, glm.vec3(0, 0, - 0.5))
	$if debug {
		println(m)
	}
    assert m.data[0]  == 1.0 
    assert m.data[1]  == 0.0
    assert m.data[2]  == 0.0
    assert m.data[3]  == 0.0
    //
    assert m.data[4]  == 0.0
    assert m.data[5]  == 1.0
    assert m.data[6]  == 0.0
    assert m.data[7]  == 0.0
    
    assert m.data[8]  == 0.0
    assert m.data[9]  == 0.0
    assert m.data[10] == 1.0
    assert m.data[11] == 0.0
    //
    assert m.data[12] == 0.0
    assert m.data[13] == 0.0
    assert m.data[14] == -0.5
    assert m.data[15] == 1.0
}

fn test_mult() {
	//TODO improve test
	mut a := glm.identity()
	mut b := glm.identity()
	mut c := glm.identity()
	a = glm.mult(a, b)
	for i in 0..15 {
		assert a.data[i] == c.data[i]
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module gx

pub struct Color {
pub:
	r int
	g int
	b int
}

pub const (
	blue   = Color { r: 0, g: 0, b: 255 }
	red    = Color { r: 255, g: 0, b: 0 }
	green  = Color { r: 0, g: 255, b: 0 }
	yellow = Color { r: 255, g: 255, b: 0 }

	orange = Color { r: 255, g: 165, b: 0 }
	purple = Color { r: 128, g: 0, b: 128 }

	black  = Color { r: 0, g: 0, b: 0 }
	gray   = Color { r: 128, g: 128, b: 128 }
	indigo = Color { r: 75, g: 0, b: 130 }
	pink   = Color { r: 255, g: 192, b: 203 }
	violet = Color { r: 238, g: 130, b: 238 }
	white  = Color { r: 255, g: 255, b: 255 }

	// Shades
	dark_blue   = Color { r: 0, g: 0, b: 139 }
	dark_gray   = Color { r: 169, g: 169, b: 169 }
	dark_green  = Color { r: 0, g: 100, b: 0 }
	dark_red    = Color { r: 139, g: 0, b: 0 }
	light_blue  = Color { r: 173, g: 216, b: 230 }
	light_gray  = Color { r: 211, g: 211, b: 211 }
	light_green = Color { r: 144, g: 238, b: 144 }
	light_red   = Color { r: 255, g: 204, b: 203 }
)

pub const (
	align_left  = 1
	align_right = 4
)

pub struct TextCfg {
pub:
	color     Color
	size      int
	align     int
	max_width int
	family    string
	bold      bool
	mono      bool
}

pub struct Image {
mut:
	obj    voidptr
pub:
	id     int
	width  int
	height int
}

pub fn (img Image) is_empty() bool {
	return isnil(img.obj)
}

pub fn (c Color) str() string {
	return '{$c.r, $c.g, $c.b}'
}

pub fn (a Color) eq(b Color) bool {
	return a.r == b.r &&	a.g == b.g &&	a.b == b.b
}

pub fn rgb(r, g, b int) Color {
	res := Color {
		r: r
		g: g
		b: b
	}
	return res
}

pub fn hex(color int) Color {
  res := Color {
    r: (color >> 16) & 0xFF
    g: (color >> 8) & 0xFF
    b: color & 0xFF
  }
  return res
}

// fn text_width_char(c char) int {
// return text_width(char2string(c))
// // return C.text_width_char(c)
// }
import gx

fn test_hex() {
  // valid colors
  color_a := gx.hex(0x6c5ce7)
  color_b := gx.rgb(108, 92, 231)
  assert color_a.eq(color_b) == true

  // doesn't give right value with short hex value
  short_color := gx.hex(0xfff)
  white_color := gx.rgb(255, 255, 255)
  assert short_color.eq(white_color) == false
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module hash

interface Hasher {
	// Sum appends the current hash to b and returns the resulting array.
	// It does not change the underlying hash state.
	sum(b []byte) []byte
	size() int
	block_size() int
}

interface Hash32er {
	sum32() u32
}

interface Hash64er {
	sum64() u64
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// This is a very basic crc32 implementation
// at the moment with no architecture optimizations
module crc32

// polynomials
pub const (
	ieee       = u32(0xedb88320)
	castagnoli = u32(0x82f63b78)
	koopman    = u32(0xeb31d82e)
)

// The size of a CRC-32 checksum in bytes.
const (
	size = 4
)

struct Crc32 {
mut:
	table []u32
}

fn(mut c Crc32) generate_table(poly int) {
	for i in 0..256 {
		mut crc := u32(i)
		for _ in 0..8 {
			if crc & u32(1) == u32(1) {
				crc = (crc >> 1) ^ u32(poly)
			} else {
				crc >>= u32(1)
			}
		}
		c.table << crc
	}
}

fn(c &Crc32) sum32(b []byte) u32 {
	mut crc := ~u32(0)
	for i in 0..b.len {
		crc = c.table[byte(crc)^b[i]] ^ (crc >> 8)
	}
	return ~crc
}

pub fn(c &Crc32) checksum(b []byte) u32 {
	return c.sum32(b)
}

// pass the polinomial to use
pub fn new(poly int) &Crc32 {
	mut c := &Crc32{}
	c.generate_table(poly)
	return c
}

// calculate crc32 using ieee
pub fn sum(b []byte) u32 {
	c := new(ieee)
	return c.sum32(b)
}
import hash.crc32

fn test_hash_crc32() {
	b1 := 'testing crc32'.bytes()
	sum1 := crc32.sum(b1)
	assert sum1 == u32(1212124400)
	assert sum1.hex() == '483f8cf0'

	
	c := crc32.new(crc32.ieee)
	b2 := 'testing crc32 again'.bytes()
	sum2 := c.checksum(b2)
	assert sum2 == u32(1420327025)
	assert sum2.hex() == '54a87871'
}
module fnv1a

const (
	fnv64_prime = u64(1099511628211)
	fnv64_offset_basis = u64(14695981039346656037)
	fnv32_offset_basis = u32(2166136261)
	fnv32_prime = u32(16777619)
)

[inline]
pub fn sum32_string(data string) u32 {
	mut hash := fnv32_offset_basis
	for i in 0..data.len {
		hash = (hash ^ u32(data[i])) * fnv32_prime
	}
	return hash
}

[inline]
pub fn sum32(data []byte) u32 {
	mut hash := fnv32_offset_basis
	for i in 0..data.len {
		hash = (hash ^ u32(data[i])) * fnv32_prime
	}
	return hash
}

[inline]
pub fn sum64_string(data string) u64 {
	mut hash := fnv64_offset_basis
	for i in 0..data.len {
		hash = (hash ^ u64(data[i])) * fnv64_prime
	}
	return hash
}

[inline]
pub fn sum64(data []byte) u64 {
	mut hash := fnv64_offset_basis
	for i in 0..data.len {
		hash = (hash ^ u64(data[i])) * fnv64_prime
	}
	return hash
}
import hash.fnv1a

fn test_fnv1a() {
	$if windows {
		return
	}
	a := 'apple'
	b := fnv1a.sum64_string(a)
	c := fnv1a.sum64(a.bytes())
	assert b.hex() == 'f74a62a458befdbf'
	assert c.hex() == 'f74a62a458befdbf'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module wyhash

pub fn rand_u64(seed &u64) u64 {
	mut seed0 := seed
	unsafe{
		mut seed1 := *seed0
		seed1 += wyp0
		*seed0 = seed1
		return wymum(seed1^wyp1, seed1)
	}	
	return 0
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
//
// this is an implementation of wyhash v4
// from https://github.com/wangyi-fudan/wyhash
//
// TODO: use u128 once implemented
// currently the C version performs slightly better
// because it uses 128 bit int when available and
// branch prediction hints. the C version will be
// removed once the perfomance is matched.
// you can test performance by running:
// `v run cmd/tools/bench/wyhash.v`
// try running with and without the `-prod` flag
module wyhash

//#flag -I @VROOT/thirdparty/wyhash
//#include "wyhash.h"
fn C.wyhash(byteptr, u64, u64) u64


const (
	wyp0 = u64(0xa0761d6478bd642f)
	wyp1 = u64(0xe7037ed1a0b428db)
	wyp2 = u64(0x8ebc6af09c88c6e3)
	wyp3 = u64(0x589965cc75374cc3)
	wyp4 = u64(0x1d8e4e27c47d124f)
)

[inline]
pub fn wyhash_c(key byteptr, len, seed u64) u64 {
	return C.wyhash(key, len, seed)
}

[inline]
pub fn sum64_string(key string, seed u64) u64 {
	return wyhash64(key.str, u64(key.len), seed)
}

[inline]
pub fn sum64(key []byte, seed u64) u64 {
	return wyhash64(byteptr(key.data), u64(key.len), seed)
}

[inline]
fn wyhash64(key byteptr, len, seed_ u64) u64 {
	if len == 0 {
		return 0
	}
	mut p := &key[0]
	mut seed := seed_
	mut i := len & 63
	if i < 4 {
		seed = wymum(wyr3(p, i) ^ seed ^ wyp0, seed ^ wyp1)
	}
	else if i <= 8 {
		seed = wymum(wyr4(p) ^ seed ^ wyp0, wyr4(p + i - 4) ^ seed ^ wyp1)
	}
	else if i <= 16 {
		seed = wymum(wyr8(p) ^ seed ^ wyp0, wyr8(p + i - 8) ^ seed ^ wyp1)
	}
	else if i <= 24 {
		seed = wymum(wyr8(p) ^ seed ^ wyp0, wyr8(p + 8) ^ seed ^ wyp1) ^ wymum(wyr8(p + i - 8) ^ seed ^ wyp2, seed ^ wyp3)
	}
	else if i <= 32 {
		seed = wymum(wyr8(p) ^ seed ^ wyp0, wyr8(p + 8) ^ seed ^ wyp1) ^ wymum(wyr8(p + 16) ^ seed ^ wyp2, wyr8(p + i - 8) ^ seed ^ wyp3)
	}
	else {
		seed = wymum(wyr8(p) ^ seed ^ wyp0, wyr8(p + 8) ^ seed ^ wyp1) ^ wymum(wyr8(p + 16) ^ seed ^ wyp2, wyr8(p + 24) ^ seed ^ wyp3) ^ wymum(wyr8(p + i - 32) ^ seed ^ wyp1, wyr8(p + i - 24) ^ seed ^ wyp2) ^ wymum(wyr8(p + i - 16) ^ seed ^ wyp3, wyr8(p + i - 8) ^ seed ^ wyp0)
	}
	if i == len {
		return wymum(seed, len ^ wyp4)
	}
	mut see1 := seed
	mut see2 := seed
	mut see3 := seed
	p = p + i
	for i = len - i; i >= 64; i -= 64 {
		seed = wymum(wyr8(p) ^ seed ^ wyp0, wyr8(p + 8) ^ seed ^ wyp1)
		see1 = wymum(wyr8(p + 16) ^ see1 ^ wyp2, wyr8(p + 24) ^ see1 ^ wyp3)
		see2 = wymum(wyr8(p + 32) ^ see2 ^ wyp1, wyr8(p + 40) ^ see2 ^ wyp2)
		see3 = wymum(wyr8(p + 48) ^ see3 ^ wyp3, wyr8(p + 56) ^ see3 ^ wyp0)
		p = p + 64
	}
	return wymum(seed ^ see1 ^ see2, see3 ^ len ^ wyp4)
}

[inline]
fn wyrotr(v u64, k u32) u64 {
	return (v>>k) | (v<<(64 - k))
}

[inline]
fn wymum(a, b u64) u64 {
	/*
	mut r := u128(a)
	r = r*b
	return (r>>64)^r
	*/
	mask32 := u32(4294967295)
	x0 := a & mask32
	x1 := a>>32
	y0 := b & mask32
	y1 := b>>32
	w0 := x0 * y0
	t := x1 * y0 + (w0>>32)
	mut w1 := t & mask32
	w2 := t>>32
	w1 += x0 * y1
	hi := x1 * y1 + w2 + (w1>>32)
	lo := a * b
	return hi ^ lo
}

[inline]
fn wyr3(p byteptr, k u64) u64 {
	return (u64(p[0])<<16) | (u64(p[k>>1])<<8) | u64(p[k - 1])
}

[inline]
fn wyr4(p byteptr) u64 {
	return u32(p[0]) | (u32(p[1])<<u32(8)) | (u32(p[2])<<u32(16)) | (u32(p[3])<<u32(24))
}

[inline]
fn wyr8(p byteptr) u64 {
	return u64(p[0]) | (u64(p[1])<<8) | (u64(p[2])<<16) | (u64(p[3])<<24) | (u64(p[4])<<32) | (u64(p[5])<<40) | (u64(p[6])<<48) | (u64(p[7])<<56)
}
import hash.wyhash

struct WyHashTest {
	s        string
	seed     u64
	expected u64
}

fn test_wyhash() {
	tests := [WyHashTest{
		'',0,0x0},
	WyHashTest{
		'v',1,0xc72a8f8bdfdd82},
	WyHashTest{
		'is',2,0xa1099c1c58fc13e},
	WyHashTest{
		'the best',3,0x1b1215ef0b0b94c},
	WyHashTest{
		'abcdefghijklmnopqrstuvwxyz',4,0x6db0e773d1503fac},
	WyHashTest{
		'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',5,0xe062dfda99413626},
	]
	for test in tests {
		got := wyhash.sum64(test.s.bytes(), test.seed)
		// println(' #      GOT: $got | $got.hex()')
		// println(' # EXPECTED: $test.expected | $test.expected.hex()')
		assert got == test.expected
	}
}

fn test_rand_u64() {
	seed := u64(111)
	mut rand_nos := []u64{}
	for _ in 0..40 {
		rand_no := wyhash.rand_u64(&seed)
		for r in rand_nos {
			assert rand_no != r
		}
		rand_nos << rand_no
	}
	assert true
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module json

#flag -I @VROOT/thirdparty/cJSON
#flag @VROOT/thirdparty/cJSON/cJSON.o
#include "cJSON.h"
#define js_get(object, key) cJSON_GetObjectItemCaseSensitive((object), (key))
struct C.cJSON {
	valueint    int
	valuedouble f32
	valuestring byteptr
}

pub fn decode(typ voidptr, s string) ?voidptr {
	// compiler implementation
	return 0
}

pub fn encode(x voidptr) string {
	// compiler implementation
	return ''
}

fn decode_int(root &C.cJSON) int {
	if isnil(root) {
		return 0
	}
	return root.valueint
}

fn decode_i8(root &C.cJSON) i8 {
	if isnil(root) {
		return i8(0)
	}
	return i8(root.valueint)
}

fn decode_i16(root &C.cJSON) i16 {
	if isnil(root) {
		return i16(0)
	}
	return i16(root.valueint)
}

fn decode_i64(root &C.cJSON) i64 {
	if isnil(root) {
		return i64(0)
	}
	return i64(root.valuedouble) // i64 is double in C
}

fn decode_byte(root &C.cJSON) byte {
	if isnil(root) {
		return byte(0)
	}
	return byte(root.valueint)
}

fn decode_u16(root &C.cJSON) u16 {
	if isnil(root) {
		return u16(0)
	}
	return u16(root.valueint)
}

fn decode_u32(root &C.cJSON) u32 {
	if isnil(root) {
		return u32(0)
	}
	return u32(root.valueint)
}

fn decode_u64(root &C.cJSON) u64 {
	if isnil(root) {
		return u64(0)
	}
	return u64(root.valueint)
}

fn decode_f32(root &C.cJSON) f32 {
	if isnil(root) {
		return f32(0)
	}
	return root.valuedouble
}

fn decode_f64(root &C.cJSON) f64 {
	if isnil(root) {
		return f64(0)
	}
	return f64(root.valuedouble)
}

fn decode_string(root &C.cJSON) string {
	if isnil(root) {
		return ''
	}
	if isnil(root.valuestring) {
		return ''
	}
	// println('decode string valuestring="$root.valuestring"')
	// return tos(root.valuestring, _strlen(root.valuestring))
	return tos_clone(root.valuestring) // , _strlen(root.valuestring))
}

fn C.cJSON_IsTrue() bool


fn C.cJSON_CreateNumber() &C.cJSON


fn C.cJSON_CreateBool() &C.cJSON


fn C.cJSON_CreateString() &C.cJSON


fn C.cJSON_Parse() &C.cJSON


fn C.cJSON_PrintUnformatted() byteptr


fn decode_bool(root &C.cJSON) bool {
	if isnil(root) {
		return false
	}
	return C.cJSON_IsTrue(root)
}

// ///////////////////
fn encode_int(val int) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_i8(val i8) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_i16(val i16) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_i64(val i64) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_byte(val byte) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_u16(val u16) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_u32(val u32) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_u64(val u64) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_f32(val f32) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_f64(val f64) &C.cJSON {
	return C.cJSON_CreateNumber(val)
}

fn encode_bool(val bool) &C.cJSON {
	return C.cJSON_CreateBool(val)
}

fn encode_string(val string) &C.cJSON {
	return C.cJSON_CreateString(val.str)
}
// ///////////////////////
// user := decode_User(json_parse(js_string_var))
fn json_parse(s string) &C.cJSON {
	return C.cJSON_Parse(s.str)
}

// json_string := json_print(encode_User(user))
fn json_print(json &C.cJSON) string {
	s := C.cJSON_PrintUnformatted(json)
	return tos(s, C.strlen(s))
}

// /  cjson wrappers
// fn json_array_for_each(val, root &C.cJSON) {
// #cJSON_ArrayForEach (val ,root)
// }
import json

struct Employee {
	name string
	age  int
}

fn test_simple() {
	x := Employee{'Peter', 28}
	s := json.encode(x)
	assert s == '{"name":"Peter","age":28}'
	y := json.decode(Employee, s) or {
		assert false
		Employee{}
	}
	assert y.name == 'Peter'
	assert y.age == 28
}

struct User2 {
	age  int
	nums []int
}

struct User {
	age           int
	nums          []int
	last_name     string [json:lastName]
	is_registered bool   [json:IsRegistered]
	typ           int    [json:'type']
	pets          string [raw; json:'pet_animals']
}

fn test_parse_user() {
	s := '{"age": 10, "nums": [1,2,3], "type": 1, "lastName": "Johnson", "IsRegistered": true, "pet_animals": {"name": "Bob", "animal": "Dog"}}'
	u2 := json.decode(User2, s) or {
		exit(1)
	}
	println(u2)
	u := json.decode(User, s) or {
		exit(1)
	}
	println(u)
	assert u.age == 10
	assert u.last_name == 'Johnson'
	assert u.is_registered == true
	assert u.nums.len == 3
	assert u.nums[0] == 1
	assert u.nums[1] == 2
	assert u.nums[2] == 3
	assert u.typ == 1
	assert u.pets == '{"name":"Bob","animal":"Dog"}'
}

fn test_encode_user() {
	usr := User{
		age: 10
		nums: [1, 2, 3]
		last_name: 'Johnson'
		is_registered: true
		typ: 0
		pets: 'foo'
	}
	expected := '{"age":10,"nums":[1,2,3],"lastName":"Johnson","IsRegistered":true,"type":0,"pet_animals":"foo"}'
	out := json.encode(usr)
	println(out)
	assert out == expected
}

struct Color {
	space string
	point string [raw]
}

fn test_raw_json_field() {
	color := json.decode(Color, '{"space": "YCbCr", "point": {"Y": 123}}') or {
		println('text')
		return
	}
	assert color.point == '{"Y":123}'
	assert color.space == 'YCbCr'
}

struct City {
	name string
}

struct Country {
	cities []City
	name   string
}

fn test_struct_in_struct() {
	country := json.decode(Country, '{ "name": "UK", "cities": [{"name":"London"}, {"name":"Manchester"}]}') or {
		assert false
		exit(1)
	}
	assert country.name == 'UK'
	assert country.cities.len == 2
	assert country.cities[0].name == 'London'
	assert country.cities[1].name == 'Manchester'
	println(country.cities)
}
module live

pub type FNLinkLiveSymbols = fn (linkcb voidptr)

pub type FNLiveReloadCB = fn (info &LiveReloadInfo)

pub struct LiveReloadInfo {
pub:
	vexe              string // full path to the v compiler
	vopts             string // v compiler options for a live shared library
	original          string // full path to the original source file, compiled with -live
	live_fn_mutex     voidptr // the address of the C mutex, that locks the [live] fns during reloads.
	live_linkfn       FNLinkLiveSymbols // generated C callback; receives a dlopen handle
	so_extension      string // .so or .dll
	so_name_template  string // a sprintf template for the shared libraries location
pub mut:
	live_lib          voidptr // the result of dl.open
	reloads           int // how many times a reloading was tried
	reloads_ok        int // how many times the reloads succeeded
	reload_time_ms    int // how much time the last reload took (compilation + loading)
	last_mod_ts       int // a timestamp for when the original was last changed
	recheck_period_ms int = 100 // how often do you want to check for changes
	cb_recheck        FNLiveReloadCB = 0 // executed periodically
	cb_compile_failed FNLiveReloadCB = 0 // executed when a reload compilation failed
	cb_before         FNLiveReloadCB = 0 // executed before a reload try happens
	cb_after          FNLiveReloadCB = 0 // executed after a reload try happened, even if failed
	cb_locked_before  FNLiveReloadCB = 0 // executed before lib reload, in the mutex section
	cb_locked_after   FNLiveReloadCB = 0 // executed after lib reload, in the mutex section
	user_ptr          voidptr = 0 // you can set it to anything, then retrieve it in the cb_ fns
}

// LiveReloadInfo.live_linkfn should be called by the reloader
// to dlsym all live functions. TODO: research a way to implement
// live_linkfn in pure V, without complicating live code generation
// too much.
//
// The callbacks: cb_compile_fail, cb_before, cb_after will be
// executed outside the mutex protected section, so be careful,
// if you modify your data inside them. They can race with your
// [live] functions.
//
// cb_locked_before and cb_locked_after will be executed *inside*
// the mutex protected section. They can NOT race with your [live]
// functions. They should be very quick in what they do though,
// otherwise your live functions can be delayed.
//
// live.info - give user access to program's LiveReloadInfo struct,
// so that the user can set callbacks, read meta information, etc.
pub fn info() &LiveReloadInfo {
	if C.g_live_info != 0 {
		return C.g_live_info
	}
	// When the current program is not compiled with -live, simply
	// return a new empty struct LiveReloadInfo in order to prevent
	// crashes. In this case, the background reloader thread is not
	// started, and the structure LiveReloadInfo will not get updated.
	// All its fields will be 0, but still safe to access.
	mut x := &LiveReloadInfo{}
	C.g_live_info = voidptr(x)
	return x
}
module executable

import os
import time
import dl
import strconv
import live

// The live reloader code is implemented here.

// NB: new_live_reload_info will be called by generated C code inside main()
pub fn new_live_reload_info(original string, vexe string, vopts string, live_fn_mutex voidptr, live_linkfn live.FNLinkLiveSymbols) &live.LiveReloadInfo {
	file_base := os.file_name(original).replace('.v', '')
	so_dir := os.cache_dir()
	so_extension := dl.dl_ext
	/* $if msvc { so_extension = '.dll' } $else { so_extension = '.so' } */
	return &live.LiveReloadInfo{
		original: original
		vexe: vexe
		vopts: vopts
		live_fn_mutex: live_fn_mutex
		live_linkfn: live_linkfn
		so_extension: so_extension
		so_name_template: '${so_dir}/tmp.%d.${file_base}'
		live_lib: 0
		reloads: 0
		reload_time_ms: 0
	}
}

// NB: start_reloader will be called by generated code inside main(), to start
// the hot code reloader thread. start_reloader is executed in the context of
// the original main thread.
pub fn start_reloader(r mut live.LiveReloadInfo) {
	// The shared library should be loaded once in the main thread
	// If that fails, the program would crash anyway, just provide
	// an error message to the user and exit:
    r.reloads++
	_ := compile_and_reload_shared_lib(r) or {
		eprintln( err )
		exit(1)
	}
	go reloader(r)
}

[if debuglive]
fn elog(r mut live.LiveReloadInfo, s string){
	eprintln(s)
}

fn compile_and_reload_shared_lib(r mut live.LiveReloadInfo) ?bool {
	sw := time.new_stopwatch()
	new_lib_path := compile_lib(r) or {
		return error('errors while compiling $r.original')
	}
	elog(r,'> compile_and_reload_shared_lib compiled: ${new_lib_path}')
	load_lib(r, new_lib_path )
	r.reload_time_ms = sw.elapsed().milliseconds()
	return true
}

fn compile_lib(r mut live.LiveReloadInfo) ?string {
	new_lib_path, new_lib_path_with_extension := current_shared_library_path(r)
	cmd := '$r.vexe $r.vopts -o $new_lib_path $r.original'
	elog(r,'>       compilation cmd: $cmd')
	cwatch := time.new_stopwatch()
	recompilation_result := os.exec( cmd ) or {
		eprintln('recompilation failed')
		return none
	}
	elog(r,'compilation took: ${cwatch.elapsed().milliseconds()}ms')
	if recompilation_result.exit_code != 0 {
		eprintln('recompilation error:')
		eprintln( recompilation_result.output )
		return none
	}
	if !os.exists( new_lib_path_with_extension ) {
		eprintln('new_lib_path: $new_lib_path_with_extension does not exist')
		return none
	}
	return new_lib_path_with_extension
}

fn current_shared_library_path(r mut live.LiveReloadInfo) (string, string) {
	lib_path := strconv.v_sprintf(r.so_name_template.replace('\\', '\\\\'), r.reloads)
	lib_path_with_extension := lib_path + r.so_extension
	return lib_path, lib_path_with_extension
}

fn load_lib(r mut live.LiveReloadInfo, new_lib_path string) {
	elog(r,'live mutex locking...')
	C.pthread_mutex_lock(r.live_fn_mutex)
	elog(r,'live mutex locked')
	//
	if r.cb_locked_before != 0 {
		r.cb_locked_before( r )
	}
	//
	protected_load_lib(r, new_lib_path)
	//
	r.reloads_ok++
	if r.cb_locked_after != 0 {
		r.cb_locked_after( r )
	}
	//
	elog(r,'live mutex unlocking...')
	C.pthread_mutex_unlock(r.live_fn_mutex)
	elog(r,'live mutex unlocked')
}

fn protected_load_lib(r mut live.LiveReloadInfo, new_lib_path string) {
	if r.live_lib != 0 {
		dl.close( r.live_lib )
		r.live_lib = 0
	}
	r.live_lib = dl.open(new_lib_path, dl.rtld_lazy)
	if r.live_lib == 0 {
		eprintln('opening $new_lib_path failed')
		exit(1)
	}
	r.live_linkfn( r.live_lib )
	elog(r,'> load_lib OK, new live_lib: $r.live_lib')
	// removing the .so file from the filesystem after dlopen-ing
    // it is safe, since it will still be mapped in memory
	os.rm( new_lib_path )
}

// NB: r.reloader() is executed in a new, independent thread
fn reloader(r mut live.LiveReloadInfo) {
//	elog(r,'reloader, r: $r')
	mut last_ts := os.file_last_mod_unix( r.original )
	for {
		if r.cb_recheck != 0 {
			r.cb_recheck( r )
		}
		now_ts := os.file_last_mod_unix( r.original )
		if last_ts != now_ts {
			r.reloads++
			last_ts = now_ts
			r.last_mod_ts = last_ts
			if r.cb_before != 0 {
				r.cb_before( r )
			}
			compile_and_reload_shared_lib(r) or {
				if r.cb_compile_failed != 0 {
					r.cb_compile_failed( r )
				}
				if r.cb_after != 0 {
					r.cb_after( r )
				}
				continue
			}
			if r.cb_after != 0 {
				r.cb_after( r )
			}
		}
		if r.recheck_period_ms > 0 {
			time.sleep_ms(r.recheck_period_ms)
		}
	}
}
module shared

import live
module log

import os
import time
import term

pub enum Level {
	fatal = 1
	error
	warn
	info
	debug
}

fn tag(l Level) string {
	return match l {
		.fatal { term.red('FATAL') }
		.error { term.red('ERROR') }
		.warn  { term.yellow('WARN ') }
		.info  { term.white('INFO ') }
		.debug { term.blue('DEBUG') }
	}
}

interface Logger {
	fatal(s string)
	error(s string)
	warn(s string)
	info(s string)
	debug(s string)
}

pub struct Log {
mut:
	level            Level
	output_label     string
	ofile            os.File
	output_to_file   bool
pub mut:
	output_file_name string
}

pub fn (mut l Log) set_level(level Level) {
	l.level = level
}

pub fn (mut l Log) set_output_level(level Level) {
	l.level = level
}

pub fn (mut l Log) set_full_logpath(full_log_path string) {
	rlog_file := os.real_path( full_log_path )
	l.set_output_label( os.file_name( rlog_file ) )
	l.set_output_path( os.base_dir( rlog_file ) )
}

pub fn (mut l Log) set_output_label(label string){
	l.output_label = label
}

pub fn (mut l Log) set_output_path(output_file_path string) {
	if l.ofile.is_opened() { l.ofile.close() }
	l.output_to_file = true
	l.output_file_name = os.join_path( os.real_path( output_file_path ) , l.output_label )
	ofile := os.open_append( l.output_file_name ) or {
		panic('error while opening log file ${l.output_file_name} for appending')
	}
	l.ofile = ofile
}

pub fn (mut l Log) close() {
  l.ofile.close()
}

fn (mut l Log) log_file(s string, level Level) {
	timestamp := time.now().format_ss()
	e := tag(level)
	l.ofile.writeln('$timestamp [$e] $s')
}

fn (l &Log) log_cli(s string, level Level) {
	f := tag(level)
	t := time.now()
	println('[$f ${t.format_ss()}] $s')
}

fn (mut l Log) send_output(s &string, level Level) {
	if l.output_to_file {
		l.log_file(s, level)
	} else {
		l.log_cli(s, level)
	}
}

pub fn (mut l Log) fatal(s string){
	if l.level < .fatal { return }
	l.send_output(s, .fatal)
	l.ofile.close()
	panic('$l.output_label: $s')
}

pub fn (mut l Log) error(s string) {
	if l.level < .error { return }
	l.send_output(s, .error)
}

pub fn (mut l Log) warn(s string) {
	if l.level < .warn { return }
	l.send_output(s, .warn)
}

pub fn (mut l Log) info(s string) {
	if l.level < .info { return }
	l.send_output(s, .info)
}

pub fn (mut l Log) debug(s string) {
	if l.level < .debug { return }
	l.send_output(s, .debug)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module math

const (
	uvnan = u64(0x7FF8000000000001)
	uvinf = u64(0x7FF0000000000000)
	uvneginf = u64(0xFFF0000000000000)
	uvone = u64(0x3FF0000000000000)
	mask = 0x7FF
	shift = 64 - 11 - 1
	bias = 1023
	sign_mask = (u64(1)<<63)
	frac_mask = ((u64(1)<<u64(shift)) - u64(1))
)
// inf returns positive infinity if sign >= 0, negative infinity if sign < 0.
pub fn inf(sign int) f64 {
	v := if sign >= 0 { uvinf } else { uvneginf }
	return f64_from_bits(v)
}

// nan returns an IEEE 754 ``not-a-number'' value.
pub fn nan() f64 {
	return f64_from_bits(uvnan)
}

// is_nan reports whether f is an IEEE 754 ``not-a-number'' value.
pub fn is_nan(f f64) bool {
	// IEEE 754 says that only NaNs satisfy f != f.
	// To avoid the floating-point hardware, could use:
	// x := f64_bits(f);
	// return u32(x>>shift)&mask == mask && x != uvinf && x != uvneginf
	return f != f
}

// is_inf reports whether f is an infinity, according to sign.
// If sign > 0, is_inf reports whether f is positive infinity.
// If sign < 0, is_inf reports whether f is negative infinity.
// If sign == 0, is_inf reports whether f is either infinity.
pub fn is_inf(f f64, sign int) bool {
	// Test for infinity by comparing against maximum float.
	// To avoid the floating-point hardware, could use:
	// x := f64_bits(f);
	// return sign >= 0 && x == uvinf || sign <= 0 && x == uvneginf;
	return (sign >= 0 && f > max_f64) || (sign <= 0 && f < -max_f64)
}

// NOTE: (joe-c) exponent notation is borked
// normalize returns a normal number y and exponent exp
// satisfying x == y  2**exp. It assumes x is finite and non-zero.
// pub fn normalize(x f64) (f64, int) {
// smallest_normal := 2.2250738585072014e-308 // 2**-1022
// if abs(x) < smallest_normal {
// return x * (1 << 52), -52
// }
// return x, 0
// }

// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module math

pub const (
	e = 2.71828182845904523536028747135266249775724709369995957496696763
	pi = 3.14159265358979323846264338327950288419716939937510582097494459
	phi = 1.61803398874989484820458683436563811772030917980576286213544862
	tau = 6.28318530717958647692528676655900576839433879875021164194988918
	sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974
	sqrt_e = 1.64872127070012814684865078781416357165377610071014801157507931
	sqrt_pi = 1.77245385090551602729816748334114518279754945612238712821380779
	sqrt_tau = 2.50662827463100050241576528481104525300698674060993831662992357
	sqrt_phi = 1.27201964951406896425242246173749149171560804184009624861664038
	ln2 = 0.693147180559945309417232121458176568075500134360255254120680009
	log2_e = 1.0 / ln2
	ln10 = 2.30258509299404568401799145468436420760110148862877297603332790
	log10_e = 1.0 / ln10
)
// Floating-point limit values
// max is the largest finite value representable by the type.
// smallest_non_zero is the smallest positive, non-zero value representable by the type.
pub const (
	max_f32 = 3.40282346638528859811704183484516925440e+38 // 2**127 * (2**24 - 1) / 2**23
	smallest_non_zero_f32 = 1.401298464324817070923729583289916131280e-45 // 1 / 2**(127 - 1 + 23)
	max_f64 = 1.797693134862315708145274237317043567981e+308 // 2**1023 * (2**53 - 1) / 2**52
	smallest_non_zero_f64 = 4.940656458412465441765687928682213723651e-324 // 1 / 2**(1023 - 1 + 52)
)
// Integer limit values
pub const (
	max_i8 = 127
	min_i8 = -128
	max_i16 = 32767
	min_i16 = -32768
	max_i32 = 2147483647
	min_i32 = -2147483648
	// -9223372036854775808 is wrong because C compilers parse litteral values
	// without sign first, and 9223372036854775808 overflows i64, hence the
	// consecutive subtraction by 1
	min_i64 = i64(-9223372036854775807 - 1)
	max_i64 = i64(9223372036854775807)
	max_u8 = 255
	max_u16 = 65535
	max_u32 = u32(4294967295)
	max_u64 = u64(18446744073709551615)
)

// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module math

#include <math.h>

fn C.acos(x f64) f64
fn C.asin(x f64) f64
fn C.atan(x f64) f64
fn C.atan2(y f64, x f64) f64
fn C.cbrt(x f64) f64
fn C.ceil(x f64) f64
fn C.cos(x f64) f64
fn C.cosf(x f32) f32
fn C.cosh(x f64) f64
fn C.erf(x f64) f64
fn C.erfc(x f64) f64
fn C.exp(x f64) f64
fn C.exp2(x f64) f64
fn C.fabs(x f64) f64
fn C.floor(x f64) f64
fn C.fmod(x f64, y f64) f64
fn C.hypot(x f64, y f64) f64
fn C.log(x f64) f64
fn C.log2(x f64) f64
fn C.log10(x f64) f64
fn C.lgamma(x f64) f64
fn C.pow(x f64, y f64) f64
fn C.powf(x f32, y f32) f32
fn C.round(x f64) f64
fn C.sin(x f64) f64
fn C.sinf(x f32) f32
fn C.sinh(x f64) f64
fn C.sqrt(x f64) f64
fn C.sqrtf(x f32) f32
fn C.tgamma(x f64) f64
fn C.tan(x f64) f64
fn C.tanf(x f32) f32
fn C.tanh(x f64) f64
fn C.trunc(x f64) f64

// NOTE
// When adding a new function, please make sure it's in the right place.
// All functions are sorted alphabetically.

// Returns the absolute value.
[inline]
pub fn abs(a f64) f64 {
	return C.fabs(a)
}

// acos calculates inverse cosine (arccosine).
[inline]
pub fn acos(a f64) f64 {
	return C.acos(a)
}

// asin calculates inverse sine (arcsine).
[inline]
pub fn asin(a f64) f64 {
	return C.asin(a)
}

// atan calculates inverse tangent (arctangent).
[inline]
pub fn atan(a f64) f64 {
	return C.atan(a)
}

// atan2 calculates inverse tangent with two arguments, returns the angle between the X axis and the point.
[inline]
pub fn atan2(a, b f64) f64 {
	return C.atan2(a, b)
}

// cbrt calculates cubic root.
[inline]
pub fn cbrt(a f64) f64 {
	return C.cbrt(a)
}

// ceil returns the nearest f64 greater or equal to the provided value.
[inline]
pub fn ceil(a f64) f64 {
	return C.ceil(a)
}

// cos calculates cosine.
[inline]
pub fn cos(a f64) f64 {
	return C.cos(a)
}

// cosf calculates cosine. (float32)
[inline]
pub fn cosf(a f32) f32 {
	return C.cosf(a)
}

// cosh calculates hyperbolic cosine.
[inline]
pub fn cosh(a f64) f64 {
	return C.cosh(a)
}

// exp calculates exponent of the number (math.pow(math.E, a)).
[inline]
pub fn exp(a f64) f64 {
	return C.exp(a)
}

// erf computes the error function value
[inline]
pub fn erf(a f64) f64 {
	return C.erf(a)
}

// erfc computes the complementary error function value
[inline]
pub fn erfc(a f64) f64 {
	return C.erfc(a)
}

// exp2 returns the base-2 exponential function of a (math.pow(2, a)).
[inline]
pub fn exp2(a f64) f64 {
	return C.exp2(a)
}

// floor returns the nearest f64 lower or equal of the provided value.
[inline]
pub fn floor(a f64) f64 {
	return C.floor(a)
}

// fmod returns the floating-point remainder of number / denom (rounded towards zero):
[inline]
pub fn fmod(a, b f64) f64 {
	return C.fmod(a, b)
}

// gamma computes the gamma function value
[inline]
pub fn gamma(a f64) f64 {
	return C.tgamma(a)
}

// Returns hypotenuse of a right triangle.
[inline]
pub fn hypot(a, b f64) f64 {
	return C.hypot(a, b)
}

// log calculates natural (base-e) logarithm of the provided value.
[inline]
pub fn log(a f64) f64 {
	return C.log(a)
}

// log2 calculates base-2 logarithm of the provided value.
[inline]
pub fn log2(a f64) f64 {
	return C.log2(a)
}

// log10 calculates the common (base-10) logarithm of the provided value.
[inline]
pub fn log10(a f64) f64 {
	return C.log10(a)
}

// log_gamma computes the log-gamma function value
[inline]
pub fn log_gamma(a f64) f64 {
	return C.lgamma(a)
}

// log_n calculates base-N logarithm of the provided value.
[inline]
pub fn log_n(a, b f64) f64 {
	return C.log(a) / C.log(b)
}

// pow returns base raised to the provided power.
[inline]
pub fn pow(a, b f64) f64 {
	return C.pow(a, b)
}

// powf returns base raised to the provided power. (float32)
[inline]
pub fn powf(a, b f32) f32 {
	return C.powf(a, b)
}

// round returns the integer nearest to the provided value.
[inline]
pub fn round(f f64) f64 {
	return C.round(f)
}

// sin calculates sine.
[inline]
pub fn sin(a f64) f64 {
	return C.sin(a)
}

// sinf calculates sine. (float32)
[inline]
pub fn sinf(a f32) f32 {
	return C.sinf(a)
}

// sinh calculates hyperbolic sine.
[inline]
pub fn sinh(a f64) f64 {
	return C.sinh(a)
}

// sqrt calculates square-root of the provided value.
[inline]
pub fn sqrt(a f64) f64 {
	return C.sqrt(a)
}

// sqrtf calculates square-root of the provided value. (float32)
[inline]
pub fn sqrtf(a f32) f32 {
	return C.sqrtf(a)
}

// tan calculates tangent.
[inline]
pub fn tan(a f64) f64 {
	return C.tan(a)
}

// tanf calculates tangent. (float32)
[inline]
pub fn tanf(a f32) f32 {
	return C.tanf(a)
}

// tanh calculates hyperbolic tangent.
[inline]
pub fn tanh(a f64) f64 {
	return C.tanh(a)
}

// trunc rounds a toward zero, returning the nearest integral value that is not
// larger in magnitude than a.
[inline]
pub fn trunc(a f64) f64 {
	return C.trunc(a)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module math

// TODO : The commented out functions need either a native V implementation, a
// JS specific implementation, or use some other JS math library, such as
// https://github.com/josdejong/mathjs
fn JS.Math.abs(x f64) f64 // Replaces C.fabs
fn JS.Math.acos(x f64) f64
fn JS.Math.asin(x f64) f64
fn JS.Math.atan(x f64) f64
fn JS.Math.atan2(y f64, x f64) f64
fn JS.Math.cbrt(x f64) f64
fn JS.Math.ceil(x f64) f64
fn JS.Math.cos(x f64) f64
fn JS.Math.cosh(x f64) f64
//fn JS.Math.erf(x f64) f64 // Not in standard JS Math object
//fn JS.Math.erfc(x f64) f64 // Not in standard JS Math object
fn JS.Math.exp(x f64) f64
//fn JS.Math.exp2(x f64) f64 // Not in standard JS Math object
fn JS.Math.floor(x f64) f64
//fn JS.Math.fmod(x f64, y f64) f64 // Not in standard JS Math object
//fn JS.Math.hypot(x f64, y f64) f64 // Not in standard JS Math object
fn JS.Math.log(x f64) f64
//fn JS.Math.log2(x f64) f64 // Not in standard JS Math object
//fn JS.Math.log10(x f64) f64 // Not in standard JS Math object
//fn JS.Math.lgamma(x f64) f64 // Not in standard JS Math object
fn JS.Math.pow(x f64, y f64) f64
fn JS.Math.round(x f64) f64
fn JS.Math.sin(x f64) f64
fn JS.Math.sinh(x f64) f64
fn JS.Math.sqrt(x f64) f64
//fn JS.Math.tgamma(x f64) f64 // Not in standard JS Math object
fn JS.Math.tan(x f64) f64
fn JS.Math.tanh(x f64) f64
fn JS.Math.trunc(x f64) f64

// NOTE
// When adding a new function, please make sure it's in the right place.
// All functions are sorted alphabetically.

// Returns the absolute value.
[inline]
pub fn abs(a f64) f64 {
	return JS.Math.abs(a)
}

// acos calculates inverse cosine (arccosine).
[inline]
pub fn acos(a f64) f64 {
	return JS.Math.acos(a)
}

// asin calculates inverse sine (arcsine).
[inline]
pub fn asin(a f64) f64 {
	return JS.Math.asin(a)
}

// atan calculates inverse tangent (arctangent).
[inline]
pub fn atan(a f64) f64 {
	return JS.Math.atan(a)
}

// atan2 calculates inverse tangent with two arguments, returns the angle between the X axis and the point.
[inline]
pub fn atan2(a, b f64) f64 {
	return JS.Math.atan2(a, b)
}

// cbrt calculates cubic root.
[inline]
pub fn cbrt(a f64) f64 {
	return JS.Math.cbrt(a)
}

// ceil returns the nearest f64 greater or equal to the provided value.
[inline]
pub fn ceil(a f64) f64 {
	return JS.Math.ceil(a)
}

// cos calculates cosine.
[inline]
pub fn cos(a f64) f64 {
	return JS.Math.cos(a)
}

// cosf calculates cosine. (float32). This doesn't exist in JS
[inline]
pub fn cosf(a f32) f32 {
	return f32(JS.Math.cos(a))
}

// cosh calculates hyperbolic cosine.
[inline]
pub fn cosh(a f64) f64 {
	return JS.Math.cosh(a)
}

// exp calculates exponent of the number (math.pow(math.E, a)).
[inline]
pub fn exp(a f64) f64 {
	return JS.Math.exp(a)
}

// erf computes the error function value
[inline]
pub fn erf(a f64) f64 {
	return JS.Math.erf(a)
}

// erfc computes the complementary error function value
[inline]
pub fn erfc(a f64) f64 {
	return JS.Math.erfc(a)
}

// exp2 returns the base-2 exponential function of a (math.pow(2, a)).
[inline]
pub fn exp2(a f64) f64 {
	return JS.Math.exp2(a)
}

// floor returns the nearest f64 lower or equal of the provided value.
[inline]
pub fn floor(a f64) f64 {
	return JS.Math.floor(a)
}

// fmod returns the floating-point remainder of number / denom (rounded towards zero):
[inline]
pub fn fmod(a, b f64) f64 {
	return JS.Math.fmod(a, b)
}

// gamma computes the gamma function value
[inline]
pub fn gamma(a f64) f64 {
	return JS.Math.tgamma(a)
}

// Returns hypotenuse of a right triangle.
[inline]
pub fn hypot(a, b f64) f64 {
	return JS.Math.hypot(a, b)
}

// log calculates natural (base-e) logarithm of the provided value.
[inline]
pub fn log(a f64) f64 {
	return JS.Math.log(a)
}

// log2 calculates base-2 logarithm of the provided value.
[inline]
pub fn log2(a f64) f64 {
	return JS.Math.log2(a)
}

// log10 calculates the common (base-10) logarithm of the provided value.
[inline]
pub fn log10(a f64) f64 {
	return JS.Math.log10(a)
}

// log_gamma computes the log-gamma function value
[inline]
pub fn log_gamma(a f64) f64 {
	return JS.Math.lgamma(a)
}

// log_n calculates base-N logarithm of the provided value.
[inline]
pub fn log_n(a, b f64) f64 {
	return JS.Math.log(a) / JS.Math.log(b)
}

// pow returns base raised to the provided power.
[inline]
pub fn pow(a, b f64) f64 {
	return JS.Math.pow(a, b)
}

// powf returns base raised to the provided power. (float32)
[inline]
pub fn powf(a, b f32) f32 {
	return f32(JS.Math.pow(a, b))
}

// round returns the integer nearest to the provided value.
[inline]
pub fn round(f f64) f64 {
	return JS.Math.round(f)
}

// sin calculates sine.
[inline]
pub fn sin(a f64) f64 {
	return JS.Math.sin(a)
}

// sinf calculates sine. (float32)
[inline]
pub fn sinf(a f32) f32 {
	return f32(JS.Math.sin(a))
}

// sinh calculates hyperbolic sine.
[inline]
pub fn sinh(a f64) f64 {
	return JS.Math.sinh(a)
}

// sqrt calculates square-root of the provided value.
[inline]
pub fn sqrt(a f64) f64 {
	return JS.Math.sqrt(a)
}

// sqrtf calculates square-root of the provided value. (float32)
[inline]
pub fn sqrtf(a f32) f32 {
	return f32(JS.Math.sqrt(a))
}

// tan calculates tangent.
[inline]
pub fn tan(a f64) f64 {
	return JS.Math.tan(a)
}

// tanf calculates tangent. (float32)
[inline]
pub fn tanf(a f32) f32 {
	return f32(JS.Math.tan(a))
}

// tanh calculates hyperbolic tangent.
[inline]
pub fn tanh(a f64) f64 {
	return JS.Math.tanh(a)
}

// trunc rounds a toward zero, returning the nearest integral value that is not
// larger in magnitude than a.
[inline]
pub fn trunc(a f64) f64 {
	return JS.Math.trunc(a)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module math

// NOTE
// When adding a new function, please make sure it's in the right place.
// All functions are sorted alphabetically, separated by wrapped functions vs
// backend specific functions.
// If using System/Backend dependent functions, put them in their respective
// .c.v or .js.v or other files

// Below are functions that are not wrappers for built-in system functions, but
// native V functions. They are still sorted alphabetically

// Faster approximate sin() and cos() implemented from lolremez
pub fn aprox_sin(a f64) f64 {
	a0 := 1.91059300966915117e-31
	a1 := 1.00086760103908896
	a2 := -1.21276126894734565e-2
	a3 := -1.38078780785773762e-1
	a4 := -2.67353392911981221e-2
	a5 := 2.08026600266304389e-2
	a6 := -3.03996055049204407e-3
	a7 := 1.38235642404333740e-4
	return a0 + a * (a1 + a * (a2 + a * (a3 + a * (a4 + a * (a5 + a * (a6 + a * a7))))))
}

pub fn aprox_cos(a f64) f64 {
	a0 := 9.9995999154986614e-1
	a1 := 1.2548995793001028e-3
	a2 := -5.0648546280678015e-1
	a3 := 1.2942246466519995e-2
	a4 := 2.8668384702547972e-2
	a5 := 7.3726485210586547e-3
	a6 := -3.8510875386947414e-3
	a7 := 4.7196604604366623e-4
	a8 := -1.8776444013090451e-5
	return a0 + a * (a1 + a * (a2 + a * (a3 + a * (a4 + a * (a5 + a * (a6 + a * (a7 + a * a8)))))))
}

// copysign returns a value with the magnitude of x and the sign of y
pub fn copysign(x, y f64) f64 {
	return f64_from_bits((f64_bits(x) & ~sign_mask) | (f64_bits(y) & sign_mask))
}

// degrees convert from degrees to radians.
pub fn degrees(radians f64) f64 {
	return radians * (180.0 / pi)
}

// digits returns an array of the digits of n in the given base.
pub fn digits(_n, base int) []int {
	if base < 2 {
		panic('digits: Cannot find digits of n with base $base')
	}
	mut n := _n
	mut sign := 1
	if n < 0 {
		sign = -1
		n = -n
	}
	mut res := []int{}
	for n != 0 {
		res << (n % base) * sign
		n /= base
	}
	return res
}

pub fn fabs(x f64) f64 {
	if x < 0.0 {
		return -x
	}
	return x
}

// gcd calculates greatest common (positive) divisor (or zero if a and b are both zero).
pub fn gcd(a_, b_ i64) i64 {
	mut a := a_
	mut b := b_
	if a < 0 {
		a = -a
	}
	if b < 0 {
		b = -b
	}
	for b != 0 {
		a %= b
		if a == 0 {
			return b
		}
		b %= a
	}
	return a
}

// lcm calculates least common (non-negative) multiple.
pub fn lcm(a, b i64) i64 {
	if a == 0 {
		return a
	}
	res := a * (b / gcd(b, a))
	if res < 0 {
		return -res
	}
	return res
}

// max returns the maximum value of the two provided.
pub fn max(a, b f64) f64 {
	if a > b {
		return a
	}
	return b
}

// min returns the minimum value of the two provided.
pub fn min(a, b f64) f64 {
	if a < b {
		return a
	}
	return b
}

// radians convert from radians to degrees.
pub fn radians(degrees f64) f64 {
	return degrees * (pi / 180.0)
}
module math

fn tst_res(str1 string, str2 string) bool {
	if (math.abs(str1.f64() - str2.f64())) < 1e-5 {
		return true
	}
	return false
}

fn test_gcd() {
	assert gcd(6, 9) == 3
	assert gcd(6, -9) == 3
	assert gcd(-6, -9) == 3
	assert gcd(0, 0) == 0
}

fn test_lcm() {
	assert lcm(2, 3) == 6
	assert lcm(-2, 3) == 6
	assert lcm(-2, -3) == 6
	assert lcm(0, 0) == 0
}

fn test_digits() {
	digits_in_10th_base := digits(125, 10)
	assert digits_in_10th_base[0] == 5
	assert digits_in_10th_base[1] == 2
	assert digits_in_10th_base[2] == 1

	digits_in_16th_base := digits(15, 16)
	assert digits_in_16th_base[0] == 15

	negative_digits := digits(-4, 2)
	assert negative_digits[2] == -1
}

fn test_erf() {
	assert erf(0) == 0
	assert erf(1.5) + erf(-1.5) == 0
	assert erfc(0) == 1
	assert erf(2.5) + erfc(2.5) == 1
	assert erfc(3.6) + erfc(-3.6) == 2
}

fn test_gamma() {
	assert gamma(1) == 1
	assert gamma(5) == 24
	sval := '2.453737'
	assert tst_res(log_gamma(4.5).str(), sval) 
	assert tst_res(log(gamma(4.5)).str(), sval) 
	//assert log_gamma(4.5).str() == sval
	//assert log(gamma(4.5)).str() == sval
	assert abs( log_gamma(4.5) - log(gamma(4.5)) ) < 0.000001
	// assert log_gamma(4.5) == log(gamma(4.5)) /* <-- fails on alpine/musl
}

fn test_mod() {
	assert 4 % 2 == 0
	x := u64(2)
	assert u64(5) % x == 1
	mut a := 10
	a %= 2
	assert a == 0
}

fn test_copysign() {
	assert copysign(5, -7) == -5.0
	assert copysign(-5, 7) == 5.0
	assert copysign(-5, -7) == -5.0
	assert copysign(10, 0) == 10.0
	assert copysign(10, 10) == 10.0
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module math
// f32_bits returns the IEEE 754 binary representation of f,
// with the sign bit of f and the result in the same bit position.
// f32_bits(f32_from_bits(x)) == x.
pub fn f32_bits(f f32) u32 {
	p := &u32(&f)
	return p
}

// f32_from_bits returns the floating-point number corresponding
// to the IEEE 754 binary representation b, with the sign bit of b
// and the result in the same bit position.
// f32_from_bits(f32_bits(x)) == x.
pub fn f32_from_bits(b u32) f32 {
	p := &f32(&b)
	return p
}

// f64_bits returns the IEEE 754 binary representation of f,
// with the sign bit of f and the result in the same bit position,
// and f64_bits(f64_from_bits(x)) == x.
pub fn f64_bits(f f64) u64 {
	p := &u64(&f)
	return p
}

// f64_from_bits returns the floating-point number corresponding
// to the IEEE 754 binary representation b, with the sign bit of b
// and the result in the same bit position.
// f64_from_bits(f64_bits(x)) == x.
pub fn f64_from_bits(b u64) f64 {
	p := &f64(&b)
	return p
}

module big

// Wrapper for https://github.com/kokke/tiny-bignum-c

#flag -I @VROOT/thirdparty/bignum
#flag @VROOT/thirdparty/bignum/bn.o
#include "bn.h"

[typedef]
struct C.bn {
	array [32]u32
}

type Number = C.bn

fn C.bignum_init( n &Number )
fn C.bignum_from_int( n &Number, i u64 )
fn C.bignum_to_int( n &Number ) int
fn C.bignum_from_string( n &Number, s byteptr, nbytes int)
fn C.bignum_to_string( n &Number, s byteptr, maxsize int)

fn C.bignum_add( a &Number, b &Number, c &Number) // c = a + b
fn C.bignum_sub( a &Number, b &Number, c &Number) // c = a - b
fn C.bignum_mul( a &Number, b &Number, c &Number) // c = a * b
fn C.bignum_div( a &Number, b &Number, c &Number) // c = a / b
fn C.bignum_mod( a &Number, b &Number, c &Number) // c = a % b
fn C.bignum_divmod( a &Number, b &Number, c &Number, d &Number)  // c = a/b d=a%b

fn C.bignum_and( a &Number, b &Number, c &Number) // c = a & b
fn C.bignum_or( a &Number, b &Number, c &Number)  // c = a | b
fn C.bignum_xor( a &Number, b &Number, c &Number) // c = a xor b
fn C.bignum_lshift( a &Number, b &Number, nbits int) // b = a << nbits
fn C.bignum_rshift( a &Number, b &Number, nbits int) // b = a >> nbits

fn C.bignum_cmp( a &Number, b &Number) int
fn C.bignum_is_zero( a &Number) int
fn C.bignum_inc(n &Number)
fn C.bignum_dec(n &Number)
fn C.bignum_pow( a &Number, b &Number, c &Number) // c = a ^ b
fn C.bignum_isqrt( a &Number, b &Number) // b = integer_square_root_of(a)
fn C.bignum_assign( dst &Number, src &Number) // copy src number to dst number

////////////////////////////////////////////////////////////
// conversion actions to/from big numbers:
pub fn new() Number {
	return Number{}
}
pub fn from_int(i int) Number {
	n := Number{}
	C.bignum_from_int( &n, i)
	return n
}

pub fn from_u64(u u64) Number {
	n := Number{}
	C.bignum_from_int( &n, u)
	return n
}
pub fn from_string(s string) Number {
	n := Number{}
	C.bignum_from_string(&n, s.str, s.len)
	return n
}

pub fn (n Number) int() int {
	r := C.bignum_to_int(&n)
	return r
}

pub fn (n Number) str() string {
	// TODO: return a decimal representation of the bignumber n.
	// A decimal representation will be easier to use in the repl
	// but will be slower to calculate. Also, it is not implemented
	// in the bn library.
	return 'Number (in hex): ' + n.hexstr()
}

pub fn (n Number) hexstr() string {
	mut buf := [8192]byte
	C.bignum_to_string( &n, buf, 8192)
	// NB: bignum_to_string , returns the HEXADECIMAL representation of the bignum n
	s := tos_clone( buf )
	if s.len == 0 { return '0' }
	return s
}
////////////////////////////////////////////////////////////
// overloaded ops for the numbers:
pub fn (a Number) + (b Number) Number {
	c := Number{}
	C.bignum_add(&a, &b, &c)
	return c
}

pub fn (a Number) - (b Number) Number {
	c := Number{}
	C.bignum_sub(&a, &b, &c)
	return c
}

pub fn (a Number) * (b Number) Number {
	c := Number{}
	C.bignum_mul(&a, &b, &c)
	return c
}

pub fn (a Number) / (b Number) Number {
	c := Number{}
	C.bignum_div(&a, &b, &c)
	return c
}

pub fn (a Number) % (b Number) Number {
	c := Number{}
	C.bignum_mod(&a, &b, &c)
	return c
}

pub fn divmod( a &Number, b &Number, c &Number) Number {
	d := Number{}
	C.bignum_divmod( a, b, c, &d)
	return d
}
////////////////////////////////////////////////////////////
pub fn cmp(a Number, b Number) int {
	return C.bignum_cmp(&a,&b)
}
pub fn (a Number) is_zero() bool {
	return C.bignum_is_zero(&a) != 0
}
pub fn (mut a Number) inc() {
	C.bignum_inc(a)
}
pub fn (mut a Number) dec() {
	C.bignum_dec(a)
}
pub fn pow(a Number, b Number) Number {
	c := Number{}
	C.bignum_pow(&a,&b,&c)
	return c
}
pub fn (a Number) isqrt() Number {
	b := Number{}
	C.bignum_isqrt(&a,&b)
	return b
}
////////////////////////////////////////////////////////////
pub fn b_and(a Number, b Number) Number {
	c := Number{}
	C.bignum_and(&a,&b,&c)
	return c
}
pub fn b_or(a Number, b Number) Number {
	c := Number{}
	C.bignum_or(&a,&b,&c)
	return c
}
pub fn b_xor(a Number, b Number) Number {
	c := Number{}
	C.bignum_xor(&a,&b,&c)
	return c
}
pub fn (a Number) lshift(nbits int) Number {
	b := Number{}
	C.bignum_lshift(&a,&b,nbits)
	return b
}
pub fn (a Number) rshift(nbits int) Number {
	b := Number{}
	C.bignum_rshift(&a,&b,nbits)
	return b
}
pub fn (a Number) clone() Number {
	b := Number{}
	C.bignum_assign(&b,&a)
	return b
}
////////////////////////////////////////////////////////////
pub fn factorial(nn Number) Number {
	mut n := nn.clone()
	mut a := nn.clone()
	n.dec()
	mut i:=1
	for !n.is_zero() {
		res := a * n
		n.dec()
		a = res
		i++
	}
	return a
}

pub fn fact(n int) Number {
	return factorial( from_int(n) )
}
import big

fn test_new_big(){
	n := big.new()
	assert sizeof( big.Number ) == 128
	assert n.hexstr() == '0'
}

fn test_from_int(){
	assert big.from_int(255).hexstr() == 'ff'
	assert big.from_int(127).hexstr() == '7f'
	assert big.from_int(1024).hexstr() == '400'
	assert big.from_int(2147483647).hexstr() == '7fffffff'
	assert big.from_int(-1).hexstr() == 'ffffffffffffffff'
}

fn test_from_u64(){
	assert big.from_u64(255).hexstr() == 'ff'
	assert big.from_u64(127).hexstr() == '7f'
	assert big.from_u64(1024).hexstr() == '400'
	assert big.from_u64(4294967295).hexstr() == 'ffffffff'
	assert big.from_u64(4398046511104).hexstr() == '40000000000'
	assert big.from_u64(-1).hexstr() == 'ffffffffffffffff'
}

fn test_plus(){
	a := big.from_u64(2)
	b := big.from_u64(3)
	c := a + b
	assert c.hexstr() == '5'
	assert (big.from_u64(1024) + big.from_u64(1024)).hexstr() == '800'
}

fn test_minus(){
	a := big.from_u64(2)
	b := big.from_u64(3)
	c := b - a
	assert c.hexstr() == '1'
	e := big.from_u64(1024)
	ee := e - e
	assert ee.hexstr() == '0'
}

fn test_divide(){
	a := big.from_u64(2)
	b := big.from_u64(3)
	c := b / a
	assert c.hexstr() == '1'
	assert (b % a ).hexstr() == '1'
	e := big.from_u64(1024) // dec(1024) == hex(0x400)
	ee := e / e
	assert ee.hexstr() == '1'
	assert (e / a).hexstr() == '200'
	assert (e / (a*a)).hexstr() == '100'
}

fn test_multiply(){
	a := big.from_u64(2)
	b := big.from_u64(3)
	c := b * a
	assert c.hexstr() == '6'
	e := big.from_u64(1024)
	e2 := e * e
	e4 := e2 * e2
	e8 := e2 * e2 * e2 * e2
	e9 := e8 + big.from_u64(1)
	d  := ((e9 * e9) + b) * c
	assert e4.hexstr() == '10000000000'
	assert e8.hexstr() == '100000000000000000000'
	assert e9.hexstr() == '100000000000000000001'
	assert d.hexstr() == '60000000000000000000c00000000000000000018'
}

fn test_mod(){
	assert (big.from_u64(13) % big.from_u64(10) ).int() == 3
	assert (big.from_u64(13) % big.from_u64(9) ).int()  == 4
	assert (big.from_u64(7) % big.from_u64(5) ).int() == 2
}


fn test_factorial(){
	f5 := big.factorial( big.from_u64(5) )
	assert f5.hexstr() == '78'
	f100 := big.factorial( big.from_u64(100) )
	assert f100.hexstr() == '1b30964ec395dc24069528d54bbda40d16e966ef9a70eb21b5b2943a321cdf10391745570cca9420c6ecb3b72ed2ee8b02ea2735c61a000000000000000000000000'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module bits

const (
// See http://supertech.csail.mit.edu/papers/debruijn.pdf
	de_bruijn32 = u32(0x077CB531)
	de_bruijn32tab = [byte(0), 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
	31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9,
	]
	de_bruijn64 = u64(0x03f79d71b4ca8b09)
	de_bruijn64tab = [byte(0), 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4,
	62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5,
	63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11,
	54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6,
	]
)

const (
	m0 = u64(0x5555555555555555) // 01010101 ...
	m1 = u64(0x3333333333333333) // 00110011 ...
	m2 = u64(0x0f0f0f0f0f0f0f0f) // 00001111 ...
	m3 = u64(0x00ff00ff00ff00ff) // etc.
	m4 = u64(0x0000ffff0000ffff)
)

const (
	// save importing math mod just for these
	max_u32 = u32(4294967295)
	max_u64 = u64(18446744073709551615)
)

// --- LeadingZeros ---
// leading_zeros_8 returns the number of leading zero bits in x; the result is 8 for x == 0.
pub fn leading_zeros_8(x byte) int {
	return 8 - len_8(x)
}

// leading_zeros_16 returns the number of leading zero bits in x; the result is 16 for x == 0.
pub fn leading_zeros_16(x u16) int {
	return 16 - len_16(x)
}

// leading_zeros_32 returns the number of leading zero bits in x; the result is 32 for x == 0.
pub fn leading_zeros_32(x u32) int {
	return 32 - len_32(x)
}

// leading_zeros_64 returns the number of leading zero bits in x; the result is 64 for x == 0.
pub fn leading_zeros_64(x u64) int {
	return 64 - len_64(x)
}

// --- TrailingZeros ---
// trailing_zeros_8 returns the number of trailing zero bits in x; the result is 8 for x == 0.
pub fn trailing_zeros_8(x byte) int {
	return int(ntz_8_tab[x])
}

// trailing_zeros_16 returns the number of trailing zero bits in x; the result is 16 for x == 0.
pub fn trailing_zeros_16(x u16) int {
	if x == 0 {
		return 16
	}
	// see comment in trailing_zeros_64
	return int(de_bruijn32tab[u32(x & -x) * de_bruijn32>>(32 - 5)])
}

// trailing_zeros_32 returns the number of trailing zero bits in x; the result is 32 for x == 0.
pub fn trailing_zeros_32(x u32) int {
	if x == 0 {
		return 32
	}
	// see comment in trailing_zeros_64
	return int(de_bruijn32tab[(x & -x) * de_bruijn32>>(32 - 5)])
}

// trailing_zeros_64 returns the number of trailing zero bits in x; the result is 64 for x == 0.
pub fn trailing_zeros_64(x u64) int {
	if x == 0 {
		return 64
	}
	// If popcount is fast, replace code below with return popcount(^x & (x - 1)).
	//
	// x & -x leaves only the right-most bit set in the word. Let k be the
	// index of that bit. Since only a single bit is set, the value is two
	// to the power of k. Multiplying by a power of two is equivalent to
	// left shifting, in this case by k bits. The de Bruijn (64 bit) constant
	// is such that all six bit, consecutive substrings are distinct.
	// Therefore, if we have a left shifted version of this constant we can
	// find by how many bits it was shifted by looking at which six bit
	// substring ended up at the top of the word.
	// (Knuth, volume 4, section 7.3.1)
	return int(de_bruijn64tab[(x & -x) * de_bruijn64>>(64 - 6)])
}

// --- OnesCount ---

// ones_count_8 returns the number of one bits ("population count") in x.
pub fn ones_count_8(x byte) int {
	return int(pop_8_tab[x])
}

// ones_count_16 returns the number of one bits ("population count") in x.
pub fn ones_count_16(x u16) int {
	return int(pop_8_tab[x>>8] + pop_8_tab[x & u16(0xff)])
}

// ones_count_32 returns the number of one bits ("population count") in x.
pub fn ones_count_32(x u32) int {
	return int(pop_8_tab[x>>24] + pop_8_tab[x>>16 & 0xff] + pop_8_tab[x>>8 & 0xff] + pop_8_tab[x & u32(0xff)])
}

// ones_count_64 returns the number of one bits ("population count") in x.
pub fn ones_count_64(x u64) int {
	// Implementation: Parallel summing of adjacent bits.
	// See "Hacker's Delight", Chap. 5: Counting Bits.
	// The following pattern shows the general approach:
	//
	// x = x>>1&(m0&m) + x&(m0&m)
	// x = x>>2&(m1&m) + x&(m1&m)
	// x = x>>4&(m2&m) + x&(m2&m)
	// x = x>>8&(m3&m) + x&(m3&m)
	// x = x>>16&(m4&m) + x&(m4&m)
	// x = x>>32&(m5&m) + x&(m5&m)
	// return int(x)
	//
	// Masking (& operations) can be left away when there's no
	// danger that a field's sum will carry over into the next
	// field: Since the result cannot be > 64, 8 bits is enough
	// and we can ignore the masks for the shifts by 8 and up.
	// Per "Hacker's Delight", the first line can be simplified
	// more, but it saves at best one instruction, so we leave
	// it alone for clarity.
	mut y := (x>>u64(1) & (m0 & max_u64)) + (x & (m0 & max_u64))
	y = (y>>u64(2) & (m1 & max_u64)) + (y & (m1 & max_u64))
	y = ((y>>4) + y) & (m2 & max_u64)
	y += y>>8
	y += y>>16
	y += y>>32
	return int(y) & ((1<<7) - 1)
}

// --- RotateLeft ---

// rotate_left_8 returns the value of x rotated left by (k mod 8) bits.
// To rotate x right by k bits, call rotate_left_8(x, -k).
//
// This function's execution time does not depend on the inputs.
[inline]
pub fn rotate_left_8(x byte, k int) byte {
	n := byte(8)
	s := byte(k) & (n - byte(1))
	return ((x<<s) | (x>>(n - s)))
}

// rotate_left_16 returns the value of x rotated left by (k mod 16) bits.
// To rotate x right by k bits, call rotate_left_16(x, -k).
//
// This function's execution time does not depend on the inputs.
[inline]
pub fn rotate_left_16(x u16, k int) u16 {
	n := u16(16)
	s := u16(k) & (n - u16(1))
	return ((x<<s) | (x>>(n - s)))
}

// rotate_left_32 returns the value of x rotated left by (k mod 32) bits.
// To rotate x right by k bits, call rotate_left_32(x, -k).
//
// This function's execution time does not depend on the inputs.
[inline]
pub fn rotate_left_32(x u32, k int) u32 {
	n := u32(32)
	s := u32(k) & (n - u32(1))
	return ((x<<s) | (x>>(n - s)))
}

// rotate_left_64 returns the value of x rotated left by (k mod 64) bits.
// To rotate x right by k bits, call rotate_left_64(x, -k).
//
// This function's execution time does not depend on the inputs.
[inline]
pub fn rotate_left_64(x u64, k int) u64 {
	n := u64(64)
	s := u64(k) & (n - u64(1))
	return ((x<<s) | (x>>(n - s)))
}

// --- Reverse ---

// reverse_8 returns the value of x with its bits in reversed order.
[inline]
pub fn reverse_8(x byte) byte {
	return rev_8_tab[x]
}

// reverse_16 returns the value of x with its bits in reversed order.
[inline]
pub fn reverse_16(x u16) u16 {
	return u16(rev_8_tab[x>>8]) | (u16(rev_8_tab[x & u16(0xff)])<<8)
}

// reverse_32 returns the value of x with its bits in reversed order.
[inline]
pub fn reverse_32(x u32) u32 {
	mut y := ((x>>u32(1) & (m0 & max_u32)) | ((x & (m0 & max_u32))<<1))
	y = ((y>>u32(2) & (m1 & max_u32)) | ((y & (m1 & max_u32))<<u32(2)))
	y = ((y>>u32(4) & (m2 & max_u32)) | ((y & (m2 & max_u32))<<u32(4)))
	return reverse_bytes_32(y)
}

// reverse_64 returns the value of x with its bits in reversed order.
[inline]
pub fn reverse_64(x u64) u64 {
	mut y := ((x>>u64(1) & (m0 & max_u64)) | ((x & (m0 & max_u64))<<1))
	y = ((y>>u64(2) & (m1 & max_u64)) | ((y & (m1 & max_u64))<<2))
	y = ((y>>u64(4) & (m2 & max_u64)) | ((y & (m2 & max_u64))<<4))
	return reverse_bytes_64(y)
}

// --- ReverseBytes ---

// reverse_bytes_16 returns the value of x with its bytes in reversed order.
//
// This function's execution time does not depend on the inputs.
[inline]
pub fn reverse_bytes_16(x u16) u16 {
	return (x>>8) | (x<<8)
}

// reverse_bytes_32 returns the value of x with its bytes in reversed order.
//
// This function's execution time does not depend on the inputs.
[inline]
pub fn reverse_bytes_32(x u32) u32 {
	y := ((x>>u32(8) & (m3 & max_u32)) | ((x & (m3 & max_u32))<<u32(8)))
	return (y>>16) | (y<<16)
}

// reverse_bytes_64 returns the value of x with its bytes in reversed order.
//
// This function's execution time does not depend on the inputs.
[inline]
pub fn reverse_bytes_64(x u64) u64 {
	mut y := ((x>>u64(8) & (m3 & max_u64)) | ((x & (m3 & max_u64))<<u64(8)))
	y = ((y>>u64(16) & (m4 & max_u64)) | ((y & (m4 & max_u64))<<u64(16)))
	return (y>>32) | (y<<32)
}

// --- Len ---

// len_8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
pub fn len_8(x byte) int {
	return int(len_8_tab[x])
}

// len_16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
pub fn len_16(x u16) int {
	mut y := x
	mut n := 0
	if y >= 1<<8 {
		y >>= 8
		n = 8
	}
	return n + int(len_8_tab[y])
}

// len_32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
pub fn len_32(x u32) int {
	mut y := x
	mut n := 0
	if y >= (1<<16) {
		y >>= 16
		n = 16
	}
	if y >= (1<<8) {
		y >>= 8
		n += 8
	}
	return n + int(len_8_tab[y])
}

// len_64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
pub fn len_64(x u64) int {
	mut y := x
	mut n := 0
	if y >= u64(1)<<u64(32) {
		y >>= 32
		n = 32
	}
	if y >= u64(1)<<u64(16) {
		y >>= 16
		n += 16
	}
	if y >= u64(1)<<u64(8) {
		y >>= 8
		n += 8
	}
	return n + int(len_8_tab[y])
}

// --- Add with carry ---

// Add returns the sum with carry of x, y and carry: sum = x + y + carry.
// The carry input must be 0 or 1; otherwise the behavior is undefined.
// The carryOut output is guaranteed to be 0 or 1.
//

// add_32 returns the sum with carry of x, y and carry: sum = x + y + carry.
// The carry input must be 0 or 1; otherwise the behavior is undefined.
// The carryOut output is guaranteed to be 0 or 1.
//
// This function's execution time does not depend on the inputs.
pub fn add_32(x u32, y u32, carry u32) (u32, u32) {
	sum64 := u64(x) + u64(y) + u64(carry)
	sum := u32(sum64)
	carry_out := u32(sum64>>32)
	return sum, carry_out
}

// add_64 returns the sum with carry of x, y and carry: sum = x + y + carry.
// The carry input must be 0 or 1; otherwise the behavior is undefined.
// The carryOut output is guaranteed to be 0 or 1.
//
// This function's execution time does not depend on the inputs.
pub fn add_64(x u64, y u64, carry u64) (u64, u64) {
	sum := x + y + carry
	// The sum will overflow if both top bits are set (x & y) or if one of them
	// is (x | y), and a carry from the lower place happened. If such a carry
	// happens, the top bit will be 1 + 0 + 1 = 0 (&^ sum).
	carry_out := ((x & y) | ((x | y) & ~sum ))>>63
	return sum, carry_out
}

// --- Subtract with borrow ---

// Sub returns the difference of x, y and borrow: diff = x - y - borrow.
// The borrow input must be 0 or 1; otherwise the behavior is undefined.
// The borrowOut output is guaranteed to be 0 or 1.
//

// sub_32 returns the difference of x, y and borrow, diff = x - y - borrow.
// The borrow input must be 0 or 1; otherwise the behavior is undefined.
// The borrowOut output is guaranteed to be 0 or 1.
//
// This function's execution time does not depend on the inputs.
pub fn sub_32(x u32, y u32, borrow u32) (u32, u32) {
	diff := x - y - borrow
	// The difference will underflow if the top bit of x is not set and the top
	// bit of y is set (^x & y) or if they are the same (^(x ^ y)) and a borrow
	// from the lower place happens. If that borrow happens, the result will be
	// 1 - 1 - 1 = 0 - 0 - 1 = 1 (& diff).
	borrow_out := ((~x & y) | (~(x ^ y) & diff))>>31
	return diff, borrow_out
}

// sub_64 returns the difference of x, y and borrow: diff = x - y - borrow.
// The borrow input must be 0 or 1; otherwise the behavior is undefined.
// The borrowOut output is guaranteed to be 0 or 1.
//
// This function's execution time does not depend on the inputs.
pub fn sub_64(x u64, y u64, borrow u64) (u64, u64) {
	diff := x - y - borrow
	// See Sub32 for the bit logic.
	borrow_out  := ((~x & y) | (~(x ^ y) & diff))>>63
	return diff, borrow_out
}

// --- Full-width multiply ---

const (
	two32  = u64(0x1_0000_0000)
	mask32 = two32 - 1
	overflow_error = "Overflow Error"
	divide_error = "Divide Error"
)

// mul_32 returns the 64-bit product of x and y: (hi, lo) = x * y
// with the product bits' upper half returned in hi and the lower
// half returned in lo.
//
// This function's execution time does not depend on the inputs.
pub fn mul_32(x u32, y u32) (u32, u32) {
	tmp := u64(x) * u64(y)
	hi := u32(tmp>>32)
	lo := u32(tmp)
	return hi, lo
}

// mul_64 returns the 128-bit product of x and y: (hi, lo) = x * y
// with the product bits' upper half returned in hi and the lower
// half returned in lo.
//
// This function's execution time does not depend on the inputs.
pub fn mul_64(x u64, y u64) (u64, u64) {
	x0 := x & mask32
	x1 := x>>32
	y0 := y & mask32
	y1 := y>>32
	w0 := x0 * y0
	t := x1*y0 + (w0>>32)
	mut w1 := t & mask32
	w2 := t>>32
	w1 += x0 * y1
	hi := x1*y1 + w2 + (w1>>32)
	lo := x * y
	return hi, lo
}

// --- Full-width divide ---

// div_32 returns the quotient and remainder of (hi, lo) divided by y:
// quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper
// half in parameter hi and the lower half in parameter lo.
// div_32 panics for y == 0 (division by zero) or y <= hi (quotient overflow).
pub fn div_32(hi u32, lo u32, y u32) (u32, u32) {
	if y != 0 && y <= hi {
		panic(overflow_error)
	}
	z := (u64(hi)<<32) | u64(lo)
	quo := u32(z/u64(y))
	rem := u32(z%u64(y))
	return quo, rem
}

// div_64 returns the quotient and remainder of (hi, lo) divided by y:
// quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper
// half in parameter hi and the lower half in parameter lo.
// div_64 panics for y == 0 (division by zero) or y <= hi (quotient overflow).
pub fn div_64(hi u64, lo u64, y1 u64) (u64, u64) {
	mut y := y1
	if y == 0 {
		panic(overflow_error)
	}
	if y <= hi {
		panic(overflow_error)
	}

	s := u32(leading_zeros_64(y))
	y <<= s

	yn1 := y>>32
	yn0 := y & mask32
	un32 := (hi<<s) | (lo>>(64-s))
	un10 := lo<<s
	un1 := un10>>32
	un0 := un10 & mask32
	mut q1 := un32 / yn1
	mut rhat := un32 - q1*yn1

	for q1 >= two32 || q1*yn0 > two32*rhat+un1 {
		q1--
		rhat += yn1
		if rhat >= two32 {
			break
		}
	}

	un21 := un32*two32 + un1 - q1*y
	mut q0 := un21 / yn1
	rhat = un21 - q0*yn1

	for q0 >= two32 || q0*yn0 > two32*rhat+un0 {
		q0--
		rhat += yn1
		if rhat >= two32 {
			break
		}
	}

	return q1*two32 + q0, (un21*two32 + un0 - q0*y)>>s
}

// rem_32 returns the remainder of (hi, lo) divided by y. Rem32 panics
// for y == 0 (division by zero) but, unlike Div32, it doesn't panic
// on a quotient overflow.
pub fn rem_32(hi u32, lo u32, y u32) u32 {
	return u32(((u64(hi)<<32) | u64(lo)) % u64(y))
}

// rem_64 returns the remainder of (hi, lo) divided by y. Rem64 panics
// for y == 0 (division by zero) but, unlike div_64, it doesn't panic
// on a quotient overflow.
pub fn rem_64(hi, lo, y u64) u64 {
	// We scale down hi so that hi < y, then use div_64 to compute the
	// rem with the guarantee that it won't panic on quotient overflow.
	// Given that
	//   hi  hi%y    (mod y)
	// we have
	//   hi<<64 + lo  (hi%y)<<64 + lo    (mod y)
	_, rem := div_64(hi%y, lo, y)
	return rem
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module bits

const (
	ntz_8_tab = [byte(0x08), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x07, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00,
	]
	pop_8_tab = [byte(0x00), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
	0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
	]
	rev_8_tab = [byte(0x00), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
	]
	len_8_tab = [byte(0x00), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	]
)

//
// test suite for bits and bits math functions
//
module bits

fn test_bits(){
	mut i := 0
	mut i1:= u64(0)

	//
	// --- LeadingZeros ---
	//

	// 8 bit
	i = 1
	for x in 0..8 {
		//C.printf("x:%02x lz: %d cmp: %d\n", i << x, leading_zeros_8(i << x), 7-x)
		assert leading_zeros_8(byte(i << x)) == 7 - x
	}

	// 16 bit
	i = 1
	for x in 0..16 {
		//C.printf("x:%04x lz: %d cmp: %d\n", u16(i) << x, leading_zeros_16(u16(i) << x), 15-x)
		assert leading_zeros_16(u16(i) << x) == 15 - x
	}

	// 32 bit
	i = 1
	for x in 0..32 {
		//C.printf("x:%08x lz: %d cmp: %d\n", u32(i) << x, leading_zeros_32(u32(i) << x), 31-x)
		assert leading_zeros_32(u32(i) << x) == 31 - x
	}

	// 64 bit
	i = 1
	for x in 0..64 {
		//C.printf("x:%016llx lz: %llu cmp: %d\n", u64(i) << x, leading_zeros_64(u64(i) << x), 63-x)
		assert leading_zeros_64(u64(i) << x) == 63 - x
	}

	//
	// --- ones_count ---
	//

	// 8 bit
	i = 0
	for x in 0..9 {
		//C.printf("x:%02x lz: %llu cmp: %d\n", byte(i), ones_count_8(byte(i)), x)
		assert ones_count_8(byte(i)) == x
		i = (i << 1) + 1
	}

	// 16 bit
	i = 0
	for x in 0..17 {
		//C.printf("x:%04x lz: %llu cmp: %d\n", u16(i), ones_count_16(u16(i)), x)
		assert ones_count_16(u16(i)) == x
		i = (i << 1) + 1
	}

	// 32 bit
	i = 0
	for x in 0..33 {
		//C.printf("x:%08x lz: %llu cmp: %d\n", u32(i), ones_count_32(u32(i)), x)
		assert ones_count_32(u32(i)) == x
		i = (i << 1) + 1
	}

	// 64 bit
	i1 = 0
	for x in 0..65 {
		//C.printf("x:%016llx lz: %llu cmp: %d\n", u64(i1), ones_count_64(u64(i1)), x)
		assert ones_count_64(i1) == x
		i1 = (i1 << 1) + 1
	}

	//
	// --- rotate_left/right ---
	//
	assert rotate_left_8( 0x12 , 4) == 0x21
	assert rotate_left_16( 0x1234 , 8) == 0x3412
	assert rotate_left_32( 0x12345678 , 16) == 0x56781234
	assert rotate_left_64( 0x1234567887654321 , 32) == 0x8765432112345678

	//
	// --- reverse ---
	//

	// 8 bit
	i = 0
	for _ in 0..9 {
		mut rv := byte(0)
		mut bc := 0
		mut n := i
		for bc < 8 {
			rv = (rv << 1) | (byte(n) & 0x01)
			bc++
			n = n >> 1
		}
		//C.printf("x:%02x lz: %llu cmp: %d\n", byte(i), reverse_8(byte(i)), rv)
		assert reverse_8(byte(i)) == rv
		i = (i << 1) + 1
	}

	// 16 bit
	i = 0
	for _ in 0..17 {
		mut rv := u16(0)
		mut bc := 0
		mut n := i
		for bc < 16 {
			rv = (rv << 1) | (u16(n) & 0x01)
			bc++
			n = n >> 1
		}
		//C.printf("x:%04x lz: %llu cmp: %d\n", u16(i), reverse_16(u16(i)), rv)
		assert reverse_16(u16(i)) == rv
		i = (i << 1) + 1
	}

	// 32 bit
	i = 0
	for _ in 0..33 {
		mut rv := u32(0)
		mut bc := 0
		mut n := i
		for bc < 32 {
			rv = (rv << 1) | (u32(n) & 0x01)
			bc++
			n = n >> 1
		}
		//C.printf("x:%08x lz: %llu cmp: %d\n", u32(i), reverse_32(u32(i)), rv)
		assert reverse_32(u32(i)) == rv
		i = (i << 1) + 1
	}

	// 64 bit
	i1 = 0
	for _ in 0..64 {
		mut rv := u64(0)
		mut bc := 0
		mut n := i1
		for bc < 64 {
			rv = (rv << 1) | (n & 0x01)
			bc++
			n = n >> 1
		}
		//C.printf("x:%016llx lz: %016llx cmp: %016llx\n", u64(i1), reverse_64(u64(i1)), rv)
		assert reverse_64(i1) == rv
		i1 = (i1 << 1) + 1
	}

	//
	// --- add ---
	//

	// 32 bit
	i = 1
	for x in 0..32 {
		v := u32(i) << x
		sum,carry := add_32(v, v, u32(0))
		//C.printf("x:%08x [%llu,%llu] %llu\n", u32(i) << x, sum, carry, u64(v) + u64(v))
		assert ((u64(carry) << 32) | u64(sum)) == u64(v) + u64(v)
	}
	mut sum_32t, mut carry_32t := add_32(0x8000_0000, 0x8000_0000, u32(0))
	assert sum_32t == u32(0)
	assert carry_32t == u32(1)

	sum_32t, carry_32t = add_32(0xFFFF_FFFF, 0xFFFF_FFFF, u32(1))
	assert sum_32t == 0xFFFF_FFFF
	assert carry_32t == u32(1)

	// 64 bit
	i = 1
	for x in 0..63 {
		v := u64(i) << x
		sum,carry := add_64(v, v, u64(0))
		//C.printf("x:%16x [%llu,%llu] %llu\n", u64(i) << x, sum, carry, u64(v >> 32) + u64(v >> 32))
		assert ((carry << 32) | sum) == v + v
	}
	mut sum_64t, mut carry_64t := add_64(0x8000_0000_0000_0000, 0x8000_0000_0000_0000, u64(0))
	assert sum_64t == u64(0)
	assert carry_64t == u64(1)

	sum_64t, carry_64t = add_64(0xFFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF_FFFF_FFFF, u64(1))
	assert sum_64t == 0xFFFF_FFFF_FFFF_FFFF
	assert carry_64t == u64(1)

	//
	// --- sub ---
	//

	// 32 bit
	i = 1
	for x in 1..32 {
		v0 := u32(i) << x
		v1 := v0 >> 1
		mut diff, mut borrow_out := sub_32(v0, v1, u32(0))
		//C.printf("x:%08x [%llu,%llu] %08x\n", u32(i) << x, diff, borrow_out, v0 - v1)
		assert diff == v1

		diff, borrow_out = sub_32(v0, v1, u32(1))
		//C.printf("x:%08x [%llu,%llu] %08x\n", u32(i) << x, diff, borrow_out, v0 - v1)
		assert diff == (v1 - 1)
		assert borrow_out == u32(0)

		diff, borrow_out = sub_32(v1, v0, u32(1))
		//C.printf("x:%08x [%llu,%llu] %08x\n", u32(i) << x, diff, borrow_out, v1 - v0)
		assert borrow_out == u32(1)
	}

	// 64 bit
	i = 1
	for x in 1..64 {
		v0 := u64(i) << x
		v1 := v0 >> 1
		mut diff, mut borrow_out := sub_64(v0, v1, u64(0))
		//C.printf("x:%08x [%llu,%llu] %08x\n", u64(i) << x, diff, borrow_out, v0 - v1)
		assert diff == v1

		diff, borrow_out = sub_64(v0, v1, u64(1))
		//C.printf("x:%08x [%llu,%llu] %08x\n", u64(i) << x, diff, borrow_out, v0 - v1)
		assert diff == (v1 - 1)
		assert borrow_out == u64(0)

		diff, borrow_out = sub_64(v1, v0, u64(1))
		//C.printf("x:%08x [%llu,%llu] %08x\n",u64(i) << x, diff, borrow_out, v1 - v0)
		assert borrow_out == u64(1)
	}

	//
	// --- mul ---
	//

	// 32 bit
	i = 1
	for x in 0..32 {
		v0 := u32(i) << x
		v1 := v0 - 1
		hi, lo := mul_32(v0, v1)
		assert (u64(hi) << 32) | (u64(lo)) == u64(v0) * u64(v1)
	}

	// 64 bit
	i = 1
	for x in 0..64 {
		v0 := u64(i) << x
		v1 := v0 - 1
		hi, lo := mul_64(v0, v1)
		//C.printf("v0: %llu v1: %llu [%llu,%llu] tt: %llu\n", v0, v1, hi, lo, (v0 >> 32) * (v1 >> 32))
		assert (hi & 0xFFFF_FFFF_0000_0000) == (((v0 >> 32)*(v1 >> 32)) & 0xFFFF_FFFF_0000_0000)
		assert (lo & 0x0000_0000_FFFF_FFFF) == (((v0 & 0x0000_0000_FFFF_FFFF) * (v1 & 0x0000_0000_FFFF_FFFF)) & 0x0000_0000_FFFF_FFFF)
	}

	//
	// --- div ---
	//

	// 32 bit
	i = 1
	for x in 0..31 {
		hi := u32(i) << x
		lo := hi - 1
		y  := u32(3) << x
		quo, rem := div_32(hi, lo, y)
		//C.printf("[%08x_%08x] %08x (%08x,%08x)\n", hi, lo, y, quo, rem)
		tst := ((u64(hi) << 32) | u64(lo))
		assert quo == (tst / u64(y))
		assert rem == (tst % u64(y))
		assert rem == rem_32(hi, lo, y)
	}

	// 64 bit
	i = 1
	for x in 0..62 {
		hi := u64(i) << x
		lo := u64(2) //hi - 1
		y  := u64(0x4000_0000_0000_0000)
		quo, rem := div_64(hi, lo, y)
		//C.printf("[%016llx_%016llx] %016llx (%016llx,%016llx)\n", hi, lo, y, quo, rem)
		assert quo == u64(2)<<(x+1)
		_, rem1 := div_64(hi%y, lo, y)
		assert rem == rem1
		assert rem == rem_64(hi, lo, y)
	}

}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module complex

import math

pub struct Complex {
pub:
	re f64
	im f64
}

pub fn complex(re f64, im f64) Complex {
	return Complex{re, im}
}

// To String method
pub fn (c Complex) str() string {
	mut out := '${c.re:f}'
	out += if c.im >= 0 {
		'+${c.im:f}'
	}
	else {
		'${c.im:f}'
	}
	out += 'i'
	return out
}

// Complex Modulus value
// mod() and abs() return the same
pub fn (c Complex) abs() f64 {
	return C.hypot(c.re, c.im)
}
pub fn (c Complex) mod() f64 {
	return c.abs()
}


// Complex Angle
pub fn (c Complex) angle() f64 {
	return math.atan2(c.im, c.re)
}

// Complex Addition c1 + c2
pub fn (c1 Complex) + (c2 Complex) Complex {
	return Complex{c1.re + c2.re, c1.im + c2.im}
}

// Complex Substraction c1 - c2
pub fn (c1 Complex) - (c2 Complex) Complex {
	return Complex{c1.re - c2.re, c1.im - c2.im}
}

// Complex Multiplication c1 * c2
pub fn (c1 Complex) * (c2 Complex) Complex {
	return Complex{
		(c1.re * c2.re) + ((c1.im * c2.im) * -1),
		(c1.re * c2.im) + (c1.im * c2.re)
	}
}

// Complex Division c1 / c2
pub fn (c1 Complex) / (c2 Complex) Complex {
	denom := (c2.re * c2.re) + (c2.im * c2.im)
	return Complex {
		((c1.re * c2.re) + ((c1.im * -c2.im) * -1))/denom,
		((c1.re * -c2.im) + (c1.im * c2.re))/denom
	}
}

// Complex Addition c1.add(c2)
pub fn (c1 Complex) add(c2 Complex) Complex {
	return c1 + c2
}

// Complex Subtraction c1.subtract(c2)
pub fn (c1 Complex) subtract(c2 Complex) Complex {
	return c1 - c2
}

// Complex Multiplication c1.multiply(c2)
pub fn (c1 Complex) multiply(c2 Complex) Complex {
	return Complex{
		(c1.re * c2.re) + ((c1.im * c2.im) * -1),
		(c1.re * c2.im) + (c1.im * c2.re)
	}
}

// Complex Division c1.divide(c2)
pub fn (c1 Complex) divide(c2 Complex) Complex {
	denom := (c2.re * c2.re) + (c2.im * c2.im)
	return Complex {
		((c1.re * c2.re) + ((c1.im * -c2.im) * -1)) / denom,
		((c1.re * -c2.im) + (c1.im * c2.re)) / denom
	}
}

// Complex Conjugate
pub fn (c Complex) conjugate() Complex{
	return Complex{c.re, -c.im}
}

// Complex Additive Inverse
// Based on
// http://tutorial.math.lamar.edu/Extras/ComplexPrimer/Arithmetic.aspx
pub fn (c Complex) addinv() Complex {
	return Complex{-c.re, -c.im}
}

// Complex Multiplicative Inverse
// Based on
// http://tutorial.math.lamar.edu/Extras/ComplexPrimer/Arithmetic.aspx
pub fn (c Complex) mulinv() Complex {
	return Complex {
		c.re / (c.re * c.re + c.im * c.im),
		-c.im / (c.re * c.re + c.im * c.im)
	}
}

// Complex Power
// Based on
// https://www.khanacademy.org/math/precalculus/imaginary-and-complex-numbers/multiplying-and-dividing-complex-numbers-in-polar-form/a/complex-number-polar-form-review
pub fn (c Complex) pow(n f64) Complex {
	r := math.pow(c.abs(), n)
	angle := c.angle()
	return Complex {
		r * math.cos(n * angle),
		r * math.sin(n * angle)
	}
}

// Complex nth root
pub fn (c Complex) root(n f64) Complex {
	return c.pow(1.0 / n)
}

// Complex Exponential
// Using Euler's Identity
// Based on
// https://www.math.wisc.edu/~angenent/Free-Lecture-Notes/freecomplexnumbers.pdf
pub fn (c Complex) exp() Complex {
	a := math.exp(c.re)
	return Complex {
		a * math.cos(c.im),
		a * math.sin(c.im)
	}
}

// Complex Natural Logarithm
// Based on
// http://www.chemistrylearning.com/logarithm-of-complex-number/
pub fn (c Complex) ln() Complex {
	return Complex {
		math.log(c.abs()),
		c.angle()
	}
}

// Complex Log Base Complex
// Based on
// http://www.milefoot.com/math/complex/summaryops.htm
pub fn (c Complex) log(base Complex) Complex {
	return base.ln().divide(c.ln())
}

// Complex Argument
// Based on
// http://mathworld.wolfram.com/ComplexArgument.html
pub fn (c Complex) arg() f64 {
	return math.atan2(c.im,c.re)
}

// Complex raised to Complex Power
// Based on
// http://mathworld.wolfram.com/ComplexExponentiation.html
pub fn (c Complex) cpow(p Complex) Complex {
	a := c.arg()
	b := math.pow(c.re,2) + math.pow(c.im,2)
	d := p.re * a + (1.0/2) * p.im * math.log(b)
	t1 := math.pow(b,p.re/2) * math.exp(-p.im*a)
	return Complex{
		t1 * math.cos(d),
		t1 * math.sin(d)
	}
}

// Complex Sin
// Based on
// http://www.milefoot.com/math/complex/functionsofi.htm
pub fn (c Complex) sin() Complex {
	return Complex{
		math.sin(c.re) * math.cosh(c.im),
		math.cos(c.re) * math.sinh(c.im)
	}
}

// Complex Cosine
// Based on
// http://www.milefoot.com/math/complex/functionsofi.htm
pub fn (c Complex) cos() Complex {
	return Complex{
		math.cos(c.re) * math.cosh(c.im),
		-(math.sin(c.re) * math.sinh(c.im))
	}
}

// Complex Tangent
// Based on
// http://www.milefoot.com/math/complex/functionsofi.htm
pub fn (c Complex) tan() Complex {
	return c.sin().divide(c.cos())
}

// Complex Cotangent
// Based on
// http://www.suitcaseofdreams.net/Trigonometric_Functions.htm
pub fn (c Complex) cot() Complex {
	return c.cos().divide(c.sin())
}

// Complex Secant
// Based on
// http://www.suitcaseofdreams.net/Trigonometric_Functions.htm
pub fn (c Complex) sec() Complex {
	return complex(1,0).divide(c.cos())
}

// Complex Cosecant
// Based on
// http://www.suitcaseofdreams.net/Trigonometric_Functions.htm
pub fn (c Complex) csc() Complex {
	return complex(1,0).divide(c.sin())
}

// Complex Arc Sin / Sin Inverse
// Based on
// http://www.milefoot.com/math/complex/summaryops.htm
pub fn (c Complex) asin() Complex {
	return complex(0,-1).multiply(
			complex(0,1)
			.multiply(c)
			.add(
				complex(1,0)
				.subtract(c.pow(2))
				.root(2)
			)
			.ln()
	)
}

// Complex Arc Consine / Consine Inverse
// Based on
// http://www.milefoot.com/math/complex/summaryops.htm
pub fn (c Complex) acos() Complex {
	return complex(0,-1).multiply(
		c.add(
			complex(0,1)
			.multiply(
				complex(1,0)
				.subtract(c.pow(2))
				.root(2)
			)
		)
		.ln()
	)
}

// Complex Arc Tangent / Tangent Inverse
// Based on
// http://www.milefoot.com/math/complex/summaryops.htm
pub fn (c Complex) atan() Complex {
	i := complex(0,1)
	return complex(0,1.0/2).multiply(
		i.add(c)
		.divide(
			i.subtract(c)
		)
		.ln()
	)
}

// Complex Arc Cotangent / Cotangent Inverse
// Based on
// http://www.suitcaseofdreams.net/Inverse_Functions.htm
pub fn (c Complex) acot() Complex {
	return complex(1,0).divide(c).atan()
}

// Complex Arc Secant / Secant Inverse
// Based on
// http://www.suitcaseofdreams.net/Inverse_Functions.htm
pub fn (c Complex) asec() Complex {
	return complex(1,0).divide(c).acos()
}

// Complex Arc Cosecant / Cosecant Inverse
// Based on
// http://www.suitcaseofdreams.net/Inverse_Functions.htm
pub fn (c Complex) acsc() Complex {
	return complex(1,0).divide(c).asin()
}

// Complex Hyperbolic Sin
// Based on
// http://www.milefoot.com/math/complex/functionsofi.htm
pub fn (c Complex) sinh() Complex {
	return Complex{
		math.cos(c.im) * math.sinh(c.re),
		math.sin(c.im) * math.cosh(c.re)
	}
}

// Complex Hyperbolic Cosine
// Based on
// http://www.milefoot.com/math/complex/functionsofi.htm
pub fn (c Complex) cosh() Complex {
	return Complex{
		math.cos(c.im) * math.cosh(c.re),
		math.sin(c.im) * math.sinh(c.re)
	}
}

// Complex Hyperbolic Tangent
// Based on
// http://www.milefoot.com/math/complex/functionsofi.htm
pub fn (c Complex) tanh() Complex {
	return c.sinh().divide(c.cosh())
}

// Complex Hyperbolic Cotangent
// Based on
// http://www.suitcaseofdreams.net/Hyperbolic_Functions.htm
pub fn (c Complex) coth() Complex {
	return c.cosh().divide(c.sinh())
}

// Complex Hyperbolic Secant
// Based on
// http://www.suitcaseofdreams.net/Hyperbolic_Functions.htm
pub fn (c Complex) sech() Complex {
	return complex(1,0).divide(c.cosh())
}

// Complex Hyperbolic Cosecant
// Based on
// http://www.suitcaseofdreams.net/Hyperbolic_Functions.htm
pub fn (c Complex) csch() Complex {
	return complex(1,0).divide(c.sinh())
}

// Complex Hyperbolic Arc Sin / Sin Inverse
// Based on
// http://www.suitcaseofdreams.net/Inverse__Hyperbolic_Functions.htm
pub fn (c Complex) asinh() Complex {
	return c.add(
		c.pow(2)
		.add(complex(1,0))
		.root(2)
	).ln()
}

// Complex Hyperbolic Arc Consine / Consine Inverse
// Based on
// http://www.suitcaseofdreams.net/Inverse__Hyperbolic_Functions.htm
pub fn (c Complex) acosh() Complex {
	if c.re > 1 {
		return c.add(
			c.pow(2)
			.subtract(complex(1,0))
			.root(2)
		).ln()
	}
	else {
		one := complex(1,0)
		return c.add(
			c.add(one)
			.root(2)
			.multiply(
				c.subtract(one)
				.root(2)
			)
		).ln()
	}
}

// Complex Hyperbolic Arc Tangent / Tangent Inverse
// Based on
// http://www.suitcaseofdreams.net/Inverse__Hyperbolic_Functions.htm
pub fn (c Complex) atanh() Complex {
	one := complex(1,0)
	if c.re < 1 {
		return complex(1.0/2,0).multiply(
			one
			.add(c)
			.divide(
				one
				.subtract(c)
			)
			.ln()
		)
	}
	else {
		return complex(1.0/2,0).multiply(
			one
			.add(c)
			.ln()
			.subtract(
				one
				.subtract(c)
				.ln()
			)
		)
	}
}

// Complex Hyperbolic Arc Cotangent / Cotangent Inverse
// Based on
// http://www.suitcaseofdreams.net/Inverse__Hyperbolic_Functions.htm
pub fn (c Complex) acoth() Complex {
	one := complex(1,0)
	if c.re < 0 || c.re > 1 {
		return complex(1.0/2,0).multiply(
			c
			.add(one)
			.divide(
				c.subtract(one)
			)
			.ln()
		)
	}
	else {
		div := one.divide(c)
		return complex(1.0/2,0).multiply(
			one
			.add(div)
			.ln()
			.subtract(
				one
				.subtract(div)
				.ln()
			)
		)
	}
}

// Complex Hyperbolic Arc Secant / Secant Inverse
// Based on
// http://www.suitcaseofdreams.net/Inverse__Hyperbolic_Functions.htm
// For certain scenarios, Result mismatch in crossverification with Wolfram Alpha - analysis pending
// pub fn (c Complex) asech() Complex {
// 	one := complex(1,0)
	// if(c.re < -1.0) {
	// 	return one.subtract(
	// 		one.subtract(
	// 			c.pow(2)
	// 		)
	// 		.root(2)
	// 	)
	// 	.divide(c)
	// 	.ln()
	// }
	// else {
		// return one.add(
		// 	one.subtract(
		// 		c.pow(2)
		// 	)
		// 	.root(2)
		// )
		// .divide(c)
		// .ln()
	// }
// }

// Complex Hyperbolic Arc Cosecant / Cosecant Inverse
// Based on
// http://www.suitcaseofdreams.net/Inverse__Hyperbolic_Functions.htm
pub fn (c Complex) acsch() Complex {
	one := complex(1,0)
	if c.re < 0 {
		return one.subtract(
			one.add(
				c.pow(2)
			)
			.root(2)
		)
		.divide(c)
		.ln()
	} else {
		return one.add(
			one.add(
				c.pow(2)
			)
			.root(2)
		)
		.divide(c)
		.ln()
	}
}

// Complex Equals
pub fn (c1 Complex) equals(c2 Complex) bool {
	return (c1.re == c2.re) && (c1.im == c2.im)
}
import math
import math.complex as cmplx

fn tst_res(str1 string, str2 string) bool {
	if (math.abs(str1.f64() - str2.f64())) < 1e-5 {
		return true
	}
	return false
}

fn test_complex_addition() {
	// Test is based on and verified from practice examples of Khan Academy
	// https://www.khanacademy.org/math/precalculus/imaginary-and-complex-numbers
	mut c1 := cmplx.complex(0,-10)
	mut c2 := cmplx.complex(-40,8)
	mut result := c1 + c2
	assert result.equals(cmplx.complex(-40,-2))
	c1 = cmplx.complex(-71,2)
	c2 = cmplx.complex(88,-12)
	result = c1 + c2
	assert result.equals(cmplx.complex(17,-10))
	c1 = cmplx.complex(0,-30)
	c2 = cmplx.complex(52,-30)
	result = c1 + c2
	assert result.equals(cmplx.complex(52,-60))
	c1 = cmplx.complex(12,-9)
	c2 = cmplx.complex(32,-6)
	result = c1 + c2
	assert result.equals(cmplx.complex(44,-15))
}

fn test_complex_subtraction() {
	// Test is based on and verified from practice examples of Khan Academy
	// https://www.khanacademy.org/math/precalculus/imaginary-and-complex-numbers
	mut c1 := cmplx.complex(-8,0)
	mut c2 := cmplx.complex(6,30)
	mut result := c1 - c2
	assert result.equals(cmplx.complex(-14,-30))
	c1 = cmplx.complex(-19,7)
	c2 = cmplx.complex(29,32)
	result = c1 - c2
	assert result.equals(cmplx.complex(-48,-25))
	c1 = cmplx.complex(12,0)
	c2 = cmplx.complex(23,13)
	result = c1 - c2
	assert result.equals(cmplx.complex(-11,-13))
	c1 = cmplx.complex(-14,3)
	c2 = cmplx.complex(0,14)
	result = c1 - c2
	assert result.equals(cmplx.complex(-14,-11))
}

fn test_complex_multiplication() {
	// Test is based on and verified from practice examples of Khan Academy
	// https://www.khanacademy.org/math/precalculus/imaginary-and-complex-numbers
	mut c1 := cmplx.complex(1,2)
	mut c2 := cmplx.complex(1,-4)
	mut result := c1 * c2
	assert result.equals(cmplx.complex(9,-2))
	c1 = cmplx.complex(-4,-4)
	c2 = cmplx.complex(-5,-3)
	result = c1 * c2
	assert result.equals(cmplx.complex(8,32))
	c1 = cmplx.complex(4,4)
	c2 = cmplx.complex(-2,-5)
	result = c1 * c2
	assert result.equals(cmplx.complex(12,-28))
	c1 = cmplx.complex(2,-2)
	c2 = cmplx.complex(4,-4)
	result = c1 * c2
	assert result.equals(cmplx.complex(0,-16))
}

fn test_complex_division() {
	// Test is based on and verified from practice examples of Khan Academy
	// https://www.khanacademy.org/math/precalculus/imaginary-and-complex-numbers
	mut c1 := cmplx.complex(-9,-6)
	mut c2 := cmplx.complex(-3,-2)
	mut result := c1 / c2
	assert result.equals(cmplx.complex(3,0))
	c1 = cmplx.complex(-23,11)
	c2 = cmplx.complex(5,1)
	result = c1 / c2
	assert result.equals(cmplx.complex(-4,3))
	c1 = cmplx.complex(8,-2)
	c2 = cmplx.complex(-4,1)
	result = c1 / c2
	assert result.equals(cmplx.complex(-2,0))
	c1 = cmplx.complex(11,24)
	c2 = cmplx.complex(-4,-1)
	result = c1 / c2
	assert result.equals(cmplx.complex(-4,-5))
}

fn test_complex_conjugate() {
	// Test is based on and verified from practice examples of Khan Academy
	// https://www.khanacademy.org/math/precalculus/imaginary-and-complex-numbers
	mut c1 := cmplx.complex(0,8)
	mut result := c1.conjugate()
	assert result.equals(cmplx.complex(0,-8))
	c1 = cmplx.complex(7,3)
	result = c1.conjugate()
	assert result.equals(cmplx.complex(7,-3))
	c1 = cmplx.complex(2,2)
	result = c1.conjugate()
	assert result.equals(cmplx.complex(2,-2))
	c1 = cmplx.complex(7,0)
	result = c1.conjugate()
	assert result.equals(cmplx.complex(7,0))
}

fn test_complex_equals() {
	mut c1 := cmplx.complex(0,8)
	mut c2 := cmplx.complex(0,8)
	assert c1.equals(c2)
	c1 = cmplx.complex(-3,19)
	c2 = cmplx.complex(-3,19)
	assert c1.equals(c2)
}

fn test_complex_abs() {
	mut c1 := cmplx.complex(3,4)
	assert c1.abs() == 5
	c1 = cmplx.complex(1,2)
	assert c1.abs().eq(math.sqrt(5))
	assert c1.abs().eq(c1.conjugate().abs())
	c1 = cmplx.complex(7,0)
	assert c1.abs() == 7
}

fn test_complex_angle(){
	// Test is based on and verified from practice examples of Khan Academy
	// https://www.khanacademy.org/math/precalculus/imaginary-and-complex-numbers
	mut c := cmplx.complex(1, 0)
	assert (c.angle() * 180 / math.pi).eq(0)
	c = cmplx.complex(1, 1)
	assert (c.angle() * 180 / math.pi).eq(45)
	c = cmplx.complex(0, 1)
	assert (c.angle() * 180 / math.pi).eq(90)
	c = cmplx.complex(-1, 1)
	assert (c.angle() * 180 / math.pi).eq(135)
	c = cmplx.complex(-1, -1)
	assert (c.angle() * 180 / math.pi).eq(-135)
	cc := c.conjugate()
	assert (cc.angle() + c.angle()).eq(0)
}


fn test_complex_addinv() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(-5,-7)
	mut result := c1.addinv()
	assert result.equals(c2)
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(3,-4)
	result = c1.addinv()
	assert result.equals(c2)
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(1,2)
	result = c1.addinv()
	assert result.equals(c2)
}

fn test_complex_mulinv() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.067568,-0.094595)
	mut result := c1.mulinv()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	println(c2.str())
	println(result.str())
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.12,-0.16)
	result = c1.mulinv()
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.2,0.4)
	result = c1.mulinv()
	assert result.equals(c2)
}

fn test_complex_mod() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut result := c1.mod()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(result.str(), '8.602325')
	c1 = cmplx.complex(-3,4)
	result = c1.mod()
	assert result == 5
	c1 = cmplx.complex(-1,-2)
	result = c1.mod()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(result.str(), '2.236068')
}

fn test_complex_pow() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(-24.0,70.0)
	mut result := c1.pow(2)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(117,44)
	result = c1.pow(3)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-7,-24)
	result = c1.pow(4)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_root() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(2.607904,1.342074)
	mut result := c1.root(2)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(1.264953,1.150614)
	result = c1.root(3)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(1.068059,-0.595482)
	result = c1.root(4)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_exp() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(111.889015,97.505457)
	mut result := c1.exp()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.032543,-0.037679)
	result = c1.exp()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.153092,-0.334512)
	result = c1.exp()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_ln() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(2.152033,0.950547)
	mut result := c1.ln()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(1.609438,2.214297)
	result = c1.ln()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(0.804719,-2.034444)
	result = c1.ln()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_arg() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(2.152033,0.950547)
	mut result := c1.arg()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(result.str(), '0.950547')
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(1.609438,2.214297)
	result = c1.arg()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(result.str(), '2.214297')
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(0.804719,-2.034444)
	result = c1.arg()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(result.str(), '-2.034444')
}

fn test_complex_log() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut b1 := cmplx.complex(-6,-2)
	mut c2 := cmplx.complex(0.232873,-1.413175)
	mut result := c1.log(b1)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	b1 = cmplx.complex(3,-1)
	c2 = cmplx.complex(0.152198,-0.409312)
	result = c1.log(b1)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	b1 = cmplx.complex(0,9)
	c2 = cmplx.complex(-0.298243,1.197981)
	result = c1.log(b1)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_cpow() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut r1 := cmplx.complex(2,2)
	mut c2 := cmplx.complex(11.022341,-0.861785)
	mut result := c1.cpow(r1)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	r1 = cmplx.complex(-4,-2)
	c2 = cmplx.complex(0.118303,0.063148)
	result = c1.cpow(r1)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	r1 = cmplx.complex(8,-9)
	c2 = cmplx.complex(-0.000000,0.000007)
	result = c1.cpow(r1)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_sin() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(-525.794515,155.536550)
	mut result := c1.sin()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-3.853738,-27.016813)
	result = c1.sin()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-3.165779,-1.959601)
	result = c1.sin()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_cos() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(155.536809,525.793641)
	mut result := c1.cos()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-27.034946,3.851153)
	result = c1.cos()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(2.032723,-3.051898)
	result = c1.cos()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_tan() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(-0.000001,1.000001)
	mut result := c1.tan()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(0.000187,0.999356)
	result = c1.tan()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.033813,-1.014794)
	result = c1.tan()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_cot() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(-0.000001,-0.999999)
	mut result := c1.cot()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(0.000188,-1.000644)
	result = c1.cot()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.032798,0.984329)
	result = c1.cot()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_sec() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.000517,-0.001749)
	mut result := c1.sec()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.036253,-0.005164)
	result = c1.sec()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(0.151176,0.226974)
	result = c1.sec()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_csc() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(-0.001749,-0.000517)
	mut result := c1.csc()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.005174,0.036276)
	result = c1.csc()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.228375,0.141363)
	result = c1.csc()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_asin() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.617064,2.846289)
	mut result := c1.asin()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.633984,2.305509)
	result = c1.asin()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.427079,-1.528571)
	result = c1.asin()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_acos() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.953732,-2.846289)
	mut result := c1.acos()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(2.204780,-2.305509)
	result = c1.acos()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(1.997875,1.528571)
	result = c1.acos()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_atan() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(1.502727,0.094441)
	mut result := c1.atan()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-1.448307,0.158997)
	result = c1.atan()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-1.338973,-0.402359)
	result = c1.atan()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_acot() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.068069,-0.094441)
	mut result := c1.acot()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.122489,-0.158997)
	result = c1.acot()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.231824,0.402359)
	result = c1.acot()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_asec() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(1.503480,0.094668)
	mut result := c1.asec()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(1.689547,0.160446)
	result = c1.asec()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(1.757114,-0.396568)
	result = c1.asec()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_acsc() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.067317,-0.094668)
	mut result := c1.acsc()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.118751,-0.160446)
	result = c1.acsc()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.186318,0.396568)
	result = c1.acsc()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_sinh() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(55.941968,48.754942)
	mut result := c1.sinh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(6.548120,-7.619232)
	result = c1.sinh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(0.489056,-1.403119)
	result = c1.sinh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_cosh() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(55.947047,48.750515)
	mut result := c1.cosh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-6.580663,7.581553)
	result = c1.cosh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.642148,1.068607)
	result = c1.cosh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_tanh() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.999988,0.000090)
	mut result := c1.tanh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-1.000710,0.004908)
	result = c1.tanh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-1.166736,0.243458)
	result = c1.tanh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_coth() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(1.000012,-0.000090)
	mut result := c1.coth()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.999267,-0.004901)
	result = c1.coth()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.821330,-0.171384)
	result = c1.coth()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_sech() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.010160,-0.008853)
	mut result := c1.sech()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.065294,-0.075225)
	result = c1.sech()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.413149,-0.687527)
	result = c1.sech()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_csch() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.010159,-0.008854)
	mut result := c1.csch()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(0.064877,0.075490)
	result = c1.csch()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(0.221501,0.635494)
	result = c1.csch()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_asinh() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(2.844098,0.947341)
	mut result := c1.asinh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-2.299914,0.917617)
	result = c1.asinh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-1.469352,-1.063440)
	result = c1.asinh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_acosh() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(2.846289,0.953732)
	mut result := c1.acosh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(2.305509,2.204780)
	result = c1.acosh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(1.528571,-1.997875)
	result = c1.acosh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_atanh() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.067066,1.476056)
	mut result := c1.atanh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.117501,1.409921)
	result = c1.atanh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.173287,-1.178097)
	result = c1.atanh()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_acoth() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.067066,-0.094740)
	mut result := c1.acoth()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.117501,-0.160875)
	result = c1.acoth()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.173287,0.392699)
	result = c1.acoth()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

// fn test_complex_asech() {
// 	// Tests were also verified on Wolfram Alpha
// 	mut c1 := cmplx.complex(5,7)
// 	mut c2 := cmplx.complex(0.094668,-1.503480)
// 	mut result := c1.asech()
// 	// Some issue with precision comparison in f64 using == operator hence serializing to string
// 	assert result.str().eq(c2.str())
// 	c1 = cmplx.complex(-3,4)
// 	c2 = cmplx.complex(0.160446,-1.689547)
// 	result = c1.asech()
// 	// Some issue with precision comparison in f64 using == operator hence serializing to string
// 	assert result.str().eq(c2.str())
// 	c1 = cmplx.complex(-1,-2)
// 	c2 = cmplx.complex(0.396568,1.757114)
// 	result = c1.asech()
// 	// Some issue with precision comparison in f64 using == operator hence serializing to string
// 	assert result.str().eq(c2.str())
// }

fn test_complex_acsch() {
	// Tests were also verified on Wolfram Alpha
	mut c1 := cmplx.complex(5,7)
	mut c2 := cmplx.complex(0.067819,-0.094518)
	mut result := c1.acsch()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-3,4)
	c2 = cmplx.complex(-0.121246,-0.159507)
	result = c1.acsch()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
	c1 = cmplx.complex(-1,-2)
	c2 = cmplx.complex(-0.215612,0.401586)
	result = c1.acsch()
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert result.str().eq(c2.str())
}

fn test_complex_re_im() {
	c := cmplx.complex(2.1, 9.05)
	assert c.re == 2.1
	assert c.im == 9.05
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Module created by Ulises Jeremias Cornejo Fandos based on
// the definitions provided in https://scientificc.github.io/cmathl/

module factorial

import math

// factorial calculates the factorial of the provided value.
pub fn factorial(n f64) f64 {
	// For a large postive argument (n >= FACTORIALS.len) return max_f64

	if n >= factorials_table.len {
			return math.max_f64
	}

	// Otherwise return n!.
	if n == f64(i64(n)) && n >= 0.0 {
		return factorials_table[i64(n)]
	}

	return math.gamma(n + 1.0)
}

// log_factorial calculates the log-factorial of the provided value.
pub fn log_factorial(n f64) f64 {
	// For a large postive argument (n < 0) return max_f64

	if n < 0 {
                return -math.max_f64
	}

	// If n < N then return ln(n!).

	if n != f64(i64(n)) {
		return math.log_gamma(n+1)
	} else if n < log_factorials_table.len {
                return log_factorials_table[i64(n)]
        }

	// Otherwise return asymptotic expansion of ln(n!).

        return log_factorial_asymptotic_expansion(int(n))
}

fn log_factorial_asymptotic_expansion(n int) f64 {
        m := 6
        mut term := []f64{}
        xx := f64((n + 1) * (n + 1))
        mut xj := f64(n + 1)

        log_factorial := log_sqrt_2pi - xj + (xj - 0.5) * math.log(xj)

        mut i := 0

        for i = 0; i < m; i++ {
                term << b_numbers[i] / xj
                xj *= xx
        }

        mut sum := term[m-1]

        for i = m - 2; i >= 0; i-- {
                if math.abs(sum) <= math.abs(term[i]) {
                        break
                }

                sum = term[i]
        }

        for i >= 0 {
                sum += term[i]
                i--
        }

        return log_factorial + sum
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module factorial

const (
    log_sqrt_2pi = 9.18938533204672741780329736e-1

    b_numbers = [
        /* Bernoulli numbers B(2),B(4),B(6),...,B(20).  Only B(2),...,B(10) currently
        * used.
        */
    f64(1.0 / (6.0 * 2.0 * 1.0)),
       -1.0 / (30.0 * 4.0 * 3.0),
        1.0 / (42.0 * 6.0 * 5.0),
       -1.0 / (30.0 * 8.0 * 7.0),
        5.0 / (66.0 * 10.0 * 9.0),
       -691.0 / (2730.0 * 12.0 * 11.0),
        7.0 / (6.0 * 14.0 * 13.0),
       -3617.0 / (510.0 * 16.0 * 15.0),
        43867.0 / (796.0 * 18.0 * 17.0),
       -174611.0 / (330.0 * 20.0 * 19.0)
        ]

	factorials_table = [
    f64(1.000000000000000000000e+0),        /*   0! */
        1.000000000000000000000e+0,         /*   1! */
        2.000000000000000000000e+0,         /*   2! */
        6.000000000000000000000e+0,         /*   3! */
        2.400000000000000000000e+1,         /*   4! */
        1.200000000000000000000e+2,         /*   5! */
        7.200000000000000000000e+2,         /*   6! */
        5.040000000000000000000e+3,         /*   7! */
        4.032000000000000000000e+4,         /*   8! */
        3.628800000000000000000e+5,         /*   9! */
        3.628800000000000000000e+6,         /*  10! */
        3.991680000000000000000e+7,         /*  11! */
        4.790016000000000000000e+8,         /*  12! */
        6.227020800000000000000e+9,         /*  13! */
        8.717829120000000000000e+10,        /*  14! */
        1.307674368000000000000e+12,        /*  15! */
        2.092278988800000000000e+13,        /*  16! */
        3.556874280960000000000e+14,        /*  17! */
        6.402373705728000000000e+15,        /*  18! */
        1.216451004088320000000e+17,        /*  19! */
        2.432902008176640000000e+18,        /*  20! */
        5.109094217170944000000e+19,        /*  21! */
        1.124000727777607680000e+21,        /*  22! */
        2.585201673888497664000e+22,        /*  23! */
        6.204484017332394393600e+23,        /*  24! */
        1.551121004333098598400e+25,        /*  25! */
        4.032914611266056355840e+26,        /*  26! */
        1.088886945041835216077e+28,        /*  27! */
        3.048883446117138605015e+29,        /*  28! */
        8.841761993739701954544e+30,        /*  29! */
        2.652528598121910586363e+32,        /*  30! */
        8.222838654177922817726e+33,        /*  31! */
        2.631308369336935301672e+35,        /*  32! */
        8.683317618811886495518e+36,        /*  33! */
        2.952327990396041408476e+38,        /*  34! */
        1.033314796638614492967e+40,        /*  35! */
        3.719933267899012174680e+41,        /*  36! */
        1.376375309122634504632e+43,        /*  37! */
        5.230226174666011117600e+44,        /*  38! */
        2.039788208119744335864e+46,        /*  39! */
        8.159152832478977343456e+47,        /*  40! */
        3.345252661316380710817e+49,        /*  41! */
        1.405006117752879898543e+51,        /*  42! */
        6.041526306337383563736e+52,        /*  43! */
        2.658271574788448768044e+54,        /*  44! */
        1.196222208654801945620e+56,        /*  45! */
        5.502622159812088949850e+57,        /*  46! */
        2.586232415111681806430e+59,        /*  47! */
        1.241391559253607267086e+61,        /*  48! */
        6.082818640342675608723e+62,        /*  49! */
        3.041409320171337804361e+64,        /*  50! */
        1.551118753287382280224e+66,        /*  51! */
        8.065817517094387857166e+67,        /*  52! */
        4.274883284060025564298e+69,        /*  53! */
        2.308436973392413804721e+71,        /*  54! */
        1.269640335365827592597e+73,        /*  55! */
        7.109985878048634518540e+74,        /*  56! */
        4.052691950487721675568e+76,        /*  57! */
        2.350561331282878571829e+78,        /*  58! */
        1.386831185456898357379e+80,        /*  59! */
        8.320987112741390144276e+81,        /*  60! */
        5.075802138772247988009e+83,        /*  61! */
        3.146997326038793752565e+85,        /*  62! */
        1.982608315404440064116e+87,        /*  63! */
        1.268869321858841641034e+89,        /*  64! */
        8.247650592082470666723e+90,        /*  65! */
        5.443449390774430640037e+92,        /*  66! */
        3.647111091818868528825e+94,        /*  67! */
        2.480035542436830599601e+96,        /*  68! */
        1.711224524281413113725e+98,        /*  69! */
        1.197857166996989179607e+100,       /*  70! */
        8.504785885678623175212e+101,       /*  71! */
        6.123445837688608686152e+103,       /*  72! */
        4.470115461512684340891e+105,       /*  73! */
        3.307885441519386412260e+107,       /*  74! */
        2.480914081139539809195e+109,       /*  75! */
        1.885494701666050254988e+111,       /*  76! */
        1.451830920282858696341e+113,       /*  77! */
        1.132428117820629783146e+115,       /*  78! */
        8.946182130782975286851e+116,       /*  79! */
        7.156945704626380229481e+118,       /*  80! */
        5.797126020747367985880e+120,       /*  81! */
        4.753643337012841748421e+122,       /*  82! */
        3.945523969720658651190e+124,       /*  83! */
        3.314240134565353266999e+126,       /*  84! */
        2.817104114380550276949e+128,       /*  85! */
        2.422709538367273238177e+130,       /*  86! */
        2.107757298379527717214e+132,       /*  87! */
        1.854826422573984391148e+134,       /*  88! */
        1.650795516090846108122e+136,       /*  89! */
        1.485715964481761497310e+138,       /*  90! */
        1.352001527678402962552e+140,       /*  91! */
        1.243841405464130725548e+142,       /*  92! */
        1.156772507081641574759e+144,       /*  93! */
        1.087366156656743080274e+146,       /*  94! */
        1.032997848823905926260e+148,       /*  95! */
        9.916779348709496892096e+149,       /*  96! */
        9.619275968248211985333e+151,       /*  97! */
        9.426890448883247745626e+153,       /*  98! */
        9.332621544394415268170e+155,       /*  99! */
        9.332621544394415268170e+157,       /* 100! */
        9.425947759838359420852e+159,       /* 101! */
        9.614466715035126609269e+161,       /* 102! */
        9.902900716486180407547e+163,       /* 103! */
        1.029901674514562762385e+166,       /* 104! */
        1.081396758240290900504e+168,       /* 105! */
        1.146280563734708354534e+170,       /* 106! */
        1.226520203196137939352e+172,       /* 107! */
        1.324641819451828974500e+174,       /* 108! */
        1.443859583202493582205e+176,       /* 109! */
        1.588245541522742940425e+178,       /* 110! */
        1.762952551090244663872e+180,       /* 111! */
        1.974506857221074023537e+182,       /* 112! */
        2.231192748659813646597e+184,       /* 113! */
        2.543559733472187557120e+186,       /* 114! */
        2.925093693493015690688e+188,       /* 115! */
        3.393108684451898201198e+190,       /* 116! */
        3.969937160808720895402e+192,       /* 117! */
        4.684525849754290656574e+194,       /* 118! */
        5.574585761207605881323e+196,       /* 119! */
        6.689502913449127057588e+198,       /* 120! */
        8.094298525273443739682e+200,       /* 121! */
        9.875044200833601362412e+202,       /* 122! */
        1.214630436702532967577e+205,       /* 123! */
        1.506141741511140879795e+207,       /* 124! */
        1.882677176888926099744e+209,       /* 125! */
        2.372173242880046885677e+211,       /* 126! */
        3.012660018457659544810e+213,       /* 127! */
        3.856204823625804217357e+215,       /* 128! */
        4.974504222477287440390e+217,       /* 129! */
        6.466855489220473672507e+219,       /* 130! */
        8.471580690878820510985e+221,       /* 131! */
        1.118248651196004307450e+224,       /* 132! */
        1.487270706090685728908e+226,       /* 133! */
        1.992942746161518876737e+228,       /* 134! */
        2.690472707318050483595e+230,       /* 135! */
        3.659042881952548657690e+232,       /* 136! */
        5.012888748274991661035e+234,       /* 137! */
        6.917786472619488492228e+236,       /* 138! */
        9.615723196941089004197e+238,       /* 139! */
        1.346201247571752460588e+241,       /* 140! */
        1.898143759076170969429e+243,       /* 141! */
        2.695364137888162776589e+245,       /* 142! */
        3.854370717180072770522e+247,       /* 143! */
        5.550293832739304789551e+249,       /* 144! */
        8.047926057471991944849e+251,       /* 145! */
        1.174997204390910823948e+254,       /* 146! */
        1.727245890454638911203e+256,       /* 147! */
        2.556323917872865588581e+258,       /* 148! */
        3.808922637630569726986e+260,       /* 149! */
        5.713383956445854590479e+262,       /* 150! */
        8.627209774233240431623e+264,       /* 151! */
        1.311335885683452545607e+267,       /* 152! */
        2.006343905095682394778e+269,       /* 153! */
        3.089769613847350887959e+271,       /* 154! */
        4.789142901463393876336e+273,       /* 155! */
        7.471062926282894447084e+275,       /* 156! */
        1.172956879426414428192e+278,       /* 157! */
        1.853271869493734796544e+280,       /* 158! */
        2.946702272495038326504e+282,       /* 159! */
        4.714723635992061322407e+284,       /* 160! */
        7.590705053947218729075e+286,       /* 161! */
        1.229694218739449434110e+289,       /* 162! */
        2.004401576545302577600e+291,       /* 163! */
        3.287218585534296227263e+293,       /* 164! */
        5.423910666131588774984e+295,       /* 165! */
        9.003691705778437366474e+297,       /* 166! */
        1.503616514864999040201e+300,       /* 167! */
        2.526075744973198387538e+302,       /* 168! */
        4.269068009004705274939e+304,       /* 169! */
        7.257415615307998967397e+306        /* 170! */
	]

	log_factorials_table = [
    f64(0.000000000000000000000e+0),      /*   0! */
        0.000000000000000000000e+0,       /*   1! */
        6.931471805599453094172e-1,       /*   2! */
        1.791759469228055000812e+0,       /*   3! */
        3.178053830347945619647e+0,       /*   4! */
        4.787491742782045994248e+0,       /*   5! */
        6.579251212010100995060e+0,       /*   6! */
        8.525161361065414300166e+0,       /*   7! */
        1.060460290274525022842e+1,       /*   8! */
        1.280182748008146961121e+1,       /*   9! */
        1.510441257307551529523e+1,       /*  10! */
        1.750230784587388583929e+1,       /*  11! */
        1.998721449566188614952e+1,       /*  12! */
        2.255216385312342288557e+1,       /*  13! */
        2.519122118273868150009e+1,       /*  14! */
        2.789927138384089156609e+1,       /*  15! */
        3.067186010608067280376e+1,       /*  16! */
        3.350507345013688888401e+1,       /*  17! */
        3.639544520803305357622e+1,       /*  18! */
        3.933988418719949403622e+1,       /*  19! */
        4.233561646075348502966e+1,       /*  20! */
        4.538013889847690802616e+1,       /*  21! */
        4.847118135183522387964e+1,       /*  22! */
        5.160667556776437357045e+1,       /*  23! */
        5.478472939811231919009e+1,       /*  24! */
        5.800360522298051993929e+1,       /*  25! */
        6.126170176100200198477e+1,       /*  26! */
        6.455753862700633105895e+1,       /*  27! */
        6.788974313718153498289e+1,       /*  28! */
        7.125703896716800901007e+1,       /*  29! */
        7.465823634883016438549e+1,       /*  30! */
        7.809222355331531063142e+1,       /*  31! */
        8.155795945611503717850e+1,       /*  32! */
        8.505446701758151741396e+1,       /*  33! */
        8.858082754219767880363e+1,       /*  34! */
        9.213617560368709248333e+1,       /*  35! */
        9.571969454214320248496e+1,       /*  36! */
        9.933061245478742692933e+1,       /*  37! */
        1.029681986145138126988e+2,       /*  38! */
        1.066317602606434591262e+2,       /*  39! */
        1.103206397147573954291e+2,       /*  40! */
        1.140342117814617032329e+2,       /*  41! */
        1.177718813997450715388e+2,       /*  42! */
        1.215330815154386339623e+2,       /*  43! */
        1.253172711493568951252e+2,       /*  44! */
        1.291239336391272148826e+2,       /*  45! */
        1.329525750356163098828e+2,       /*  46! */
        1.368027226373263684696e+2,       /*  47! */
        1.406739236482342593987e+2,       /*  48! */
        1.445657439463448860089e+2,       /*  49! */
        1.484777669517730320675e+2,       /*  50! */
        1.524095925844973578392e+2,       /*  51! */
        1.563608363030787851941e+2,       /*  52! */
        1.603311282166309070282e+2,       /*  53! */
        1.643201122631951814118e+2,       /*  54! */
        1.683274454484276523305e+2,       /*  55! */
        1.723527971391628015638e+2,       /*  56! */
        1.763958484069973517152e+2,       /*  57! */
        1.804562914175437710518e+2,       /*  58! */
        1.845338288614494905025e+2,       /*  59! */
        1.886281734236715911873e+2,       /*  60! */
        1.927390472878449024360e+2,       /*  61! */
        1.968661816728899939914e+2,       /*  62! */
        2.010093163992815266793e+2,       /*  63! */
        2.051681994826411985358e+2,       /*  64! */
        2.093425867525368356464e+2,       /*  65! */
        2.135322414945632611913e+2,       /*  66! */
        2.177369341139542272510e+2,       /*  67! */
        2.219564418191303339501e+2,       /*  68! */
        2.261905483237275933323e+2,       /*  69! */
        2.304390435657769523214e+2,       /*  70! */
        2.347017234428182677427e+2,       /*  71! */
        2.389783895618343230538e+2,       /*  72! */
        2.432688490029827141829e+2,       /*  73! */
        2.475729140961868839366e+2,       /*  74! */
        2.518904022097231943772e+2,       /*  75! */
        2.562211355500095254561e+2,       /*  76! */
        2.605649409718632093053e+2,       /*  77! */
        2.649216497985528010421e+2,       /*  78! */
        2.692910976510198225363e+2,       /*  79! */
        2.736731242856937041486e+2,       /*  80! */
        2.780675734403661429141e+2,       /*  81! */
        2.824742926876303960274e+2,       /*  82! */
        2.868931332954269939509e+2,       /*  83! */
        2.913239500942703075662e+2,       /*  84! */
        2.957666013507606240211e+2,       /*  85! */
        3.002209486470141317540e+2,       /*  86! */
        3.046868567656687154726e+2,       /*  87! */
        3.091641935801469219449e+2,       /*  88! */
        3.136528299498790617832e+2,       /*  89! */
        3.181526396202093268500e+2,       /*  90! */
        3.226634991267261768912e+2,       /*  91! */
        3.271852877037752172008e+2,       /*  92! */
        3.317178871969284731381e+2,       /*  93! */
        3.362611819791984770344e+2,       /*  94! */
        3.408150588707990178690e+2,       /*  95! */
        3.453794070622668541074e+2,       /*  96! */
        3.499541180407702369296e+2,       /*  97! */
        3.545390855194408088492e+2,       /*  98! */
        3.591342053695753987760e+2,       /*  99! */
        3.637393755555634901441e+2,       /* 100! */
        3.683544960724047495950e+2,       /* 101! */
        3.729794688856890206760e+2,       /* 102! */
        3.776141978739186564468e+2,       /* 103! */
        3.822585887730600291111e+2,       /* 104! */
        3.869125491232175524822e+2,       /* 105! */
        3.915759882173296196258e+2,       /* 106! */
        3.962488170517915257991e+2,       /* 107! */
        4.009309482789157454921e+2,       /* 108! */
        4.056222961611448891925e+2,       /* 109! */
        4.103227765269373054205e+2,       /* 110! */
        4.150323067282496395563e+2,       /* 111! */
        4.197508055995447340991e+2,       /* 112! */
        4.244781934182570746677e+2,       /* 113! */
        4.292143918666515701285e+2,       /* 114! */
        4.339593239950148201939e+2,       /* 115! */
        4.387129141861211848399e+2,       /* 116! */
        4.434750881209189409588e+2,       /* 117! */
        4.482457727453846057188e+2,       /* 118! */
        4.530248962384961351041e+2,       /* 119! */
        4.578123879812781810984e+2,       /* 120! */
        4.626081785268749221865e+2,       /* 121! */
        4.674121995716081787447e+2,       /* 122! */
        4.722243839269805962399e+2,       /* 123! */
        4.770446654925856331047e+2,       /* 124! */
        4.818729792298879342285e+2,       /* 125! */
        4.867092611368394122258e+2,       /* 126! */
        4.915534482232980034989e+2,       /* 127! */
        4.964054784872176206648e+2,       /* 128! */
        5.012652908915792927797e+2,       /* 129! */
        5.061328253420348751997e+2,       /* 130! */
        5.110080226652360267439e+2,       /* 131! */
        5.158908245878223975982e+2,       /* 132! */
        5.207811737160441513633e+2,       /* 133! */
        5.256790135159950627324e+2,       /* 134! */
        5.305842882944334921812e+2,       /* 135! */
        5.354969431801695441897e+2,       /* 136! */
        5.404169241059976691050e+2,       /* 137! */
        5.453441777911548737966e+2,       /* 138! */
        5.502786517242855655538e+2,       /* 139! */
        5.552202941468948698523e+2,       /* 140! */
        5.601690540372730381305e+2,       /* 141! */
        5.651248810948742988613e+2,       /* 142! */
        5.700877257251342061414e+2,       /* 143! */
        5.750575390247102067619e+2,       /* 144! */
        5.800342727671307811636e+2,       /* 145! */
        5.850178793888391176022e+2,       /* 146! */
        5.900083119756178539038e+2,       /* 147! */
        5.950055242493819689670e+2,       /* 148! */
        6.000094705553274281080e+2,       /* 149! */
        6.050201058494236838580e+2,       /* 150! */
        6.100373856862386081868e+2,       /* 151! */
        6.150612662070848845750e+2,       /* 152! */
        6.200917041284773200381e+2,       /* 153! */
        6.251286567308909491967e+2,       /* 154! */
        6.301720818478101958172e+2,       /* 155! */
        6.352219378550597328635e+2,       /* 156! */
        6.402781836604080409209e+2,       /* 157! */
        6.453407786934350077245e+2,       /* 158! */
        6.504096828956552392500e+2,       /* 159! */
        6.554848567108890661717e+2,       /* 160! */
        6.605662610758735291676e+2,       /* 161! */
        6.656538574111059132426e+2,       /* 162! */
        6.707476076119126755767e+2,       /* 163! */
        6.758474740397368739994e+2,       /* 164! */
        6.809534195136374546094e+2,       /* 165! */
        6.860654073019939978423e+2,       /* 166! */
        6.911834011144107529496e+2,       /* 167! */
        6.963073650938140118743e+2,       /* 168! */
        7.014372638087370853465e+2,       /* 169! */
        7.065730622457873471107e+2,       /* 170! */
        7.117147258022900069535e+2,       /* 171! */
	]
)
import math
import math.factorial as fact

fn test_factorial() {
	assert fact.factorial(12) == 479001600
	assert fact.factorial(5) == 120
	assert fact.factorial(0) == 1
}

fn test_log_factorial() {
	assert fact.log_factorial(12) == math.log(479001600)
	assert fact.log_factorial(5) == math.log(120)
	assert fact.log_factorial(0) == math.log(1)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module fractions

import math

const (
	default_eps    = 1.0e-4
	max_iterations = 50
	zero           = fraction(0, 1)
)

// ------------------------------------------------------------------------
// Unwrapped evaluation methods for fast evaluation of continued fractions.
// ------------------------------------------------------------------------
// We need these functions because the evaluation of continued fractions
// always has to be done from the end. Also, the numerator-denominator pairs
// are generated from front to end. This means building a result from a
// previous one isn't possible. So we need unrolled versions to ensure that
// we don't take too much of a performance penalty by calling eval_cf
// several times.
// ------------------------------------------------------------------------
// eval_1 returns the result of evaluating a continued fraction series of length 1
fn eval_1(whole i64, d []i64) Fraction {
	return fraction(whole * d[0] + 1, d[0])
}

// eval_2 returns the result of evaluating a continued fraction series of length 2
fn eval_2(whole i64, d []i64) Fraction {
	den := d[0] * d[1] + 1
	return fraction(whole * den + d[1], den)
}

// eval_3 returns the result of evaluating a continued fraction series of length 3
fn eval_3(whole i64, d []i64) Fraction {
	d1d2_plus_n2 := d[1] * d[2] + 1
	den := d[0] * d1d2_plus_n2 + d[2]
	return fraction(whole * den + d1d2_plus_n2, den)
}

// eval_cf evaluates a continued fraction series and returns a Fraction.
fn eval_cf(whole i64, den []i64) Fraction {
	count := den.len
	// Offload some small-scale calculations
	// to dedicated functions
	match count {
		1 {
			return eval_1(whole, den)
		}
		2 {
			return eval_2(whole, den)
		}
		3 {
			return eval_3(whole, den)
		}
		else {
			last := count - 1
			mut n := i64(1)
			mut d := den[last]
			// The calculations are done from back to front
			for index := count - 2; index >= 0; index-- {
				t := d
				d = den[index] * d + n
				n = t
			}
			return fraction(d * whole + n, d)
		}
	}
}

// approximate returns a Fraction that approcimates the given value to
// within the default epsilon value (1.0e-4). This means the result will
// be accurate to 3 places after the decimal.
pub fn approximate(val f64) Fraction {
	return approximate_with_eps(val, default_eps)
}

// approximate_with_eps returns a Fraction
pub fn approximate_with_eps(val, eps f64) Fraction {
	if val == 0.0 {
		return zero
	}
	if eps < 0.0 {
		panic('Epsilon value cannot be negative.')
	}
	if math.fabs(val) > math.max_i64 {
		panic('Value out of range.')
	}
	// The integer part is separated first. Then we process the fractional
	// part to generate numerators and denominators in tandem.
	whole := i64(val)
	mut frac := val - f64(whole)
	// Quick exit for integers
	if frac == 0.0 {
		return fraction(whole, 1)
	}
	mut d := []i64{}
	mut partial := zero
	// We must complete the approximation within the maximum number of
	// itertations allowed. If we can't panic.
	// Empirically tested: the hardest constant to approximate is the
	// golden ratio (math.phi) and for f64s, it only needs 38 iterations.
	for _ in 0 .. max_iterations {
		// We calculate the reciprocal. That's why the numerator is
		// always 1.
		frac = 1.0 / frac
		den := i64(frac)
		d << den
		// eval_cf is called often so it needs to be performant
		partial = eval_cf(whole, d)
		// Check if we're done
		if math.fabs(val - partial.f64()) < eps {
			return partial
		}
		frac -= f64(den)
	}
	panic("Couldn\'t converge. Please create an issue on https://github.com/vlang/v")
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
import fractions
import math

fn test_half() {
	float_val := 0.5
	fract_val := fractions.approximate(float_val)
	assert fract_val.equals(fractions.fraction(1, 2))
}

fn test_third() {
	float_val := 1.0 / 3.0
	fract_val := fractions.approximate(float_val)
	assert fract_val.equals(fractions.fraction(1, 3))
}

fn test_minus_one_twelfth() {
	float_val := -1.0 / 12.0
	fract_val := fractions.approximate(float_val)
	assert fract_val.equals(fractions.fraction(-1, 12))
}

fn test_zero() {
	float_val := 0.0
	println('Pre')
	fract_val := fractions.approximate(float_val)
	println('Post')
	assert fract_val.equals(fractions.fraction(0, 1))
}

fn test_minus_one() {
	float_val := -1.0
	fract_val := fractions.approximate(float_val)
	assert fract_val.equals(fractions.fraction(-1, 1))
}

fn test_thirty_three() {
	float_val := 33.0
	fract_val := fractions.approximate(float_val)
	assert fract_val.equals(fractions.fraction(33, 1))
}

fn test_millionth() {
	float_val := 1.0 / 1000000.0
	fract_val := fractions.approximate(float_val)
	assert fract_val.equals(fractions.fraction(1, 1000000))
}

fn test_minus_27_by_57() {
	float_val := -27.0 / 57.0
	fract_val := fractions.approximate(float_val)
	assert fract_val.equals(fractions.fraction(-27, 57))
}

fn test_29_by_104() {
	float_val := 29.0 / 104.0
	fract_val := fractions.approximate(float_val)
	assert fract_val.equals(fractions.fraction(29, 104))
}

fn test_140710_232() {
	float_val := 140710.232
	fract_val := fractions.approximate(float_val)
	// Approximation will match perfectly for upto 3 places after the decimal
	// The result will be within default_eps of original value
	assert fract_val.f64() == float_val
}

fn test_pi_1_digit() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-2).equals(fractions.fraction(22, 7))
}

fn test_pi_2_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-3).equals(fractions.fraction(22, 7))
}

fn test_pi_3_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-4).equals(fractions.fraction(333, 106))
}

fn test_pi_4_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-5).equals(fractions.fraction(355, 113))
}

fn test_pi_5_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-6).equals(fractions.fraction(355, 113))
}

fn test_pi_6_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-7).equals(fractions.fraction(355, 113))
}

fn test_pi_7_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-8).equals(fractions.fraction(103993,
		33102))
}

fn test_pi_8_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-9).equals(fractions.fraction(103993,
		33102))
}

fn test_pi_9_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-10).equals(fractions.fraction(104348,
		33215))
}

fn test_pi_10_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-11).equals(fractions.fraction(312689,
		99532))
}

fn test_pi_11_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-12).equals(fractions.fraction(1146408,
		364913))
}

fn test_pi_12_digits() {
	assert fractions.approximate_with_eps(math.pi, 5.0e-13).equals(fractions.fraction(4272943,
		1360120))
}

fn test_phi_1_digit() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-2).equals(fractions.fraction(5, 3))
}

fn test_phi_2_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-3).equals(fractions.fraction(21, 13))
}

fn test_phi_3_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-4).equals(fractions.fraction(55, 34))
}

fn test_phi_4_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-5).equals(fractions.fraction(233,
		144))
}

fn test_phi_5_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-6).equals(fractions.fraction(610,
		377))
}

fn test_phi_6_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-7).equals(fractions.fraction(1597,
		987))
}

fn test_phi_7_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-8).equals(fractions.fraction(6765,
		4181))
}

fn test_phi_8_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-9).equals(fractions.fraction(17711,
		10946))
}

fn test_phi_9_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-10).equals(fractions.fraction(75025,
		46368))
}

fn test_phi_10_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-11).equals(fractions.fraction(196418,
		121393))
}

fn test_phi_11_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-12).equals(fractions.fraction(514229,
		317811))
}

fn test_phi_12_digits() {
	assert fractions.approximate_with_eps(math.phi, 5.0e-13).equals(fractions.fraction(2178309,
		1346269))
}// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module fractions

import math
import math.bits

// Fraction Struct
// ---------------
// A Fraction has a numerator (n) and a denominator (d). If the user uses
// the helper functions in this module, then the following are guaranteed:
// 1. If the user provides n and d with gcd(n, d) > 1, the fraction will
// not be reduced automatically.
// 2. d cannot be set to zero. The factory function will panic.
// 3. If provided d is negative, it will be made positive. n will change as well.
struct Fraction {
	n          i64
	d          i64
pub:
	is_reduced bool
}

// A factory function for creating a Fraction, adds a boundary condition
// to ensure that the denominator is non-zero. It automatically converts
// the negative denominator to positive and adjusts the numerator.
// NOTE: Fractions created are not reduced by default.
pub fn fraction(n, d i64) Fraction {
	if d == 0 {
		panic('Denominator cannot be zero')
	}
	// The denominator is always guaranteed to be positive (and non-zero).
	if d < 0 {
		return fraction(-n, -d)
	}
	return Fraction{
		n: n
		d: d
		is_reduced: math.gcd(n, d) == 1
	}
}

// To String method
pub fn (f Fraction) str() string {
	return '$f.n/$f.d'
}

//
// + ---------------------+
// | Arithmetic functions.|
// + ---------------------+
//
// These are implemented from Knuth, TAOCP Vol 2. Section 4.5
//
// Returns a correctly reduced result for both addition and subtraction
// NOTE: requires reduced inputs
fn general_addition_result(f1, f2 Fraction, addition bool) Fraction {
	d1 := math.gcd(f1.d, f2.d)
	// d1 happends to be 1 around 600/(pi)^2 or 61 percent of the time (Theorem 4.5.2D)
	if d1 == 1 {
		num1n2d := f1.n * f2.d
		num1d2n := f1.d * f2.n
		n := if addition { num1n2d + num1d2n } else { num1n2d - num1d2n }
		return Fraction{
			n: n
			d: f1.d * f2.d
			is_reduced: true
		}
	}
	// Here d1 > 1.
	f1den := f1.d / d1
	f2den := f2.d / d1
	term1 := f1.n * f2den
	term2 := f2.n * f1den
	t := if addition { term1 + term2 } else { term1 - term2 }
	d2 := math.gcd(t, d1)
	return Fraction{
		n: t / d2
		d: f1den * (f2.d / d2)
		is_reduced: true
	}
}

// Fraction add using operator overloading
pub fn (f1 Fraction) +(f2 Fraction) Fraction {
	return general_addition_result(f1.reduce(), f2.reduce(), true)
}

// Fraction subtract using operator overloading
pub fn (f1 Fraction) -(f2 Fraction) Fraction {
	return general_addition_result(f1.reduce(), f2.reduce(), false)
}

// Returns a correctly reduced result for both multiplication and division
// NOTE: requires reduced inputs
fn general_multiplication_result(f1, f2 Fraction, multiplication bool) Fraction {
	// * Theorem: If f1 and f2 are reduced i.e. gcd(f1.n, f1.d) ==  1 and gcd(f2.n, f2.d) == 1,
	// then gcd(f1.n * f2.n, f1.d * f2.d) == gcd(f1.n, f2.d) * gcd(f1.d, f2.n)
	// * Knuth poses this an exercise for 4.5.1. - Exercise 2
	// * Also, note that:
	// The terms are flipped for multiplication and division, so the gcds must be calculated carefully
	// We do multiple divisions in order to prevent any possible overflows.
	// * One more thing:
	// if d = gcd(a, b) for example, then d divides both a and b
	if multiplication {
		d1 := math.gcd(f1.n, f2.d)
		d2 := math.gcd(f1.d, f2.n)
		return Fraction{
			n: (f1.n / d1) * (f2.n / d2)
			d: (f2.d / d1) * (f1.d / d2)
			is_reduced: true
		}
	} else {
		d1 := math.gcd(f1.n, f2.n)
		d2 := math.gcd(f1.d, f2.d)
		return Fraction{
			n: (f1.n / d1) * (f2.d / d2)
			d: (f2.n / d1) * (f1.d / d2)
			is_reduced: true
		}
	}
}

// Fraction multiply using operator overloading
pub fn (f1 Fraction) *(f2 Fraction) Fraction {
	return general_multiplication_result(f1.reduce(), f2.reduce(), true)
}

// Fraction divide using operator overloading
pub fn (f1 Fraction) /(f2 Fraction) Fraction {
	if f2.n == 0 {
		panic('Cannot divive by zero')
	}
	// If the second fraction is negative, it will
	// mess up the sign. We need positive denominator
	if f2.n < 0 {
		return f1.negate() / f2.negate()
	}
	return general_multiplication_result(f1.reduce(), f2.reduce(), false)
}

// Fraction add method. Deprecated. Use the operator instead.
[deprecated]
pub fn (f1 Fraction) add(f2 Fraction) Fraction {
	return f1 + f2
}

// Fraction subtract method. Deprecated. Use the operator instead.
[deprecated]
pub fn (f1 Fraction) subtract(f2 Fraction) Fraction {
	return f1 - f2
}

// Fraction multiply method. Deprecated. Use the operator instead.
[deprecated]
pub fn (f1 Fraction) multiply(f2 Fraction) Fraction {
	return f1 * f2
}

// Fraction divide method. Deprecated. Use the operator instead.
[deprecated]
pub fn (f1 Fraction) divide(f2 Fraction) Fraction {
	return f1 / f2
}

// Fraction negate method
pub fn (f Fraction) negate() Fraction {
	return Fraction{
		n: -f.n
		d: f.d
		is_reduced: f.is_reduced
	}
}

// Fraction reciprocal method
pub fn (f Fraction) reciprocal() Fraction {
	if f.n == 0 {
		panic('Denominator cannot be zero')
	}
	return Fraction{
		n: f.d
		d: f.n
		is_reduced: f.is_reduced
	}
}

// Fraction method which reduces the fraction
pub fn (f Fraction) reduce() Fraction {
	if f.is_reduced {
		return f
	}
	cf := math.gcd(f.n, f.d)
	return Fraction{
		n: f.n / cf
		d: f.d / cf
		is_reduced: true
	}
}

// f64 converts the Fraction to 64-bit floating point
pub fn (f Fraction) f64() f64 {
	return f64(f.n) / f64(f.d)
}

//
// + ------------------+
// | Utility functions.|
// + ------------------+
//
// Returns the absolute value of an i64
fn abs(num i64) i64 {
	if num < 0 {
		return -num
	} else {
		return num
	}
}

fn cmp_i64s(a, b i64) int {
	if a == b {
		return 0
	} else if a > b {
		return 1
	} else {
		return -1
	}
}

fn cmp_f64s(a, b f64) int {
	// V uses epsilon comparison internally
	if a == b {
		return 0
	} else if a > b {
		return 1
	} else {
		return -1
	}
}

// Two integers are safe to multiply when their bit lengths
// sum up to less than 64 (conservative estimate).
fn safe_to_multiply(a, b i64) bool {
	return (bits.len_64(abs(a)) + bits.len_64(abs(b))) < 64
}

fn cmp(f1, f2 Fraction) int {
	if safe_to_multiply(f1.n, f2.d) && safe_to_multiply(f2.n, f1.d) {
		return cmp_i64s(f1.n * f2.d, f2.n * f1.d)
	} else {
		return cmp_f64s(f1.f64(), f2.f64())
	}
}

// +-----------------------------+
// | Public comparison functions |
// +-----------------------------+
// equals returns true if both the Fractions are equal
pub fn (f1 Fraction) equals(f2 Fraction) bool {
	return cmp(f1, f2) == 0
}

// ge returns true if f1 >= f2
pub fn (f1 Fraction) ge(f2 Fraction) bool {
	return cmp(f1, f2) >= 0
}

// gt returns true if f1 > f2
pub fn (f1 Fraction) gt(f2 Fraction) bool {
	return cmp(f1, f2) > 0
}

// le returns true if f1 <= f2
pub fn (f1 Fraction) le(f2 Fraction) bool {
	return cmp(f1, f2) <= 0
}

// lt returns true if f1 < f2
pub fn (f1 Fraction) lt(f2 Fraction) bool {
	return cmp(f1, f2) < 0
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
import math.fractions

// (Old) results are verified using https://www.calculatorsoup.com/calculators/math/fractions.php
// Newer ones are contrived for corner cases or prepared by hand.
fn test_4_by_8_f64_and_str() {
	f := fractions.fraction(4, 8)
	assert f.f64() == 0.5
	assert f.str() == '4/8'
}

fn test_10_by_5_f64_and_str() {
	f := fractions.fraction(10, 5)
	assert f.f64() == 2.0
	assert f.str() == '10/5'
}

fn test_9_by_3_f64_and_str() {
	f := fractions.fraction(9, 3)
	assert f.f64() == 3.0
	assert f.str() == '9/3'
}

fn test_4_by_minus_5_f64_and_str() {
	f := fractions.fraction(4, -5)
	assert f.f64() == -0.8
	assert f.str() == '-4/5'
}

fn test_minus_7_by_minus_92_str() {
	f := fractions.fraction(-7, -5)
	assert f.str() == '7/5'
}

fn test_4_by_8_plus_5_by_10() {
	f1 := fractions.fraction(4, 8)
	f2 := fractions.fraction(5, 10)
	sum := f1 + f2
	assert sum.f64() == 1.0
	assert sum.str() == '1/1'
	assert sum.equals(fractions.fraction(1, 1))
}

fn test_5_by_5_plus_8_by_8() {
	f1 := fractions.fraction(5, 5)
	f2 := fractions.fraction(8, 8)
	sum := f1 + f2
	assert sum.f64() == 2.0
	assert sum.str() == '2/1'
	assert sum.equals(fractions.fraction(2, 1))
}

fn test_9_by_3_plus_1_by_3() {
	f1 := fractions.fraction(9, 3)
	f2 := fractions.fraction(1, 3)
	sum := f1 + f2
	assert sum.str() == '10/3'
	assert sum.equals(fractions.fraction(10, 3))
}

fn test_3_by_7_plus_1_by_4() {
	f1 := fractions.fraction(3, 7)
	f2 := fractions.fraction(1, 4)
	sum := f1 + f2
	assert sum.str() == '19/28'
	assert sum.equals(fractions.fraction(19, 28))
}

fn test_36529_by_12409100000_plus_418754901_by_9174901000() {
	f1 := fractions.fraction(i64(36529), i64(12409100000))
	f2 := fractions.fraction(i64(418754901), i64(9174901000))
	sum := f1 + f2
	assert sum.str() == '5196706591957729/113852263999100000'
}

fn test_4_by_8_plus_minus_5_by_10() {
	f1 := fractions.fraction(4, 8)
	f2 := fractions.fraction(-5, 10)
	diff := f2 + f1
	assert diff.f64() == 0
	assert diff.str() == '0/1'
}

fn test_4_by_8_minus_5_by_10() {
	f1 := fractions.fraction(4, 8)
	f2 := fractions.fraction(5, 10)
	diff := f2 - f1
	assert diff.f64() == 0
	assert diff.str() == '0/1'
}

fn test_5_by_5_minus_8_by_8() {
	f1 := fractions.fraction(5, 5)
	f2 := fractions.fraction(8, 8)
	diff := f2 - f1
	assert diff.f64() == 0
	assert diff.str() == '0/1'
}

fn test_9_by_3_minus_1_by_3() {
	f1 := fractions.fraction(9, 3)
	f2 := fractions.fraction(1, 3)
	diff := f1 - f2
	assert diff.str() == '8/3'
}

fn test_3_by_7_minus_1_by_4() {
	f1 := fractions.fraction(3, 7)
	f2 := fractions.fraction(1, 4)
	diff := f1 - f2
	assert diff.str() == '5/28'
}

fn test_36529_by_12409100000_minus_418754901_by_9174901000() {
	f1 := fractions.fraction(i64(36529), i64(12409100000))
	f2 := fractions.fraction(i64(418754901), i64(9174901000))
	sum := f1 - f2
	assert sum.str() == '-5196036292040471/113852263999100000'
}

fn test_4_by_8_times_5_by_10() {
	f1 := fractions.fraction(4, 8)
	f2 := fractions.fraction(5, 10)
	product := f1 * f2
	assert product.f64() == 0.25
	assert product.str() == '1/4'
}

fn test_5_by_5_times_8_by_8() {
	f1 := fractions.fraction(5, 5)
	f2 := fractions.fraction(8, 8)
	product := f1 * f2
	assert product.f64() == 1.0
	assert product.str() == '1/1'
}

fn test_9_by_3_times_1_by_3() {
	f1 := fractions.fraction(9, 3)
	f2 := fractions.fraction(1, 3)
	product := f1 * f2
	assert product.f64() == 1.0
	assert product.str() == '1/1'
}

fn test_3_by_7_times_1_by_4() {
	f1 := fractions.fraction(3, 7)
	f2 := fractions.fraction(1, 4)
	product := f2 * f1
	assert product.f64() == (3.0 / 28.0)
	assert product.str() == '3/28'
}

fn test_4_by_8_over_5_by_10() {
	f1 := fractions.fraction(4, 8)
	f2 := fractions.fraction(5, 10)
	q := f1 / f2
	assert q.f64() == 1.0
	assert q.str() == '1/1'
}

fn test_5_by_5_over_8_by_8() {
	f1 := fractions.fraction(5, 5)
	f2 := fractions.fraction(8, 8)
	q := f1 / f2
	assert q.f64() == 1.0
	assert q.str() == '1/1'
}

fn test_9_by_3_over_1_by_3() {
	f1 := fractions.fraction(9, 3)
	f2 := fractions.fraction(1, 3)
	q := f1 / f2
	assert q.f64() == 9.0
	assert q.str() == '9/1'
}

fn test_3_by_7_over_1_by_4() {
	f1 := fractions.fraction(3, 7)
	f2 := fractions.fraction(1, 4)
	q := f1 / f2
	assert q.str() == '12/7'
}

fn test_reciprocal_4_by_8() {
	f := fractions.fraction(4, 8)
	assert f.reciprocal().str() == '8/4'
}

fn test_reciprocal_5_by_10() {
	f := fractions.fraction(5, 10)
	assert f.reciprocal().str() == '10/5'
}

fn test_reciprocal_5_by_5() {
	f := fractions.fraction(5, 5)
	assert f.reciprocal().str() == '5/5'
}

fn test_reciprocal_8_by_8() {
	f := fractions.fraction(8, 8)
	assert f.reciprocal().str() == '8/8'
}

fn test_reciprocal_9_by_3() {
	f := fractions.fraction(9, 3)
	assert f.reciprocal().str() == '3/9'
}

fn test_reciprocal_1_by_3() {
	f := fractions.fraction(1, 3)
	assert f.reciprocal().str() == '3/1'
}

fn test_reciprocal_7_by_3() {
	f := fractions.fraction(7, 3)
	assert f.reciprocal().str() == '3/7'
}

fn test_reciprocal_1_by_4() {
	f := fractions.fraction(1, 4)
	assert f.reciprocal().str() == '4/1'
}

fn test_4_by_8_equals_5_by_10() {
	f1 := fractions.fraction(4, 8)
	f2 := fractions.fraction(5, 10)
	assert f1.equals(f2)
}

fn test_1_by_2_does_not_equal_3_by_4() {
	f1 := fractions.fraction(1, 2)
	f2 := fractions.fraction(3, 4)
	assert !f1.equals(f2)
}

fn test_reduce_3_by_9() {
	f := fractions.fraction(3, 9)
	assert f.reduce().equals(fractions.fraction(1, 3))
}

fn test_1_by_3_less_than_2_by_4() {
	f1 := fractions.fraction(1, 3)
	f2 := fractions.fraction(2, 4)
	assert f1.lt(f2)
	assert f1.le(f2)
}

fn test_2_by_3_greater_than_2_by_4() {
	f1 := fractions.fraction(2, 3)
	f2 := fractions.fraction(2, 4)
	assert f1.gt(f2)
	assert f1.ge(f2)
}

fn test_5_by_7_not_less_than_2_by_4() {
	f1 := fractions.fraction(5, 7)
	f2 := fractions.fraction(2, 4)
	assert !f1.lt(f2)
	assert !f1.le(f2)
}

fn test_49_by_75_not_greater_than_2_by_3() {
	f1 := fractions.fraction(49, 75)
	f2 := fractions.fraction(2, 3)
	assert !f1.gt(f2)
	assert !f1.ge(f2)
}module stats

import math

// TODO: Implement all of them with generics

// This module defines the following statistical operations on f64 array
//  ---------------------------
// |   Summary of Functions    |
//  ---------------------------
// -----------------------------------------------------------------------
// freq - Frequency
// mean - Mean
// geometric_mean - Geometric Mean
// harmonic_mean - Harmonic Mean
// median - Median
// mode - Mode
// rms - Root Mean Square
// population_variance - Population Variance
// sample_variance - Sample Variance
// population_stddev - Population Standard Deviation
// sample_stddev - Sample Standard Deviation
// mean_absdev - Mean Absolute Deviation
// min - Minimum of the Array
// max - Maximum of the Array
// range - Range of the Array ( max - min )
// -----------------------------------------------------------------------


// Measure of Occurance
// Frequency of a given number
// Based on
// https://www.mathsisfun.com/data/frequency-distribution.html
pub fn freq(arr []f64, val f64) int {
	if arr.len == 0 {
		return 0
	}
	mut count := 0
	for v in arr {
		if v == val {
			count++
		}
	}
	return count
}

// Measure of Central Tendancy
// Mean of the given input array
// Based on
// https://www.mathsisfun.com/data/central-measures.html
pub fn mean(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	mut sum := f64(0)
	for v in arr {
		sum += v
	}
	return sum/f64(arr.len)
}

// Measure of Central Tendancy
// Geometric Mean of the given input array
// Based on
// https://www.mathsisfun.com/numbers/geometric-mean.html
pub fn geometric_mean(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	mut sum := f64(1)
	for v in arr {
		sum *= v
	}
	return math.pow(sum,f64(1)/arr.len)
}

// Measure of Central Tendancy
// Harmonic Mean of the given input array
// Based on
// https://www.mathsisfun.com/numbers/harmonic-mean.html
pub fn harmonic_mean(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	mut sum := f64(0)
	for v in arr {
		sum += f64(1)/v
	}
	return f64(arr.len)/sum
}

// Measure of Central Tendancy
// Median of the given input array ( input array is assumed to be sorted )
// Based on
// https://www.mathsisfun.com/data/central-measures.html
pub fn median(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	if arr.len % 2 == 0 {
		mid := (arr.len/2)-1
		return (arr[mid] + arr[mid+1])/f64(2)
	}
	else {
		return arr[((arr.len-1)/2)]
	}
}

// Measure of Central Tendancy
// Mode of the given input array
// Based on
// https://www.mathsisfun.com/data/central-measures.html
pub fn mode(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	mut freqs := []int{}
	for v in arr {
		freqs<<freq(arr,v)
	}
	mut max := 0
	for i in 0..freqs.len {
		if freqs[i] > freqs[max] {
			max = i
		}
	}
	return arr[max]
}

// Root Mean Square of the given input array
// Based on
// https://en.wikipedia.org/wiki/Root_mean_square
pub fn rms(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	mut sum := f64(0)
	for v in arr {
		sum += math.pow(v,2)
	}
	return math.sqrt(sum/f64(arr.len))
}

// Measure of Dispersion / Spread
// Population Variance of the given input array
// Based on
// https://www.mathsisfun.com/data/standard-deviation.html
pub fn population_variance(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	m := mean(arr)
	mut sum := f64(0)
	for v in arr {
		sum += math.pow(v-m,2)
	}
	return sum/f64(arr.len)
}

// Measure of Dispersion / Spread
// Sample Variance of the given input array
// Based on
// https://www.mathsisfun.com/data/standard-deviation.html
pub fn sample_variance(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	m := mean(arr)
	mut sum := f64(0)
	for v in arr {
		sum += math.pow(v-m,2)
	}
	return sum/f64(arr.len-1)
}

// Measure of Dispersion / Spread
// Population Standard Deviation of the given input array
// Based on
// https://www.mathsisfun.com/data/standard-deviation.html
pub fn population_stddev(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	return math.sqrt(population_variance(arr))
}

// Measure of Dispersion / Spread
// Sample Standard Deviation of the given input array
// Based on
// https://www.mathsisfun.com/data/standard-deviation.html
pub fn sample_stddev(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	return math.sqrt(sample_variance(arr))
}

// Measure of Dispersion / Spread
// Mean Absolute Deviation of the given input array
// Based on
// https://en.wikipedia.org/wiki/Average_absolute_deviation
pub fn mean_absdev(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	mean := mean(arr)
	mut sum := f64(0)
	for v in arr {
		sum += math.abs(v-mean)
	}
	return sum/f64(arr.len)
}

// Minimum of the given input array
pub fn min(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	mut min := arr[0]
	for v in arr {
		if v < min {
			min = v
		}
	}
	return min
}

// Maximum of the given input array
pub fn max(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	mut max := arr[0]
	for v in arr {
		if v > max {
			max = v
		}
	}
	return max
}

// Measure of Dispersion / Spread
// Range ( Maximum - Minimum ) of the given input array
// Based on
// https://www.mathsisfun.com/data/range.html
pub fn range(arr []f64) f64 {
	if arr.len == 0 {
		return f64(0)
	}
	return max(arr) - min(arr)
}
import math.stats as stats
import math

fn test_freq() {
	// Tests were also verified on Wolfram Alpha
	data := [f64(10.0),f64(10.0),f64(5.9),f64(2.7)]
	mut o := stats.freq(data,10.0)
	assert o == 2
	o = stats.freq(data,2.7)
	assert o == 1
	o = stats.freq(data,15)
	assert o == 0
}

fn tst_res(str1 string, str2 string) bool {
	if (math.abs(str1.f64() - str2.f64())) < 1e-5 {
		return true
	}
	return false
}

fn test_mean() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.mean(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '5.762500')
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.mean(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '17.650000')
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.mean(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '37.708000')
}

fn test_geometric_mean() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.geometric_mean(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(),'5.15993')
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.geometric_mean(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert o.str().eq('nan') || o.str().eq('-nan') || o.str().eq('-1.#IND00') || o == f64(0) || o.str().eq('-nan(ind)') // Because in math it yields a complex number
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.geometric_mean(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(),'25.064496')
}

fn test_harmonic_mean() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.harmonic_mean(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '4.626519')
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.harmonic_mean(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '9.134577')
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.harmonic_mean(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '16.555477')
}

fn test_median() {
	// Tests were also verified on Wolfram Alpha
	// Assumes sorted array

	// Even
	mut data := [f64(2.7),f64(4.45),f64(5.9),f64(10.0)]
	mut o := stats.median(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '5.175000')
	data = [f64(-3.0),f64(1.89),f64(4.4),f64(67.31)]
	o = stats.median(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '3.145000')
	data = [f64(7.88),f64(12.0),f64(54.83),f64(76.122)]
	o = stats.median(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '33.415000')

	// Odd
	data = [f64(2.7),f64(4.45),f64(5.9),f64(10.0),f64(22)]
	o = stats.median(data)
	assert o == f64(5.9)
	data = [f64(-3.0),f64(1.89),f64(4.4),f64(9),f64(67.31)]
	o = stats.median(data)
	assert o == f64(4.4)
	data = [f64(7.88),f64(3.3),f64(12.0),f64(54.83),f64(76.122)]
	o = stats.median(data)
	assert o == f64(12.0)
}

fn test_mode() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(2.7),f64(2.7),f64(4.45),f64(5.9),f64(10.0)]
	mut o := stats.mode(data)
	assert o == f64(2.7)
	data = [f64(-3.0),f64(1.89),f64(1.89),f64(1.89),f64(9),f64(4.4),f64(4.4),f64(9),f64(67.31)]
	o = stats.mode(data)
	assert o == f64(1.89)
	// Testing greedy nature
	data = [f64(2.0),f64(4.0),f64(2.0),f64(4.0)]
	o = stats.mode(data)
	assert o == f64(2.0)
}

fn test_rms() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.rms(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '6.362046')
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.rms(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '33.773393')
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.rms(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '47.452561')
}

fn test_population_variance() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.population_variance(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '7.269219')
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.population_variance(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '829.119550')
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.population_variance(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '829.852282')
}

fn test_sample_variance() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.sample_variance(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '9.692292')
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.sample_variance(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '1105.492733')
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.sample_variance(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '1106.469709')
}

fn test_population_stddev() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.population_stddev(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '2.696149')
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.population_stddev(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '28.794436')
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.population_stddev(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '28.807157')
}

fn test_sample_stddev() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.sample_stddev(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '3.113245')
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.sample_stddev(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '33.248951')
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.sample_stddev(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '33.263639')
}

fn test_mean_absdev() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.mean_absdev(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '2.187500')
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.mean_absdev(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '24.830000')
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.mean_absdev(data)
	// Some issue with precision comparison in f64 using == operator hence serializing to string
	assert tst_res(o.str(), '27.768000')
}

fn test_min() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.min(data)
	assert o == f64(2.7)
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.min(data)
	assert o == f64(-3.0)
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.min(data)
	assert o == f64(7.88)
}

fn test_max() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.max(data)
	assert o == f64(10.0)
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.max(data)
	assert o == f64(67.31)
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.max(data)
	assert o == f64(76.122)
}

fn test_range() {
	// Tests were also verified on Wolfram Alpha
	mut data := [f64(10.0),f64(4.45),f64(5.9),f64(2.7)]
	mut o := stats.range(data)
	assert o == f64(7.3)
	data = [f64(-3.0),f64(67.31),f64(4.4),f64(1.89)]
	o = stats.range(data)
	assert o == f64(70.31)
	data = [f64(12.0),f64(7.88),f64(76.122),f64(54.83)]
	o = stats.range(data)
	assert o == f64(68.242)
}

fn test_passing_empty() {
	data := []f64{}
	assert stats.freq(data,0) == 0
	assert stats.mean(data) == f64(0)
	assert stats.geometric_mean(data) == f64(0)
	assert stats.harmonic_mean(data) == f64(0)
	assert stats.median(data) == f64(0)
	assert stats.mode(data) == f64(0)
	assert stats.rms(data) == f64(0)
	assert stats.population_variance(data) == f64(0)
	assert stats.sample_variance(data) == f64(0)
	assert stats.population_stddev(data) == f64(0)
	assert stats.sample_stddev(data) == f64(0)
	assert stats.mean_absdev(data) == f64(0)
	assert stats.min(data) == f64(0)
	assert stats.max(data) == f64(0)
	assert stats.range(data) == f64(0)
}
module mysql

/* MYSQL CONNECT FLAGS */
pub const (
	// CAN_HANDLE_EXPIRED_PASSWORDS       = C.CAN_HANDLE_EXPIRED_PASSWORDS
	client_compress                    = C.CLIENT_COMPRESS
	client_found_rows                  = C.CLIENT_FOUND_ROWS
	client_ignore_sigpipe              = C.CLIENT_IGNORE_SIGPIPE
	client_ignore_space                = C.CLIENT_IGNORE_SPACE
	client_interactive                 = C.CLIENT_INTERACTIVE
	client_local_files                 = C.CLIENT_LOCAL_FILES
	client_multi_results               = C.CLIENT_MULTI_RESULTS
	client_multi_statements            = C.CLIENT_MULTI_STATEMENTS
	client_no_schema                   = C.CLIENT_NO_SCHEMA
	client_odbc                        = C.CLIENT_ODBC
	// client_optional_resultset_metadata = C.CLIENT_OPTIONAL_RESULTSET_METADATA
	client_ssl                         = C.CLIENT_SSL
	client_remember_options            = C.CLIENT_REMEMBER_OPTIONS
)

/* MYSQL REFRESH FLAGS */
pub const (
	refresh_grant   = u32(C.REFRESH_GRANT)
	refresh_log     = u32(C.REFRESH_LOG)
	refresh_tables  = u32(C.REFRESH_TABLES)
	refresh_hosts   = u32(C.REFRESH_HOSTS)
	refresh_status  = u32(C.REFRESH_STATUS)
	refresh_threads = u32(C.REFRESH_THREADS)
	refresh_slave   = u32(C.REFRESH_SLAVE)
	refresh_master  = u32(C.REFRESH_MASTER)
)
module mysql

pub enum FieldType {
	type_decimal
	type_tiny
	type_short
	type_long
	type_float
	type_double
	type_null
	type_timestamp
	type_longlong
	type_int24
	type_date
	type_time
	type_datetime
	type_year
	type_newdate
	type_varchar
	type_bit
	type_timestamp2
	type_datetime2
	type_time2
	type_json        = 245
	type_newdecimal
	type_enum
	type_set
	type_tiny_blob
	type_medium_blob
	type_long_blob
	type_blob
	type_var_string
	type_string
	type_geometry
}

pub fn (f FieldType) str() string {
	return match f {
		0    { 'decimal'     }
		1    { 'tiny'        }
		2    { 'short'       }
		3    { 'long'        }
		4    { 'float'       }
		5    { 'double'      }
		6    { 'null'        }
		7    { 'timestamp'   }
		8    { 'longlong'    }
		9    { 'int24'       }
		10   { 'date'        }
		11   { 'time'        }
		12   { 'datetime'    }
		13   { 'year'        }
		14   { 'newdate'     }
		15   { 'varchar'     }
		16   { 'bit'         }
		17   { 'timestamp2'  }
		18   { 'datetime2'   }
		19   { 'time2'       }
		245  { 'json'        }
		246  { 'newdecimal'  }
		247  { 'enum'        }
		248  { 'set'         }
		249  { 'tiny_blob'   }
		250  { 'medium_blob' }
		251  { 'long_blob'   }
		252  { 'blob'        }
		253  { 'var_string'  }
		254  { 'string'      }
		255  { 'geometry'    }
		else { 'unknown'     }
	}
}
module mysql

#flag -lmysqlclient
#flag linux -I/usr/include/mysql
#include <mysql.h>

pub struct Connection {
	host     string
	port     u32
	username string
	password string
	dbname   string
	flag     int
mut:
	conn     &C.MYSQL
}

pub fn new_connection(host, username, password, dbname string) ?Connection {
	instance := C.mysql_init(0)
	if isnil(instance) {
		return error_with_code(get_error_msg(instance), get_errno(instance))
	}
	return Connection{ host, 0, username, password, dbname, 0, instance }
}

pub fn (mut conn Connection) connect() ?bool {
	mut instance := C.mysql_init(0)
	if !isnil(conn.conn) {
		instance = conn.conn
	}
	if isnil(instance) {
		return error_with_code(get_error_msg(instance), get_errno(instance))
	}
	conn.conn = C.mysql_real_connect(
		instance,
		conn.host.str,
		conn.username.str,
		conn.password.str,
		conn.dbname.str,
		conn.port,
		0,
		conn.flag
	)
	if isnil(conn.conn) {
		return error_with_code(get_error_msg(instance), get_errno(instance))
	}
	return true
}

pub fn (conn Connection) query(q string) ?Result {
	if C.mysql_query(conn.conn, q.str) != 0 {
		return error_with_code(get_error_msg(conn.conn), get_errno(conn.conn))
	}
	res := C.mysql_store_result(conn.conn)
	return Result{res}
}

pub fn (conn Connection) select_db(dbname string) ?bool {
	if C.mysql_select_db(conn.conn, dbname.str) != 0 {
		return error_with_code(get_error_msg(conn.conn), get_errno(conn.conn))
	}
	return true
}

pub fn (conn Connection) change_user(username, password, dbname string) ?bool {
	mut ret := true
	if dbname != '' {
		ret = C.mysql_change_user(conn.conn, username.str, password.str, dbname.str)
	} else {
		ret = C.mysql_change_user(conn.conn, username.str, password.str, 0)
	}
	if !ret {
		return error_with_code(get_error_msg(conn.conn), get_errno(conn.conn))
	}
	return ret
}

pub fn (conn Connection) affected_rows() u64 {
	return C.mysql_affected_rows(conn.conn)
}

pub fn (conn Connection) autocommit(mode bool) {
	C.mysql_autocommit(conn.conn, mode)
}


pub fn (conn Connection) escape_string(s string) string {
    len := C.strlen(s.str)
    to := malloc(2 * len + 1)
    quote := byte(39) // single quote

    C.mysql_real_escape_string_quote(conn.conn, to, s.str, len, quote)
    return string(to)
}

pub fn (conn Connection) set_option(option_type int, val voidptr) {
	C.mysql_options(conn.conn, option_type, val)
}

pub fn (conn Connection) get_option(option_type int) ?voidptr {
	ret := voidptr(0)
	if C.mysql_get_option(conn.conn, option_type, &ret) != 0 {
		return error_with_code(get_error_msg(conn.conn), get_errno(conn.conn))
	}
	return ret
}

pub fn (conn Connection) refresh(options u32) ?bool {
	if C.mysql_refresh(conn.conn, options) != 0 {
		return error_with_code(get_error_msg(conn.conn), get_errno(conn.conn))
	}
	return true
}

pub fn (conn Connection) reset_connection() ?bool {
	if C.mysql_reset_connection(conn.conn) != 0 {
		return error_with_code(get_error_msg(conn.conn), get_errno(conn.conn))
	}
	return true
}

pub fn (conn Connection) ping() ?bool {
	if C.mysql_ping(conn.conn) != 0 {
		return error_with_code(get_error_msg(conn.conn), get_errno(conn.conn))
	}
	return true
}

pub fn (conn Connection) close() {
	C.mysql_close(conn.conn)
}

/* MYSQL INFO & VERSION */

pub fn (conn Connection) info() string {
	return string(C.mysql_info(conn.conn))
}

pub fn (conn Connection) get_host_info() string {
	return string(C.mysql_get_host_info(conn.conn))
}

pub fn (conn Connection) get_server_info() string {
	return string(C.mysql_get_server_info(conn.conn))
}

pub fn (conn Connection) get_server_version() u64 {
	return C.mysql_get_server_version(conn.conn)
}

pub fn get_client_version() u64 {
	return C.mysql_get_client_version()
}

pub fn get_client_info() string {
	return string(C.mysql_get_client_info())
}

/* MYSQL DEBUG */
pub fn (conn Connection) dump_debug_info() ?bool {
	if C.mysql_dump_debug_info(conn.conn) != 0 {
		return error_with_code(get_error_msg(conn.conn), get_errno(conn.conn))
	}
	return true
}

pub fn debug(debug string) {
	C.mysql_debug(debug.str)
}
module mysql

pub struct Result {
	result &C.MYSQL_RES
}

pub struct Row {
pub mut:
	vals []string
}

pub struct Field {
	name             string
	org_name         string
	table            string
	org_table        string
	db               string
	catalog          string
	def              string
	length           int
	max_length       int
	name_length      u32
	org_name_length  u32
	table_length     u32
	org_table_length u32
	db_length        u32
	catalog_length   u32
	def_length       u32
	flags            u32
	decimals         u32
	charsetnr        u32
	type_            FieldType
}

pub fn (r Result) fetch_row() &byteptr {
	return C.mysql_fetch_row(r.result)
}

pub fn (r Result) num_fields() int {
	return C.mysql_num_fields(r.result)
}

pub fn (r Result) rows() []Row {
	mut rows := []Row{}
	nr_cols := r.num_fields()
	for rr := r.fetch_row(); rr; rr = r.fetch_row() {
		mut row := Row{}
		for i in 0..nr_cols {
			if rr[i] == 0 {
				row.vals << ''
			} else {
				row.vals << string(&byte(rr[i]))
			}
		}
		rows << row
	}
	return rows
}

// maps return rows with `map` of columns instead `array` of columns
pub fn (r Result) maps() []map[string]string {
	mut array_map := []map[string]string{}
	rows := r.rows()
	fields := r.fetch_fields()
	for i in 0..rows.len {
		mut map_val := map[string]string
		for j in 0..fields.len {
			map_val[fields[j].name] = rows[i].vals[j]
		}
		array_map << map_val
	}
	return array_map
}

pub fn (r Result) fetch_fields() []Field {
	mut fields := []Field{}
	nr_cols := r.num_fields()
	orig_fields := C.mysql_fetch_fields(r.result)
	for i in 0..nr_cols {
		fields << Field{
			name: string(orig_fields[i].name)
			org_name: string(orig_fields[i].org_name)
			table: string(orig_fields[i].table)
			org_table: string(orig_fields[i].org_table)
			db: string(orig_fields[i].db)
			catalog: string(orig_fields[i].catalog)
			def: resolve_nil_str(orig_fields[i].def)
			length: orig_fields.length
			max_length: orig_fields.max_length
			name_length: orig_fields.name_length
			org_name_length: orig_fields.org_name_length
			table_length: orig_fields.table_length
			org_table_length: orig_fields.org_table_length
			db_length: orig_fields.db_length
			catalog_length: orig_fields.catalog_length
			def_length: orig_fields.def_length
			flags: orig_fields.flags
			decimals: orig_fields.decimals
			charsetnr: orig_fields.charsetnr
			type_: FieldType(orig_fields.@type)
		}
	}
	return fields
}

pub fn (f Field) str() string {
	return '
{
	name: "$f.name"
	org_name: "$f.org_name"
	table: "$f.table"
	org_table: "$f.org_table"
	db: "$f.db"
	catalog: "$f.catalog"
	def: "$f.def"
	length: $f.length
	max_length: $f.max_length
	name_length: $f.name_length
	org_name_length: $f.org_name_length
	table_length: $f.table_length
	org_table_length: $f.org_table_length
	db_length: $f.db_length
	catalog_length: $f.catalog_length
	def_length: $f.def_length
	flags: $f.flags
	decimals: $f.decimals
	charsetnr: $f.charsetnr
	type: ${f.type_.str()}
}
'
}

pub fn (r Result) free() {
	C.mysql_free_result(r.result)
}
module mysql

fn get_error_msg(conn &C.MYSQL) string {
	return string(C.mysql_error(conn))
}

fn get_errno(conn &C.MYSQL) int {
	return C.mysql_errno(conn)
}

fn resolve_nil_str(ptr byteptr) string {
	if isnil(ptr) {
		return ''
	}
	return string(ptr)
}
module mysql

struct C.MYSQL
struct C.MYSQL_RES
struct C.MYSQL_FIELD {
	name             byteptr /* Name of column */
	org_name         byteptr /* Original column name, if an alias */
	table            byteptr /* Table of column if column was a field */
	org_table        byteptr /* Org table name, if table was an alias */
	db               byteptr /* Database for table */
	catalog          byteptr /* Catalog for table */
	def              byteptr /* Default value (set by mysql_list_fields) */
	length           int     /* Width of column (create length) */
	max_length       int     /* Max width for selected set */
	name_length      u32
	org_name_length  u32
	table_length     u32
	org_table_length u32
	db_length        u32
	catalog_length   u32
	def_length       u32
	flags            u32     /* Div flags */
	decimals         u32     /* Number of decimals in field */
	charsetnr        u32     /* Character set */
	@type            int     /* Type of field. See mysql_com.h for types */
}

fn C.mysql_init(mysql &C.MYSQL) &C.MYSQL
fn C.mysql_real_connect(mysql &C.MYSQL, host byteptr, user byteptr, passwd byteptr, db byteptr, port u32, unix_socket byteptr, clientflag u64) &C.MYSQL
fn C.mysql_query(mysql &C.MYSQL, q byteptr) int
fn C.mysql_select_db(mysql &C.MYSQL, db byteptr) int
fn C.mysql_change_user(mysql &C.MYSQL, user byteptr, password byteptr, db byteptr) bool
fn C.mysql_affected_rows(mysql &C.MYSQL) u64
fn C.mysql_options(mysql &C.MYSQL, option int, arg voidptr) int
fn C.mysql_get_option(mysql &C.MYSQL, option int, arg voidptr) int
fn C.mysql_num_fields(res &C.MYSQL_RES) int
fn C.mysql_autocommit(mysql MYSQL, mode bool)
fn C.mysql_refresh(mysql MYSQL, options u32) int
fn C.mysql_reset_connection(mysql MYSQL) int
fn C.mysql_ping(mysql MYSQL) int
fn C.mysql_store_result(mysql &C.MYSQL) &C.MYSQL_RES
fn C.mysql_fetch_row(res &C.MYSQL_RES) &byteptr
fn C.mysql_fetch_fields(res &C.MYSQL_RES) &C.MYSQL_FIELD
fn C.mysql_free_result(res &C.MYSQL_RES)
fn C.mysql_real_escape_string_quote(mysql &C.MYSQL, to byteptr, from byteptr, len u64, quote byte) u64
fn C.mysql_close(sock &C.MYSQL)

/* INFO & VERSION */
fn C.mysql_info(mysql &C.MYSQL) byteptr
fn C.mysql_get_host_info(mysql &C.MYSQL) byteptr
fn C.mysql_get_server_info(mysql &C.MYSQL) byteptr
fn C.mysql_get_server_version(mysql &C.MYSQL) u64
fn C.mysql_get_client_version() u64
fn C.mysql_get_client_info() byteptr

/* DEBUG & ERROR INFO */
fn C.mysql_error(mysql &C.MYSQL) byteptr
fn C.mysql_errno(mysql &C.MYSQL) int
fn C.mysql_dump_debug_info(mysql &C.MYSQL) int
fn C.mysql_debug(debug byteptr)
module net

#include <sys/socket.h>
#include <unistd.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>
fn error_code() int {
	return C.errno
}

pub const (
	msg_nosignal = 0x4000
)

#flag solaris -lsocket
module net

#flag -lws2_32
#include <winsock2.h>
#include <Ws2tcpip.h>

struct C.WSAData {
mut:
	wVersion u16
	wHighVersion u16
	szDescription [257]byte
	szSystemStatus [129]byte
	iMaxSockets u16
	iMaxUdpDg u16
	lpVendorInfo byteptr
}


const (
	wsa_v22 = 0x202 // C.MAKEWORD(2, 2)
)

fn init() {
	mut wsadata := C.WSAData{}
	res := C.WSAStartup(wsa_v22, &wsadata)
	if res != 0 {
		panic('socket: WSAStartup failed')
	}
}

fn error_code() int {
	return C.WSAGetLastError()
}

pub const (
	msg_nosignal = 0
)
module net

fn C.gethostname() int
// hostname returns the host name reported by the kernel.
pub fn hostname() ?string {
	mut name := [256]byte
	// https://www.ietf.org/rfc/rfc1035.txt
	// The host name is returned as a null-terminated string.
	namebp := byteptr(name)
	res := C.gethostname(namebp, 256)
	if res != 0 {
		return error('net.hostname: failed with $res')
	}
	return tos_clone(namebp)
}

module net

import os

pub struct Socket {
pub:
	sockfd int
	family int
	typ    int
	proto  int
}

struct C.in_addr {
mut:
	s_addr int
}

struct C.sockaddr {
}

struct C.sockaddr_in {
mut:
	sin_family int
	sin_port   int
	sin_addr   C.in_addr
}

struct C.addrinfo {
mut:
	ai_family    int
	ai_socktype  int
	ai_flags     int
	ai_protocol  int
	ai_addrlen   int
	ai_addr      voidptr
	ai_canonname voidptr
	ai_next      voidptr
}

struct C.sockaddr_storage {
}

fn C.socket() int

fn C.setsockopt() int

fn C.htonl() int

fn C.htons() int

fn C.bind() int

fn C.listen() int

fn C.accept() int

fn C.getaddrinfo() int

fn C.connect() int

fn C.send() int

fn C.recv() int

fn C.read() int

fn C.shutdown() int

fn C.close() int

fn C.ntohs() int

fn C.getsockname() int

// create socket
pub fn new_socket(family, typ, proto int) ?Socket {
	sockfd := C.socket(family, typ, proto)
	one := 1
	// This is needed so that there are no problems with reusing the
	// same port after the application exits.
	C.setsockopt(sockfd, C.SOL_SOCKET, C.SO_REUSEADDR, &one, sizeof(int))
	if sockfd == -1 {
		return error('net.socket: failed')
	}
	s := Socket{
		sockfd: sockfd
		family: family
		typ: typ
		proto: proto
	}
	return s
}

pub fn socket_udp() ?Socket {
	return new_socket(C.AF_INET, C.SOCK_DGRAM, C.IPPROTO_UDP)
}

// set socket options
pub fn (s Socket) setsockopt(level, optname int, optvalue &int) ?int {
	res := C.setsockopt(s.sockfd, level, optname, optvalue, sizeof(&int))
	if res < 0 {
		return error('net.setsocketopt: failed with $res')
	}
	return res
}

// bind socket to port
pub fn (s Socket) bind(port int) ?int {
	mut addr := C.sockaddr_in{}
	addr.sin_family = s.family
	addr.sin_port = C.htons(port)
	addr.sin_addr.s_addr = C.htonl(C.INADDR_ANY)
	size := 16 // sizeof(C.sockaddr_in)
	tmp := voidptr(&addr)
	skaddr := &C.sockaddr(tmp)
	res := C.bind(s.sockfd, skaddr, size)
	if res < 0 {
		return error('net.bind: failed with $res')
	}
	return res
}

// put socket into passive mode and wait to receive
pub fn (s Socket) listen() ?int {
	backlog := 128
	res := C.listen(s.sockfd, backlog)
	if res < 0 {
		return error('net.listen: failed with $res')
	}
	$if debug {
		println('listen res = $res')
	}
	return res
}

// put socket into passive mode with user specified backlog and wait to receive
pub fn (s Socket) listen_backlog(backlog int) ?int {
	mut n := 0
	if backlog > 0 {
		n = backlog
	}
	res := C.listen(s.sockfd, n)
	if res < 0 {
		return error('net.listen_backlog: failed with $res')
	}
	return res
}

// helper method to create, bind, and listen given port number
pub fn listen(port int) ?Socket {
	$if debug {
		println('net.listen($port)')
	}
	s := new_socket(C.AF_INET, C.SOCK_STREAM, 0) or {
		return error(err)
	}
	_ = s.bind(port) or {
		return error(err)
	}
	_ = s.listen() or {
		return error(err)
	}
	return s
}

// accept first connection request from socket queue
pub fn (s Socket) accept() ?Socket {
	$if debug {
		println('accept()')
	}
	addr := C.sockaddr_storage{}
	size := 128 // sizeof(sockaddr_storage)
	tmp := voidptr(&addr)
	skaddr := &C.sockaddr(tmp)
	sockfd := C.accept(s.sockfd, skaddr, &size)
	if sockfd < 0 {
		return error('net.accept: failed with $sockfd')
	}
	c := Socket{
		sockfd: sockfd
		family: s.family
		typ: s.typ
		proto: s.proto
	}
	return c
}

// connect to given addrress and port
pub fn (s Socket) connect(address string, port int) ?int {
	mut hints := C.addrinfo{}
	hints.ai_family = s.family
	hints.ai_socktype = s.typ
	hints.ai_flags = C.AI_PASSIVE
	hints.ai_protocol = s.proto
	hints.ai_addrlen = 0
	hints.ai_canonname = C.NULL
	hints.ai_addr = C.NULL
	hints.ai_next = C.NULL
	info := &C.addrinfo(0)
	sport := '$port'
	info_res := C.getaddrinfo(address.str, sport.str, &hints, &info)
	if info_res != 0 {
		error_message := os.get_error_msg(error_code())
		return error('net.connect: getaddrinfo failed "$error_message"')
	}
	res := C.connect(s.sockfd, info.ai_addr, info.ai_addrlen)
	if res < 0 {
		error_message := os.get_error_msg(error_code())
		return error('net.connect: connect failed "$error_message"')
	}
	return res
}

// helper method to create socket and connect
pub fn dial(address string, port int) ?Socket {
	s := new_socket(C.AF_INET, C.SOCK_STREAM, 0) or {
		return error(err)
	}
	_ = s.connect(address, port) or {
		return error(err)
	}
	return s
}

// send data to socket (when you have a memory buffer)
pub fn (s Socket) send(buf byteptr, len int) ?int {
	mut dptr := buf
	mut dlen := len
	for {
		sbytes := C.send(s.sockfd, dptr, dlen, msg_nosignal)
		if sbytes < 0 {
			return error('net.send: failed with $sbytes')
		}
		dlen -= sbytes
		if dlen <= 0 {
			break
		}
		dptr += sbytes
	}
	return len
}

// send string data to socket (when you have a v string)
pub fn (s Socket) send_string(sdata string) ?int {
	return s.send(sdata.str, sdata.len)
}

// receive string data from socket. NB: you are responsible for freeing the returned byteptr
pub fn (s Socket) recv(bufsize int) (byteptr, int) {
	mut buf := byteptr(0)
	unsafe {
		buf = malloc(bufsize)
	}
	res := C.recv(s.sockfd, buf, bufsize, 0)
	return buf, res
}

// TODO: remove cread/2 and crecv/2 when the Go net interface is done
pub fn (s Socket) cread(buffer byteptr, buffersize int) int {
	return C.read(s.sockfd, buffer, buffersize)
}

// Receive a message from the socket, and place it in a preallocated buffer buf,
// with maximum message size bufsize. Returns the length of the received message.
pub fn (s Socket) crecv(buffer voidptr, buffersize int) int {
	return C.recv(s.sockfd, byteptr(buffer), buffersize, 0)
}

// shutdown and close socket
pub fn (s Socket) close() ?int {
	mut shutdown_res := 0
	$if windows {
		shutdown_res = C.shutdown(s.sockfd, C.SD_BOTH)
	} $else {
		shutdown_res = C.shutdown(s.sockfd, C.SHUT_RDWR)
	}
	// TODO: should shutdown throw an error? close will
	// continue even if shutdown failed
	// if shutdown_res < 0 {
	// return error('net.close: shutdown failed with $shutdown_res')
	// }
	mut res := 0
	$if windows {
		res = C.closesocket(s.sockfd)
	} $else {
		res = C.close(s.sockfd)
	}
	if res < 0 {
		return error('net.close: failed with $res')
	}
	return 0
}

pub const (
	crlf     = '\r\n'
	max_read = 400
	msg_peek = 0x02
)

// write - write a string with CRLF after it over the socket s
pub fn (s Socket) write(str string) ?int {
	line := '$str$crlf'
	res := C.send(s.sockfd, line.str, line.len, msg_nosignal)
	if res < 0 {
		return error('net.write: failed with $res')
	}
	return res
}

// read_line - retrieves a line from the socket s (i.e. a string ended with \n)
pub fn (s Socket) read_line() string {
	mut buf := [max_read]byte // where C.recv will store the network data
	mut res := '' // The final result, including the ending \n.
	for {
		mut line := '' // The current line. Can be a partial without \n in it.
		n := C.recv(s.sockfd, buf, max_read - 1, msg_peek)
		if n == -1 {
			return res
		}
		if n == 0 {
			return res
		}
		buf[n] = `\0`
		mut eol_idx := -1
		for i in 0 .. n {
			if int(buf[i]) == `\n` {
				eol_idx = i
				// Ensure that tos_clone(buf) later,
				// will return *only* the first line (including \n),
				// and ignore the rest
				buf[i + 1] = `\0`
				break
			}
		}
		bufbp := byteptr(buf)
		line = tos_clone(bufbp)
		if eol_idx > 0 {
			// At this point, we are sure that recv returned valid data,
			// that contains *at least* one line.
			// Ensure that the block till the first \n (including it)
			// is removed from the socket's receive queue, so that it does
			// not get read again.
			C.recv(s.sockfd, buf, eol_idx + 1, 0)
			res += line
			break
		}
		// recv returned a buffer without \n in it .
		C.recv(s.sockfd, buf, n, 0)
		res += line
		res += crlf
		break
	}
	return res
}

// TODO
pub fn (s Socket) read_all() string {
	mut buf := [max_read]byte // where C.recv will store the network data
	mut res := '' // The final result, including the ending \n.
	for {
		n := C.recv(s.sockfd, buf, max_read - 1, 0)
		if n == -1 {
			return res
		}
		if n == 0 {
			return res
		}
		bufbp := byteptr(buf)
		res += tos_clone(bufbp)
	}
	return res
}

pub fn (s Socket) get_port() int {
	mut addr := C.sockaddr_in{}
	size := 16 // sizeof(sockaddr_in)
	tmp := voidptr(&addr)
	skaddr := &C.sockaddr(tmp)
	C.getsockname(s.sockfd, skaddr, &size)
	return C.ntohs(addr.sin_port)
}
import net

fn setup() (net.Socket, net.Socket, net.Socket) {
	server := net.listen(0) or { panic(err)	}
	server_port := server.get_port()
	client := net.dial('127.0.0.1', server_port) or {	panic(err) }
	socket := server.accept() or { panic(err) }
	return server, client, socket
}

fn cleanup(server &net.Socket, client &net.Socket, socket &net.Socket) {
	server.close() or {}
	client.close() or {}
	socket.close() or {}
}

fn test_socket() {
	server, client, socket := setup()
	message := 'Hello World'
	socket.send(message.str, message.len) or { assert false }
	$if debug {	println('message send: $message')	}
	$if debug {	println('send socket: $socket.sockfd')	}

	bytes, blen := client.recv(1024)
	received := tos(bytes, blen)
	$if debug {	println('message received: $received')	}
	$if debug {	println('client: $client.sockfd')	}

	assert message == received
	cleanup(server, client, socket)
}

fn test_socket_write() {
	server, client, socket := setup()
	message1 := 'a message 1'
	socket.write(message1) or { assert false }
	line1 := client.read_line()
	assert line1 != message1
	assert line1.trim_space() == message1
	cleanup(server, client, socket)
}

fn test_socket_write_fail_without_panic() {
	server, client, socket := setup()
	message2 := 'a message 2'
	// ensure that socket.write (i.e. done on the server side)
	// continues to work, even when the client side has been disconnected
	// this test is important for a stable long standing server
	client.close() or {}
	$if solaris { return } // TODO: fix segfaulting on Solaris
	for i:=0; i<3; i++ {
		socket.write(message2) or {
			println('write to a socket without a recipient should produce an option fail: $err | $message2')
			assert true
		}
	}
	cleanup(server, client, socket)
}
import net

fn start_socket_udp_server() {
	bufsize := 1024
	bytes := [1024]byte
	s := net.socket_udp() or { panic(err) }
	_ = s.bind( 9876 ) or { panic(err) }
	println('Waiting for udp packets:')
	for {
		res := s.crecv(bytes, bufsize)
		if res < 0 { break }
		print('Received $res bytes: ' + tos(bytes, res))
	}
}

fn test_udp_server() {
	// start_socket_udp_server()
}
/*
basic ftp module
	RFC-959
	https://tools.ietf.org/html/rfc959

	Methods:
	ftp.connect(host)
	ftp.login(user, passw)
	pwd := ftp.pwd()
	ftp.cd(folder)
	dtp := ftp.pasv()
	ftp.dir()
	ftp.get(file)
	dtp.read()
	dtp.close()
	ftp.close()
*/
module ftp

import net

const (
	connected             = 220
	specify_password      = 331
	logged_in             = 230
	login_first           = 503
	anonymous             = 530
	open_data_connection  = 150
	close_data_connection = 226
	command_ok            = 200
	denied                = 550
	passive_mode          = 227
	complete              = 226
)

struct DTP {
mut:
	sock net.Socket
	ip   string
	port int
}

fn (dtp DTP) read() []byte {
	mut data := []byte{}
	for {
		buf, len := dtp.sock.recv(1024)
		if len == 0 {
			break
		}
		for i in 0 .. len {
			data << buf[i]
		}
		unsafe {
			free(buf)
		}
	}
	return data
}

fn (dtp DTP) close() {
	dtp.sock.close() or {
	}
}

struct FTP {
mut:
	sock        net.Socket
	buffer_size int
}

pub fn new() FTP {
	mut f := FTP{}
	f.buffer_size = 1024
	return f
}

fn (ftp FTP) write(data string) ?int {
	$if debug {
		println('FTP.v >>> $data')
	}
	n := ftp.sock.send_string('$data\r\n') or {
		return error('Cannot send data')
	}
	return n
}

fn (ftp FTP) read() (int, string) {
	mut data := ftp.sock.read_line()
	$if debug {
		println('FTP.v <<< $data')
	}
	if data.len < 5 {
		return 0, ''
	}
	code := data[..3].int()
	if data[3] == `-` {
		for {
			data = ftp.sock.read_line()
			if data[..3].int() == code && data[3] != `-` {
				break
			}
		}
	}
	return code, data
}

pub fn (mut ftp FTP) connect(ip string) bool {
	sock := net.dial(ip, 21) or {
		return false
	}
	ftp.sock = sock
	code, _ := ftp.read()
	if code == connected {
		return true
	}
	return false
}

pub fn (ftp FTP) login(user, passwd string) bool {
	ftp.write('USER $user') or {
		$if debug {
			println('ERROR sending user')
		}
		return false
	}
	mut code, mut data := ftp.read()
	if code == logged_in {
		return true
	}
	if code != specify_password {
		return false
	}
	ftp.write('PASS $passwd') or {
		$if debug {
			println('ERROR sending password')
		}
		return false
	}
	code, data = ftp.read()
	// TODO Replace `data` with `_`
	_ := data
	if code == logged_in {
		return true
	}
	return false
}

pub fn (ftp FTP) close() {
	send_quit := 'QUIT\r\n'
	ftp.sock.send_string(send_quit) or {
	}
	ftp.sock.close() or {
	}
}

pub fn (ftp FTP) pwd() string {
	ftp.write('PWD') or {
		return ''
	}
	_, data := ftp.read()
	spl := data.split('"')
	if spl.len >= 2 {
		return spl[1]
	}
	return data
}

pub fn (ftp FTP) cd(dir string) {
	ftp.write('CWD $dir') or {
		return
	}
	mut code, mut data := ftp.read()
	match int(code) {
		denied {
			$if debug {
				println('CD $dir denied!')
			}
		}
		complete {
			code, data = ftp.read()
		}
		else {}
	}
	$if debug {
		println('CD $data')
	}
}

fn new_dtp(msg string) ?DTP {
	if !is_dtp_message_valid(msg) {
		return error('Bad message')
	}
	ip, port := get_host_ip_from_dtp_message(msg)
	sock := net.dial(ip, port) or {
		return error('Cannot connect to the data channel')
	}
	dtp := DTP{
		sock: sock
		ip: ip
		port: port
	}
	return dtp
}

fn (ftp FTP) pasv() ?DTP {
	ftp.write('PASV') or {
	}
	code, data := ftp.read()
	$if debug {
		println('pass: $data')
	}
	if code != passive_mode {
		return error('pasive mode not allowed')
	}
	dtp := new_dtp(data) or {
		return error(err)
	}
	return dtp
}

pub fn (ftp FTP) dir() ?[]string {
	dtp := ftp.pasv() or {
		return error('cannot establish data connection')
	}
	ftp.write('LIST') or {
	}
	code, _ := ftp.read()
	if code == denied {
		return error('LIST denied')
	}
	if code != open_data_connection {
		return error('data channel empty')
	}
	list_dir := dtp.read()
	result, _ := ftp.read()
	if result != close_data_connection {
		println('LIST not ok')
	}
	dtp.close()
	mut dir := []string{}
	sdir := string(byteptr(list_dir.data))
	for lfile in sdir.split('\n') {
		if lfile.len > 1 {
			spl := lfile.split(' ')
			dir << spl[spl.len - 1]
		}
	}
	return dir
}

pub fn (ftp FTP) get(file string) ?[]byte {
	dtp := ftp.pasv() or {
		return error('Cannot stablish data connection')
	}
	ftp.write('RETR $file') or {
	}
	code, _ := ftp.read()
	if code == denied {
		return error('Permission denied')
	}
	if code != open_data_connection {
		return error('Data connection not ready')
	}
	blob := dtp.read()
	dtp.close()
	return blob
}

fn is_dtp_message_valid(msg string) bool {
	// An example of message:
	// '227 Entering Passive Mode (209,132,183,61,48,218)'
	return msg.contains('(') && msg.contains(')') && msg.contains(',')
}

fn get_host_ip_from_dtp_message(msg string) (string, int) {
	mut par_start_idx := -1
	mut par_end_idx := -1
	for i, c in msg {
		if c == `(` {
			par_start_idx = i + 1
		} else if c == `)` {
			par_end_idx = i
		}
	}
	data := msg[par_start_idx..par_end_idx].split(',')
	ip := data[0..4].join('.')
	port := data[4].int() * 256 + data[5].int()
	return ip, port
}
module main

import net.ftp

// NB: this function makes network calls to external servers,
// that is why it is not a very good idea to run it in CI.
// If you want to run it manually, use `v -d network vlib/net/ftp/ftp_test.v`
fn test_ftp_client() {
	$if !network ? { return }
	mut ftp := ftp.new()
	defer {
		ftp.close()
	}
	assert ftp.connect('ftp.redhat.com')
	assert ftp.login('ftp', 'ftp')
	pwd := ftp.pwd()
	assert pwd.len > 0
	ftp.cd('/')
	dir_list1 := ftp.dir() or {
		assert false
		return
	}
	assert dir_list1.len > 0
	ftp.cd('/suse/linux/enterprise/11Server/en/SAT-TOOLS/SRPMS/')
	dir_list2 := ftp.dir() or {
		assert false
		return
	}
	assert dir_list2.len > 0
	blob := ftp.get('katello-host-tools-3.3.5-8.sles11_4sat.src.rpm') or {
		assert false
		return
	}
	assert blob.len > 0
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module http

import strings

// On linux, prefer a localy build openssl, because it is
// much more likely for it to be newer, than the system
// openssl from libssl-dev. If there is no local openssl,
// the next flag is harmless, since it will still use the
// (older) system openssl.
#flag linux -I/usr/local/include/openssl -L/usr/local/lib
#flag -l ssl -l crypto
// MacPorts
#flag darwin -I/opt/local/include
#flag darwin -L/opt/local/lib
// Brew
#flag darwin -I/usr/local/opt/openssl/include
#flag darwin -L/usr/local/opt/openssl/lib
#include <openssl/ssl.h>

struct C.ssl_st {}

fn C.SSL_library_init()

fn C.TLSv1_2_method() voidptr

fn C.SSL_CTX_set_options()

fn C.SSL_CTX_new() voidptr

fn C.SSL_CTX_set_verify_depth()

fn C.SSL_CTX_load_verify_locations() int

fn C.BIO_new_ssl_connect() voidptr

fn C.BIO_set_conn_hostname() int

fn C.BIO_get_ssl()

fn C.SSL_set_cipher_list() int

fn C.BIO_do_connect() int

fn C.BIO_do_handshake() int

fn C.SSL_get_peer_certificate() int

fn C.SSL_get_verify_result() int

fn C.SSL_set_tlsext_host_name() int

fn C.BIO_puts()

fn C.BIO_read() int

fn C.BIO_free_all()

fn C.SSL_CTX_free()

fn init() int {
	C.SSL_library_init()
	return 1
}

fn (req &Request) ssl_do(port int, method, host_name, path string) ?Response {
	// ssl_method := C.SSLv23_method()
	ssl_method := C.TLSv1_2_method()
	ctx := C.SSL_CTX_new(ssl_method)
	C.SSL_CTX_set_verify_depth(ctx, 4)
	flags := C.SSL_OP_NO_SSLv2 | C.SSL_OP_NO_SSLv3 | C.SSL_OP_NO_COMPRESSION
	C.SSL_CTX_set_options(ctx, flags)
	mut res := C.SSL_CTX_load_verify_locations(ctx, 'random-org-chain.pem', 0)
	web := C.BIO_new_ssl_connect(ctx)
	addr := host_name + ':' + port.str()
	res = C.BIO_set_conn_hostname(web, addr.str)
	ssl := &C.ssl_st(0)
	C.BIO_get_ssl(web, &ssl)
	preferred_ciphers := 'HIGH:!aNULL:!kRSA:!PSK:!SRP:!MD5:!RC4'
	res = C.SSL_set_cipher_list(ssl, preferred_ciphers.str)
	if res != 1 {
		println('http: openssl: cipher failed')
	}
	res = C.SSL_set_tlsext_host_name(ssl, host_name.str)
	res = C.BIO_do_connect(web)
	if res != 1 {
		return error('cannot connect the endpoint')
	}
	res = C.BIO_do_handshake(web)
	C.SSL_get_peer_certificate(ssl)
	res = C.SSL_get_verify_result(ssl)
	// /////
	req_headers := req.build_request_headers(method, host_name, path)
	C.BIO_puts(web, req_headers.str)
	mut content := strings.new_builder(100)
	mut buff := [bufsize]byte
	mut readcounter := 0
	for {
		readcounter++
		len := C.BIO_read(web, buff, bufsize)
		if len <= 0 {
			break
		}
		$if debug_http ? {
			eprintln('ssl_do, read ${readcounter:4d} | len: $len')
			eprintln('-'.repeat(20))
			eprintln(tos(buff, len))
			eprintln('-'.repeat(20))
		}
		content.write_bytes(buff, len)
	}
	if web != 0 {
		C.BIO_free_all(web)
	}
	if ctx != 0 {
		C.SSL_CTX_free(ctx)
	}
	return parse_response(content.str())
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module http

#flag windows -I @VROOT/thirdparty/vschannel
#flag -l ws2_32 -l crypt32 -l secur32
 
#include "vschannel.c"

fn C.new_tls_context() C.TlsContext

fn (req &Request) ssl_do(port int, method, host_name, path string) ?Response {
	mut ctx := C.new_tls_context()
	C.vschannel_init(&ctx)

	mut buff := malloc(C.vsc_init_resp_buff_size)
	addr := host_name
	sdata := req.build_request_headers(method, host_name, path)
	length := int(C.request(&ctx, port, addr.to_wide(), sdata.str, &buff))

	C.vschannel_cleanup(&ctx)
	return parse_response(string(buff, length))
}
// Copyright (c) 2019 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module http

import time
import strings

pub struct Cookie {
pub mut:
	name        string
	value       string
	path        string // optional
	domain      string // optional
	expires     time.Time // optional
	raw_expires string // for reading cookies only. optional.
	// max_age=0 means no 'Max-Age' attribute specified.
	// max_age<0 means delete cookie now, equivalently 'Max-Age: 0'
	// max_age>0 means Max-Age attribute present and given in seconds
	max_age     int
	secure      bool
	http_only   bool
	same_site   SameSite
	raw         string
	unparsed    []string // Raw text of unparsed attribute-value pairs
}
// SameSite allows a server to define a cookie attribute making it impossible for
// the browser to send this cookie along with cross-site requests. The main
// goal is to mitigate the risk of cross-origin information leakage, and provide
// some protection against cross-site request forgery attacks.
//
// See https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.
pub enum SameSite {
	same_site_default_mode = 1
	same_site_lax_mode
	same_site_strict_mode
	same_site_none_mode
}

// Parses all "Set-Cookie" values from the header `h` and
// returns the successfully parsed Cookies.
pub fn read_set_cookies(h map[string][]string) []&Cookie {
	cookies_s := h['Set-Cookie']
	cookie_count := cookies_s.len
	if cookie_count == 0 {
		return []
	}
	mut cookies := []&Cookie{}
	for _, line in cookies_s {
		mut parts := line.trim_space().split(';')
		if parts.len == 1 && parts[0] == '' {
			continue
		}
		parts[0] = parts[0].trim_space()
		keyval := parts[0].split('=')
		if keyval.len != 2 {
			continue
		}
		name := keyval[0]
		raw_value := keyval[1]
		if !is_cookie_name_valid(name) {
			continue
		}
		value := parse_cookie_value(raw_value, true) or {
			continue
		}
		mut c  := &Cookie{
			name: name,
			value: value,
			raw: line
		}
		for i, _ in parts {
			parts[i] = parts[i].trim_space()
			if parts[i].len == 0 {
				continue
			}
			mut attr := parts[i]
			mut raw_val := ''
			if attr.contains('=') {
				pieces := attr.split('=')
				attr = pieces[0]
				raw_val = pieces[1]
			}
			lower_attr := attr.to_lower()
			val := parse_cookie_value(raw_val, false) or {
				c.unparsed << parts[i]
				continue
			}
			match lower_attr {
				'samesite' {
					lower_val := val.to_lower()
					match lower_val {
						'lax' { c.same_site = .same_site_lax_mode }
						'strict' { c.same_site = .same_site_strict_mode }
						'none' { c.same_site = .same_site_none_mode }
						else { c.same_site = .same_site_default_mode }
					}
				}
				'secure' {
					c.secure = true
					continue
				}
				'httponly' {
					c.http_only = true
					continue
				}
				'domain' {
					c.domain = val
					continue
				}
				'max-age' {
					mut secs := val.int()
					if secs != 0 && val[0] != `0` {
						break
					}
					if secs <= 0 {
						secs = -1
					}
					c.max_age = secs
					continue
				}
				// TODO: Fix this once time works better
				// 'expires' {
				// 	c.raw_expires = val
				// 	mut exptime := time.parse_iso(val)
				// 	if exptime.year == 0 {
				// 		exptime = time.parse_iso('Mon, 02-Jan-2006 15:04:05 MST')
				// 	}
				// 	c.expires = exptime
				// 	continue
				// }
				'path' {
					c.path = val
					continue
				}
				else {
					c.unparsed << parts[i]
				}
			}
		}
		cookies << c
	}
	return cookies
}

// Parses all "Cookie" values from the header `h` and
// returns the successfully parsed Cookies.
//
// if `filter` isn't empty, only cookies of that name are returned
pub fn read_cookies(h map[string][]string, filter string) []&Cookie {
	lines := h['Cookie']
	if lines.len == 0 {
		return []
	}
	mut cookies := []&Cookie{}
	for _, _line in lines {
		mut line := _line.trim_space()
		mut part := ''
		for line.len > 0 {
			if line.index_any(';') > 0 {
				line_parts := line.split(';')
				part = line_parts[0]
				line = line_parts[1]
			} else {
				part = line
				line = ''
			}
			part = part.trim_space()
			if part.len == 0 {
				continue
			}
			mut name := part
			mut val := ''
			if part.contains('=') {
				val_parts := part.split('=')
				name = val_parts[0]
				val = val_parts[1]
			}
			if !is_cookie_name_valid(name) {
				continue
			}
			if filter != '' && filter != name {
				continue
			}
			val = parse_cookie_value(val, true) or {
				continue
			}
			cookies << &Cookie{name: name, value: val}
		}
	}
	return cookies
}

// Returns the serialization of the cookie for use in a Cookie header
// (if only Name and Value are set) or a Set-Cookie response
// header (if other fields are set).
//
// If c.name is invalid, the empty string is returned.
pub fn (c &Cookie) str() string {
	if !is_cookie_name_valid(c.name) {
		return ''
	}
	// extra_cookie_length derived from typical length of cookie attributes
	// see RFC 6265 Sec 4.1.
	extra_cookie_length := 110
	mut b := strings.new_builder(c.name.len + c.value.len + c.domain.len + c.path.len + extra_cookie_length)
	b.write(c.name)
	b.write('=')
	b.write(sanitize_cookie_value(c.value))
	if c.path.len > 0 {
		b.write('; path=')
		b.write(sanitize_cookie_path(c.path))
	}
	if c.domain.len > 0 {
		if valid_cookie_domain(c.domain) {
			// A `domain` containing illegal characters is not
			// sanitized but simply dropped which turns the cookie
			// into a host-only cookie. A leading dot is okay
			// but won't be sent.
			mut d := c.domain
			if d[0] == `.` {
				d = d.substr(1, d.len)
			}
			b.write('; domain=')
			b.write(d)
		} else {
			// TODO: Log invalid cookie domain warning
		}
	}
	if c.expires.year > 1600 {
		e := c.expires
		time_str := '${e.weekday_str()}, ${e.day.str()} ${e.smonth()} ${e.year} ${e.hhmmss()} GMT'
		b.write('; expires=')
		b.write(time_str)
	}
	// TODO: Fix this. Techically a max age of 0 or less should be 0
	// We need a way to not have a max age.
	if c.max_age > 0 {
		b.write('; Max-Age=')
		b.write(c.max_age.str())
	} else if c.max_age < 0 {
		b.write('; Max-Age=0')
	}
	if c.http_only {
		b.write('; HttpOnly')
	}
	if c.secure {
		b.write('; Secure')
	}
	match c.same_site {
		.same_site_default_mode {
			b.write('; SameSite')
		}
		.same_site_none_mode {
			b.write('; SameSite=None')
		}
		.same_site_lax_mode {
			b.write('; SameSite=Lax')
		}
		.same_site_strict_mode {
			b.write('; SameSite=Strict')
		}
	}
	return b.str()
}

fn sanitize(valid fn(byte) bool, v string) string {
	mut ok := true
	for i in 0..v.len {
		if valid(v[i]) {
			continue
		}
		// TODO: Warn that we're dropping the invalid byte?
		ok = false
		break
	}
	if ok {
		return v
	}
	// TODO: Use `filter` instead of this nonesense
	buf := v.bytes()
	mut bytes := v.bytes()
	for i, _ in buf {
		if !valid(buf[i]) {
			bytes.delete(i)
		}
	}
	return string(bytes)
}

fn sanitize_cookie_name(name string) string {
	return name.replace_each(['\n', '-', '\r', '-'])
}

// https://tools.ietf.org/html/rfc6265#section-4.1.1
// cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
// cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
//           ; US-ASCII characters excluding CTLs,
//           ; whitespace DQUOTE, comma, semicolon,
//           ; and backslash
// We loosen this as spaces and commas are common in cookie values
// but we produce a quoted cookie-value in when value starts or ends
// with a comma or space.
pub fn sanitize_cookie_value(v string) string {
	val := sanitize(valid_cookie_value_byte, v)
	if v.len == 0 {
		return v
	}
	// Check for the existence of a space or comma
	if val.starts_with(' ') || val.ends_with(' ') || val.starts_with(',') || val.ends_with(',') {
		return '"$v"'
	}
	return v
}

fn sanitize_cookie_path(v string) string {
	return sanitize(valid_cookie_path_byte, v)
}

fn valid_cookie_value_byte(b byte) bool {
	return 0x20 <= b && b < 0x7f && b != `"` && b != `;` && b != `\\`
}

fn valid_cookie_path_byte(b byte) bool {
	return 0x20 <= b && b < 0x7f && b != `!`
}

fn valid_cookie_domain(v string) bool {
	if is_cookie_domain_name(v) {
		return true
	}
	// TODO
	// valid_ip := net.parse_ip(v) or {
	// 	false
	// }
	// if valid_ip {
	// 	return true
	// }
	return false
}

pub fn is_cookie_domain_name(_s string) bool {
	mut s := _s
	if s.len == 0 {
		return false
	}
	if s.len > 255 {
		return false
	}
	if s[0] == `.` {
		s = s.substr(1, s.len)
	}
	mut last := `.`
	mut ok := false
	mut part_len := 0
	for i, _ in s {
		c := s[i]
		if (`a` <= c && c <= `z`) || (`A` <= c && c <= `Z`) {
			// No '_' allowed here (in contrast to package net).
			ok = true
			part_len++
		} else if `0` <= c && c <= `9` {
			// fine
			part_len++
		} else if c == `-` {
			// Byte before dash cannot be dot.
			if last == `.` {
				return false
			}
			part_len++
		} else if c == `.` {
			// Byte before dot cannot be dot, dash.
			if last == `.` || last == `-` {
				return false
			}
			if part_len > 63 || part_len == 0 {
				return false
			}
			part_len = 0
		} else {
			 return false
		}
		last = c
	}
	if last == `-` || part_len > 63 {
		return false
	}
	return ok
}

fn parse_cookie_value(_raw string, allow_double_quote bool) ?string {
	mut raw := _raw
	// Strip the quotes, if present
	if allow_double_quote && raw.len > 1 && raw[0] == `"` && raw[raw.len - 1] == `"` {
		raw = raw.substr(1, raw.len - 1)
	}
	for i in 0..raw.len {
		if !valid_cookie_value_byte(raw[i]) {
			return error('http.cookie: invalid cookie value')
		}
	}
	return raw
}

fn is_cookie_name_valid(name string) bool {
	if name == '' {
		return false
	}
	for b in name {
		if b < 33 || b > 126 {
			return false
		}
	}
	return true
}
import net.http

struct SetCookieTestCase {
	cookie &http.Cookie
	raw string
}

struct ReadSetCookiesTestCase {
	header map[string][]string
	cookies []&http.Cookie
}

struct AddCookieTestCase {
	cookie []&http.Cookie
	raw string
}

const (
	write_set_cookie_tests = [
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-1', value: 'v1'},
			raw: 'cookie-1=v1'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-2', value: 'two', max_age: 3600},
			raw: 'cookie-2=two; Max-Age=3600'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-3', value: 'three', domain: '.example.com'},
			raw: 'cookie-3=three; domain=example.com'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-4', value: 'four', path: '/restricted/'},
			raw: 'cookie-4=four; path=/restricted/'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-5', value: 'five', domain: 'wrong;bad.abc'},
			raw: 'cookie-5=five'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-6', value: 'six', domain: 'bad-.abc'},
			raw: 'cookie-6=six'
		},
		// SetCookieTestCase{
		// 	cookie: &http.Cookie{name: 'cookie-7', value: 'seven', domain: '127.0.0.1'},
		// 	raw: 'cookie-7=seven; domain=127.0.0.1'
		// },
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-8', value: 'eight', domain: '::1'},
			raw: 'cookie-8=eight'
		},
		// {
		// 	cookie: &http.Cookie{name: 'cookie-9', value: 'expiring', expires: time.unix(1257894000, 0)},
		// 	'cookie-9=expiring; Expires=Tue, 10 Nov 2009 23:00:00 GMT',
		// },
		// According to IETF 6265 Section 5.1.1.5, the year cannot be less than 1601
		// SetCookieTestCase{
		// 	cookie: &http.Cookie{name: 'cookie-10', value: 'expiring-1601', expires: time.parse('Mon, 01 Jan 1601 01:01:01 GMT')},
		// 	raw: 'cookie-10=expiring-1601; Expires=Mon, 01 Jan 1601 01:01:01 GMT'
		// },
		// SetCookieTestCase{
		// 	cookie: &http.Cookie{name: 'cookie-11', value: 'invalid-expiry', expires: time.parse('Mon, 01 Jan 1600 01:01:01 GMT')},
		// 	raw: 'cookie-11=invalid-expiry'
		// },
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-12', value: 'samesite-default', same_site: .same_site_default_mode},
			raw: 'cookie-12=samesite-default; SameSite'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-13', value: 'samesite-lax', same_site: .same_site_lax_mode},
			raw: 'cookie-13=samesite-lax; SameSite=Lax'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-14', value: 'samesite-strict', same_site: .same_site_strict_mode},
			raw: 'cookie-14=samesite-strict; SameSite=Strict'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'cookie-15', value: 'samesite-none', same_site: .same_site_none_mode},
			raw: 'cookie-15=samesite-none; SameSite=None'
		},
		// The 'special' cookies have values containing commas or spaces which
		// are disallowed by RFC 6265 but are common in the wild.
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'special-1', value: 'a z'},
			raw: 'special-1=a z'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'special-2', value: ' z'},
			raw: 'special-2=" z"'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'special-3', value: 'a '},
			raw: 'special-3="a "'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'special-4', value: ' '},
			raw: 'special-4=" "'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'special-5', value: 'a,z'},
			raw: 'special-5=a,z'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'special-6', value: ',z'},
			raw: 'special-6=",z"'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'special-7', value: 'a,'},
			raw: 'special-7="a,"'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'special-8', value: ','},
			raw: 'special-8=","'
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'empty-value', value: ''},
			raw: 'empty-value='
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: ''},
			raw: ''
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: '\t'},
			raw: ''
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: '\r'},
			raw: ''
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'a\nb', value: 'v'},
			raw: ''
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'a\nb', value: 'v'},
			raw: ''
		},
		SetCookieTestCase{
			cookie: &http.Cookie{name: 'a\rb', value: 'v'},
			raw: ''
		},
	]
	add_cookies_tests = [
		AddCookieTestCase{
			cookie: [],
			raw: ""
		},
		AddCookieTestCase{
			cookie: [&http.Cookie{name: "cookie-1", value: "v1"}],
			raw: "cookie-1=v1"
		},
		AddCookieTestCase{
			cookie: [
				&http.Cookie{name: "cookie-1", value: "v1"},
				&http.Cookie{name: "cookie-2", value: "v2"},
				&http.Cookie{name: "cookie-3", value: "v3"}
			],
			raw: "cookie-1=v1; cookie-2=v2; cookie-3=v3"
		}
	]
	read_set_cookies_tests = [
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ["Cookie-1=v1"]},
			cookies: [&http.Cookie{name: "Cookie-1", value: "v1", raw: "Cookie-1=v1"}]
		},
		// ReadSetCookiesTestCase{
		// 	header: {"Set-Cookie": ["NID=99=YsDT5i3E-CXax-; expires=Wed, 23-Nov-2011 01:05:03 GMT; path=/; domain=.google.ch; HttpOnly"]},
		// 	cookies: [&http.Cookie{
		// 		name:       "NID",
		// 		value:      "99=YsDT5i3E-CXax-",
		// 		path:       "/",
		// 		domain:     ".google.ch",
		// 		http_only:   true,
		// 		expires:    time.parse_iso('Wed, 23-Nov-2011 01:05:03 GMT'),
		// 		raw_expires: "Wed, 23-Nov-2011 01:05:03 GMT",
		// 		raw:        "NID=99=YsDT5i3E-CXax-; expires=Wed, 23-Nov-2011 01:05:03 GMT; path=/; domain=.google.ch; HttpOnly"
		// 	}]
		// },
		// ReadSetCookiesTestCase{
		// 	header: {"Set-Cookie": [".ASPXAUTH=7E3AA; expires=Wed, 07-Mar-2012 14:25:06 GMT; path=/; HttpOnly"]},
		// 	cookies: [&http.Cookie{
		// 		name:       ".ASPXAUTH",
		// 		value:      "7E3AA",
		// 		path:       "/",
		// 		expires:    time.parse_iso('Wed, 07-Mar-2012 14:25:06 GMT'),
		// 		raw_expires: "Wed, 07-Mar-2012 14:25:06 GMT",
		// 		http_only:   true,
		// 		raw:        ".ASPXAUTH=7E3AA; expires=Wed, 07-Mar-2012 14:25:06 GMT; path=/; HttpOnly"
		// 	}]
		// },
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ["ASP.NET_SessionId=foo; path=/; HttpOnly"]},
			cookies: [&http.Cookie{
				name:     "ASP.NET_SessionId",
				value:    "foo",
				path:     "/",
				http_only: true,
				raw:      "ASP.NET_SessionId=foo; path=/; HttpOnly"
			}]
		},
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ["samesitedefault=foo; SameSite"]},
			cookies: [&http.Cookie{
				name:     "samesitedefault",
				value:    "foo",
				same_site: .same_site_default_mode,
				raw:      "samesitedefault=foo; SameSite"
			}]
		},
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ["samesitelax=foo; SameSite=Lax"]},
			cookies: [&http.Cookie{
				name:     "samesitelax",
				value:    "foo",
				same_site: .same_site_lax_mode,
				raw:      "samesitelax=foo; SameSite=Lax"
			}]
		},
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ["samesitestrict=foo; SameSite=Strict"]},
			cookies: [&http.Cookie{
				name:     "samesitestrict",
				value:    "foo",
				same_site: .same_site_strict_mode,
				raw:      "samesitestrict=foo; SameSite=Strict"
			}]
		},
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ["samesitenone=foo; SameSite=None"]},
			cookies: [&http.Cookie{
				name:     "samesitenone",
				value:    "foo",
				same_site: .same_site_none_mode,
				raw:      "samesitenone=foo; SameSite=None"
			}]
		},
		// Make sure we can properly read back the Set-Cookie headers we create
		// for values containing spaces or commas:
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ['special-1=a z']},
			cookies: [&http.Cookie{name: "special-1", value: "a z", raw: 'special-1=a z'}]
		},
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ['special-2=" z"']},
			cookies: [&http.Cookie{name: "special-2", value: " z", raw: 'special-2=" z"'}]
		},

		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ['special-3="a "']},
			cookies: [&http.Cookie{name: "special-3", value: "a ", raw: 'special-3="a "'}]
		},
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ['special-4=" "']},
			cookies: [&http.Cookie{name: "special-4", value: " ", raw: 'special-4=" "'}]
		},
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ['special-5=a,z']},
			cookies: [&http.Cookie{name: "special-5", value: "a,z", raw: 'special-5=a,z'}]
		},
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ['special-6=",z"']},
			cookies: [&http.Cookie{name: "special-6", value: ",z", raw: 'special-6=",z"'}]
		},
		ReadSetCookiesTestCase{
			header: {"Set-Cookie": ['special-7=","']},
			cookies: [&http.Cookie{name: "special-7", value: ",", raw: 'special-8=","'}]
		}
		// TODO(bradfitz): users have reported seeing this in the
		// wild, but do browsers handle it? RFC 6265 just says "don't
		// do that" (section 3) and then never mentions header folding
		// again.
		// Header{"Set-Cookie": ["ASP.NET_SessionId=foo; path=/; HttpOnly, .ASPXAUTH=7E3AA; expires=Wed, 07-Mar-2012 14:25:06 GMT; path=/; HttpOnly"]},
	]
)

fn test_write_set_cookies() {
	for _, tt in write_set_cookie_tests {
		assert tt.cookie.str() == tt.raw
	}
}

fn test_read_set_cookies() {
	for _, tt in read_set_cookies_tests {
		h := tt.header['Set-Cookie'][0]
		c := http.read_set_cookies(tt.header)
		println(h)
		println(c[0].str())
		assert c[0].str() == h
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module http

import os

pub fn download_file(url, out string) bool {
	println('download file url=$url out=$out')
	s := get(url) or {
		return false
	}
	os.write_file(out, s.text)
	return true
	// download_file_with_progress(url, out, empty, empty)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module http

type DownloadFn = fn (written int)

/*
struct DownloadStruct {
mut:
	stream  voidptr
	written int
	cb      DownloadFn
}
*/
fn download_cb(ptr voidptr, size, nmemb size_t, userp voidptr) {
	/*
	mut data := &DownloadStruct(userp)
	written := C.fwrite(ptr, size, nmemb, data.stream)
	data.written += written
	data.cb(data.written)
	//#data->cb(data->written); // TODO
	return written
*/
}

pub fn download_file_with_progress(url, out string, cb DownloadFn, cb_finished fn()) {
	/*
	curl := C.curl_easy_init()
	if isnil(curl) {
		return
	}
	cout := out.str
	fp := C.fopen(cout, 'wb')
	C.curl_easy_setopt(curl, CURLOPT_URL, url.str)
	C.curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, download_cb)
	data := &DownloadStruct {
		stream:fp
		cb: cb
	}
	C.curl_easy_setopt(curl, CURLOPT_WRITEDATA, data)
	mut d := 0.0
	C.curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &d)
	C.curl_easy_perform(curl)
	C.curl_easy_cleanup(curl)
	C.fclose(fp)
	cb_finished()
*/
}

fn empty() {
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module http

#flag -l Urlmon

#include <Urlmon.h>

fn download_file_with_progress(url, out string, cb, cb_finished voidptr) {
}

/*
pub fn download_file(url, out string) {
	C.URLDownloadToFile(0, url.to_wide(), out.to_wide(), 0, 0)
	/*
	if (res == S_OK) {
	println('Download Ok')
	# } else if(res == E_OUTOFMEMORY) {
	println('Buffer length invalid, or insufficient memory')
	# } else if(res == INET_E_DOWNLOAD_FAILURE) {
	println('URL is invalid')
	# } else {
	# printf("Download error: %d\n", res);
	# }
	*/
}
*/
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module http

import net.urllib
import net.http.chunked
import strings
import net

const (
	max_redirects        = 4
	content_type_default = 'text/plain'
	bufsize = 1536
)

pub struct Request {
pub mut:
	method     string
	headers    map[string]string
	cookies    map[string]string
	data       string
	url        string
	user_agent string = 'v.http'
	verbose    bool
	user_ptr   voidptr
	ws_func    voidptr
}

pub struct FetchConfig {
pub mut:
	method     string
	data       string
	params     map[string]string
	headers    map[string]string
	cookies    map[string]string
	user_agent string = 'v.http'
	verbose    bool = false
}

pub struct Response {
pub:
	text        string
	headers     map[string]string
	cookies     map[string]string
	status_code int
}

pub fn new_request(method, url_, data string) ?Request {
	url := if method == 'GET' { url_ + '?' + data } else { url_ }
	//println('new req() method=$method url="$url" dta="$data"')
	return Request{
		method: method.to_upper()
		url: url
		data: data
		/*
		headers: {
			'Accept-Encoding': 'compress'
		}
		*/
	}
}

pub fn get(url string) ?Response {
	return fetch_with_method('GET', url, FetchConfig{})
}

pub fn post(url, data string) ?Response {
	return fetch_with_method('POST', url, {
		data: data
		headers: {
			'Content-Type': content_type_default
		}
	})
}

pub fn post_form(url string, data map[string]string) ?Response {
	return fetch_with_method('POST', url, {
		headers: {
			'Content-Type': 'application/x-www-form-urlencoded'
		}
		data: url_encode_form_data(data)
	})
}

pub fn put(url, data string) ?Response {
	return fetch_with_method('PUT', url, {
		data: data
		headers: {
			'Content-Type': content_type_default
		}
	})
}

pub fn patch(url, data string) ?Response {
	return fetch_with_method('PATCH', url, {
		data: data
		headers: {
			'Content-Type': content_type_default
		}
	})
}

pub fn head(url string) ?Response {
	return fetch_with_method('HEAD', url, FetchConfig{})
}

pub fn delete(url string) ?Response {
	return fetch_with_method('DELETE', url, FetchConfig{})
}

pub fn fetch(_url string, config FetchConfig) ?Response {
	if _url == '' {
		return error('http.fetch: empty url')
	}
	url := build_url_from_fetch(_url, config) or {
		return error('http.fetch: invalid url ${_url}')
	}
	data := config.data
	method := config.method.to_upper()
	req := Request{
		method: method
		url: url
		data: data
		headers: config.headers
		cookies: config.cookies
		user_agent: config.user_agent
		ws_func: 0
		user_ptr: 0
		verbose: config.verbose
	}
	res := req.do() or {
		return error(err)
	}
	return res
}

pub fn get_text(url string) string {
	resp := fetch(url, {
		method: 'GET'
	}) or {
		return ''
	}
	return resp.text
}

pub fn url_encode_form_data(data map[string]string) string {
	mut pieces := []string{}
	for _key, _value in data {
		key := urllib.query_escape(_key)
		value := urllib.query_escape(_value)
		pieces << '$key=$value'
	}
	return pieces.join('&')
}

fn fetch_with_method(method, url string, _config FetchConfig) ?Response {
	mut config := _config
	config.method = method
	return fetch(url, config)
}

fn build_url_from_fetch(_url string, config FetchConfig) ?string {
	mut url := urllib.parse(_url) or {
		return error(err)
	}
	params := config.params
	if params.keys().len == 0 {
		return url.str()
	}
	mut pieces := []string{}
	for key in params.keys() {
		pieces << '${key}=${params[key]}'
	}
	mut query := pieces.join('&')
	if url.raw_query.len > 1 {
		query = url.raw_query + '&' + query
	}
	url.raw_query = query
	return url.str()
}

fn (mut req Request) free() {
	req.headers.free()
}

fn (mut resp Response) free() {
	resp.headers.free()
}

// add_header adds the key and value of an HTTP request header
pub fn (mut req Request) add_header(key, val string) {
	req.headers[key] = val
}

pub fn parse_headers(lines []string) map[string]string {
	mut headers := map[string]string{}
	for i, line in lines {
		if i == 0 {
			continue
		}
		words := line.split(': ')
		if words.len != 2 {
			continue
		}
		headers[words[0]] = words[1]
	}
	return headers
}

// do will send the HTTP request and returns `http.Response` as soon as the response is recevied
pub fn (req &Request) do() ?Response {
	mut url := urllib.parse(req.url) or {
		return error('http.Request.do: invalid url ${req.url}')
	}
	mut rurl := url
	mut resp := Response{}
	mut no_redirects := 0
	for {
		if no_redirects == max_redirects {
			return error('http.request.do: maximum number of redirects reached ($max_redirects)')
		}
		qresp := req.method_and_url_to_response(req.method, rurl) or {
			return error(err)
		}
		resp = qresp
		if resp.status_code !in [301, 302, 303, 307, 308] {
			break
		}
		// follow any redirects
		mut redirect_url := resp.headers['Location']
		if redirect_url.len > 0 && redirect_url[0] == `/` {
			url.set_path(redirect_url) or {
				return error('http.request.do: invalid path in redirect: "$redirect_url"')
			}
			redirect_url = url.str()
		}
		qrurl := urllib.parse(redirect_url) or {
			return error('http.request.do: invalid URL in redirect "$redirect_url"')
		}
		rurl = qrurl
		no_redirects++
	}
	return resp
}

fn (req &Request) method_and_url_to_response(method string, url urllib.URL) ?Response {
	host_name := url.hostname()
	scheme := url.scheme
	p := url.path.trim_left('/')
	path := if url.query().size > 0 { '/$p?${url.query().encode()}' } else { '/$p' }
	mut nport := url.port().int()
	if nport == 0 {
		if scheme == 'http' {
			nport = 80
		}
		if scheme == 'https' {
			nport = 443
		}
	}
	// println('fetch $method, $scheme, $host_name, $nport, $path ')
	if scheme == 'https' {
		// println('ssl_do( $nport, $method, $host_name, $path )')
		res := req.ssl_do(nport, method, host_name, path) or {
			return error(err)
		}
		return res
	} else if scheme == 'http' {
		// println('http_do( $nport, $method, $host_name, $path )')
		res := req.http_do(nport, method, host_name, path) or {
			return error(err)
		}
		return res
	}
	return error('http.request.method_and_url_to_response: unsupported scheme: "$scheme"')
}

fn parse_response(resp string) Response {
	// TODO: Header data type
	mut headers := map[string]string{}
	// TODO: Cookie data type
	mut cookies := map[string]string{}
	first_header := resp.all_before('\n')
	mut status_code := 0
	if first_header.contains('HTTP/') {
		val := first_header.find_between(' ', ' ')
		status_code = val.int()
	}
	mut text := ''
	// Build resp headers map and separate the body
	mut nl_pos := 3
	mut i := 1
	for {
		old_pos := nl_pos
		nl_pos = resp.index_after('\n', nl_pos + 1)
		if nl_pos == -1 {
			break
		}
		h := resp[old_pos + 1..nl_pos]
		// End of headers
		if h.len <= 1 {
			text = resp[nl_pos + 1..]
			break
		}
		i++
		pos := h.index(':') or {
			continue
		}
		// if h.contains('Content-Type') {
		// continue
		// }
		key := h[..pos]
		val := h[pos + 2..]
		if key == 'Set-Cookie' {
			parts := val.trim_space().split('=')
			cookies[parts[0]] = parts[1]
		}
		headers[key] = val.trim_space()
	}
	if headers['Transfer-Encoding'] == 'chunked' || headers['Content-Length'] == '' {
		text = chunked.decode(text)
	}
	return Response{
		status_code: status_code
		headers: headers
		cookies: cookies
		text: text
	}
}

fn (req &Request) build_request_headers(method, host_name, path string) string {
	ua := req.user_agent
	mut uheaders := []string{}
	if 'Host' !in req.headers {
		uheaders << 'Host: $host_name\r\n'
	}
	if 'User-Agent' !in req.headers {
		uheaders << 'User-Agent: $ua\r\n'
	}
	if req.data.len > 0 && 'Content-Length' !in req.headers {
		uheaders << 'Content-Length: ${req.data.len}\r\n'
	}
	for key, val in req.headers {
		if key == 'Cookie' {
			continue
		}
		uheaders << '${key}: ${val}\r\n'
	}
	uheaders << req.build_request_cookies_header()
	return '$method $path HTTP/1.1\r\n' + uheaders.join('') + 'Connection: close\r\n\r\n' +
		req.data
}

fn (req &Request) build_request_cookies_header() string {
	if req.cookies.keys().len < 1 {
		return ''
	}
	mut cookie := []string{}
	for key, val in req.cookies {
		cookie << '$key: $val'
	}
	if 'Cookie' in req.headers && req.headers['Cookie'] != '' {
		cookie << req.headers['Cookie']
	}
	return 'Cookie: ' + cookie.join('; ') + '\r\n'
}

pub fn unescape_url(s string) string {
	panic('http.unescape_url() was replaced with urllib.query_unescape()')
}

pub fn escape_url(s string) string {
	panic('http.escape_url() was replaced with urllib.query_escape()')
}

pub fn unescape(s string) string {
	panic('http.unescape() was replaced with http.unescape_url()')
}

pub fn escape(s string) string {
	panic('http.escape() was replaced with http.escape_url()')
}

fn (req &Request) http_do(port int, method, host_name, path string) ?Response {
	rbuffer := [bufsize]byte
	mut sb := strings.new_builder(100)
	s := req.build_request_headers(method, host_name, path)
	client := net.dial(host_name, port) or {
		return error(err)
	}
	client.send(s.str, s.len) or {
	}
	for {
		readbytes := client.crecv(rbuffer, bufsize)
		if readbytes < 0 {
			return error('http.request.http_do: error reading response. readbytes=$readbytes')
		}
		if readbytes == 0 {
			break
		}
		sb.write(tos(rbuffer, readbytes))
	}
	client.close() or {
	}
	return parse_response(sb.str())
}
module http //internal tests have access to *everything in the module*

import json

struct HttpbinResponseBody {
	args    map[string]string
	data    string
	files   map[string]string
	form    map[string]string
	headers map[string]string
	json    ?map[string]string
	origin  string
	url     string
}


fn http_fetch_mock(_methods []string, _config FetchConfig) ?[]Response {
	url := 'https://httpbin.org/'
	methods := if _methods.len == 0 { ['GET', 'POST', 'PATCH', 'PUT', 'DELETE'] } else { _methods }
	mut config := _config
	mut result := []Response{}
	// Note: httpbin doesn't support head
	for method in methods {
		lmethod := method.to_lower()
		config.method = method
		res := fetch(url + lmethod, config) or {
			return error(err)
		}
		// TODO
		// body := json.decode(HttpbinResponseBody,res.text) or {
		// return error(err)
		// }
		result << res
	}
	return result
}

fn test_http_fetch_bare() {
	$if !network ? { return }
	responses := http_fetch_mock([], FetchConfig{}) or {
		panic(err)
	}
	for response in responses {
		assert response.status_code == 200
	}
}

fn test_http_fetch_with_data() {
	$if !network ? { return }
	responses := http_fetch_mock(['POST', 'PUT', 'PATCH', 'DELETE'], {
		data: 'hello world'
	}) or {
		panic(err)
	}
	for response in responses {
		payload := json.decode(HttpbinResponseBody,response.text) or {
			panic(err)
		}
		assert payload.data == 'hello world'
	}
}

fn test_http_fetch_with_params() {
	$if !network ? { return }
	responses := http_fetch_mock([], {
		params: {
			'a': 'b',
			'c': 'd'
		}
	}) or {
		panic(err)
	}
	for response in responses {
		// payload := json.decode(HttpbinResponseBody,response.text) or {
		// panic(err)
		// }
		assert response.status_code == 200
		// TODO
		// assert payload.args['a'] == 'b'
		// assert payload.args['c'] == 'd'
	}
}

fn test_http_fetch_with_headers() {
	$if !network ? { return }
	responses := http_fetch_mock([], {
		headers: {
			'Test-Header': 'hello world'
		}
	}) or {
		panic(err)
	}
	for response in responses {
		// payload := json.decode(HttpbinResponseBody,response.text) or {
		// panic(err)
		// }
		assert response.status_code == 200
		// TODO
		// assert payload.headers['Test-Header'] == 'hello world'
	}
}
import net.http

fn test_http_get() {
	$if !network ? { return }
	assert http.get_text('https://vlang.io/version') == '0.1.5'
	println('http ok')
}

fn test_http_get_from_vlang_utc_now() {
	$if !network ? { return }
	urls := ['http://vlang.io/utc_now', 'https://vlang.io/utc_now']
	for url in urls {
		println('Test getting current time from $url by http.get')
		res := http.get(url) or { panic(err) }
		assert 200 == res.status_code
		assert res.text.len > 0
		assert res.text.int() > 1566403696
		println('Current time is: ${res.text.int()}')
	}
}

fn test_public_servers() {
	$if !network ? { return }
	urls := [
		'http://github.com/robots.txt',
		'http://google.com/robots.txt',
		'http://yahoo.com/robots.txt',
		'https://github.com/robots.txt',
		'https://google.com/robots.txt',
		'https://yahoo.com/robots.txt',
	]
	for url in urls {
		println('Testing http.get on public url: $url ')
		res :=  http.get( url ) or { panic(err) }
		assert 200 == res.status_code
		assert res.text.len > 0
	}
}

fn test_relative_redirects() {
	$if !network ? { return }
	res := http.get('https://httpbin.org/relative-redirect/3?abc=xyz') or { panic(err) }
	assert 200 == res.status_code
	assert res.text.len > 0
	assert res.text.contains('"abc": "xyz"')
}

module chunked

import strings
// See: https://en.wikipedia.org/wiki/Chunked_transfer_encoding
// /////////////////////////////////////////////////////////////
// The chunk size is transferred as a hexadecimal number
// followed by \r\n as a line separator,
// followed by a chunk of data of the given size.
// The end is marked with a chunk with size 0.
struct ChunkScanner {
mut:
	pos  int
	text string
}

fn (mut s ChunkScanner) read_chunk_size() int {
	mut n := 0
	for {
		if s.pos >= s.text.len {
			break
		}
		c := s.text[s.pos]
		if !c.is_hex_digit() {
			break
		}
		n = n<<4
		n += int(unhex(c))
		s.pos++
	}
	return n
}

fn unhex(c byte) byte {
	if `0` <= c && c <= `9` {
		return c - `0`
	}
	else if `a` <= c && c <= `f` {
		return c - `a` + 10
	}
	else if `A` <= c && c <= `F` {
		return c - `A` + 10
	}
	return 0
}

fn (mut s ChunkScanner) skip_crlf() {
	s.pos += 2
}

fn (mut s ChunkScanner) read_chunk(chunksize int) string {
	startpos := s.pos
	s.pos += chunksize
	return s.text[startpos..s.pos]
}

pub fn decode(text string) string {
	mut sb := strings.new_builder(100)
	mut cscanner := ChunkScanner{
		pos: 0
		text: text
	}
	for {
		csize := cscanner.read_chunk_size()
		if 0 == csize {
			break
		}
		cscanner.skip_crlf()
		sb.write(cscanner.read_chunk(csize))
		cscanner.skip_crlf()
	}
	cscanner.skip_crlf()
	return sb.str()
}
// urllib parses URLs and implements query escaping.
// See RFC 3986. This module generally follows RFC 3986, except where
// it deviates for compatibility reasons.
// Based off:   https://github.com/golang/go/blob/master/src/net/url/url.go
// Last commit: https://github.com/golang/go/commit/fe2ed5054176935d4adcf13e891715ccf2ee3cce
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
module urllib

import strings

enum EncodingMode {
	encode_path
	encode_path_segment
	encode_host
	encode_zone
	encode_user_password
	encode_query_component
	encode_fragment
}

const (
	err_msg_escape = 'unescape: invalid URL escape'
	err_msg_parse = 'parse: failed parsing url'
)

fn error_msg(message, val string) string {
	mut msg := 'net.urllib.$message'
	if val != '' {
		msg = '$msg ($val)'
	}
	return msg
}

// Return true if the specified character should be escaped when
// appearing in a URL string, according to RFC 3986.
//
// Please be informed that for now should_escape does not check all
// reserved characters correctly. See golang.org/issue/5684.
fn should_escape(c byte, mode EncodingMode) bool {
	// 2.3 Unreserved characters (alphanum)
	if (`a` <= c && c <= `z`) || (`A` <= c && c <= `Z`) || (`0` <= c && c <= `9`) {
		return false
	}
	if mode == .encode_host || mode == .encode_zone {
		// 3.2.2 host allows
		// sub-delims = `!` / `$` / `&` / ``` / `(` / `)` / `*` / `+` / `,` / `;` / `=`
		// as part of reg-name.
		// We add : because we include :port as part of host.
		// We add [ ] because we include [ipv6]:port as part of host.
		// We add < > because they`re the only characters left that
		// we could possibly allow, and parse will reject them if we
		// escape them (because hosts can`t use %-encoding for
		// ASCII bytes).
		if c in [`!`, `$`, `&`, `\\`, `(`, `)`, `*`, `+`, `,`, `;`, `=`, `:`, `[`, `]`, `<`, `>`, `"`] {
			return false
		}
	}
	match c {
		`-`, `_`, `.`, `~` {
			// 2.3 Unreserved characters (mark)
			return false
		}
		`$`, `&`, `+`, `,`, `/`, `:`, `;`, `=`, `?`, `@` {
			// 2.2 Reserved characters (reserved)
			// Different sections of the URL allow a few of
			// the reserved characters to appear unescaped.
			match mode {
				.encode_path {
					// 3.3
					// The RFC allows : @ & = + $ but saves / ; , for assigning
					// meaning to individual path segments. This package
					// only manipulates the path as a whole, so we allow those
					// last three as well. That leaves only ? to escape.
					return c == `?`
				}
				.encode_path_segment {
					// 3.3
					// The RFC allows : @ & = + $ but saves / ; , for assigning
					// meaning to individual path segments.
					return c == `/` || c == `;` || c == `,` || c == `?`
				}
				.encode_user_password {
					// 3.2.1
					// The RFC allows `;`, `:`, `&`, `=`, `+`, `$`, and `,` in
					// userinfo, so we must escape only `@`, `/`, and `?`.
					// The parsing of userinfo treats `:` as special so we must escape
					// that too.
					return c == `@` || c == `/` || c == `?` || c == `:`
				}
				.encode_query_component {
					// 3.4
					// The RFC reserves (so we must escape) everything.
					return true
				}
				.encode_fragment {
					// 4.1
					// The RFC text is silent but the grammar allows
					// everything, so escape nothing.
					return false
				}
				else {
				}}
		}
		else {
		}}
	if mode == .encode_fragment {
		// RFC 3986 2.2 allows not escaping sub-delims. A subset of sub-delims are
		// included in reserved from RFC 2396 2.2. The remaining sub-delims do not
		// need to be escaped. To minimize potential breakage, we apply two restrictions:
		// (1) we always escape sub-delims outside of the fragment, and (2) we always
		// escape single quote to avoid breaking callers that had previously assumed that
		// single quotes would be escaped. See issue #19917.
		match c {
			`!`, `(`, `)`, `*` {
				return false
			}
			else {
			}}
	}
	// Everything else must be escaped.
	return true
}

// query_unescape does the inverse transformation of query_escape,
// converting each 3-byte encoded substring of the form '%AB' into the
// hex-decoded byte 0xAB.
// It returns an error if any % is not followed by two hexadecimal
// digits.
pub fn query_unescape(s string) ?string {
	return unescape(s, .encode_query_component)
}

// path_unescape does the inverse transformation of path_escape,
// converting each 3-byte encoded substring of the form '%AB' into the
// hex-decoded byte 0xAB. It returns an error if any % is not followed
// by two hexadecimal digits.
//
// path_unescape is identical to query_unescape except that it does not
// unescape '+' to ' ' (space).
pub fn path_unescape(s string) ?string {
	return unescape(s, .encode_path_segment)
}

// unescape unescapes a string; the mode specifies
// which section of the URL string is being unescaped.
fn unescape(s_ string, mode EncodingMode) ?string {
	mut s := s_
	// Count %, check that they're well-formed.
	mut n := 0
	mut has_plus := false
	for i := 0; i < s.len;  {
		x := s[i]
		match x {
			`%` {
				if s == '' {
					break
				}
				n++
				if i + 2 >= s.len || !ishex(s[i + 1]) || !ishex(s[i + 2]) {
					s = s[i..]
					if s.len > 3 {
						s = s[..3]
					}
					return error(error_msg(err_msg_escape, s))
				}
				// Per https://tools.ietf.org/html/rfc3986#page-21
				// in the host component %-encoding can only be used
				// for non-ASCII bytes.
				// But https://tools.ietf.org/html/rfc6874#section-2
				// introduces %25 being allowed to escape a percent sign
				// in IPv6 scoped-address literals. Yay.
				if mode == .encode_host && unhex(s[i + 1]) < 8 && s[i..i + 3] != '%25' {
					return error(error_msg(err_msg_escape, s[i..i + 3]))
				}
				if mode == .encode_zone {
					// RFC 6874 says basically 'anything goes' for zone identifiers
					// and that even non-ASCII can be redundantly escaped,
					// but it seems prudent to restrict %-escaped bytes here to those
					// that are valid host name bytes in their unescaped form.
					// That is, you can use escaping in the zone identifier but not
					// to introduce bytes you couldn't just write directly.
					// But Windows puts spaces here! Yay.
					v := ( (unhex(s[i + 1])<<byte(4)) | unhex(s[i + 2]))
					if s[i..i + 3] != '%25' && v != ` ` && should_escape(v, .encode_host) {
						error(error_msg(err_msg_escape, s[i..i + 3]))
					}
				}
				i += 3
			}
			`+` {
				has_plus = mode == .encode_query_component
				i++
			}
			else {
				if (mode == .encode_host || mode == .encode_zone) && s[i] < 0x80 && should_escape(s[i], mode) {
					error(error_msg('unescape: invalid character in host name', s[i..i + 1]))
				}
				i++
			}}
	}
	if n == 0 && !has_plus {
		return s
	}
	mut t := strings.new_builder(s.len - 2 * n)
	for i := 0; i < s.len; i++ {
		x := s[i]
		match x {
			`%` {
				t.write( ((unhex(s[i + 1])<<byte(4)) | unhex(s[i + 2])).str() )
				i += 2
			}
			`+` {
				if mode == .encode_query_component {
					t.write(' ')
				}
				else {
					t.write('+')
				}
			}
			else {
				t.write(s[i].str())
			}}
	}
	return t.str()
}

// query_escape escapes the string so it can be safely placed
// inside a URL query.
pub fn query_escape(s string) string {
	return escape(s, .encode_query_component)
}

// path_escape escapes the string so it can be safely placed inside a URL path segment,
// replacing special characters (including /) with %XX sequences as needed.
pub fn path_escape(s string) string {
	return escape(s, .encode_path_segment)
}

fn escape(s string, mode EncodingMode) string {
	mut space_count := 0
	mut hex_count := 0
	mut c := byte(0)
	for i in 0..s.len {
		c = s[i]
		if should_escape(c, mode) {
			if c == ` ` && mode == .encode_query_component {
				space_count++
			}
			else {
				hex_count++
			}
		}
	}
	if space_count == 0 && hex_count == 0 {
		return s
	}
	buf := [byte(0)].repeat(64)
	mut t := []byte{}
	required := s.len + 2 * hex_count
	if required <= buf.len {
		t = buf[..required]
	}
	else {
		t = [byte(0)].repeat(required)
	}
	if hex_count == 0 {
		copy(t, s.bytes())
		for i in 0..s.len {
			if s[i] == ` ` {
				t[i] = `+`
			}
		}
		return string(t,t.len)
	}
	upperhex := '0123456789ABCDEF'
	mut j := 0
	for i in 0..s.len {
		c1 := s[i]
		if c1 == ` ` && mode == .encode_query_component {
			t[j] = `+`
			j++
		}
		else if should_escape(c1, mode) {
			t[j] = `%`
			t[j + 1] = upperhex[c1>>4]
			t[j + 2] = upperhex[c1 & 15]
			j += 3
		}
		else {
			t[j] = s[i]
			j++
		}
	}
	return string(t,t.len)
}

// A URL represents a parsed URL (technically, a URI reference).
//
// The general form represented is:
//
// [scheme:][//[userinfo@]host][/]path[?query][#fragment]
//
// URLs that do not start with a slash after the scheme are interpreted as:
//
// scheme:opaque[?query][#fragment]
//
// Note that the path field is stored in decoded form: /%47%6f%2f becomes /Go/.
// A consequence is that it is impossible to tell which slashes in the path were
// slashes in the raw URL and which were %2f. This distinction is rarely important,
// but when it is, the code should use raw_path, an optional field which only gets
// set if the default encoding is different from path.
//
// URL's String method uses the escaped_path method to obtain the path. See the
// escaped_path method for more details.
pub struct URL {
pub mut:
	scheme      string
	opaque      string // encoded opaque data
	user        &Userinfo // username and password information
	host        string // host or host:port
	path        string // path (relative paths may omit leading slash)
	raw_path    string // encoded path hint (see escaped_path method)
	force_query bool // append a query ('?') even if raw_query is empty
	raw_query   string // encoded query values, without '?'
	fragment    string // fragment for references, without '#'
}

// user returns a Userinfo containing the provided username
// and no password set.
pub fn user(username string) &Userinfo {
	return &Userinfo{
		username: username
		password: ''
		password_set: false
	}
}

// user_password returns a Userinfo containing the provided username
// and password.
//
// This functionality should only be used with legacy web sites.
// RFC 2396 warns that interpreting Userinfo this way
// ``is NOT RECOMMENDED, because the passing of authentication
// information in clear text (such as URI) has proven to be a
// security risk in almost every case where it has been used.''
fn user_password(username, password string) &Userinfo {
	return &Userinfo{
		username,password,true}
}

// The Userinfo type is an immutable encapsulation of username and
// password details for a URL. An existing Userinfo value is guaranteed
// to have a username set (potentially empty, as allowed by RFC 2396),
// and optionally a password.
struct Userinfo {
pub:
	username     string
	password     string
	password_set bool
}

fn (u &Userinfo) empty() bool {
	return u.username == '' && u.password == ''
}

// string returns the encoded userinfo information in the standard form
// of 'username[:password]'.
fn (u &Userinfo) string() string {
	if u.empty() {
		return ''
	}
	mut s := escape(u.username, .encode_user_password)
	if u.password_set {
		s += ':' + escape(u.password, .encode_user_password)
	}
	return s
}

// Maybe rawurl is of the form scheme:path.
// (scheme must be [a-zA-Z][a-zA-Z0-9+-.]*)
// If so, return [scheme, path]; else return ['', rawurl]
fn split_by_scheme(rawurl string) ?[]string {
	for i in 0..rawurl.len {
		c := rawurl[i]
		if (`a` <= c && c <= `z`) || (`A` <= c && c <= `Z`) {
			// do nothing
		}
		else if (`0` <= c && c <= `9`) || (c == `+` || c == `-` || c == `.`) {
			if i == 0 {
				return ['', rawurl]
			}
		}
		else if c == `:` {
			if i == 0 {
				return error(error_msg('split_by_scheme: missing protocol scheme', ''))
			}
			return [rawurl[..i], rawurl[i + 1..]]
		}
		else {
			// we have encountered an invalid character,
			// so there is no valid scheme
			return ['', rawurl]
		}
	}
	return ['', rawurl]
}

fn get_scheme(rawurl string) ?string {
	split := split_by_scheme(rawurl) or {
		return err
	}
	return split[0]
}

// split slices s into two substrings separated by the first occurence of
// sep. If cutc is true then sep is included with the second substring.
// If sep does not occur in s then s and the empty string is returned.
fn split(s string, sep byte, cutc bool) (string,string) {
	i := s.index_byte(sep)
	if i < 0 {
		return s,''
	}
	if cutc {
		return s[..i],s[i + 1..]
	}
	return s[..i],s[i..]
}

// parse parses rawurl into a URL structure.
//
// The rawurl may be relative (a path, without a host) or absolute
// (starting with a scheme). Trying to parse a hostname and path
// without a scheme is invalid but may not necessarily return an
// error, due to parsing ambiguities.
pub fn parse(rawurl string) ?URL {
	// Cut off #frag
	u,frag := split(rawurl, `#`, true)
	mut url := parse_url(u, false) or {
		return error(error_msg(err_msg_parse, u))
	}
	if frag == '' {
		return url
	}
	f := unescape(frag, .encode_fragment) or {
		return error(error_msg(err_msg_parse, u))
	}
	url.fragment = f
	return url
}

// parse_request_uri parses rawurl into a URL structure. It assumes that
// rawurl was received in an HTTP request, so the rawurl is interpreted
// only as an absolute URI or an absolute path.
// The string rawurl is assumed not to have a #fragment suffix.
// (Web browsers strip #fragment before sending the URL to a web server.)
fn parse_request_uri(rawurl string) ?URL {
	return parse_url(rawurl, true)
}

// parse_url parses a URL from a string in one of two contexts. If
// via_request is true, the URL is assumed to have arrived via an HTTP request,
// in which case only absolute URLs or path-absolute relative URLs are allowed.
// If via_request is false, all forms of relative URLs are allowed.
fn parse_url(rawurl string, via_request bool) ?URL {
	if string_contains_ctl_byte(rawurl) {
		return error(error_msg('parse_url: invalid control character in URL', rawurl))
	}
	if rawurl == '' && via_request {
		return error(error_msg('parse_url: empty URL', rawurl))
	}
	mut url := URL{
		user: 0
	}
	if rawurl == '*' {
		url.path = '*'
		return url
	}
	// Split off possible leading 'http:', 'mailto:', etc.
	// Cannot contain escaped characters.
	p := split_by_scheme(rawurl) or {
		return error(err)
	}
	url.scheme = p[0]
	mut rest := p[1]
	url.scheme = url.scheme.to_lower()
	// if rest.ends_with('?') && strings.count(rest, '?') == 1 {
	if rest.ends_with('?') && !rest[..1].contains('?') {
		url.force_query = true
		rest = rest[..rest.len - 1]
	}
	else {
		r,raw_query := split(rest, `?`, true)
		rest = r
		url.raw_query = raw_query
	}
	if !rest.starts_with('/') {
		if url.scheme != '' {
			// We consider rootless paths per RFC 3986 as opaque.
			url.opaque = rest
			return url
		}
		if via_request {
			return error(error_msg('parse_url: invalid URI for request', ''))
		}
		// Avoid confusion with malformed schemes, like cache_object:foo/bar.
		// See golang.org/issue/16822.
		//
		// RFC 3986, 3.3:
		// In addition, a URI reference (Section 4.1) may be a relative-path reference,
		// in which case the first path segment cannot contain a colon (':') character.
		colon := rest.index(':') or {
			return error('there should be a : in the URL')
		}
		slash := rest.index('/') or {
			return error('there should be a / in the URL')
		}
		if colon >= 0 && (slash < 0 || colon < slash) {
			// First path segment has colon. Not allowed in relative URL.
			return error(error_msg('parse_url: first path segment in URL cannot contain colon', ''))
		}
	}
	if ((url.scheme != '' || !via_request) && !rest.starts_with('///')) && rest.starts_with('//') {
		authority,r := split(rest[2..], `/`, false)
		rest = r
		a := parse_authority(authority) or {
			return error(err)
		}
		url.user = a.user
		url.host = a.host
	}
	// Set path and, optionally, raw_path.
	// raw_path is a hint of the encoding of path. We don't want to set it if
	// the default escaping of path is equivalent, to help make sure that people
	// don't rely on it in general.
	url.set_path(rest) or {
		return error(err)
	}
	return url
}

struct ParseAuthorityRes {
	user &Userinfo
	host string
}

fn parse_authority(authority string) ?ParseAuthorityRes {
	i := authority.last_index('@') or {
		-1
	}
	mut host := ''
	mut zuser := user('')
	if i < 0 {
		h := parse_host(authority) or {
			return error(err)
		}
		host = h
	}
	else {
		h := parse_host(authority[i + 1..]) or {
			return error(err)
		}
		host = h
	}
	if i < 0 {
		return ParseAuthorityRes{
			host: host
			user: zuser
		}
	}
	mut userinfo := authority[..i]
	if !valid_userinfo(userinfo) {
		return error(error_msg('parse_authority: invalid userinfo', ''))
	}
	if !userinfo.contains(':') {
		u := unescape(userinfo, .encode_user_password) or {
			return error(err)
		}
		userinfo = u
		zuser = user(userinfo)
	}
	else {
		mut username,mut password := split(userinfo, `:`, true)
		u := unescape(username, .encode_user_password) or {
			return error(err)
		}
		username = u
		p := unescape(password, .encode_user_password) or {
			return error(err)
		}
		password = p
		zuser = user_password(username, password)
	}
	return ParseAuthorityRes{
		user: zuser
		host: host
	}
}

// parse_host parses host as an authority without user
// information. That is, as host[:port].
fn parse_host(host string) ?string {
	if host.starts_with('[') {
		// parse an IP-Literal in RFC 3986 and RFC 6874.
		// E.g., '[fe80::1]', '[fe80::1%25en0]', '[fe80::1]:80'.
		mut i := host.last_index(']') or {
			return error(error_msg("parse_host: missing \']\' in host", ''))
		}
		mut colon_port := host[i + 1..]
		if !valid_optional_port(colon_port) {
			return error(error_msg('parse_host: invalid port $colon_port after host ', ''))
		}
		// RFC 6874 defines that %25 (%-encoded percent) introduces
		// the zone identifier, and the zone identifier can use basically
		// any %-encoding it likes. That's different from the host, which
		// can only %-encode non-ASCII bytes.
		// We do impose some restrictions on the zone, to avoid stupidity
		// like newlines.
		if zone:=host[..i].index('%25'){
			host1 := unescape(host[..zone], .encode_host) or {
				return err
			}
			host2 := unescape(host[zone..i], .encode_zone) or {
				return err
			}
			host3 := unescape(host[i..], .encode_host) or {
				return err
			}
			return host1 + host2 + host3
		}
		if idx:=host.last_index(':'){
			colon_port = host[idx..]
			if !valid_optional_port(colon_port) {
				return error(error_msg('parse_host: invalid port $colon_port after host ', ''))
			}
		}
	}
	h := unescape(host, .encode_host) or {
		return err
	}
	return h
	// host = h
	// return host
}
// set_path sets the path and raw_path fields of the URL based on the provided
// escaped path p. It maintains the invariant that raw_path is only specified
// when it differs from the default encoding of the path.
// For example:
// - set_path('/foo/bar')   will set path='/foo/bar' and raw_path=''
// - set_path('/foo%2fbar') will set path='/foo/bar' and raw_path='/foo%2fbar'
// set_path will return an error only if the provided path contains an invalid
// escaping.
pub fn (mut u URL) set_path(p string) ?bool {
	path := unescape(p, .encode_path) or {
		return error(err)
	}
	u.path = path
	escp := escape(path, .encode_path)
	if p == escp {
		// Default encoding is fine.
		u.raw_path = ''
	}
	else {
		u.raw_path = p
	}
	return true
}

// escaped_path returns the escaped form of u.path.
// In general there are multiple possible escaped forms of any path.
// escaped_path returns u.raw_path when it is a valid escaping of u.path.
// Otherwise escaped_path ignores u.raw_path and computes an escaped
// form on its own.
// The String and request_uri methods use escaped_path to construct
// their results.
// In general, code should call escaped_path instead of
// reading u.raw_path directly.
fn (u &URL) escaped_path() string {
	if u.raw_path != '' && valid_encoded_path(u.raw_path) {
		unescape(u.raw_path, .encode_path) or {
			return ''
		}
		return u.raw_path
	}
	if u.path == '*' {
		return '*' // don't escape (Issue 11202)
	}
	return escape(u.path, .encode_path)
}

// valid_encoded_path reports whether s is a valid encoded path.
// It must not contain any bytes that require escaping during path encoding.
fn valid_encoded_path(s string) bool {
	for i in 0..s.len {
		// RFC 3986, Appendix A.
		// pchar = unreserved / pct-encoded / sub-delims / ':' / '@'.
		// should_escape is not quite compliant with the RFC,
		// so we check the sub-delims ourselves and let
		// should_escape handle the others.
		x := s[i]
		match x {
			`!`, `$`, `&`, `\\`, `(`, `)`, `*`, `+`, `,`, `;`, `=`, `:`, `@` {
				// ok
			}
			`[`, `]` {
				// ok - not specified in RFC 3986 but left alone by modern browsers
			}
			`%` {
				// ok - percent encoded, will decode
			}
			else {
				if should_escape(s[i], .encode_path) {
					return false
				}
			}}
	}
	return true
}

// valid_optional_port reports whether port is either an empty string
// or matches /^:\d*$/
fn valid_optional_port(port string) bool {
	if port == '' {
		return true
	}
	if port[0] != `:` {
		return false
	}
	for b in port[1..] {
		if b < `0` || b > `9` {
			return false
		}
	}
	return true
}

// str reassembles the URL into a valid URL string.
// The general form of the result is one of:
//
// scheme:opaque?query#fragment
// scheme://userinfo@host/path?query#fragment
//
// If u.opaque is non-empty, String uses the first form;
// otherwise it uses the second form.
// Any non-ASCII characters in host are escaped.
// To obtain the path, String uses u.escaped_path().
//
// In the second form, the following rules apply:
// - if u.scheme is empty, scheme: is omitted.
// - if u.user is nil, userinfo@ is omitted.
// - if u.host is empty, host/ is omitted.
// - if u.scheme and u.host are empty and u.user is nil,
// the entire scheme://userinfo@host/ is omitted.
// - if u.host is non-empty and u.path begins with a /,
// the form host/path does not add its own /.
// - if u.raw_query is empty, ?query is omitted.
// - if u.fragment is empty, #fragment is omitted.
pub fn (u URL) str() string {
	mut buf := strings.new_builder(200)
	if u.scheme != '' {
		buf.write(u.scheme)
		buf.write(':')
	}
	if u.opaque != '' {
		buf.write(u.opaque)
	}
	else {
		if u.scheme != '' || u.host != '' || (u.user != 0 && !u.user.empty()) {
			if u.host != '' || u.path != '' || !u.user.empty() {
				buf.write('//')
			}
			if !u.user.empty() {
				buf.write(u.user.string())
				buf.write('@')
			}
			if u.host != '' {
				buf.write(escape(u.host, .encode_host))
			}
		}
		path := u.escaped_path()
		if path != '' && path[0] != `/` && u.host != '' {
			buf.write('/')
		}
		if buf.len == 0 {
			// RFC 3986 4.2
			// A path segment that contains a colon character (e.g., 'this:that')
			// cannot be used as the first segment of a relative-path reference, as
			// it would be mistaken for a scheme name. Such a segment must be
			// preceded by a dot-segment (e.g., './this:that') to make a relative-
			// path reference.
			i := path.index_byte(`:`)
			if i > -1 && path[..i].index_byte(`/`) == -1 {
				buf.write('./')
			}
		}
		buf.write(path)
	}
	if u.force_query || u.raw_query != '' {
		buf.write('?')
		buf.write(u.raw_query)
	}
	if u.fragment != '' {
		buf.write('#')
		buf.write(escape(u.fragment, .encode_fragment))
	}
	return buf.str()
}

// Values maps a string key to a list of values.
// It is typically used for query parameters and form values.
// Unlike in the http.Header map, the keys in a Values map
// are case-sensitive.
// parseQuery parses the URL-encoded query string and returns
// a map listing the values specified for each key.
// parseQuery always returns a non-nil map containing all the
// valid query parameters found; err describes the first decoding error
// encountered, if any.
//
// Query is expected to be a list of key=value settings separated by
// ampersands or semicolons. A setting without an equals sign is
// interpreted as a key set to an empty value.
pub fn parse_query(query string) ?Values {
	mut m := new_values()
	parse_query_values(mut m, query) or {
		return error(err)
	}
	return m
}

// parse_query_silent is the same as parse_query
// but any errors will be silent
fn parse_query_silent(query string) Values {
	mut m := new_values()
	parse_query_values(mut m, query)
	return m
}

fn parse_query_values(m mut Values, query string) ?bool {
	mut had_error := false
	mut q := query
	for q != '' {
		mut key := q
		mut i := key.index_any('&;')
		if i >= 0 {
			q = key[i + 1..]
			key = key[..i]
		}
		else {
			q = ''
		}
		if key == '' {
			continue
		}
		mut value := ''
		if idx:=key.index('='){
			i = idx
			value = key[i + 1..]
			key = key[..i]
		}
		k := query_unescape(key) or {
			had_error = true
			continue
		}
		key = k
		v := query_unescape(value) or {
			had_error = true
			continue
		}
		value = v
		m.add(key, value)
	}
	if had_error {
		return error(error_msg('parse_query_values: failed parsing query string', ''))
	}
	return true
}

// encode encodes the values into ``URL encoded'' form
// ('bar=baz&foo=quux') sorted by key.
pub fn (v Values) encode() string {
	if v.size == 0 {
		return ''
	}
	mut buf := strings.new_builder(200)
	mut keys := []string{}
	for k, _ in v.data {
		keys << k
	}
	keys.sort()
	for k in keys {
		vs := v.data[k]
		key_kscaped := query_escape(k)
		for _, val in vs.data {
			if buf.len > 0 {
				buf.write('&')
			}
			buf.write(key_kscaped)
			buf.write('=')
			buf.write(query_escape(val))
		}
	}
	return buf.str()
}

// resolve_path applies special path segments from refs and applies
// them to base, per RFC 3986.
fn resolve_path(base, ref string) string {
	mut full := ''
	if ref == '' {
		full = base
	}
	else if ref[0] != `/` {
		i := base.last_index('/') or {
			-1
		}
		full = base[..i + 1] + ref
	}
	else {
		full = ref
	}
	if full == '' {
		return ''
	}
	mut dst := []string{}
	src := full.split('/')
	for _, elem in src {
		match elem {
			'.' {
				// drop
			}
			'..' {
				if dst.len > 0 {
					dst = dst[..dst.len - 1]
				}
			}
			else {
				dst << elem
			}}
	}
	last := src[src.len - 1]
	if last == '.' || last == '..' {
		// Add final slash to the joined path.
		dst << ''
	}
	return '/' + dst.join('/').trim_left('/')
}

// is_abs reports whether the URL is absolute.
// Absolute means that it has a non-empty scheme.
pub fn (u &URL) is_abs() bool {
	return u.scheme != ''
}

// parse parses a URL in the context of the receiver. The provided URL
// may be relative or absolute. parse returns nil, err on parse
// failure, otherwise its return value is the same as resolve_reference.
pub fn (u &URL) parse(ref string) ?URL {
	refurl := parse(ref) or {
		return error(err)
	}
	return u.resolve_reference(refurl)
}

// resolve_reference resolves a URI reference to an absolute URI from
// an absolute base URI u, per RFC 3986 Section 5.2. The URI reference
// may be relative or absolute. resolve_reference always returns a new
// URL instance, even if the returned URL is identical to either the
// base or reference. If ref is an absolute URL, then resolve_reference
// ignores base and returns a copy of ref.
pub fn (u &URL) resolve_reference(ref &URL) ?URL {
	mut url := *ref
	if ref.scheme == '' {
		url.scheme = u.scheme
	}
	if ref.scheme != '' || ref.host != '' || !ref.user.empty() {
		// The 'absoluteURI' or 'net_path' cases.
		// We can ignore the error from set_path since we know we provided a
		// validly-escaped path.
		url.set_path(resolve_path(ref.escaped_path(), '')) or {
			return error(err)
		}
		return url
	}
	if ref.opaque != '' {
		url.user = user('')
		url.host = ''
		url.path = ''
		return url
	}
	if ref.path == '' && ref.raw_query == '' {
		url.raw_query = u.raw_query
		if ref.fragment == '' {
			url.fragment = u.fragment
		}
	}
	// The 'abs_path' or 'rel_path' cases.
	url.host = u.host
	url.user = u.user
	url.set_path(resolve_path(u.escaped_path(), ref.escaped_path())) or {
		return error(err)
	}
	return url
}

// query parses raw_query and returns the corresponding values.
// It silently discards malformed value pairs.
// To check errors use parseQuery.
pub fn (u &URL) query() Values {
	v := parse_query_silent(u.raw_query)
	return v
}

// request_uri returns the encoded path?query or opaque?query
// string that would be used in an HTTP request for u.
pub fn (u &URL) request_uri() string {
	mut result := u.opaque
	if result == '' {
		result = u.escaped_path()
		if result == '' {
			result = '/'
		}
	}
	else {
		if result.starts_with('//') {
			result = u.scheme + ':' + result
		}
	}
	if u.force_query || u.raw_query != '' {
		result += '?' + u.raw_query
	}
	return result
}

// hostname returns u.host, stripping any valid port number if present.
//
// If the result is enclosed in square brackets, as literal IPv6 addresses are,
// the square brackets are removed from the result.
pub fn (u &URL) hostname() string {
	host,_ := split_host_port(u.host)
	return host
}

// port returns the port part of u.host, without the leading colon.
// If u.host doesn't contain a port, port returns an empty string.
pub fn (u &URL) port() string {
	_,port := split_host_port(u.host)
	return port
}

// split_host_port separates host and port. If the port is not valid, it returns
// the entire input as host, and it doesn't check the validity of the host.
// Per RFC 3986, it requires ports to be numeric.
fn split_host_port(hostport string) (string,string) {
	mut host := hostport
	mut port := ''
	colon := host.last_index_byte(`:`)
	if colon != -1 && valid_optional_port(host[colon..]) {
		port = host[colon + 1..]
		host = host[..colon]
	}
	if host.starts_with('[') && host.ends_with(']') {
		host = host[1..host.len - 1]
	}
	return host,port
}

// valid_userinfo reports whether s is a valid userinfo string per RFC 3986
// Section 3.2.1:
// userinfo    = *( unreserved / pct-encoded / sub-delims / ':' )
// unreserved  = ALPHA / DIGIT / '-' / '.' / '_' / '~'
// sub-delims  = '!' / '$' / '&' / ''' / '(' / ')'
// / '*' / '+' / ',' / ';' / '='
//
// It doesn't validate pct-encoded. The caller does that via fn unescape.
pub fn valid_userinfo(s string) bool {
	for r in s {
		if `A` <= r && r <= `Z` {
			continue
		}
		if `a` <= r && r <= `z` {
			continue
		}
		if `0` <= r && r <= `9` {
			continue
		}
		match r {
			`-`, `.`, `_`, `:`, `~`, `!`, `$`, `&`, `\\`, `(`, `)`, `*`, `+`, `,`, `;`, `=`, `%`, `@` {
				continue
			}
			else {
				return false
			}}
	}
	return true
}

// string_contains_ctl_byte reports whether s contains any ASCII control character.
fn string_contains_ctl_byte(s string) bool {
	for i in 0..s.len {
		b := s[i]
		if b < ` ` || b == 0x7f {
			return true
		}
	}
	return false
}

pub fn ishex(c byte) bool {
	if `0` <= c && c <= `9` {
		return true
	}
	else if `a` <= c && c <= `f` {
		return true
	}
	else if `A` <= c && c <= `F` {
		return true
	}
	return false
}

fn unhex(c byte) byte {
	if `0` <= c && c <= `9` {
		return c - `0`
	}
	else if `a` <= c && c <= `f` {
		return c - `a` + 10
	}
	else if `A` <= c && c <= `F` {
		return c - `A` + 10
	}
	return 0
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

import net.urllib

fn test_net_urllib() {
	test_query := 'Hell Wrld@vlang'
	assert urllib.query_escape(test_query) == 'Hell%C3%B6+W%C3%B6rld%40vlang'

	test_url := 'https://joe:pass@www.mydomain.com:8080/som/url?param1=test1&param2=test2&foo=bar#testfragment'
	u := urllib.parse(test_url) or {
		assert false
		return
	}
	assert u.scheme     == 'https' &&
		u.hostname()    == 'www.mydomain.com' &&
		u.port()        == '8080' &&
		u.path          == '/som/url' &&
		u.fragment      == 'testfragment' &&
		u.user.username == 'joe' &&
		u.user.password == 'pass'
}

fn test_str() {
	url := urllib.parse("https://en.wikipedia.org/wiki/Brazil_(1985_film)") or {
		panic("unable to parse URL")
	}
	assert url.str() == 'https://en.wikipedia.org/wiki/Brazil_(1985_film)'
}	

fn test_escape_unescape() {
	original := ' : \\%'
	escaped := urllib.query_escape(original) 
	assert escaped == '%D1%82%D0%B5+%D1%81%D1%82%3A+%D1%82%5C%25'
	unescaped := urllib.query_unescape(escaped) or { assert false return }
	assert unescaped == original
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module urllib

struct Value {
pub mut:
	data []string
}

struct Values {
pub mut:
	data map[string]Value
	size int
}

// new_values returns a new Values struct for creating
// urlencoded query string parameters. it can also be to
// post form data with application/x-www-form-urlencoded.
// values.encode() will return the encoded data
pub fn new_values() Values {
	return Values{
		data: map[string]Value
	}
}

// Currently you will need to use all()[key].data
// once map[string][]string is implemented
// this will be fixed
pub fn (v &Value) all() []string {
	return v.data
}

// get gets the first value associated with the given key.
// If there are no values associated with the key, get returns
// a empty string.
pub fn (v &Values) get(key string) string {
	if v.data.size == 0 {
		return ''
	}
	vs := v.data[key]
	if vs.data.len == 0 {
		return ''
	}
	return vs.data[0]
}

// get_all gets the all the values associated with the given key.
// If there are no values associated with the key, get returns
// a empty []string.
pub fn (v &Values) get_all(key string) []string {
	if v.data.size == 0 {
		return []
	}
	vs := v.data[key]
	if vs.data.len == 0 {
		return []
	}
	return vs.data
}

// set sets the key to value. It replaces any existing
// values.
pub fn (mut v Values) set(key, value string) {
	mut a := v.data[key]
	a.data = [value]
	v.data[key] = a
	v.size = v.data.size
}

// add adds the value to key. It appends to any existing
// values associated with key.
pub fn (mut v Values) add(key, value string) {
	mut a := v.data[key]
	if a.data.len == 0 {
		a.data = []
	}
	a.data << value
	v.data[key] = a
	v.size = v.data.size
}

// del deletes the values associated with key.
pub fn (mut v Values) del(key string) {
	v.data.delete(key)
	v.size = v.data.size
}
module websocket

fn (ws &Client) send_message_event(msg Message) {
	ws.eb.publish('on_message', ws, msg)
	l.d('sending on_message event')
}

fn (ws &Client) send_error_event(err string) {
	ws.eb.publish('on_error', ws, err)
	l.d('sending on_error event')
}

fn (ws &Client) send_close_event() {
	ws.eb.publish('on_close', ws, voidptr(0))
	l.d('sending on_close event')
}

fn (ws &Client) send_open_event() {
	ws.eb.publish('on_open', ws, voidptr(0))
	l.d('sending on_open event')
}
module websocket

fn (mut ws Client) read_handshake(seckey string){
	l.d("reading handshake...")
	mut bytes_read := 0
	max_buffer := 1024
	buffer_size := 1
	mut buffer := malloc(max_buffer)

	for bytes_read <= max_buffer {
		res := ws.read_from_server(buffer + bytes_read, buffer_size)
		if res == 0 || res == -1 {
			l.f("read_handshake: Failed to read handshake.")
		}
		if buffer[bytes_read] == `\n` && buffer[bytes_read-1] == `\r` && buffer[bytes_read-2] == `\n` && buffer[bytes_read-3] == `\r` {
			break
		}
		bytes_read += buffer_size
	}
	buffer[max_buffer+1] = `\0`
	ws.handshake_handler(string(byteptr(buffer)), seckey)
}

fn (mut ws Client) handshake_handler(handshake_response, seckey string){
	l.d("handshake_handler:\r\n${handshake_response}")
	lines := handshake_response.split_into_lines()

	header := lines[0]
	if !header.starts_with("HTTP/1.1 101") && !header.starts_with("HTTP/1.0 101") {
		l.f("handshake_handler: invalid HTTP status response code")
	}

	for i in 1..lines.len {
		if lines[i].len <= 0 || lines[i] == "\r\n" {
			continue
		}
		keys := lines[i].split(":")

		match keys[0] {
			"Upgrade", "upgrade" {
				ws.flags << .has_upgrade
			}
			"Connection", "connection" {
				ws.flags << .has_connection
			}
			"Sec-WebSocket-Accept", "sec-websocket-accept" {
				l.d("comparing hashes")
				l.d("seckey: ${seckey}")
				challenge := create_key_challenge_response(seckey)
				l.d("challenge: ${challenge}")
				l.d("response: ${keys[1]}")
				if keys[1].trim_space() != challenge {
					l.e("handshake_handler: Sec-WebSocket-Accept header does not match computed sha1/base64 response.")
				}
				ws.flags << .has_accept
				unsafe {
					challenge.free()
				}
			} else {}
		}
		unsafe {
			keys.free()
		}
	}
	if ws.flags.len < 3 {
		ws.close(1002, "invalid websocket HTTP headers")
		l.e("invalid websocket HTTP headers")
	}
	l.i("handshake successful!")
	unsafe {
		handshake_response.free()
		lines.free()
		header.free()
	}
}module websocket

fn C.write() int

fn (mut ws Client) write_to_server(buf voidptr, len int) int {
	mut bytes_written := 0
	ws.write_lock.lock()
	bytes_written = if ws.is_ssl {
		C.SSL_write(ws.ssl, buf, len)
	} else {
		C.write(ws.socket.sockfd, buf, len)
	}
	ws.write_lock.unlock()
	return bytes_written
}

fn (ws &Client) read_from_server(buffer byteptr, buffer_size int) int {
	return if ws.is_ssl {
		C.SSL_read(ws.ssl, buffer, buffer_size)
	} else {
		C.read(ws.socket.sockfd, buffer, buffer_size)
	}
}# WebSockets Library for V

Originally located at [thecodrr/vws](https://github.com/thecodrr/vws) (contains example usage)

**This is still work-in-progress!**

Heavily inspired from [cwebsockets](https://github.com/jeremyhahn/cwebsocket).

The websockets library itself is ready and working (passes all tests of AutoBahn). What's left:

1. It needs to be updated and made to run with latest V.
2. No Windows Support (SSL issues)
3. No proper AutoBahn test client (a prototype is in the main.v but nothing proper).
4. No Websocket Server.
5. Remove the `logger` and move to `log`

## What's needed for Windows support:

1. SSL (either make the VSChannel work or OpenSSL)

General code cleanup etc. is also needed.
module websocket

#flag -lssl
#include <openssl/rand.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

struct C.SSL_CTX
struct C.SSL
struct C.SSL_METHOD
fn C.SSL_load_error_strings()
fn C.SSL_library_init()
fn C.SSLv23_client_method() &C.SSL_METHOD
fn C.SSL_CTX_new() &C.SSL_CTX
fn C.SSL_new() &C.SSL
fn C.SSL_set_fd() int
fn C.SSL_connect() int
fn C.SSL_shutdown()
fn C.SSL_free()
fn C.SSL_CTX_free()
fn C.SSL_write() int
fn C.SSL_read() int

fn (mut ws Client) connect_ssl(){
	l.i("Using secure SSL connection")
	C.SSL_load_error_strings()
	C.SSL_library_init()

	ws.sslctx = C.SSL_CTX_new(C.SSLv23_client_method())
	if ws.sslctx == C.NULL {
		l.f("Couldn't get ssl context")
	}

	ws.ssl = C.SSL_new(ws.sslctx)
	if ws.ssl == C.NULL {
		l.f("Couldn't create OpenSSL instance.")
	}

	if C.SSL_set_fd(ws.ssl, ws.socket.sockfd) != 1 {
		l.f("Couldn't assign ssl to socket.")
	}

	if C.SSL_connect(ws.ssl) != 1 {
		l.f("Couldn't connect using SSL.")
	}
}module websocket

pub fn utf8_validate_str(str string) bool {
	return utf8_validate(str.str, str.len)
}
struct Utf8State {
	mut:
	index int
	subindex int
	failed bool
}
pub fn utf8_validate(data byteptr, len int) bool {
	mut state := Utf8State{}
	for i := 0; i < len; i++ {
		s := data[i]
		if s == 0 {break}
		state.next_state(s)
		if state.failed {
			return false
		}
		//i++ //fast forward
	}
	return !state.failed && state.subindex <= 0
}

fn (mut s Utf8State) seq(r0 bool, r1 bool, is_tail bool) bool {
	if s.subindex == 0 || (s.index > 1 && s.subindex == 1) || (s.index >= 6 && s.subindex == 2) {
		if (s.subindex == 0 && r0) || (s.subindex == 1 && r1) || (s.subindex == 2 && is_tail) {
			s.subindex++
			return true
		}
		goto next
	}
	else {
		s.failed = true
		if is_tail {
			s.index = 0
			s.subindex = 0
			s.failed = false
		}
		return true
	}
	next:
	s.index++
	s.subindex = 0
	return false
}

fn (mut s Utf8State) next_state (c byte) {
	//sequence 1
	if s.index == 0 {
		if (c >= 0x00 + 1 && c <= 0x7F) || c == 0x00 {
			return
		}
		s.index++
		s.subindex = 0
	}
	is_tail := c >= 0x80 && c <= 0xBF
	//sequence 2
	if s.index == 1 && s.seq(c >= 0xC2 && c <= 0xDF, false, is_tail) {return}

	//sequence 3
	if s.index == 2 && s.seq(c == 0xE0, c >= 0xA0 && c <= 0xBF, is_tail) {return}
	if s.index == 3 && s.seq(c >= 0xE1 && c <= 0xEC, c >= 0x80 && c <= 0xBF, is_tail) {return}
	if s.index == 4 && s.seq(c == 0xED, c >= 0x80 && c <= 0x9F, is_tail) {return}
	if s.index == 5 && s.seq(c >= 0xEE && c <= 0xEF, c >= 0x80 && c <= 0xBF, is_tail) {return}

	//sequence 4
	if s.index == 6 && s.seq(c == 0xF0, c >= 0x90 && c <= 0xBF, is_tail) {return}
	if s.index == 7 && s.seq(c >= 0xF1 && c <= 0xF3, c >= 0x80 && c <= 0xBF, is_tail) {return}
	if s.index == 8 && s.seq(c == 0xF4, c >= 0x80 && c <= 0x8F, is_tail) {return}

	//we should never reach here
	s.failed = true
}module websocket

import time
import rand
import math
import crypto.sha1
import encoding.base64

fn htonl64(payload_len u64) byteptr {
	mut ret := malloc(8)

	ret[0] = byte(((payload_len & (u64(0xff) << 56)) >> 56) & 0xff)
	ret[1] = byte(((payload_len & (u64(0xff) << 48)) >> 48) & 0xff)
	ret[2] = byte(((payload_len & (u64(0xff) << 40)) >> 40) & 0xff)
	ret[3] = byte(((payload_len & (u64(0xff) << 32)) >> 32) & 0xff)
	ret[4] = byte(((payload_len & (u64(0xff) << 24)) >> 24) & 0xff)
	ret[5] = byte(((payload_len & (u64(0xff) << 16)) >> 16) & 0xff)
	ret[6] = byte(((payload_len & (u64(0xff) << 8)) >> 8) & 0xff)
	ret[7] = byte(((payload_len & (u64(0xff) << 0)) >> 0) & 0xff)
	return ret
}

fn create_masking_key() []byte {
	t := time.ticks()
	tseq := t % 23237671
	mut rnd := rand.new_pcg32(u64(t), u64(tseq) )
	mask_bit := byte(rnd.bounded_next(u32(math.max_i32)))
	buf := [`0`].repeat(4)
	C.memcpy(buf.data, &mask_bit, 4)
	return buf
}

fn create_key_challenge_response(seckey string) string {
	guid := "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
	sha1buf := seckey + guid
	hash := sha1.sum(sha1buf.bytes())
	hashstr := string(byteptr(hash.data))
	b64 := base64.encode(hashstr)
	unsafe {
		sha1buf.free()
		hash.free()
	}
	return b64
}

fn get_nonce() string {
	mut nonce := []byte{}
	alphanum := "0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz"
	for i in 0..18 {
		nonce << alphanum[rand.next(61)]
	}
	return string(byteptr(nonce.data))
}module websocket

import net
import net.urllib
import encoding.base64
import eventbus
import sync
import net.websocket.logger

const (
	l = logger.new("ws")
)

pub struct Client {
	retry int
	eb &eventbus.EventBus
	is_ssl bool
	lock sync.Mutex = sync.new_mutex()
	write_lock sync.Mutex = sync.new_mutex()
	//subprotocol_len int
	//cwebsocket_subprotocol *subprotocol;
	//cwebsocket_subprotocol *subprotocols[];
	mut:
	state State
	socket net.Socket
	flags []Flag
	sslctx &C.SSL_CTX
	ssl &C.SSL
	fragments []Fragment
	pub mut:
	uri string
	subscriber &eventbus.Subscriber
}

struct Fragment {
	data voidptr
	len u64
	code OPCode
}

pub struct Message {
	pub:
	opcode OPCode
	payload voidptr
	payload_len int
}

pub enum OPCode {
	continuation = 0x00
	text_frame = 0x01
	binary_frame = 0x02
	close = 0x08
	ping = 0x09
	pong = 0x0A
}

enum State {
	connecting = 0
	connected
	open
    closing
	closed
}

struct Uri {
	mut:
	hostname string
	port string
	resource string
	querystring string
}

enum Flag {
	has_accept
	has_connection
	has_upgrade
}

struct Frame {
	mut:
	fin bool
	rsv1 bool
	rsv2 bool
	rsv3 bool
	opcode OPCode
	mask bool
	payload_len u64
	masking_key [4]byte
}

pub fn new(uri string) &Client {
	eb := eventbus.new()
	ws := &Client{
		uri: uri
		state: .closed
		eb: eb,
		subscriber: eb.subscriber
		is_ssl: uri.starts_with("wss")
		ssl: C.NULL
		sslctx: C.NULL
	}
	return ws
}
fn C.sscanf() int

fn (ws &Client) parse_uri() &Uri {
	u := urllib.parse(ws.uri) or {panic(err)}
	v := u.request_uri().split("?")
	querystring := if v.len > 1 {"?" + v[1]} else {""}
	return &Uri {
		hostname: u.hostname()
		port: u.port()
		resource: v[0]
		querystring: querystring
	}
}

pub fn (mut ws Client) connect() int {
	match ws.state {
		.connected {
			l.f("connect: websocket already connected")
		}
		.connecting {
			l.f("connect: websocket already connecting")
		}
		.open {
			l.f("connect: websocket already open")
		} else {
			// do nothing
		}
	}

	ws.lock.lock()
	ws.state = .connecting
	ws.lock.unlock()

	uri := ws.parse_uri()

	nonce := get_nonce()
	seckey := base64.encode(nonce)

	ai_family := C.AF_INET
	ai_socktype := C.SOCK_STREAM

	l.d("handshake header:")
	handshake := "GET ${uri.resource}${uri.querystring} HTTP/1.1\r\nHost: ${uri.hostname}:${uri.port}\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Key: ${seckey}\r\nSec-WebSocket-Version: 13\r\n\r\n"
	l.d(handshake)

	socket := net.new_socket(ai_family, ai_socktype, 0) or {
		l.f(err)
		return -1
	}
	ws.socket = socket
	ws.socket.connect(uri.hostname, uri.port.int()) or {
		l.f(err)
		return -1
	}

	optval := 1
	ws.socket.setsockopt(C.SOL_SOCKET, C.SO_KEEPALIVE, &optval) or {
		l.f(err)
		return -1
	}

	if ws.is_ssl {
		ws.connect_ssl()
	}

	ws.lock.lock()
	ws.state = .connected
	ws.lock.unlock()

	res := ws.write_to_server(handshake.str, handshake.len)
	if res <= 0 {
		l.f("Handshake failed.")
	}

	ws.read_handshake(seckey)

	ws.lock.lock()
	ws.state = .open
	ws.lock.unlock()

	ws.send_open_event()

	unsafe {
		handshake.free()
		nonce.free()
		free(uri)
	}
	return 0
}

pub fn (mut ws Client) close(code int, message string){
	if ws.state != .closed && ws.socket.sockfd > 1 {

		ws.lock.lock()
		ws.state = .closing
		ws.lock.unlock()

		mut code32 := 0
		if code > 0 {
			_code := C.htons(code)
			message_len := message.len + 2
			mut close_frame := [`0`].repeat(message_len)
			close_frame[0] = _code & 0xFF
			close_frame[1] = (_code >> 8)
			code32 = (close_frame[0] << 8) + close_frame[1]
			for i in 0..message.len {
				close_frame[i+2] = message[i]
			}
			ws.send_control_frame(.close, "CLOSE", close_frame)
		} else {
			ws.send_control_frame(.close, "CLOSE", [])
		}

		if ws.ssl != C.NULL {
			C.SSL_shutdown(ws.ssl)
			C.SSL_free(ws.ssl)
			if ws.sslctx != C.NULL {
				C.SSL_CTX_free(ws.sslctx)
			}
		} else {
			if C.shutdown(ws.socket.sockfd, C.SHUT_WR) == -1 {
				l.e("Unabled to shutdown websocket.")
			}
			mut buf := [`0`]
			for ws.read_from_server(buf.data, 1) > 0 {
				buf[0] = `\0`
			}
			unsafe {
				buf.free()
			}
			if C.close(ws.socket.sockfd) == -1 {
				//ws.send_close_event()(websocket, 1011, strerror(errno));
			}
		}
		ws.fragments = []
		ws.send_close_event()

		ws.lock.lock()
		ws.state = .closed
		ws.lock.unlock()
		unsafe {

		}
		//TODO impl autoreconnect
	}
}

pub fn (mut ws Client) write(payload byteptr, payload_len int, code OPCode) int {
	if ws.state != .open {
		ws.send_error_event("WebSocket closed. Cannot write.")
		goto free_data
		return -1
	}

	header_len := 6 + if payload_len > 125 {2} else {0} + if payload_len > 0xffff {6} else {0}
	masking_key := create_masking_key()
	mut header := [`0`].repeat(header_len)
	mut bytes_written := -1

	header[0] = (int(code) | 0x80)
	if payload_len <= 125 {
		header[1] = (payload_len | 0x80)
		header[2] = masking_key[0]
		header[3] = masking_key[1]
		header[4] = masking_key[2]
		header[5] = masking_key[3]
	} else if payload_len > 125 && payload_len <= 0xffff {
		len16 := C.htons(payload_len)
		header[1] = (126 | 0x80)
		C.memcpy(header.data+2, &len16, 2)
		header[4] = masking_key[0]
		header[5] = masking_key[1]
		header[6] = masking_key[2]
		header[7] = masking_key[3]
	} else if payload_len > 0xffff && payload_len <= 0xffffffffffffffff { // 65535 && 18446744073709551615
		len64 := htonl64(u64(payload_len))
		header[1] = (127 | 0x80)
		C.memcpy(header.data+2, len64, 8)
		header[10] = masking_key[0]
		header[11] = masking_key[1]
		header[12] = masking_key[2]
		header[13] = masking_key[3]
	} else {
		l.c("write: frame too large")
		ws.close(1009, "frame too large")
		goto free_data
		return -1
	}

	frame_len := header_len + payload_len
	mut frame_buf := [`0`].repeat(frame_len)

	C.memcpy(frame_buf.data, header.data, header_len)
	C.memcpy(&frame_buf.data[header_len], payload, payload_len)

	for i in 0..payload_len {
		frame_buf[header_len+i] ^= masking_key[i % 4] & 0xff
	}

	bytes_written = ws.write_to_server(frame_buf.data, frame_len)
	if bytes_written == -1 {
		err := string(byteptr(C.strerror(C.errno)))
		l.e("write: there was an error writing data: ${err}")
		ws.send_error_event("Error writing data")
		goto free_data
		return -1
	}
	l.d("write: ${bytes_written} bytes written.")
	free_data:
	unsafe {
		free(payload)
		frame_buf.free()
		header.free()
		masking_key.free()
	}
	return bytes_written
}

pub fn (mut ws Client) listen() {
	l.i("Starting listener...")
	for ws.state == .open {
		ws.read()
	}
	l.i("Listener stopped as websocket was closed.")
}

pub fn (mut ws Client) read() int {
	mut bytes_read := u64(0)

	initial_buffer := u64(256)
	mut header_len := 2
	header_len_offset := 2
	extended_payload16_end_byte := 4
	extended_payload64_end_byte := 10

	mut payload_len := u64(0)
	mut data := C.calloc(initial_buffer, 1)//[`0`].repeat(int(max_buffer))

	mut frame := Frame{}
	mut frame_size := u64(header_len)

	for bytes_read < frame_size && ws.state == .open {
		byt := ws.read_from_server(data + int(bytes_read), 1)
		match byt {
			0 {
				error := "server closed the connection."
				l.e("read: ${error}")
				ws.send_error_event(error)
				ws.close(1006, error)
				goto free_data
				return -1
			}
			-1 {
				err := string(byteptr(C.strerror(C.errno)))
				l.e("read: error reading frame. ${err}")
				ws.send_error_event("error reading frame")
				goto free_data
				return -1
			} else {
				bytes_read++
			}
		}
		if bytes_read == u64(header_len_offset) {
			frame.fin = (data[0] & 0x80) == 0x80
			frame.rsv1 = (data[0] & 0x40) == 0x40
			frame.rsv2 = (data[0] & 0x20) == 0x20
			frame.rsv3 = (data[0] & 0x10) == 0x10
			frame.opcode = OPCode(int(data[0] & 0x7F))
			frame.mask = (data[1] & 0x80) == 0x80
			frame.payload_len = u64(data[1] & 0x7F)

			//masking key
			if frame.mask {
				frame.masking_key[0] = data[2]
				frame.masking_key[1] = data[3]
				frame.masking_key[2] = data[4]
				frame.masking_key[3] = data[5]
			}

			payload_len = frame.payload_len
			frame_size = u64(header_len) + payload_len
		}

		if frame.payload_len == u64(126) && bytes_read == u64(extended_payload16_end_byte) {
			header_len += 2

			mut extended_payload_len := 0
			extended_payload_len |= data[2] << 8
			extended_payload_len |= data[3] << 0

			//masking key
			if frame.mask {
				frame.masking_key[0] = data[4]
				frame.masking_key[1] = data[5]
				frame.masking_key[2] = data[6]
				frame.masking_key[3] = data[7]
			}

			payload_len = u64(extended_payload_len)
			frame_size = u64(header_len) + payload_len
			if frame_size > initial_buffer {
				l.d("reallocating: ${frame_size}")
				data = C.realloc(data, frame_size)
			}
		} else if frame.payload_len == u64(127) && bytes_read == u64(extended_payload64_end_byte) {
			header_len += 8 //TODO Not sure...

			mut extended_payload_len := u64(0)
			extended_payload_len |= u64(data[2]) << 56
			extended_payload_len |= u64(data[3]) << 48
			extended_payload_len |= u64(data[4]) << 40
			extended_payload_len |= u64(data[5]) << 32
			extended_payload_len |= u64(data[6]) << 24
			extended_payload_len |= u64(data[7]) << 16
			extended_payload_len |= u64(data[8]) << 8
			extended_payload_len |= u64(data[9]) << 0

			//masking key
			if frame.mask {
				frame.masking_key[0] = data[10]
				frame.masking_key[1] = data[11]
				frame.masking_key[2] = data[12]
				frame.masking_key[3] = data[13]
			}

			payload_len = extended_payload_len
			frame_size = u64(header_len) + payload_len
			if frame_size > initial_buffer {
				l.d("reallocating: ${frame_size}")
				data = C.realloc(data, frame_size)
			}
		}
	}

	// unmask the payload
	if frame.mask {
		for i in 0..payload_len {
			data[header_len+i] ^= frame.masking_key[i % 4] & 0xff
		}
	}

	if ws.fragments.len > 0 && frame.opcode in [.text_frame, .binary_frame] {
		ws.close(0, "")
		goto free_data
		return -1
	} else if frame.opcode in [.text_frame, .binary_frame] {
		data_node:
		l.d("read: recieved text_frame or binary_frame")
		mut payload := malloc(sizeof(byte) * int(payload_len) + 1)
		if payload == C.NULL {
			l.f("out of memory")
		}
		C.memcpy(payload, &data[header_len], payload_len)
		if frame.fin {
			if ws.fragments.len > 0 {
				//join fragments
				ws.fragments << Fragment{
					data: payload
					len: payload_len
				}
				mut frags := []Fragment{}
				mut size := u64(0)
				for f in ws.fragments {
					if f.len > 0 {
						frags << f
						size += f.len
					}
				}
				mut pl := malloc(sizeof(byte) * int(size))
				if pl == C.NULL {
					l.f("out of memory")
				}
				mut by := 0
				for i, f in frags {
					C.memcpy(pl + by, f.data, f.len)
					by += int(f.len)
					unsafe {free(f.data)}
				}
				payload = pl
				frame.opcode = ws.fragments[0].code
				payload_len = size
				//clear the fragments
				unsafe {
					ws.fragments.free()
				}
				ws.fragments = []
			}
			payload[payload_len] = `\0`
			if frame.opcode == .text_frame && payload_len > 0 {
				if !utf8_validate(payload, int(payload_len)) {
					l.e("malformed utf8 payload")
					ws.send_error_event("Recieved malformed utf8.")
					ws.close(1007, "malformed utf8 payload")
					goto free_data
					return -1
				}
			}
			message := Message {
				opcode: frame.opcode
				payload: payload
				payload_len: int(payload_len)
			}
			ws.send_message_event(message)
		} else {
			//fragment start.
			ws.fragments << Fragment{
				data: payload
				len: payload_len
				code: frame.opcode
			}
		}
		unsafe {
			free(data)
		}
		return int(bytes_read)
	}
	else if frame.opcode == .continuation {
		l.d("read: continuation")
		if ws.fragments.len <= 0 {
			l.e("Nothing to continue.")
			ws.close(1002, "nothing to continue")
			goto free_data
			return -1
		}
		goto data_node
		return 0
	}
	else if frame.opcode == .ping {
		l.d("read: ping")
		if !frame.fin {
			ws.close(1002, "control message must not be fragmented")
			goto free_data
			return -1
		}
		if frame.payload_len > 125 {
			ws.close(1002, "control frames must not exceed 125 bytes")
			goto free_data
			return -1
		}
		mut payload := []byte{}
		if payload_len > 0 {
			payload = [`0`].repeat(int(payload_len))
			C.memcpy(payload.data, &data[header_len], payload_len)
		}
		unsafe {
			free(data)
		}
		return ws.send_control_frame(.pong, "PONG", payload)
	}
	else if frame.opcode == .pong {
		if !frame.fin {
			ws.close(1002, "control message must not be fragmented")
			goto free_data
			return -1
		}
		unsafe {
			free(data)
		}
		//got pong
		return 0
	}
	else if frame.opcode == .close {
		l.d("read: close")
		if frame.payload_len > 125 {
			ws.close(1002, "control frames must not exceed 125 bytes")
			goto free_data
			return -1
		}
		mut code := 0
		mut reason := ""
		if payload_len > 2 {
			code = (int(data[header_len]) << 8) + int(data[header_len+1])
			header_len += 2
			payload_len -= 2
			reason = string(&data[header_len])
			l.i("Closing with reason: ${reason} & code: ${code}")
			if reason.len > 1 && !utf8_validate(reason.str, reason.len) {
				l.e("malformed utf8 payload")
				ws.send_error_event("Recieved malformed utf8.")
				ws.close(1007, "malformed utf8 payload")
				goto free_data
				return -1
			}
		}
		unsafe{
			free(data)
		}
		ws.close(code, reason)
		return 0
	}
	l.e("read: Recieved unsupported opcode: ${frame.opcode} fin: ${frame.fin} uri: ${ws.uri}")
	ws.send_error_event("Recieved unsupported opcode: ${frame.opcode}")
	ws.close(1002, "Unsupported opcode")
	free_data:
	unsafe {
		free(data)
	}
	return -1
}

fn (mut ws Client) send_control_frame(code OPCode, frame_typ string, payload []byte) int {
	if ws.socket.sockfd <= 0 {
		l.e("No socket opened.")
		goto free_data
		return -1
	}
	header_len := 6
	frame_len := header_len + payload.len
	mut control_frame := [`0`].repeat(frame_len)
	masking_key := create_masking_key()
	control_frame[0] = (int(code) | 0x80)
	control_frame[1] = (payload.len | 0x80)
	control_frame[2] = masking_key[0]
	control_frame[3] = masking_key[1]
	control_frame[4] = masking_key[2]
	control_frame[5] = masking_key[3]
	if code == .close {
		close_code := 1000
		if payload.len > 2 {
			mut parsed_payload := [`0`].repeat(payload.len + 1)
			C.memcpy(parsed_payload.data, &payload[0], payload.len)
			parsed_payload[payload.len] = `\0`
			for i in 0..payload.len {
				control_frame[6+i] = (parsed_payload[i] ^ masking_key[i % 4]) & 0xff
			}
			unsafe {
				parsed_payload.free()
			}
		}
	} else {
		for i in 0..payload.len {
			control_frame[header_len + i] = (payload[i] ^ masking_key[i % 4]) & 0xff
		}
	}
	mut bytes_written := -1
	bytes_written = ws.write_to_server(control_frame.data, frame_len)
	free_data:
	unsafe {
		control_frame.free()
		payload.free()
		masking_key.free()
	}
	match bytes_written {
		0 {
			l.d("send_control_frame: remote host closed the connection.")
			return 0
		}
		-1 {
			l.c("send_control_frame: error sending ${frame_typ} control frame.")
			return -1
		} else {
			l.d("send_control_frame: wrote ${bytes_written} byte ${frame_typ} frame.")
			return bytes_written
		}
	}
}module main

import net.websocket
import eventbus
import time
import readline
import term
import benchmark

const (
	eb = eventbus.new()
)

#flag -I $PWD
#include "utf8.h"
fn C.utf8_validate_str() bool

fn main() {
	// println(sss)
	/*
	for sss in 0..10 {
		mut bm := benchmark.new_benchmark()
		for i in 0..10000 {
			for a, t in tests {
				ss := ws.utf8_validate(t.str, t.len)
				if !ss {
					panic("failed")
				}
				//println("${a}:${ss}")
			}
		}
		bm.stop()
		println( bm.total_message('remarks about the benchmark') )
	}
*/
	mut ws := websocket.new('ws://localhost:9001/getCaseCount')
	// defer { }
	ws.subscriber.subscribe('on_open', on_open)
	ws.subscriber.subscribe('on_message', on_message)
	ws.subscriber.subscribe('on_error', on_error)
	ws.subscriber.subscribe('on_close', on_close)
	// go
	ws.connect()
	ws.read()
	// time.usleep(2000000)
	// go ws.listen()
	// term.erase_clear()
	/*
	text := read_line("[client]:")
	if text == "close" {
		ws.close(1005, "done")
		time.usleep(1000000)
		exit(0)
	}
	ws.write(text, .text_frame)
*/
	/*
	time.usleep(1000000)
	ws.read()
*/
	// ws.close(1005, "done")	//
	// ws.close(1005, "done")
	// read_line("wait")
}

fn read_line(text string) string {
	mut r := readline.Readline{}
	mut output := r.read_line(text + ' ') or {
		panic(err)
	}
	output = output.replace('\n', '')
	if output.len <= 0 {
		return ''
	}
	return output
}

fn on_open(params eventbus.Params) {
	println('websocket opened.')
}

fn on_message(params eventbus.Params) {
	println('Message recieved. Sending it back.')
	typ := params.get_string('type')
	len := params.get_int('len')
	mut ws := params.get_caller(websocket.Client{})
	if typ == 'string' {
		message := params.get_string('payload')
		if ws.uri.ends_with('getCaseCount') {
			num := message.int()
			ws.close(1005, 'done')
			start_tests(mut ws, num)
			return
		}
		// println("Message: " + message)
		ws.write(message.str, len, .text_frame)
	} else {
		println('Binary message.')
		message := params.get_raw('payload')
		ws.write(message, len, .binary_frame)
	}
}

fn start_tests(ws mut websocket.Client, num int) {
	for i := 1; i < num; i++ {
		println('Running test: ' + i.str())
		ws.uri = 'ws://localhost:9001/runCase?case=${i.str()}&agent=vws/1.0a'
		if ws.connect() >= 0 {
			ws.listen()
		}
	}
	println('Done!')
	ws.uri = 'ws://localhost:9001/updateReports?agent=vws/1.0a'
	if ws.connect() >= 0 {
		ws.read()
		ws.close(1000, 'disconnecting...')
	}
	exit(0)
}

fn on_close(params eventbus.Params) {
	println('websocket closed.')
}

fn on_error(params eventbus.Params) {
	println('we have an error.')
}
/*
   Copyright (c) 2015, Andreas Fett
   All rights reserved.
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:
   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <assert.h>

typedef int utf8_state;

static utf8_state next_state(utf8_state, unsigned char);

// Public API see utf8-validate.h for docs of the following function

bool utf8_validate(utf8_state *const state, int c)
{
	assert(state);
	return (*state = next_state(*state, c)) != -1;
}

bool utf8_validate_some(utf8_state *const state, const void * const src, size_t len)
{
	assert(state);
	assert(src);
	for (size_t i = 0; i < len; ++i) {
		*state = next_state(*state, *((unsigned char *)src + i));
		if (*state == -1) {
			return false;
		}
	}
	return true;
}

bool utf8_validate_mem(const void * const src, size_t len)
{
	assert(src);
	utf8_state state = 0;
	for (size_t i = 0; i < len; ++i) {
		state = next_state(state, *((unsigned char *)src + i));
		if (state == -1) {
			return false;
		}
	}

	// detect unterminated sequence
	return state == 0;
}

bool utf8_validate_str(const char * const str)
{
	assert(str);
	utf8_state state = 0;
	for (size_t i = 0; str[i] != 0; ++i) {
		state = next_state(state, str[i]);
		if (state == -1) {
			return false;
		}
	}
	// detect unterminated sequence
	return state == 0;
}

/* Private state engine
 *
 * The macros below assemble the cases for a switch statement
 * matching the language of the ABNF grammar given in rfc3629.
 *
 * Each SEQ# macro adds the states to match a # char long sequence.
 *
 * The SEQ#_HELPERs all have a 'fall through' to the next sequence.
 * for # > 1 this is an explicit goto
 */

#define SEQ_END(n) SEQ_ ## n ## _END

#define SEQ1_HELPER(s, r0)                                     \
case (s * 4) + 0: if (r0) return 0; goto SEQ_END(s);           \
SEQ_END(s):

#define SEQ2_HELPER(s, r0, r1)                                 \
case (s * 4) + 0: if (r0) { printf("ehe"); return (s * 4) + 1; } goto SEQ_END(s); \
case (s * 4) + 1: if (r1) return 0;           return -1;       \
SEQ_END(s):

#define SEQ3_HELPER(s, r0, r1, r2)                             \
case (s * 4) + 0: if (r0) return (s * 4) + 1; goto SEQ_END(s); \
case (s * 4) + 1: if (r1) return (s * 4) + 2; return -1;       \
case (s * 4) + 2: if (r2) return 0;           return -1;       \
SEQ_END(s):

#define SEQ4_HELPER(s, r0, r1, r2, r3)                         \
case (s * 4) + 0: if (r0) return (s * 4) + 1; goto SEQ_END(s); \
case (s * 4) + 1: if (r1) return (s * 4) + 2; return -1;       \
case (s * 4) + 2: if (r2) return (s * 4) + 3; return -1;       \
case (s * 4) + 3: if (r3) return 0;           return -1;       \
SEQ_END(s):

#define SEQ1(s, r0)             SEQ1_HELPER(s, r0)
#define SEQ2(s, r0, r1)         SEQ2_HELPER(s, r0, r1)
#define SEQ3(s, r0, r1, r2)     SEQ3_HELPER(s, r0, r1, r2)
#define SEQ4(s, r0, r1, r2, r3) SEQ4_HELPER(s, r0, r1, r2, r3)

// Matcher macros

#define VALUE(v)     (c == v)
#define RANGE(s, e)  (c >= s && c <= e)
/* workaround for "-Wtype-limits" as c >= s is allways true for
 * the unsigned char in the case of c == 0 */
#define EGNAR(s, e) ((c >= s + 1 && c <= e) || c == s)

/* from rfc3629
 *
 * UTF8-octets = *( UTF8-char )
 *    UTF8-char   = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4
 *    UTF8-1      = %x00-7F
 *    UTF8-2      = %xC2-DF UTF8-tail
 *    UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /
 *                  %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )
 *    UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /
 *                  %xF4 %x80-8F 2( UTF8-tail )
 *    UTF8-tail   = %x80-BF
 */

#define TAIL RANGE(0x80, 0xBF)

static inline utf8_state next_state(utf8_state state, unsigned char c)
{
	printf("C: %d\n", c);
	switch (state) {
	SEQ1(0, EGNAR(0x00, 0x7F))
	SEQ2(1, RANGE(0xC2, 0xDF), TAIL)
	SEQ3(2, VALUE(0xE0),       RANGE(0xA0, 0xBF), TAIL)
	SEQ3(3, RANGE(0xE1, 0xEC), TAIL,              TAIL)
	SEQ3(4, VALUE(0xED),       RANGE(0x80, 0x9F), TAIL)
	SEQ3(5, RANGE(0xEE, 0xEF), TAIL,              TAIL)
	SEQ4(6, VALUE(0xF0),       RANGE(0x90, 0xBF), TAIL, TAIL)
	SEQ4(7, RANGE(0xF1, 0xF3), TAIL,              TAIL, TAIL)
	SEQ4(8, VALUE(0xF4),       RANGE(0x80, 0x8F), TAIL, TAIL)
		// no sequence start matched
		break;
	default:
		/*
		 * This should not happen, unless you feed an error
		 * state or an uninitialized utf8_state to this function.
		 */
		assert(false && "invalid utf8 state");
	}

	return -1;
}module logger

const (
	colors = {
		"success": "\e[32",
		"debug": "\e[36",
		"error": "\e[91",
		"warn": "\e[33",
		"critical": "\e[31",
		"fatal": "\e[31",
		"info": "\e[37"
	}
)

struct Logger {
	mod string
}

pub fn new(mod string) &Logger {
	return &Logger{mod: mod}
}

pub fn (l &Logger) d(message string){
	$if debug {
		l.print("debug", message)
	}
}

pub fn (l &Logger) i(message string){
	l.print('info', message)
}

pub fn (l &Logger) e(message string){
	l.print('error', message)
}

pub fn (l &Logger) c(message string){
	l.print('critical', message)
}

pub fn (l &Logger) f(message string){
	l.print('fatal', message)
	exit(-1)
}

pub fn (l &Logger) w(message string){
	l.print('warn', message)
}

pub fn (l &Logger) s(message string) {
	l.print('success', message)
}

fn (l &Logger) print(mod, message string) {
	println('${colors[mod]};7m[${mod}]\e[0m \e[1m${l.mod}\e[0m: ${message}')
}//import pg
 
struct Modules {
	id int 
	user_id int 
	name string 
	url string
	//nr_downloads int 
}

fn test_orm() {
/* 
	db := pg.connect('vpm', 'alex')
	//nr_modules := db.select count from modules  
	//nr_modules := db.select count from Modules where id == 1 
	nr_modules := db.select count from Modules where  
		name == 'Bob' && id == 1 
	println(nr_modules) 
 
	mod := db.select from Modules where id = 1 limit 1 
	println(mod) 

	mods := db.select from Modules limit 10 
	for mod in mods { 
	println(mod) 
	} 
*/ 

/* 
	mod := db.retrieve<Module>(1) 

	mod := db.update Module set name = name + '!' where id > 10 


	nr_modules := db.select count from Modules 
		where id > 1 && name == '' 
	println(nr_modules) 

	nr_modules := db.select count from modules 
	nr_modules := db.select from modules 
	nr_modules := db[:modules].select 
*/ 
/* 
	mod := select from db.modules where id = 1 limit 1 
	println(mod.name) 
	top_mods := select from db.modules where nr_downloads > 1000 order by nr_downloads desc limit 10 
	top_mods := db.select from modules where nr_downloads > 1000 order by nr_downloads desc limit 10 
	top_mods := db.select<Module>(m => m.nr_downloads > 1000).order_by(m => m.nr_downloads).desc().limit(10) 
	names := select name from db.modules // []string 


	n := db.q_int('select count(*) from modules') 
	println(n) 
*/ 
} 
module os
// (Must be realized in Syscall) (Must be specified)

// ref: http://www.ccfit.nsu.ru/~deviv/courses/unix/unix/ng7c229.html
const (
	s_ifmt  = 0xF000 // type of file
	s_ifdir = 0x4000 // directory
	s_iflnk = 0xa000 // link
	s_ixusr = 0o100  // is executable by the owner
	s_ixgrp = 0o010  // is executable by group
	s_ixoth = 0o001  // is executable by others
)

const (
	std_input_handle = -10
	std_output_handle = -11
	std_error_handle = -12
)
module os

// File modes
const (
	o_rdonly	= 000000000 // open the file read-only.
	o_wronly	= 000000001 // open the file write-only.
	o_rdwr		= 000000002 // open the file read-write.
	o_create	= 000000100 // create a new file if none exists.
	o_excl		= 000000200 // used with o_create, file must not exist.
	o_noctty	= 000000400 // if file is terminal, don't make it the controller terminal
	o_trunc		= 000001000 // truncate regular writable file when opened.
	o_append	= 000002000 // append data to the file when writing.
	o_nonblock	= 000004000 // prevents blocking when opening files
	o_sync		= 000010000 // open for synchronous I/O.
)
module os

// Ref - winnt.h
const (
	success = 0 // ERROR_SUCCESS
	error_insufficient_buffer = 130
)

const (
	file_share_read   = 1
	file_share_write  = 2
	file_share_delete = 4
)

const (
	file_notify_change_file_name   = 1
	file_notify_change_dir_name    = 2
	file_notify_change_attributes  = 4
	file_notify_change_size        = 8
	file_notify_change_last_write  = 16
	file_notify_change_last_access = 32
	file_notify_change_creation    = 64
	file_notify_change_security    = 128
)

const (
	file_action_added              = 1
	file_action_removed            = 2
	file_action_modified           = 3
	file_action_renamed_old_name   = 4
	file_action_renamed_new_name   = 5
)

const (
	file_attr_readonly                 = 0x1
	file_attr_hidden                   = 0x2
	file_attr_system                   = 0x4
	file_attr_directory                = 0x10
	file_attr_archive                  = 0x20
	file_attr_device                   = 0x40
	file_attr_normal                   = 0x80
	file_attr_temporary                = 0x100
	file_attr_sparse_file              = 0x200
	file_attr_reparse_point            = 0x400
	file_attr_compressed               = 0x800
	file_attr_offline                  = 0x1000
	file_attr_not_content_indexed      = 0x2000
	file_attr_encrypted                = 0x4000
	file_attr_integrity_stream         = 0x8000
	file_attr_virtual                  = 0x10000
	file_attr_no_scrub_data            = 0x20000
	// file_attr_recall_on_open        = u32(0x...)
	// file_attr_recall_on_data_access = u32(0x...)
)

const (
	file_type_disk = 0x1
	file_type_char = 0x2
	file_type_pipe = 0x3

	file_type_unknown = 0x0
)

const (
	file_invalid_file_id = (-1)
)

const(
	invalid_handle_value = voidptr(-1)
)

// https://docs.microsoft.com/en-us/windows/console/setconsolemode
const (
    // Input Buffer
    enable_echo_input                  = 0x0004
    enable_extended_flags              = 0x0080
    enable_insert_mode                 = 0x0020
    enable_line_input                  = 0x0002
    enable_mouse_input                 = 0x0010
    enable_processed_input             = 0x0001
    enable_quick_edit_mode             = 0x0040
    enable_window_input                = 0x0008
    enable_virtual_terminal_input      = 0x0200
    // Output Screen Buffer
    enable_processed_output            = 0x0001
    enable_wrap_at_eol_output          = 0x0002
    enable_virtual_terminal_processing = 0x0004
    disable_newline_auto_return        = 0x0008
    enable_lvb_grid_worldwide          = 0x0010
)

// File modes
const (
	o_rdonly	= 0			// open the file read-only.
	o_wronly	= 1			// open the file write-only.
	o_rdwr		= 2			// open the file read-write.
	o_append	= 0x0008	// append data to the file when writing.
	o_create	= 0x0100	// create a new file if none exists.
	o_trunc		= 0x0200	// truncate regular writable file when opened.
	o_excl		= 0x0400	// used with o_create, file must not exist.
	o_sync		= 0			// open for synchronous I/O (ignored on Windows)
	o_noctty	= 0			// make file non-controlling tty (ignored on Windows)
	o_nonblock	= 0			// don't block on opening file (ignored on Windows)
)
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module os

fn C.getenv(byteptr) &char
// C.GetEnvironmentStringsW & C.FreeEnvironmentStringsW are defined only on windows
fn C.GetEnvironmentStringsW() &u16


fn C.FreeEnvironmentStringsW(&u16) int
// `getenv` returns the value of the environment variable named by the key.
pub fn getenv(key string) string {
	$if windows {
		s := C._wgetenv(key.to_wide())
		if s == 0 {
			return ''
		}
		return string_from_wide(s)
	} $else {
		s := C.getenv(key.str)
		if s == 0 {
			return ''
		}
		// NB: C.getenv *requires* that the result be copied.
		return cstring_to_vstring(byteptr(s))
	}
}

// os.setenv sets the value of an environment variable with `name` to `value`.
pub fn setenv(name string, value string, overwrite bool) int {
	$if windows {
		format := '$name=$value'
		if overwrite {
			return C._putenv(format.str)
		}
		return -1
	} $else {
		return C.setenv(name.str, value.str, overwrite)
	}
}

// os.unsetenv clears an environment variable with `name`.
pub fn unsetenv(name string) int {
	$if windows {
		format := '${name}='
		return C._putenv(format.str)
	} $else {
		return C.unsetenv(name.str)
	}
}

// See: https://linux.die.net/man/5/environ for unix platforms.
// See: https://docs.microsoft.com/bg-bg/windows/win32/api/processenv/nf-processenv-getenvironmentstrings
// os.environ returns a map of all the current environment variables
pub fn environ() map[string]string {
	mut res := map[string]string
	$if windows {
		mut estrings := C.GetEnvironmentStringsW()
		mut eline := ''
		for c := estrings; *c != 0; c = c + eline.len + 1 {
			eline = string_from_wide(c)
			eq_index := eline.index_byte(`=`)
			if eq_index > 0 {
				res[eline[0..eq_index]] = eline[eq_index + 1..]
			}
		}
		C.FreeEnvironmentStringsW(estrings)
	} $else {
		e := &charptr(C.environ)
		for i := 0; !isnil(e[i]); i++ {
			eline := cstring_to_vstring(e[i])
			eq_index := eline.index_byte(`=`)
			if eq_index > 0 {
				res[eline[0..eq_index]] = eline[eq_index + 1..]
			}
		}
	}
	return res
}
import os

fn test_getenv() {
	// VEXE is set by the V builtin test runner
	assert os.getenv('VEXE').len > 0
	assert os.getenv('PATH').len > 0
}

fn test_setenv() {
	os.setenv('foo', 'bar', true)
	assert os.getenv('foo') == 'bar'
	// `setenv` should not set if `overwrite` is false
	os.setenv('foo', 'bar2', false)
	assert os.getenv('foo') == 'bar'
	// `setenv` should overwrite if `overwrite` is true
	os.setenv('foo', 'bar2', true)
	assert os.getenv('foo') == 'bar2'
}

fn test_unsetenv() {
	os.setenv('foo', 'bar', true)
	os.unsetenv('foo')
	assert os.getenv('foo') == ''
}

fn test_environ() {
	os.setenv('myvar1', 'bar1', true)
	os.setenv('myvar2', 'bar2', true)
	assert os.getenv('myvar1') == 'bar1'
	assert os.getenv('myvar2') == 'bar2'
	assert os.getenv('myvar_not_defined') == ''
	all := os.environ()
	assert all['myvar1'] == 'bar1'
	assert all['myvar2'] == 'bar2'
	assert all['myvar_not_defined'] == ''
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module os

enum FileType {
	regular
	directory
	character_device
	block_device
	fifo
	symbolic_link
	socket
}

struct FilePermission {
pub:
	read bool
	write bool
	execute bool
}

struct FileMode {
pub:
	typ FileType
	owner FilePermission
	group FilePermission
	others FilePermission
}

// inode returns the mode of the file/inode containing inode type and permission information
// it supports windows for regular files but it doesn't matter if you use owner, group or others when checking permissions on windows
pub fn inode(path string) FileMode {
	mut attr := C.stat{}
	C.stat(path.str, &attr)

	mut typ := FileType.regular
	if attr.st_mode & C.S_IFMT == C.S_IFDIR {
		typ = .directory
	}
	$if !windows {
		if attr.st_mode & C.S_IFMT == C.S_IFCHR {
			typ = .character_device
		} else if attr.st_mode & C.S_IFMT == C.S_IFBLK {
			typ = .block_device
		} else if attr.st_mode & C.S_IFMT == C.S_IFIFO {
			typ = .fifo
		} else if attr.st_mode & C.S_IFMT == C.S_IFLNK {
			typ = .symbolic_link
		} else if attr.st_mode & C.S_IFMT == C.S_IFSOCK {
			typ = .socket
		}
	}

	$if windows {
		return FileMode{
			typ: typ
			owner: FilePermission{
				read: bool(attr.st_mode & C.S_IREAD)
				write: bool(attr.st_mode & C.S_IWRITE)
				execute: bool(attr.st_mode & C.S_IEXEC)
			}
			group: FilePermission{
				read: bool(attr.st_mode & C.S_IREAD)
				write: bool(attr.st_mode & C.S_IWRITE)
				execute: bool(attr.st_mode & C.S_IEXEC)
			}
			others: FilePermission{
				read: bool(attr.st_mode & C.S_IREAD)
				write: bool(attr.st_mode & C.S_IWRITE)
				execute: bool(attr.st_mode & C.S_IEXEC)
			}
		}
	} $else {
		return FileMode{
			typ: typ
			owner: FilePermission{
				read: bool(attr.st_mode & C.S_IRUSR)
				write: bool(attr.st_mode & C.S_IWUSR)
				execute: bool(attr.st_mode & C.S_IXUSR)
			}
			group: FilePermission{
				read: bool(attr.st_mode & C.S_IRGRP)
				write: bool(attr.st_mode & C.S_IWGRP)
				execute: bool(attr.st_mode & C.S_IXGRP)
			}
			others: FilePermission{
				read: bool(attr.st_mode & C.S_IROTH)
				write: bool(attr.st_mode & C.S_IWOTH)
				execute: bool(attr.st_mode & C.S_IXOTH)
			}
		}
	}
}
import os

const (
	// tfolder will contain all the temporary files/subfolders made by
	// the different tests. It would be removed in testsuite_end(), so
	// individual os tests do not need to clean up after themselves.
	tfolder = os.join_path(os.temp_dir(), 'v', 'tests', 'inode_test')
)

fn testsuite_begin() {
	eprintln('testsuite_begin, tfolder = $tfolder')
	os.rmdir_all(tfolder)
	assert !os.is_dir(tfolder)
	os.mkdir_all(tfolder)
	os.chdir(tfolder)
	assert os.is_dir(tfolder)
}

fn testsuite_end() {
	os.chdir(os.wd_at_startup)
	os.rmdir_all(tfolder)
	assert !os.is_dir(tfolder)
}

fn test_inode_file_type() {
	filename := './test1.txt'
	if file := os.open_file(filename, 'w', 0o600) {
		file.close()
	}
	mode := os.inode(filename)
	os.rm(filename)
	assert mode.typ == .regular
}

fn test_inode_file_owner_permission() {
	filename := './test2.txt'
	if file := os.open_file(filename, 'w', 0o600) {
		file.close()
	}
	mode := os.inode(filename)
	os.rm(filename)
	assert mode.owner.read
	assert mode.owner.write
	assert !mode.owner.execute
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module os

#include <sys/stat.h> // #include <signal.h>
#include <errno.h>

/*
struct dirent {
     d_ino int
     d_off int
	d_reclen u16
	d_type byte
	d_name [256]byte
}
*/

struct C.dirent {
	d_name byteptr
}

fn C.readdir(voidptr) C.dirent

pub const (
	args = []string{}
	max_path_len = 4096
)

pub struct File {
	cfile  voidptr // Using void* instead of FILE*
pub:
	fd     int
mut:
	opened bool
}

struct FileInfo {
	name string
	size int
}

struct C.stat {
	st_size  int
	st_mode  u32
	st_mtime int
}

struct C.DIR {}

// struct C.dirent {
// d_name byteptr
// }
struct C.sigaction {
mut:
	sa_mask      int
	sa_sigaction int
	sa_flags     int
}

fn C.getline(voidptr, voidptr, voidptr) int


fn C.ftell(fp voidptr) int


fn C.sigaction(int, voidptr, int)


fn C.open(charptr, int, int) int


fn C.fdopen(int, string) voidptr


pub fn (f File) is_opened() bool {
	return f.opened
}

/***************************** Write ops ****************************/

pub fn (mut f File) write(s string) {
	if !f.opened {
		return
	}
	/*
	$if linux {
		$if !android {
			C.syscall(sys_write, f.fd, s.str, s.len)
			return
		}
	}
	*/
	C.fputs(s.str, f.cfile)
}

pub fn (mut f File) writeln(s string) {
	if !f.opened {
		return
	}
	/*
	$if linux {
		$if !android {
			snl := s + '\n'
			C.syscall(sys_write, f.fd, snl.str, snl.len)
			return
		}
	}
	*/
	// TODO perf
	C.fputs(s.str, f.cfile)
	C.fputs('\n', f.cfile)
}

pub fn (mut f File) write_bytes(data voidptr, size int) {
	C.fwrite(data, 1, size, f.cfile)
}

pub fn (mut f File) write_bytes_at(data voidptr, size, pos int) {
	//$if linux {
	//}
	//$else {
	C.fseek(f.cfile, pos, C.SEEK_SET)
	C.fwrite(data, 1, size, f.cfile)
	C.fseek(f.cfile, 0, C.SEEK_END)
	//}
}

/***************************** Read ops  ****************************/


// read_bytes reads an amount of bytes from the beginning of the file
pub fn (f &File) read_bytes(size int) []byte {
	return f.read_bytes_at(size, 0)
}

// read_bytes_at reads an amount of bytes at the given position in the file
pub fn (f &File) read_bytes_at(size, pos int) []byte {
	mut arr := [`0`].repeat(size)
	C.fseek(f.cfile, pos, C.SEEK_SET)
	nreadbytes := C.fread(arr.data, 1, size, f.cfile)
	C.fseek(f.cfile, 0, C.SEEK_SET)
	return arr[0..nreadbytes]
}


pub fn read_bytes(path string) ?[]byte {
	mut fp := vfopen(path, 'rb')
	if isnil(fp) {
		return error('failed to open file "$path"')
	}
	C.fseek(fp, 0, C.SEEK_END)
	fsize := C.ftell(fp)
	C.rewind(fp)
	mut res := [`0`].repeat(fsize)
	nr_read_elements := C.fread(res.data, fsize, 1, fp)
	C.fclose(fp)
	return res[0..nr_read_elements * fsize]
}


// read_file reads the file in `path` and returns the contents.
pub fn read_file(path string) ?string {
	mode := 'rb'
	mut fp := vfopen(path, mode)
	if isnil(fp) {
		return error('failed to open file "$path"')
	}
	defer { C.fclose(fp) }
	C.fseek(fp, 0, C.SEEK_END)
	fsize := C.ftell(fp)
	// C.fseek(fp, 0, SEEK_SET)  // same as `C.rewind(fp)` below
	C.rewind(fp)
	mut str := &byte(0)
	unsafe { str = malloc(fsize + 1) }
	C.fread(str, fsize, 1, fp)
	str[fsize] = 0
	return string(str,fsize)
}

/***************************** Utility  ops ************************/
pub fn (mut f File) flush() {
	if !f.opened {
		return
	}
	C.fflush(f.cfile)
}

/***************************** OS ops ************************/
// file_size returns the size of the file located in `path`.
pub fn file_size(path string) int {
	mut s := C.stat{}
	$if windows {
		C._wstat(path.to_wide(), voidptr(&s))
	} $else {
		C.stat(charptr(path.str), &s)
	}
	return s.st_size
}

pub fn mv(old, new string) {
	$if windows {
		C._wrename(old.to_wide(), new.to_wide())
	} $else {
		C.rename(charptr(old.str), charptr(new.str))
	}
}

fn C.CopyFile(&u32, &u32, int) int
// TODO implement actual cp for linux
pub fn cp(old, new string) ?bool {
	$if windows {
		w_old := old.replace('/', '\\')
		w_new := new.replace('/', '\\')
		C.CopyFile(w_old.to_wide(), w_new.to_wide(), false)
		result := C.GetLastError()
		if result == 0 {
			return true
		}
		else {
			return error_with_code('failed to copy $old to $new', int(result))
		}
	} $else {
		os.system('cp "$old" "$new"')
		return true // TODO make it return true or error when cp for linux is implemented
	}
}

[deprecated]
pub fn cp_r(osource_path, odest_path string, overwrite bool) ?bool {
	panic('Use `os.cp_all` instead of `os.cp_r`')
}

pub fn cp_all(osource_path, odest_path string, overwrite bool) ?bool {
	source_path := os.real_path(osource_path)
	dest_path := os.real_path(odest_path)
	if !os.exists(source_path) {
		return error("Source path doesn\'t exist")
	}
	// single file copy
	if !os.is_dir(source_path) {
		adjusted_path := if os.is_dir(dest_path) {os.join_path(dest_path,os.file_name(source_path)) } else { dest_path }
		if os.exists(adjusted_path) {
			if overwrite {
				os.rm(adjusted_path)
			}
			else {
				return error('Destination file path already exist')
			}
		}
		os.cp(source_path, adjusted_path) or {
			return error(err)
		}
		return true
	}
	if !os.is_dir(dest_path) {
		return error('Destination path is not a valid directory')
	}
	files := os.ls(source_path) or {
		return error(err)
	}
	for file in files {
		sp := os.join_path(source_path, file)
		dp := os.join_path(dest_path, file)
		if os.is_dir(sp) {
			os.mkdir(dp) or {
				panic(err)
			}
		}
		cp_all(sp, dp, overwrite) or {
			os.rmdir(dp)
			panic(err)
		}
	}
	return true
}

// mv_by_cp first copies the source file, and if it is copied successfully, deletes the source file.
// mv_by_cp may be used when you are not sure that the source and target are on the same mount/partition.
pub fn mv_by_cp(source string, target string) ?bool {
	os.cp(source, target) or {
		return error(err)
	}
	os.rm(source)
	return true
}

// vfopen returns an opened C file, given its path and open mode.
// NB: os.vfopen is useful for compatibility with C libraries, that expect `FILE *`.
// If you write pure V code, os.create or os.open are more convenient.
pub fn vfopen(path, mode string) &C.FILE {
	$if windows {
		return C._wfopen(path.to_wide(), mode.to_wide())
	} $else {
		return C.fopen(charptr(path.str), charptr(mode.str))
	}
}

// fileno returns the file descriptor of an opened C file
pub fn fileno(cfile voidptr) int {
	$if windows {
		return C._fileno(cfile)
	} $else {
		return C.fileno(cfile)
	}
}

// read_lines reads the file in `path` into an array of lines.
pub fn read_lines(path string) ?[]string {
	buf := read_file(path) or {
		return error(err)
	}
	return buf.split_into_lines()
}

fn read_ulines(path string) ?[]ustring {
	lines := read_lines(path) or {
		return error(err)
	}
	// mut ulines := new_array(0, lines.len, sizeof(ustring))
	mut ulines := []ustring{}
	for myline in lines {
		// ulines[i] = ustr
		ulines << myline.ustring()
	}
	return ulines
}

pub fn open_append(path string) ?File {
	mut file := File{}
	$if windows {
		wpath := path.replace('/', '\\').to_wide()
		mode := 'ab'
		file = File{
			cfile: C._wfopen(wpath, mode.to_wide())
		}
	} $else {
		cpath := path.str
		file = File{
			cfile: C.fopen(charptr(cpath), 'ab')
		}
	}
	if isnil(file.cfile) {
		return error('failed to create(append) file "$path"')
	}
	file.opened = true
	return file
}

// open_file can be used to open or create a file with custom flags and permissions and returns a `File` object
pub fn open_file(path string, mode string, options ...int) ?File {
	mut flags := 0
	for m in mode {
		match m {
			`r` { flags |= o_rdonly }
			`w` { flags |= o_create | o_trunc }
			`a` { flags |= o_create | o_append }
			`s` { flags |= o_sync }
			`n` { flags |= o_nonblock }
			`c` { flags |= o_noctty }
			`+` { flags |= o_rdwr }
			else {}
		}
	}

	mut permission := 0o666
	if options.len > 0 {
		permission = options[0]
	}

	$if windows {
		if permission < 0o600 {
			permission = 0x0100
		}
		else {
			permission = 0x0100 | 0x0080
		}
	}

	mut p := path
	$if windows {
		p = path.replace('/', '\\')
	}

	fd := C.open(charptr(p.str), flags, permission)
	if fd == -1 {
		return error(posix_get_error_msg(C.errno))
	}

	cfile := C.fdopen(fd, charptr(mode.str))
	if isnil(cfile) {
		return error('Failed to open or create file "$path"')
	}

	return File{
		cfile: cfile
		fd: fd
		opened: true
	}
}



// system starts the specified command, waits for it to complete, and returns its code.
fn vpopen(path string) voidptr {
	// *C.FILE {
	$if windows {
		mode := 'rb'
		wpath := path.to_wide()
		return C._wpopen(wpath, mode.to_wide())
	} $else {
		cpath := path.str
		return C.popen(cpath, 'r')
	}
}

fn posix_wait4_to_exit_status(waitret int) (int,bool) {
	$if windows {
		return waitret,false
	} $else {
		mut ret := 0
		mut is_signaled := true
		// (see man system, man 2 waitpid: C macro WEXITSTATUS section)
		if C.WIFEXITED(waitret) {
			ret = C.WEXITSTATUS(waitret)
			is_signaled = false
		}
		else if C.WIFSIGNALED(waitret) {
			ret = C.WTERMSIG(waitret)
			is_signaled = true
		}
		return ret,is_signaled
	}
}

// posix_get_error_msg return error code representation in string.
pub fn posix_get_error_msg(code int) string {
	ptr_text := C.strerror(code) // voidptr?
	if ptr_text == 0 {
		return ''
	}
	return tos3(ptr_text)
}

fn vpclose(f voidptr) int {
	$if windows {
		return C._pclose(f)
	} $else {
		ret,_ := posix_wait4_to_exit_status(C.pclose(f))
		return ret
	}
}

struct Foo2 {
	x int

}

pub struct Result {
pub:
	exit_code int
	output    string
	// stderr string // TODO
}
// `system` works like `exec()`, but only returns a return code.
pub fn system(cmd string) int {
	// if cmd.contains(';') || cmd.contains('&&') || cmd.contains('||') || cmd.contains('\n') {
	// TODO remove panic
	// panic(';, &&, || and \\n are not allowed in shell commands')
	// }
	mut ret := 0
	$if windows {
		// overcome bug in system & _wsystem (cmd) when first char is quote `"`
		wcmd := if cmd.len > 1 && cmd[0] == `"` && cmd[1] != `"` { '"$cmd"' } else { cmd }
		ret = C._wsystem(wcmd.to_wide())
	} $else {
		ret = C.system(cmd.str)
	}
	if ret == -1 {
		print_c_errno()
	}
	$if !windows {
		pret,is_signaled := posix_wait4_to_exit_status(ret)
		if is_signaled {
			println('Terminated by signal ${ret:2d} (' + sigint_to_signal_name(pret) + ')')
		}
		ret = pret
	}
	return ret
}

pub fn sigint_to_signal_name(si int) string {
	// POSIX signals:
	match si {
		1 {
			return 'SIGHUP'
		}
		2 {
			return 'SIGINT'
		}
		3 {
			return 'SIGQUIT'
		}
		4 {
			return 'SIGILL'
		}
		6 {
			return 'SIGABRT'
		}
		8 {
			return 'SIGFPE'
		}
		9 {
			return 'SIGKILL'
		}
		11 {
			return 'SIGSEGV'
		}
		13 {
			return 'SIGPIPE'
		}
		14 {
			return 'SIGALRM'
		}
		15 {
			return 'SIGTERM'
		}
		else {}
	}
	$if linux {
		// From `man 7 signal` on linux:
		match si {
			// TODO dependent on platform
			// works only on x86/ARM/most others
			10 /*, 30, 16 */ {
				return 'SIGUSR1'
			}
			12 /*, 31, 17 */ {
				return 'SIGUSR2'
			}
			17 /*, 20, 18 */ {
				return 'SIGCHLD'
			}
			18 /*, 19, 25 */ {
				return 'SIGCONT'
			}
			19 /*, 17, 23 */ {
				return 'SIGSTOP'
			}
			20 /*, 18, 24 */ {
				return 'SIGTSTP'
			}
			21 /*, 26 */ {
				return 'SIGTTIN'
			}
			22 /*, 27 */ {
				return 'SIGTTOU'
			}
			// /////////////////////////////
			5 {
				return 'SIGTRAP'
			}
			7 {
				return 'SIGBUS'
			}
			else {}
		}
	}
	return 'unknown'
}

const (
	f_ok = 0
	x_ok = 1
	w_ok = 2
	r_ok = 4
)

// exists returns true if `path` exists.
pub fn exists(path string) bool {
	$if windows {
		p := path.replace('/', '\\')
		return C._waccess(p.to_wide(), f_ok) != -1
	} $else {
		return C.access(path.str, f_ok) != -1
	}
}

// `is_executable` returns `true` if `path` is executable.
pub fn is_executable(path string) bool {
  $if windows {
    // NB: https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=vs-2019
    // i.e. there is no X bit there, the modes can be:
    // 00 Existence only
    // 02 Write-only
    // 04 Read-only
    // 06 Read and write
    p := os.real_path( path )
    return ( os.exists( p ) && p.ends_with('.exe') )
  }
  $if solaris {
    statbuf := C.stat{}
    if C.stat(path.str, &statbuf) != 0 {
      return false
    }
    return (int(statbuf.st_mode) & ( s_ixusr | s_ixgrp | s_ixoth )) != 0
  }
  return C.access(path.str, x_ok) != -1
}

// `is_writable_folder` - `folder` exists and is writable to the process
pub fn is_writable_folder(folder string) ?bool {
	if !os.exists(folder) {
		return error('`$folder` does not exist')
	}
	if !os.is_dir(folder) {
		return error('`folder` is not a folder')
	}
	tmp_perm_check := os.join_path(folder, 'tmp_perm_check')
	f := os.open_file(tmp_perm_check, 'w+', 0o700) or {
		return error('cannot write to folder `$folder`: $err')
	}
	f.close()
	os.rm(tmp_perm_check)
	return true
}

// `is_writable` returns `true` if `path` is writable.
pub fn is_writable(path string) bool {
  $if windows {
    p := path.replace('/', '\\')
    return C._waccess(p.to_wide(), w_ok) != -1
  } $else {
    return C.access(path.str, w_ok) != -1
  }
}

// `is_readable` returns `true` if `path` is readable.
pub fn is_readable(path string) bool {
  $if windows {
    p := path.replace('/', '\\')
    return C._waccess(p.to_wide(), r_ok) != -1
  } $else {
    return C.access(path.str, r_ok) != -1
  }
}

[deprecated]
pub fn file_exists(_path string) bool {
	panic('Use `os.exists` instead of `os.file_exists`')
}

// rm removes file in `path`.
pub fn rm(path string) {
	$if windows {
		C._wremove(path.to_wide())
	} $else {
		C.remove(path.str)
	}
	// C.unlink(path.cstr())
}
// rmdir removes a specified directory.
pub fn rmdir(path string) {
	$if !windows {
		C.rmdir(path.str)
	} $else {
		C.RemoveDirectory(path.to_wide())
	}
}

[deprecated]
pub fn rmdir_recursive(path string) {
	panic('Use `os.rmdir_all` instead of `os.rmdir_recursive`')
}

pub fn rmdir_all(path string) {
	items := os.ls(path) or {
		return
	}
	for item in items {
		if os.is_dir(os.join_path(path, item)) {
			rmdir_all(os.join_path(path, item))
		}
		os.rm(os.join_path(path, item))
	}
	os.rmdir(path)
}

pub fn is_dir_empty(path string) bool {
	items := os.ls(path) or {
		return true
	}
	return items.len == 0
}

fn print_c_errno() {
	e := C.errno
	se := tos_clone(byteptr(C.strerror(C.errno)))
	println('errno=$e err=$se')
}

pub fn file_ext(path string) string {
	pos := path.last_index('.') or {
		return ''
	}
	return path[pos..]
}

pub fn dir(path string) string {
	pos := path.last_index(path_separator) or {
		return '.'
	}
	return path[..pos]
}

pub fn base_dir(path string) string {
	posx := path.last_index(path_separator) or {
		return path
	}
	// NB: *without* terminating /
	return path[..posx]
}

pub fn file_name(path string) string {
	return path.all_after_last(path_separator)
}

// input returns a one-line string from stdin, after printing a prompt
pub fn input(prompt string) string {
	print(prompt)
	flush()
	return get_line()
}

// get_line returns a one-line string from stdin
pub fn get_line() string {
	str := get_raw_line()
	$if windows {
		return str.trim_right('\r\n')
	} $else {
		return str.trim_right('\n')
	}
}

// get_raw_line returns a one-line string from stdin along with '\n' if there is any
pub fn get_raw_line() string {
	$if windows {
		unsafe {
			max_line_chars := 256
			buf := malloc(max_line_chars * 2)
			h_input := C.GetStdHandle(std_input_handle)
			mut bytes_read := 0
			if is_atty(0) > 0 {
				C.ReadConsole(h_input, buf, max_line_chars * 2, &bytes_read, 0)
				return string_from_wide2(&u16(buf), bytes_read)
			}
			mut offset := 0
			for {
				pos := buf + offset
				res := C.ReadFile(h_input, pos, 1, &bytes_read, 0)
				if !res || bytes_read == 0 {
						break
				}
				if *pos == `\n` || *pos == `\r` {
					offset++
					break
				}
				offset++
			}
			return string(buf, offset)
		}
	} $else {
		max := size_t(0)
		mut buf := charptr(0)
		nr_chars := C.getline(&buf, &max, C.stdin)
		//defer { unsafe{ free(buf) } }
		if nr_chars == 0 || nr_chars == -1 {
			return ''
		}
		return tos3(buf)
		//res := tos_clone(buf)
		//return res
	}
}

pub fn get_lines() []string {
	mut line := ''
	mut inputstr := []string{}
	for {
		line = get_line()
		if line.len <= 0 {
			break
		}
		line = line.trim_space()
		inputstr << line
	}
	return inputstr
}

pub fn get_lines_joined() string {
	mut line := ''
	mut inputstr := ''
	for {
		line = get_line()
		if line.len <= 0 {
			break
		}
		line = line.trim_space()
		inputstr += line
	}
	return inputstr
}

// user_os returns current user operating system name.
pub fn user_os() string {
	$if linux {
		return 'linux'
	}
	$if macos {
		return 'mac'
	}
	$if windows {
		return 'windows'
	}
	$if freebsd {
		return 'freebsd'
	}
	$if openbsd {
		return 'openbsd'
	}
	$if netbsd {
		return 'netbsd'
	}
	$if dragonfly {
		return 'dragonfly'
	}
	$if android {
		return 'android'
	}
	$if solaris {
		return 'solaris'
	}
	$if haiku {
		return 'haiku'
	}
	return 'unknown'
}

// home_dir returns path to user's home directory.
pub fn home_dir() string {
	$if windows {
		return os.getenv('USERPROFILE') + os.path_separator
	} $else {
		//println('home_dir() call')
		//res:= os.getenv('HOME') + os.path_separator
		//println('res="$res"')
		return os.getenv('HOME') + os.path_separator
	}
}

// write_file writes `text` data to a file in `path`.
pub fn write_file(path, text string) {
	mut f := os.create(path) or {
		return
	}
	f.write(text)
	f.close()
}

// clear clears current terminal screen.
pub fn clear() {
	$if !windows {
		C.printf('\x1b[2J')
		C.printf('\x1b[H')
	}
}

pub fn on_segfault(f voidptr) {
	$if windows {
		return
	}
	$if macos {
		C.printf("TODO")
		/*
		mut sa := C.sigaction{}
		C.memset(&sa, 0, sizeof(C.sigaction_size))
		C.sigemptyset(&sa.sa_mask)
		sa.sa_sigaction = f
		sa.sa_flags = C.SA_SIGINFO
		C.sigaction(C.SIGSEGV, &sa, 0)
		*/
	}
}

fn C.getpid() int


//fn C.proc_pidpath(int, byteptr, int) int


fn C.readlink() int
// executable returns the path name of the executable that started the current
// process.
pub fn executable() string {
	$if linux {
		mut result := vcalloc(max_path_len)
		count := C.readlink('/proc/self/exe', result, max_path_len)
		if count < 0 {
			eprintln('os.executable() failed at reading /proc/self/exe to get exe path')
			return executable_fallback()
		}
		return string(result)
	}
	$if windows {
		max := 512
		mut result := &u16(vcalloc(max * 2)) // max_path_len * sizeof(wchar_t)
		len := C.GetModuleFileName(0, result, max)
		return string_from_wide2(result, len)
	}
	$if macos {
		mut result := vcalloc(max_path_len)
		pid := C.getpid()
		ret := proc_pidpath(pid, result, max_path_len)
		if ret <= 0 {
			eprintln('os.executable() failed at calling proc_pidpath with pid: $pid . proc_pidpath returned $ret ')
			return executable_fallback()
		}
		return string(result)
	}
	$if freebsd {
		mut result := vcalloc(max_path_len)
		mib := [1/* CTL_KERN */, 14/* KERN_PROC */, 12/* KERN_PROC_PATHNAME */, -1]
		size := max_path_len
		C.sysctl(mib.data, 4, result, &size, 0, 0)
		return string(result)
	}
	// "Sadly there is no way to get the full path of the executed file in OpenBSD."
	$if openbsd {}
	$if solaris {}
	$if haiku {}
	$if netbsd {
		mut result := vcalloc(max_path_len)
		count := C.readlink('/proc/curproc/exe', result, max_path_len)
		if count < 0 {
			eprintln('os.executable() failed at reading /proc/curproc/exe to get exe path')
			return executable_fallback()
		}
		return string(result,count)
	}
	$if dragonfly {
		mut result := vcalloc(max_path_len)
		count := C.readlink('/proc/curproc/file', result, max_path_len)
		if count < 0 {
			eprintln('os.executable() failed at reading /proc/curproc/file to get exe path')
			return executable_fallback()
		}
		return string(result,count)
	}
	return executable_fallback()
}

// executable_fallback is used when there is not a more platform specific and accurate implementation
// it relies on path manipulation of os.args[0] and os.wd_at_startup, so it may not work properly in
// all cases, but it should be better, than just using os.args[0] directly.
fn executable_fallback() string {
	if os.args.len == 0 {
		// we are early in the bootstrap, os.args has not been initialized yet :-|
		return ''
	}
	mut exepath := os.args[0]
	if !os.is_abs_path(exepath) {
		if exepath.contains( os.path_separator ) {
			exepath = os.join_path(os.wd_at_startup, exepath)
		}else{
			// no choice but to try to walk the PATH folders :-| ...
			foundpath := os.find_abs_path_of_executable(exepath) or { '' }
			if foundpath.len > 0 {
				exepath = foundpath
			}
		}
	}
	exepath = os.real_path(exepath)
	return exepath
}

// find_exe_path walks the environment PATH, just like most shell do, it returns
// the absolute path of the executable if found
pub fn find_abs_path_of_executable(exepath string) ?string {
	if os.is_abs_path(exepath) {
		return exepath
	}
	mut res := ''
	env_path_delimiter := if os.user_os() == 'windows' { ';' } else { ':' }
	paths := os.getenv('PATH').split(env_path_delimiter)
	for p in paths {
		found_abs_path := os.join_path( p, exepath )
		if os.exists( found_abs_path ) && os.is_executable( found_abs_path ) {
			res = found_abs_path
			break
		}
	}
	if res.len>0 {
		return res
	}
	return error('failed to find executable')
}

// exists_in_system_path returns true if prog exists in the system's path
pub fn exists_in_system_path(prog string) bool {
	os.find_abs_path_of_executable(prog) or {
		return false
	}
	return true
}

[deprecated]
pub fn dir_exists(path string) bool {
	panic('Use `os.is_dir` instead of `os.dir_exists`')
}

// is_dir returns a boolean indicating whether the given path is a directory.
pub fn is_dir(path string) bool {
	$if windows {
		w_path := path.replace('/', '\\')
		attr := C.GetFileAttributesW(w_path.to_wide())
		if attr == u32(C.INVALID_FILE_ATTRIBUTES) {
			return false
		}
		if int(attr) & C.FILE_ATTRIBUTE_DIRECTORY != 0 {
			return true
		}
		return false
	} $else {
		statbuf := C.stat{}
		if C.stat(path.str, &statbuf) != 0 {
			return false
		}
		// ref: https://code.woboq.org/gcc/include/sys/stat.h.html
		val:= int(statbuf.st_mode) & os.s_ifmt
		return val == s_ifdir
	}
}

// is_link returns a boolean indicating whether the given path is a link.
pub fn is_link(path string) bool {
	$if windows {
		return false // TODO
	} $else {
		statbuf := C.stat{}
		if C.lstat(path.str, &statbuf) != 0 {
			return false
		}
		return int(statbuf.st_mode) & s_ifmt == s_iflnk
	}
}

// chdir changes the current working directory to the new directory path.
pub fn chdir(path string) {
	$if windows {
		C._wchdir(path.to_wide())
	} $else {
		C.chdir(path.str)
	}
}

// getwd returns the absolute path name of the current directory.
pub fn getwd() string {
	$if windows {
		max := 512 // max_path_len * sizeof(wchar_t)
		buf := &u16(vcalloc(max * 2))
		if C._wgetcwd(buf, max) == 0 {
			return ''
		}
		return string_from_wide(buf)
	} $else {
		buf := vcalloc(512)
		if C.getcwd(buf, 512) == 0 {
			return ''
		}
		return string(buf)
	}
}

// Returns the full absolute path for fpath, with all relative ../../, symlinks and so on resolved.
// See http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html
// Also https://insanecoding.blogspot.com/2007/11/pathmax-simply-isnt.html
// and https://insanecoding.blogspot.com/2007/11/implementing-realpath-in-c.html
// NB: this particular rabbit hole is *deep* ...
pub fn real_path(fpath string) string {
	mut fullpath := vcalloc(max_path_len)
	mut ret := charptr(0)
	$if windows {
		ret = C._fullpath(fullpath, fpath.str, max_path_len)
		if ret == 0 {
			return fpath
		}
	} $else {
		ret = C.realpath(fpath.str, fullpath)
		if ret == 0 {
			return fpath
		}
	}
	return string(fullpath)
}

// is_abs_path returns true if `path` is absolute.
pub fn is_abs_path(path string) bool {
	$if windows {
		return path[0] == `/` || // incase we're in MingGW bash
		(path[0].is_letter() && path[1] == `:`)
	}
	return path[0] == `/`
}

// join returns path as string from string parameter(s).
pub fn join_path(base string, dirs ...string) string {
	mut result := []string{}
	result << base.trim_right('\\/')
	for d in dirs {
		result << d
	}
	return result.join(path_separator)
}

// walk_ext returns a recursive list of all file paths ending with `ext`.
pub fn walk_ext(path, ext string) []string {
	if !os.is_dir(path) {
		return []
	}
	mut files := os.ls(path) or {
		return []
	}
	mut res := []string{}
	separator := if path.ends_with(os.path_separator) { '' } else { os.path_separator }
	for file in files {
		if file.starts_with('.') {
			continue
		}
		p := path + separator + file
		if os.is_dir(p) && !os.is_link(p) {
			res << walk_ext(p, ext)
		}
		else if file.ends_with(ext) {
			res << p
		}
	}
	return res
}

// walk recursively traverses the given directory path.
// When a file is encountred it will call the callback function with current file as argument.
pub fn walk(path string, f fn(path string)) {
	if !os.is_dir(path) {
		return
	}
	mut files := os.ls(path) or {
		return
	}
	for file in files {
		p := path + os.path_separator + file
		if os.is_dir(p) && !os.is_link(p) {
			walk(p, f)
		}
		else if os.exists(p) {
			f(p)
		}
	}
	return
}

pub fn signal(signum int, handler voidptr) {
	C.signal(signum, handler)
}

fn C.fork() int


fn C.wait() int


pub fn fork() int {
	mut pid := -1
	$if !windows {
		pid = C.fork()
	}
	$if windows {
		panic('os.fork not supported in windows') // TODO
	}
	return pid
}

pub fn wait() int {
	mut pid := -1
	$if !windows {
		pid = C.wait(0)
	}
	$if windows {
		panic('os.wait not supported in windows') // TODO
	}
	return pid
}

pub fn file_last_mod_unix(path string) int {
	attr := C.stat{}
	// # struct stat attr;
	C.stat(path.str, &attr)
	// # stat(path.str, &attr);
	return attr.st_mtime
	// # return attr.st_mtime ;
}

pub fn log(s string) {
	println('os.log: ' + s)
}

[deprecated]
pub fn flush_stdout() {
	panic('Use `os.flush` instead of `os.flush_stdout`')
}

pub fn flush() {
	C.fflush(C.stdout)
}

pub fn mkdir_all(path string) {
	mut p := if path.starts_with(os.path_separator) { os.path_separator } else { '' }
	for subdir in path.split(os.path_separator) {
		p += subdir + os.path_separator
		if !os.is_dir(p) {
			os.mkdir(p) or {
				panic(err)
			}
		}
	}
}

// cache_dir returns the path to a *writable* user specific folder, suitable for writing non-essential data.
pub fn cache_dir() string {
	// See: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
	// There is a single base directory relative to which user-specific non-essential
	// (cached) data should be written. This directory is defined by the environment
	// variable $XDG_CACHE_HOME.
	// $XDG_CACHE_HOME defines the base directory relative to which user specific
	// non-essential data files should be stored. If $XDG_CACHE_HOME is either not set
	// or empty, a default equal to $HOME/.cache should be used.
	$if !windows {
		xdg_cache_home := os.getenv('XDG_CACHE_HOME')
		if xdg_cache_home != '' {
			return xdg_cache_home
		}
	}
	cdir := os.home_dir() + '.cache'
	if !os.is_dir(cdir) && !os.is_link(cdir) {
		os.mkdir(cdir) or {
			panic(err)
		}
	}
	return cdir
}

// tmpdir returns the path to a folder, that is suitable for storing temporary files
pub fn temp_dir() string {
	mut path := os.getenv('TMPDIR')
	$if windows {
		if path == '' {
			// TODO see Qt's implementation?
			// https://doc.qt.io/qt-5/qdir.html#tempPath
			// https://github.com/qt/qtbase/blob/e164d61ca8263fc4b46fdd916e1ea77c7dd2b735/src/corelib/io/qfilesystemengine_win.cpp#L1275
			path = os.getenv('TEMP')
			if path == '' {
				path = os.getenv('TMP')
			}
			if path == '' {
				path = 'C:/tmp'
			}
		}
	}
	if path == '' {
		path = os.cache_dir()
	}
	if path == '' {
		path = '/tmp'
	}
	return path
}

pub fn chmod(path string, mode int) {
	C.chmod(path.str, mode)
}

pub const (
	wd_at_startup = getwd()
)

// resource_abs_path returns an absolute path, for the given `path`
// (the path is expected to be relative to the executable program)
// See https://discordapp.com/channels/592103645835821068/592294828432424960/630806741373943808
// It gives a convenient way to access program resources like images, fonts, sounds and so on,
// *no matter* how the program was started, and what is the current working directory.
pub fn resource_abs_path(path string) string {
	mut base_path := os.real_path(os.dir(os.executable()))
	vresource := os.getenv('V_RESOURCE_PATH')
	if vresource.len != 0 {
		base_path = vresource
	}
	return os.real_path(os.join_path(base_path, path))
}


// open tries to open a file for reading and returns back a read-only `File` object
pub fn open(path string) ?File {
  /*
	$if linux {
		$if !android {
			fd := C.syscall(sys_open, path.str, 511)
			if fd == -1 {
				return error('failed to open file "$path"')
			}
			return File{
				fd: fd
				opened: true
			}
		}
	}
  */
	cfile := vfopen(path, 'rb')
	if cfile == 0 {
		return error('failed to open file "$path"')
	}
	fd := fileno(cfile)
	return File {
		cfile: cfile
		fd: fd
		opened: true
	}
}

// create creates or opens a file at a specified location and returns a write-only `File` object
pub fn create(path string) ?File {
  /*
	// NB: android/termux/bionic is also a kind of linux,
	// but linux syscalls there sometimes fail,
	// while the libc version should work.
	$if linux {
		$if !android {
			//$if macos {
			//	fd = C.syscall(398, path.str, 0x601, 0x1b6)
			//}
			//$if linux {
			fd = C.syscall(sys_creat, path.str, 511)
			//}
			if fd == -1 {
				return error('failed to create file "$path"')
			}
			file = File{
				fd: fd
				opened: true
			}
			return file
		}
	}
  */
	cfile := vfopen(path, 'wb')
	if cfile == 0 {
		return error('failed to create file "$path"')
	}
	fd := fileno(cfile)
	return File {
		cfile: cfile
		fd: fd
		opened: true
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module os

pub const (
	sys_write = 4
	sys_open = 5
	sys_close = 6
	sys_mkdir = 136
	sys_creat =  8
	sys_open_nocancel = 398
	sys_stat64  = 338
)



// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module os

const (
	prot_read = 1
	prot_write = 2

	map_private = 0x02
	map_anonymous = 0x20
)

pub const (
	sys_write = 1
	sys_open = 2
	sys_close = 3
	sys_mkdir = 83
	sys_creat = 85
)



/*
// TODO no pub => error
pub fn write(fd int, data voidptr, nbytes int) int {
	return syscall5(
          1, // SYS_write
          fd,
          data,
          nbytes,
          0, // ignored
          0  // ignored
	)
}

pub fn println(s string) {
	write(1, (s + '\n').str, s.len)
}

fn mmap(start voidptr, len, prot, flags, fd, off int) byteptr {
	return syscall6(9, start, len, prot, flags, fd, off) // sys_mmap
}

pub fn malloc(n int) byteptr {
	println('malloc($n)')
	return mmap(0, n, 3, 		4098, //prot_read|prot_write,
	 -1,0)			//map_private|map_anonymous,
}

pub fn free(b byteptr) {

}
*/
module os

import strings

#include <dirent.h>
#include <unistd.h>
#include <fcntl.h>

pub const (
	path_separator = '/'
)

const (
	stdin_value = 0
	stdout_value = 1
	stderr_value = 2
)

fn C.symlink(charptr, charptr) int

fn init_os_args(argc int, argv &&byte) []string {
	mut args := []string{}
	//mut args := []string(make(0, argc, sizeof(string)))
	//mut args := []string{len:argc}
	for i in 0 .. argc {

		//args [i] = string(argv[i])
		args << string(argv[i])
	}
	return args
}

pub fn ls(path string) ?[]string {
	mut res := []string{}
	dir := C.opendir(path.str)
	if isnil(dir) {
		return error('ls() couldnt open dir "$path"')
	}
	mut ent := &C.dirent(0)
	// mut ent := &C.dirent{!}
	for {
		ent = C.readdir(dir)
		if isnil(ent) {
			break
		}
		name := tos_clone(byteptr(ent.d_name))
		if name != '.' && name != '..' && name != '' {
			res << name
		}
	}
	C.closedir(dir)
	return res
}

/*
pub fn is_dir(path string) bool {
	//$if linux {
		//C.syscall(4, path.str) // sys_newstat
	//}
	dir := C.opendir(path.str)
	res := !isnil(dir)
	if res {
		C.closedir(dir)
	}
	return res
}
*/

/*
pub fn (mut f File) fseek(pos, mode int) {
}
*/


// mkdir creates a new directory with the specified path.
pub fn mkdir(path string) ?bool {
	if path == '.' {
		return true
	}
	apath := os.real_path(path)
  /*
	$if linux {
		$if !android {
			ret := C.syscall(sys_mkdir, apath.str, 511)
			if ret == -1 {
				return error(posix_get_error_msg(C.errno))
			}
			return true
		}
	}
  */
	r := C.mkdir(apath.str, 511)
	if r == -1 {
		return error(posix_get_error_msg(C.errno))
	}
	return true
}

// exec starts the specified command, waits for it to complete, and returns its output.
pub fn exec(cmd string) ?Result {
	// if cmd.contains(';') || cmd.contains('&&') || cmd.contains('||') || cmd.contains('\n') {
	// return error(';, &&, || and \\n are not allowed in shell commands')
	// }
	pcmd := '$cmd 2>&1'
	f := vpopen(pcmd)
	if isnil(f) {
		return error('exec("$cmd") failed')
	}
	buf := [4096]byte
	mut res := strings.new_builder(1024)
	for C.fgets(charptr(buf), 4096, f) != 0 {
		bufbp := byteptr(buf)
		res.write_bytes( bufbp, vstrlen(bufbp) )
	}
	soutput := res.str().trim_space()
	//res.free()
	exit_code := vpclose(f)
	// if exit_code != 0 {
	// return error(res)
	// }
	return Result{
		exit_code: exit_code
		output: soutput
	}
}

pub fn symlink(origin, target string) ?bool {
	res := C.symlink(origin.str, target.str)
	if res == 0 {
		return true
	}
	return error(posix_get_error_msg(C.errno))
}

// get_error_msg return error code representation in string.
pub fn get_error_msg(code int) string {
	return posix_get_error_msg(code)
}

pub fn (mut f File) close() {
	if !f.opened {
		return
	}
	f.opened = false
  /*
	$if linux {
		$if !android {
			C.syscall(sys_close, f.fd)
			return
		}
	}
  */
	C.fflush(f.cfile)
	C.fclose(f.cfile)
}
import os

const (
	// tfolder will contain all the temporary files/subfolders made by
	// the different tests. It would be removed in testsuite_end(), so
	// individual os tests do not need to clean up after themselves.
	tfolder = os.join_path( os.temp_dir(), 'v', 'tests', 'os_test')
)

fn testsuite_begin() {
	eprintln('testsuite_begin, tfolder = $tfolder')
	os.rmdir_all( tfolder )
	assert !os.is_dir( tfolder )
	os.mkdir_all( tfolder )
	os.chdir( tfolder )
	assert os.is_dir( tfolder )
}

fn testsuite_end() {
	os.chdir( os.wd_at_startup )
	os.rmdir_all( tfolder )
	assert !os.is_dir( tfolder )
}

fn test_open_file() {
	filename := './test1.txt'
	hello := 'hello world!'
	os.open_file(filename, 'r+', 0o666) or {
		assert err == 'No such file or directory'
		os.File{}
	}
	mut file := os.open_file(filename, 'w+', 0o666) or {
		panic(err)
	}
	file.write(hello)
	file.close()
	assert hello.len == os.file_size(filename)
	read_hello := os.read_file(filename) or {
		panic('error reading file $filename')
	}
	assert hello == read_hello
	os.rm(filename)
}

fn test_create_file() {
	filename := './test1.txt'
	hello := 'hello world!'
	mut f := os.create(filename) or {
		panic(err)
	}
	f.write(hello)
	f.close()
	assert hello.len == os.file_size(filename)
	os.rm(filename)
}

fn test_write_and_read_string_to_file() {
	filename := './test1.txt'
	hello := 'hello world!'
	os.write_file(filename, hello)
	assert hello.len == os.file_size(filename)
	read_hello := os.read_file(filename) or {
		panic('error reading file $filename')
	}
	assert hello == read_hello
	os.rm(filename)
}

// test_write_and_read_bytes checks for regressions made in the functions
// read_bytes, read_bytes_at and write_bytes.
/*
fn test_write_and_read_bytes() {
        file_name :=  './byte_reader_writer.tst'
        payload   :=  [`I`, `D`, `D`, `Q`, `D`]

        mut file_write := os.create(os.real_path(file_name)) or {
                eprintln('failed to create file $file_name')
                return
        }

        // We use the standard write_bytes function to write the payload and
        // compare the length of the array with the file size (have to match).
        file_write.write_bytes(payload.data, 5)

        file_write.close()

        assert payload.len == os.file_size(file_name)

        mut file_read := os.open(os.real_path(file_name)) or {
          eprintln('failed to open file $file_name')
          return
        }

        // We only need to test read_bytes because this function calls
        // read_bytes_at with second parameter zeroed (size, 0).
        red_bytes := file_read.read_bytes(5)

        file_read.close()

        assert red_bytes.str() == payload.str()

        // We finally delete the test file.
        os.rm(file_name)
}
*/


fn test_create_and_delete_folder() {
	folder := './test1'
	os.mkdir(folder) or {
		panic(err)
	}
	assert os.is_dir(folder)
	folder_contents := os.ls(folder) or {
		panic(err)
	}
	assert folder_contents.len == 0
	os.rmdir(folder)
	folder_exists := os.is_dir(folder)
	assert folder_exists == false
}

fn walk_callback(file string) {
	if file == '.' || file == '..' {
		return
	}
	assert file == 'test_walk' + os.path_separator + 'test1'
}

fn test_walk() {
	folder := 'test_walk'
	os.mkdir(folder) or {
		panic(err)
	}
	file1 := folder + os.path_separator + 'test1'
	os.write_file(file1, 'test-1')
	os.walk(folder, walk_callback)
	os.rm(file1)
	os.rmdir(folder)
}

fn test_cp() {
	old_file_name := 'cp_example.txt'
	new_file_name := 'cp_new_example.txt'
	os.write_file(old_file_name, 'Test data 1 2 3, V is awesome #$%^[]!~')
	os.cp(old_file_name, new_file_name) or {
		panic('$err: errcode: $errcode')
	}
	old_file := os.read_file(old_file_name) or {
		panic(err)
	}
	new_file := os.read_file(new_file_name) or {
		panic(err)
	}
	assert old_file == new_file
	os.rm(old_file_name)
	os.rm(new_file_name)
}

fn test_cp_r() {
	// fileX -> dir/fileX
	// NB: clean up of the files happens inside the cleanup_leftovers function
	os.write_file('ex1.txt', 'wow!')
	os.mkdir('ex') or {
		panic(err)
	}
	os.cp_all('ex1.txt', 'ex', false) or {
		panic(err)
	}
	old := os.read_file('ex1.txt') or {
		panic(err)
	}
	new := os.read_file('ex/ex1.txt') or {
		panic(err)
	}
	assert old == new
	os.mkdir('ex/ex2') or {
		panic(err)
	}
	os.write_file('ex2.txt', 'great!')
	os.cp_all('ex2.txt', 'ex/ex2', false) or {
		panic(err)
	}
	old2 := os.read_file('ex2.txt') or {
		panic(err)
	}
	new2 := os.read_file('ex/ex2/ex2.txt') or {
		panic(err)
	}
	assert old2 == new2
	// recurring on dir -> local dir
	os.cp_all('ex', './', true) or {
		panic(err)
	}
}

fn test_tmpdir() {
	t := os.temp_dir()
	assert t.len > 0
	assert os.is_dir(t)
	tfile := t + os.path_separator + 'tmpfile.txt'
	os.rm(tfile) // just in case
	tfile_content := 'this is a temporary file'
	os.write_file(tfile, tfile_content)
	tfile_content_read := os.read_file(tfile) or {
		panic(err)
	}
	assert tfile_content_read == tfile_content
	os.rm(tfile)
}

fn test_is_writable_folder() {
	tmp := os.temp_dir()
	f := os.is_writable_folder(tmp) or {
		eprintln('err: $err')
		false
	}
	assert f
}

fn test_make_symlink_check_is_link_and_remove_symlink() {
	$if windows {
		// TODO
		assert true
		return
	}
	folder := 'tfolder'
	symlink := 'tsymlink'
	os.rm(symlink)
	os.rm(folder)
	os.mkdir(folder) or {
		panic(err)
	}
	folder_contents := os.ls(folder) or {
		panic(err)
	}
	assert folder_contents.len == 0
	os.system('ln -s $folder $symlink')
	assert os.is_link(symlink) == true
	os.rm(symlink)
	os.rm(folder)
	folder_exists := os.is_dir(folder)
	assert folder_exists == false
	symlink_exists := os.is_link(symlink)
	assert symlink_exists == false
}

// fn test_fork() {
// pid := os.fork()
// if pid == 0 {
// println('Child')
// }
// else {
// println('Parent')
// }
// }
// fn test_wait() {
// pid := os.fork()
// if pid == 0 {
// println('Child')
// exit(0)
// }
// else {
// cpid := os.wait()
// println('Parent')
// println(cpid)
// }
// }
fn test_symlink() {
	$if windows {
		return
	}
	os.mkdir('symlink') or {
		panic(err)
	}
	os.symlink('symlink', 'symlink2') or {
		panic(err)
	}
	assert os.exists('symlink2')
	// cleanup
	os.rm('symlink')
	os.rm('symlink2')
}

fn test_is_executable_writable_readable() {
	file_name := 'rwxfile.exe'
	mut f := os.create(file_name) or {
		eprintln('failed to create file $file_name')
		return
	}
	f.close()
	$if !windows {
		os.chmod(file_name, 0o600) // mark as readable && writable, but NOT executable
		assert os.is_writable(file_name)
		assert os.is_readable(file_name)
		assert !os.is_executable(file_name)
		os.chmod(file_name, 0o700) // mark as executable too
		assert os.is_executable(file_name)
	} $else {
		assert os.is_writable(file_name)
		assert os.is_readable(file_name)
		assert os.is_executable(file_name)
	}
	// We finally delete the test file.
	os.rm(file_name)
}

fn test_ext() {
	assert os.file_ext('file.v') == '.v'
	assert os.file_ext('file') == ''
}

fn test_is_abs() {
	assert os.is_abs_path('/home/user') == true
	assert os.is_abs_path('v/vlib') == false
	$if windows {
		assert os.is_abs_path('C:\\Windows\\') == true
	}
}

fn test_join() {
	$if windows {
		assert os.join_path('v','vlib','os') == 'v\\vlib\\os'
	} $else {
		assert os.join_path('v','vlib','os') == 'v/vlib/os'
	}
}

fn test_dir() {
	$if windows {
		assert os.dir('C:\\a\\b\\c') == 'C:\\a\\b'
	} $else {
		assert os.dir('/var/tmp/foo') == '/var/tmp'
	}
	assert os.dir('os') == '.'
}

fn test_basedir() {
	$if windows {
		assert os.base_dir('v\\vlib\\os') == 'v\\vlib'
	} $else {
		assert os.base_dir('v/vlib/os') == 'v/vlib'
	}
	assert os.base_dir('filename') == 'filename'
}
module os

import strings

#flag -lws2_32
#include <winsock2.h>

pub const (
	path_separator = '\\'
)

// Ref - https://docs.microsoft.com/en-us/windows/desktop/winprog/windows-data-types
// A handle to an object.
pub type HANDLE voidptr

// win: FILETIME
// https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime
struct Filetime {
  dw_low_date_time u32
  dw_high_date_time u32
}

// win: WIN32_FIND_DATA
// https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-_win32_find_dataw
struct Win32finddata {
mut:
    dw_file_attributes u32
    ft_creation_time Filetime
  	ft_last_access_time Filetime
  	ft_last_write_time Filetime
	n_file_size_high u32
	n_file_size_low u32
	dw_reserved0 u32
	dw_reserved1 u32
	c_file_name [260]u16 // max_path_len = 260
	c_alternate_file_name [14]u16 // 14
  	dw_file_type u32
  	dw_creator_type u32
  	w_finder_flags u16
}

struct ProcessInformation {
mut:
	h_process voidptr
	h_thread voidptr
	dw_process_id u32
	dw_thread_id u32
}

struct StartupInfo {
mut:
	cb u32
	lp_reserved &u16
	lp_desktop &u16
	lp_title &u16
	dw_x u32
	dw_y u32
	dw_x_size u32
	dw_y_size u32
	dw_x_count_chars u32
	dw_y_count_chars u32
	dw_fill_attributes u32
	dw_flags u32
	w_show_window u16
	cb_reserved2 u16
	lp_reserved2 byteptr
	h_std_input voidptr
	h_std_output voidptr
	h_std_error voidptr
}

struct SecurityAttributes {
mut:
	n_length u32
	lp_security_descriptor voidptr
	b_inherit_handle bool
}

fn init_os_args_wide(argc int, argv &byteptr) []string {
	mut args := []string{}
	for i in 0..argc {
		args << string_from_wide(&u16(argv[i]))
	}
	return args
}

pub fn ls(path string) ?[]string {
	mut find_file_data := Win32finddata{}
	mut dir_files := []string{}
	// We can also check if the handle is valid. but using is_dir instead
	// h_find_dir := C.FindFirstFile(path.str, &find_file_data)
	// if (invalid_handle_value == h_find_dir) {
	//     return dir_files
	// }
	// C.FindClose(h_find_dir)
	if !is_dir(path) {
		return error('ls() couldnt open dir "$path": directory does not exist')
	}
	// NOTE: Should eventually have path struct & os dependant path seperator (eg os.PATH_SEPERATOR)
	// we need to add files to path eg. c:\windows\*.dll or :\windows\*
	path_files := '$path\\*'
	// NOTE:TODO: once we have a way to convert utf16 wide character to utf8
	// we should use FindFirstFileW and FindNextFileW
	h_find_files := C.FindFirstFile(path_files.to_wide(), voidptr(&find_file_data))
	first_filename := string_from_wide(&u16(find_file_data.c_file_name))
	if first_filename != '.' && first_filename != '..' {
		dir_files << first_filename
	}
	for C.FindNextFile(h_find_files, voidptr(&find_file_data)) > 0 {
		filename := string_from_wide(&u16(find_file_data.c_file_name))
		if filename != '.' && filename != '..' {
			dir_files << filename.clone()
		}
	}
	C.FindClose(h_find_files)
	return dir_files
}

/*
pub fn is_dir(path string) bool {
	_path := path.replace('/', '\\')
	attr := C.GetFileAttributesW(_path.to_wide())
	if int(attr) == int(C.INVALID_FILE_ATTRIBUTES) {
		return false
	}
	if (int(attr) & C.FILE_ATTRIBUTE_DIRECTORY) != 0 {
		return true
	}
	return false
}
*/


// mkdir creates a new directory with the specified path.
pub fn mkdir(path string) ?bool {
	if path == '.' { return true }
	apath := os.real_path( path )
	if !C.CreateDirectory(apath.to_wide(), 0) {
		return error('mkdir failed for "$apath", because CreateDirectory returned ' + get_error_msg(int(C.GetLastError())))
	}
	return true
}

// Ref - https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/get-osfhandle?view=vs-2019
// get_file_handle retrieves the operating-system file handle that is associated with the specified file descriptor.
pub fn get_file_handle(path string) HANDLE {
    cfile := vfopen(path, 'rb')
    if cfile == 0 {
	    return HANDLE(invalid_handle_value)
    }
    handle := HANDLE(C._get_osfhandle(fileno(cfile))) // CreateFile? - hah, no -_-
    return handle
}

// Ref - https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea
// get_module_filename retrieves the fully qualified path for the file that contains the specified module.
// The module must have been loaded by the current process.
pub fn get_module_filename(handle HANDLE) ?string {
	unsafe {
		mut sz := 4096 // Optimized length
		mut buf := &u16(malloc(4096))
		for {
			status := int(C.GetModuleFileNameW(handle, voidptr(&buf), sz))
			match status {
				success {
					return string_from_wide2(buf, sz)
				}
				else {
					// Must handled with GetLastError and converted by FormatMessage
					return error('Cannot get file name from handle')
				}
			}
		}
	}
    panic('this should be unreachable') // TODO remove unreachable after loop
}

// Ref - https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-formatmessagea#parameters
const (
    format_message_allocate_buffer = 0x00000100
    format_message_argument_array  = 0x00002000
    format_message_from_hmodule    = 0x00000800
    format_message_from_string     = 0x00000400
    format_message_from_system     = 0x00001000
    format_message_ignore_inserts  = 0x00000200
)

// Ref - winnt.h
const (
    sublang_neutral = 0x00
    sublang_default = 0x01
    lang_neutral    = (sublang_neutral)
)

// Ref - https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--12000-15999-
const (
    max_error_code  = 15841 // ERROR_API_UNAVAILABLE
)

// ptr_win_get_error_msg return string (voidptr)
// representation of error, only for windows.
fn ptr_win_get_error_msg(code u32) voidptr {
    mut buf := voidptr(0)
    // Check for code overflow
    if code > u32(max_error_code) {
        return buf
    }
    C.FormatMessage(
		format_message_allocate_buffer
		| format_message_from_system
		| format_message_ignore_inserts,
        0, code, C.MAKELANGID(lang_neutral, sublang_default), voidptr(&buf), 0, 0)
    return buf
}

// get_error_msg return error code representation in string.
pub fn get_error_msg(code int) string {
    if code < 0 { // skip negative
        return ''
    }
    ptr_text := ptr_win_get_error_msg(u32(code))
    if ptr_text == 0 { // compare with null
        return ''
    }
    return string_from_wide(ptr_text)
}

// exec starts the specified command, waits for it to complete, and returns its output.
pub fn exec(cmd string) ?Result {
	if cmd.contains(';') || cmd.contains('&&') || cmd.contains('||') || cmd.contains('\n') {
		return error(';, &&, || and \\n are not allowed in shell commands')
	}
	mut child_stdin := &u32(0)
	mut child_stdout_read := &u32(0)
	mut child_stdout_write := &u32(0)
	mut sa := SecurityAttributes {}
	sa.n_length = sizeof(C.SECURITY_ATTRIBUTES)
	sa.b_inherit_handle = true

	create_pipe_ok := C.CreatePipe(voidptr(&child_stdout_read),
		voidptr(&child_stdout_write), voidptr(&sa), 0)
	if !create_pipe_ok {
		error_msg := get_error_msg(int(C.GetLastError()))
		return error('exec failed (CreatePipe): $error_msg')
	}
	set_handle_info_ok := C.SetHandleInformation(child_stdout_read, C.HANDLE_FLAG_INHERIT, 0)
	if !set_handle_info_ok {
		error_msg := get_error_msg(int(C.GetLastError()))
		panic('exec failed (SetHandleInformation): $error_msg')
	}

	proc_info := ProcessInformation{}
	start_info := StartupInfo{
		lp_reserved: 0
		lp_desktop: 0
		lp_title: 0
		cb: sizeof(C.PROCESS_INFORMATION)
		h_std_input: child_stdin
		h_std_output: child_stdout_write
		h_std_error: child_stdout_write
		dw_flags: u32(C.STARTF_USESTDHANDLES)
	}
	command_line := [32768]u16
	C.ExpandEnvironmentStringsW(cmd.to_wide(), voidptr(&command_line), 32768)
	create_process_ok := C.CreateProcessW(0, command_line, 0, 0, C.TRUE, 0, 0, 0, voidptr(&start_info), voidptr(&proc_info))
	if !create_process_ok {
		error_msg := get_error_msg(int(C.GetLastError()))
		return error('exec failed (CreateProcess): $error_msg cmd: $cmd')
	}
	C.CloseHandle(child_stdin)
	C.CloseHandle(child_stdout_write)
	buf := [4096]byte
	mut bytes_read := u32(0)
	mut read_data := strings.new_builder(1024)
	for {
		readfile_result := C.ReadFile(child_stdout_read, buf, 1000, voidptr(&bytes_read), 0)
		read_data.write_bytes(buf, int(bytes_read))
		if readfile_result == false || int(bytes_read) == 0 {
			break
		}
	}
	soutput := read_data.str().trim_space()
	read_data.free()
	exit_code := u32(0)
	C.WaitForSingleObject(proc_info.h_process, C.INFINITE)
	C.GetExitCodeProcess(proc_info.h_process, voidptr(&exit_code))
	C.CloseHandle(proc_info.h_process)
	C.CloseHandle(proc_info.h_thread)
	return Result {
		output: soutput
		exit_code: int(exit_code)
	}
}

fn C.CreateSymbolicLinkW(&u16, &u16, u32) int

pub fn symlink(origin, target string) ?bool {
	flags := if os.is_dir(origin) { 1 } else { 0 }
	if C.CreateSymbolicLinkW(origin.to_wide(), target.to_wide(), u32(flags)) != 0 {
		return true
	}
	return error(get_error_msg(int(C.GetLastError())))
}

pub fn (mut f File) close() {
	if !f.opened {
		return
	}
	f.opened = false
	C.fflush(f.cfile)
	C.fclose(f.cfile)
}
fn main() {
	sys_write(1, 'hello\n'.str, 6)
	s := 'test string\n'
	sys_write(1, s.str, u64(s.len))
	a := s[0]
	println("Hello freestanding!")
}
module cmdline

// Fetch multiple option by param, e.g.
// args: ['v', '-d', 'aa', '-d', 'bb', '-d', 'cc']
// param: '-d'
// ret: ['aa', 'bb', 'cc']
pub fn options(args []string, param string) []string {
	mut flags := []string{}
	for i, v in args {
		if v == param {
			if i + 1 < args.len {
				flags << args[i + 1]
			}
		}
	}
	return flags
}

// Fetch option by param, e.g.
// args: ['v', '-d', 'aa']
// param: '-d'
// def: ''
// ret: 'aa'
pub fn option(args []string, param string, def string) string {
	mut found := false
	for arg in args {
		if found {
			return arg
		}
		else if param == arg {
			found = true
		}
	}
	return def
}

// Fetch all options before what params, e.g.
// args: ['-stat', 'test', 'aaa.v']
// what: ['test']
// ret: ['-stat']
pub fn options_before(args []string, what []string) []string {
	mut args_before := []string{}
	for a in args {
		if a in what {
			break
		}
		args_before << a
	}
	return args_before
}

// Fetch all options after what params, e.g.
// args: ['-stat', 'test', 'aaa.v']
// what: ['test']
// ret: ['aaa.v']
pub fn options_after(args []string, what []string) []string {
	mut found := false
	mut args_after := []string{}
	for a in args {
		if a in what {
			found = true
			continue
		}
		if found {
			args_after << a
		}
	}
	return args_after
}

// Fetch all options not start with '-', e.g.
// args: ['-d', 'aa', '--help', 'bb']
// ret: ['aa', 'bb']
pub fn only_non_options(args []string) []string {
	return args.filter(!it.starts_with('-'))
}

// Fetch all options start with '-', e.g.
// args: ['-d', 'aa', '--help', 'bb']
// ret: ['-d', '--help']
pub fn only_options(args []string) []string {
	return args.filter(it.starts_with('-'))
}
import os.cmdline

fn test_options() {
	args := ['v', '-d', 'aa', '-d', 'bb', '-d', 'cc']
	ret := cmdline.options(args, '-d')
	assert ret.eq(['aa', 'bb', 'cc'])
}

fn test_option() {
	args := ['v', '-d', 'aa']
	ret := cmdline.option(args, '-d', '')
	assert ret == 'aa'
}

fn test_options_before() {
	args := ['-stat', 'test', 'aaa.v']
	ret := cmdline.options_before(args, ['test'])
	assert ret.eq(['-stat'])
}

fn test_options_after() {
	args := ['-stat', 'test', 'aaa.v']
	ret := cmdline.options_after(args, ['test'])
	assert ret.eq(['aaa.v'])
}

fn test_only_non_options() {
	args := ['-d', 'aa', '--help', 'bb']
	ret := cmdline.only_non_options(args)
	assert ret.eq(['aa', 'bb'])
}

fn test_only_options() {
	args := ['-d', 'aa', '--help', 'bb']
	ret := cmdline.only_options(args)
	assert ret.eq(['-d', '--help'])
}
//this keeps vfmt happy
module os2
module os2

#include <fcntl.h>
struct File {
	fd int
}

fn C.perror(charptr)


fn C.open(byteptr, int, int) int


fn C.write(voidptr, byteptr, int) int


fn C.close(int) int


pub fn create(path string) ?File {
	fd := C.open(path.str, C.O_CREAT | C.O_TRUNC | C.O_WRONLY, 0644) // 511
	if fd == -1 {
		return error('failed to create "$path":')
		// os.print_c_errno()
	}
	return File{
		fd}
}

pub fn (f File) writeln(s string) {
	ss := s + '\n'
	ret := C.write(f.fd, ss.str, s.len + 1)
	if ret == -1 {
		C.perror('failed to write')
	}
}

pub fn (f File) close() {
	C.close(f.fd)
}
//import os2

fn test_open() {
	/*
	$if macos {
		f := os2.create('os2.test')
		f.writeln('hello world!')
		f.close()
	}
	*/
}	
module pg

#flag -lpq
#flag linux -I/usr/include/postgresql
#flag darwin -I/opt/local/include/postgresql11
#flag windows -I @VROOT/thirdparty/pg/include
#flag windows -L @VROOT/thirdparty/pg/win64
#include <libpq-fe.h>

pub struct DB {
mut:
	conn &C.PGconn
}

pub struct Row {
pub mut:
	vals []string
}

struct C.PGResult { }

pub struct Config {
pub:
	host string
	port int = 5432
	user string
	password string
	dbname string
}

fn C.PQconnectdb(a byteptr) &C.PGconn
fn C.PQerrorMessage(voidptr) byteptr
fn C.PQgetvalue(voidptr, int, int) byteptr
fn C.PQstatus(voidptr) int
fn C.PQntuples(voidptr) int
fn C.PQnfields(voidptr) int
fn C.PQexec(voidptr) voidptr
fn C.PQexecParams(voidptr) voidptr

pub fn connect(config Config) ?DB {
	conninfo := 'host=$config.host port=$config.port user=$config.user dbname=$config.dbname password=$config.password'
	conn := C.PQconnectdb(conninfo.str)
	status := C.PQstatus(conn)
	println("status=$status")
	if status != C.CONNECTION_OK {
		error_msg := C.PQerrorMessage(conn)
		return error ('Connection to a PG database failed: ' + string(error_msg))
	}
	return DB {conn: conn}
}

fn res_to_rows(res voidptr) []Row {
	nr_rows := C.PQntuples(res)
	nr_cols := C.PQnfields(res)
	mut rows := []Row{}
	for i in 0..nr_rows {
		mut row := Row{}
		for j in 0..nr_cols {
			val := C.PQgetvalue(res, i, j)
			row.vals << string(val)
		}
		rows << row
	}
	return rows
}

pub fn (db DB) q_int(query string) int {
	rows := db.exec(query)
	if rows.len == 0 {
		println('q_int "$query" not found')
		return 0
	}
	row := rows[0]
	if row.vals.len == 0 {
		return 0
	}
	val := row.vals[0]
	return val.int()
}

pub fn (db DB) q_string(query string) string {
	rows := db.exec(query)
	if rows.len == 0 {
		println('q_string "$query" not found')
		return ''
	}
	row := rows[0]
	if row.vals.len == 0 {
		return ''
	}
	val := row.vals[0]
	return val
}

pub fn (db DB) q_strings(query string) []Row {
	return db.exec(query)
}

pub fn (db DB) exec(query string) []Row {
	res := C.PQexec(db.conn, query.str)
	e := string(C.PQerrorMessage(db.conn))
	if e != '' {
		println('pg exec error:')
		println(e)
		return res_to_rows(res)
	}
	return res_to_rows(res)
}

fn rows_first_or_empty(rows []Row) ?Row {
	if rows.len == 0 {
		return error('no row')
	}
	return rows[0]
}

pub fn (db DB) exec_one(query string) ?Row {
	res := C.PQexec(db.conn, query.str)
	e := string(C.PQerrorMessage(db.conn))
	if e != '' {
		return error('pg exec error: "$e"')
	}
	row := rows_first_or_empty( res_to_rows(res) ) or { return error(err) }
	return row
}

// The entire function can be considered unsafe because of the malloc and the
// free. This prevents warnings and doesn't seem to affect behavior.
pub fn (db DB) exec_param_many(query string, params []string) []Row {
	unsafe {
		mut param_vals := &byteptr( malloc( params.len * sizeof(byteptr) ) )
		for i in 0..params.len {
			param_vals[i] = params[i].str
		}
		res := C.PQexecParams(db.conn, query.str, params.len, 0, param_vals, 0, 0, 0)
		free(param_vals)
		return db.handle_error_or_result(res, 'exec_param_many')
	}
}

pub fn (db DB) exec_param2(query string, param, param2 string) []Row {
	mut param_vals := [2]byteptr
	param_vals[0] = param.str
	param_vals[1] = param2.str
	res := C.PQexecParams(db.conn, query.str, 2, 0, param_vals, 0, 0, 0)
	return db.handle_error_or_result(res, 'exec_param2')
}

pub fn (db DB) exec_param(query string, param string) []Row {
	mut param_vals := [1]byteptr
	param_vals[0] = param.str
	res := C.PQexecParams(db.conn, query.str, 1, 0, param_vals, 0, 0, 0)
	return db.handle_error_or_result(res, 'exec_param')
}

fn (db DB) handle_error_or_result(res voidptr, elabel string) []Row {
	e := string(C.PQerrorMessage(db.conn))
	if e != '' {
		println('pg $elabel error:')
		println(e)
		return res_to_rows(res)
	}
	return res_to_rows(res)
}
Before you can use this module, you must first have PostgreSQL installed on
your system. To do this, find your OS and perform the actions listed. 

**NOTE**: These instructions are meant only as a convenience. If your OS is not
listed or you need extra help, [go here](https://www.postgresql.org/download/).

### Fedora 31
```
sudo dnf install postgresql-server postgresql-contrib
sudo systemctl enable postgresql # to autostart on startup
sudo systemctl start  postgresql
```

### Debian 10/11
```
sudo apt-get install postgresql postgresql-client
sudo systemctl enable postgresql # to autostart on startup
sudo systemctl start  postgresql
```

### MacOSX (Homebrew)
```
brew install postgresql
brew services start postgresql
```
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module picoev

import picohttpparser

#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <fcntl.h>
#include <signal.h>

#flag -I @VROOT/thirdparty/picoev
#flag -L @VROOT/thirdparty/picoev
#flag @VROOT/thirdparty/picoev/picoev.o

#include "src/picoev.h"

const (
	MAX_FDS = 1024
	TIMEOUT_SECS = 8
	MAX_TIMEOUT = 10
	MAX_READ = 4096
	MAX_WRITE = 8192
)

struct C.in_addr {
mut:
	s_addr int
}

struct C.sockaddr_in {
mut:
	sin_family int
	sin_port   int
	sin_addr   C.in_addr
}

struct C.sockaddr_storage {}

fn C.socket() int
fn C.setsockopt() int
fn C.htonl() int
fn C.htons() int
fn C.bind() int
fn C.listen() int
fn C.accept() int
fn C.getaddrinfo() int
fn C.connect() int
fn C.send() int
fn C.recv() int
fn C.read() int
fn C.shutdown() int
fn C.close() int
fn C.ntohs() int
fn C.getsockname() int

fn C.fcntl() int
fn C.write() int

struct C.picoev_loop {}

struct Picoev {
	loop &C.picoev_loop
	cb   fn(req picohttpparser.Request, res mut picohttpparser.Response)
mut:
	date byteptr
	buf  byteptr
	idx  [1024]int
	out  byteptr
	oidx [1024]int
}

fn C.picoev_del(&C.picoev_loop, int) int
fn C.picoev_set_timeout(&C.picoev_loop, int, int)
fn C.picoev_add(&C.picoev_loop, int, int, int, &C.picoev_handler, voidptr) int
fn C.picoev_init(int) int
fn C.picoev_create_loop(int) &C.picoev_loop
fn C.picoev_loop_once(&C.picoev_loop, int) int
fn C.picoev_destroy_loop(&C.picoev_loop) int
fn C.picoev_deinit() int
fn C.phr_parse_request() int
fn C.phr_parse_request_path_pipeline() int
fn C.phr_parse_request_path() int

[inline]
fn setup_sock(fd int) {
	on := 1
	if C.setsockopt(fd, C.IPPROTO_TCP, C.TCP_NODELAY, &on, sizeof(int)) < 0 {
		println('setup_sock.setup_sock failed')
	}
	if C.fcntl(fd, C.F_SETFL, C.O_NONBLOCK) != 0 {
		println('fcntl failed')
	}
}

[inline]
fn close_conn(loop &C.picoev_loop, fd int) {
	C.picoev_del(loop, fd)
	C.close(fd)
}

[inline]
fn myread(fd int, b byteptr, max_len, idx int) int {
	return C.read(fd, b + idx, max_len - idx)
}

[inline]
fn mysubstr(s byteptr, from, len int) string {
	return tos(s + from, len)
}

fn rw_callback(loop &C.picoev_loop, fd, events int, cb_arg voidptr) {
	mut p := &Picoev(cb_arg)
	if (events & C.PICOEV_TIMEOUT) != 0 {
		close_conn(loop, fd)
		p.idx[fd] = 0
		return
	}
	else if (events & C.PICOEV_READ) != 0 {
		C.picoev_set_timeout(loop, fd, TIMEOUT_SECS)
		buf := (p.buf + fd * MAX_READ)
		idx := p.idx[fd]
		mut r := myread(fd, buf, MAX_READ, idx)
		if r == 0 {
			close_conn(loop, fd)
			p.idx[fd] = 0
			return
		} else if r == -1 {
			if false { //errno == C.EAGAIN || errno == C.EWOULDBLOCK {
				// TODO
			} else {
				close_conn(loop, fd)
				p.idx[fd] = 0
				return
			}
		} else {
			r += idx
			mut s := tos(buf, r)
			out := (p.out + fd * MAX_WRITE)
			mut res := picohttpparser.Response{
				fd: fd
				date: p.date
				buf_start: out
				buf: out + p.oidx[fd]
			}
			mut req := picohttpparser.Request{}
			for {
				pret := req.parse_request_path_pipeline(s)
				if pret <= 0 && s.len > 0 {
					C.memmove(buf, s.str, s.len)
					p.idx[fd] = s.len
					p.oidx[fd] = int(res.buf - res.buf_start)
					break
				}
				p.cb(req, mut res)
				if pret >= s.len {
					p.idx[fd] = 0
					p.oidx[fd] = 0
					if res.end() < 0 {
						close_conn(loop, fd)
						return
					}
					break
				}
				s = mysubstr(buf, pret, s.len - pret)
			}
		}
	}
}

fn accept_callback(loop &C.picoev_loop, fd, events int, cb_arg voidptr) {
	newfd := C.accept(fd, 0, 0)
	if newfd != -1 {
		setup_sock(newfd)
		C.picoev_add(loop, newfd, C.PICOEV_READ, TIMEOUT_SECS, rw_callback, cb_arg)
	}
}

pub fn new(port int, cb voidptr) &Picoev {
	fd := C.socket(C.AF_INET, C.SOCK_STREAM, 0)
	assert fd != -1

	flag := 1
	assert C.setsockopt(fd, C.SOL_SOCKET, C.SO_REUSEADDR, &flag, sizeof(int)) == 0
	assert C.setsockopt(fd, C.SOL_SOCKET, C.SO_REUSEPORT, &flag, sizeof(int)) == 0
	$if linux {
		assert C.setsockopt(fd, C.IPPROTO_TCP, C.TCP_QUICKACK, &flag, sizeof(int)) == 0
		timeout := 10
		assert C.setsockopt(fd, C.IPPROTO_TCP, C.TCP_DEFER_ACCEPT, &timeout, sizeof(int)) == 0
		queue_len := 4096
		assert C.setsockopt(fd, C.IPPROTO_TCP, C.TCP_FASTOPEN, &queue_len, sizeof(int)) == 0
	}

	mut addr := C.sockaddr_in{}
	addr.sin_family = C.AF_INET
	addr.sin_port = C.htons(port)
	addr.sin_addr.s_addr = C.htonl(C.INADDR_ANY)
	size := 16 // sizeof(C.sockaddr_in)
	bind_res := C.bind(fd, &addr, size)
	assert bind_res == 0

	listen_res := C.listen(fd, C.SOMAXCONN)
	assert listen_res == 0

	setup_sock(fd)

	C.picoev_init(MAX_FDS)
	loop := C.picoev_create_loop(MAX_TIMEOUT)
	pv := &Picoev{
		loop: loop
		cb: cb
		date: C.get_date()
		buf: malloc(MAX_FDS * MAX_READ + 1)
		out: malloc(MAX_FDS * MAX_WRITE + 1)
	}
	C.picoev_add(loop, fd, C.PICOEV_READ, 0, accept_callback, pv)

	go update_date(pv)

	return pv
}

pub fn (p Picoev) serve() {
	for {
		C.picoev_loop_once(p.loop, 1)
	}
}

fn update_date(p mut Picoev) {
	for {
		p.date = C.get_date()
		C.usleep(1000000)
	}
}
module picohttpparser

[inline]
fn cpy_str(dst byteptr, src string) int {
	C.memcpy(dst, src.str, src.len)
	return src.len
}

[inline]
fn cpy(dst, src byteptr, len int) int {
	C.memcpy(dst, src, len)
	return len
}

[inline]
pub fn cmp(dst, src string) bool {
	if dst.len != src.len { return false }
	return C.memcmp(dst.str, src.str, src.len) == 0
}

[inline]
pub fn cmpn(dst, src string, n int) bool {
	return C.memcmp(dst.str, src.str, n) == 0
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module picohttpparser

#flag -I @VROOT/thirdparty/picohttpparser
#flag -L @VROOT/thirdparty/picohttpparser
#flag @VROOT/thirdparty/picohttpparser/picohttpparser.o

#include "picohttpparser.h"

struct C.phr_header {
pub:
	name charptr
	name_len int
	value charptr
	value_len int
}
struct C.phr_header_t {}

fn phr_parse_request() int
fn phr_parse_response() int
fn phr_parse_headers() int

fn phr_parse_request_path() int
fn phr_parse_request_path_pipeline() int
fn C.get_date() byteptr
fn C.u64toa() int
module picohttpparser

pub struct Request {
pub mut:
	method string
	path string
	headers &C.phr_header_t
	num_headers u64
}




[inline]
pub fn (mut r Request) parse_request(s string, headers &C.phr_header_t, max_headers int) int {
	method_len := u64(0)
	path_len := u64(0)
	minor_version := 0
	num_headers := u64(max_headers)

	pret := C.phr_parse_request(
		s.str, s.len,
		&r.method, &method_len,
		&r.path, &path_len,
		&minor_version,
		headers, &num_headers,
		0
	)
	if pret > 0 {
		r.method = tos(r.method.str, int(method_len))
		r.path = tos(r.path.str, int(path_len))
		r.headers = headers
		r.num_headers = num_headers
	}
	return pret
}

[inline]
pub fn (mut r Request) parse_request_path(s string) int {
	method_len := u64(0)
	path_len := u64(0)

	pret := C.phr_parse_request_path(
		s.str, s.len,
		&r.method, &method_len,
		&r.path, &path_len
	)
	if pret > 0 {
		r.method = tos(r.method.str, int(method_len))
		r.path = tos(r.path.str, int(path_len))
	}
	return pret
}

[inline]
pub fn (mut r Request) parse_request_path_pipeline(s string) int {
	method_len := u64(0)
	path_len := u64(0)

	pret := C.phr_parse_request_path_pipeline(
		s.str, s.len,
		&r.method, &method_len,
		&r.path, &path_len
	)
	if pret > 0 {
		r.method = tos(r.method.str, int(method_len))
		r.path = tos(r.path.str, int(path_len))
	}
	return pret
}
module picohttpparser

pub struct Response {
	fd int
pub:
	date byteptr
	buf_start byteptr
pub mut:
	buf byteptr
}

[inline]
pub fn (mut r Response) http_ok() &Response {
	r.buf += cpy_str(r.buf, "HTTP/1.1 200 OK\r\n")
	return r
}

[inline]
pub fn (mut r Response) header(k, v string) &Response {
	r.buf += cpy_str(r.buf, k)
	r.buf += cpy_str(r.buf, ": ")
	r.buf += cpy_str(r.buf, v)
	r.buf += cpy_str(r.buf, "\r\n")
	return r
}

[inline]
pub fn (mut r Response) header_date() &Response {
	r.buf += cpy_str(r.buf, "Date: ")
	r.buf += cpy(r.buf, r.date, 29)
	r.buf += cpy_str(r.buf, "\r\n")
	return r
}

[inline]
pub fn (mut r Response) header_server() &Response {
	r.buf += cpy_str(r.buf, "Server: V\r\n")
	return r
}

[inline]
pub fn (mut r Response) content_type(s string) &Response {
	r.buf += cpy_str(r.buf, "Content-Type: ")
	r.buf += cpy_str(r.buf, s)
	r.buf += cpy_str(r.buf, "\r\n")
	return r
}

[inline]
pub fn (mut r Response) plain() &Response {
	r.buf += cpy_str(r.buf, "Content-Type: text/plain\r\n")
	return r
}

[inline]
pub fn (mut r Response) json() &Response {
	r.buf += cpy_str(r.buf, "Content-Type: application/json\r\n")
	return r
}

[inline]
pub fn (mut r Response) body(body string) {
	r.buf += cpy_str(r.buf, "Content-Length: ")
	r.buf += C.u64toa(r.buf, body.len)
	r.buf += cpy_str(r.buf, "\r\n\r\n")
	r.buf += cpy_str(r.buf, body)
}

[inline]
pub fn (mut r Response) http_404() {
	r.buf += cpy_str(r.buf, 'HTTP/1.1 404 Not Found\r\nContent-Length: 0\r\n\r\n')
}

[inline]
pub fn (mut r Response) http_405() {
	r.buf += cpy_str(r.buf, 'HTTP/1.1 405 Method Not Allowed\r\nContent-Length: 0\r\n\r\n')
}

[inline]
pub fn (mut r Response) http_500() {
	r.buf += cpy_str(r.buf, 'HTTP/1.1 500 Internal Server Error\r\nContent-Length: 0\r\n\r\n')
}

[inline]
pub fn (mut r Response) raw(response string) {
	r.buf += cpy_str(r.buf, response)
}

[inline]
pub fn (mut r Response) end() int {
	n := int(r.buf - r.buf_start)
	if C.write(r.fd, r.buf_start, n) != n {
		return -1
	}
	return n
}
module rand
// Ported from http://www.pcg-random.org/download.html
// and https://github.com/imneme/pcg-c-basic/blob/master/pcg_basic.c
pub struct Pcg32 {
mut:
	state u64
	inc   u64
}

/**
 * new_pcg32 - a Pcg32 PRNG generator
 * @param initstate - the initial state of the PRNG.
 * @param initseq - the stream/step of the PRNG.
 * @return a new Pcg32 PRNG instance
*/


pub fn new_pcg32(initstate u64, initseq u64) Pcg32 {
	mut rng := Pcg32{
	}
	rng.state = u64(0)
	rng.inc = (initseq<<u64(1)) | u64(1)
	rng.next()
	rng.state += initstate
	rng.next()
	return rng
}

/**
 * Pcg32.next - update the PRNG state and get back the next random number
 * @return the generated pseudo random number
*/


[inline]
pub fn (mut rng Pcg32) next() u32 {
	oldstate := rng.state
	rng.state = oldstate * (6364136223846793005) + rng.inc
	xorshifted := u32(((oldstate>>u64(18)) ^ oldstate)>>u64(27))
	rot := u32(oldstate>>u64(59))
	return ((xorshifted>>rot) | (xorshifted<<((-rot) & u32(31))))
}

/**
 * Pcg32.bounded_next - update the PRNG state. Get the next number <  bound
 * @param bound - the returned random number will be < bound
 * @return the generated pseudo random number
*/


[inline]
pub fn (mut rng Pcg32) bounded_next(bound u32) u32 {
	// To avoid bias, we need to make the range of the RNG a multiple of
	// bound, which we do by dropping output less than a threshold.
	threshold := (-bound % bound)
	// Uniformity guarantees that loop below will terminate. In practice, it
	// should usually terminate quickly; on average (assuming all bounds are
	// equally likely), 82.25% of the time, we can expect it to require just
	// one iteration. In practice, bounds are typically small and only a
	// tiny amount of the range is eliminated.
	for {
		r := rng.next()
		if r >= threshold {
			return (r % bound)
		}
	}
	return u32(0)
}

import rand
import time

fn show_u32s(a []u32){
   mut res := []string{}
   for x in a {
	  res << x.str()
   }
   print('[')
   print(res.join(', '))
   println(']')
}
fn gen_randoms(initstate i64, initseq i64, bound int) []u32 {
	mut randoms := [u32(0)].repeat(20)
	mut rnd := rand.new_pcg32( u64(initstate), u64(initseq) )
	for i in 0..20 {
		randoms[i] = rnd.bounded_next(u32(bound))
	}
	return randoms
}

fn test_pcg32_reproducibility() {
	t := time.ticks()
	tseq := t % 23237671
	println('t: $t | tseq: $tseq')
	randoms1 := gen_randoms(t, tseq, 1000)
	randoms2 := gen_randoms(t, tseq, 1000)
	assert randoms1.len == randoms2.len
	show_u32s(randoms1)
	show_u32s(randoms2)
	len := randoms1.len
	for i in 0..len {
		assert randoms1[i] == randoms2[i]
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module rand

fn C.rand() int

pub fn seed(s int) {
	C.srand(s)
}

pub fn next(max int) int {
	return C.rand() % max
}

// rand_r returns a pseudo-random number;
// writes a result value to the seed argument.
pub fn rand_r(seed &int) int {
	ns := *seed * 1103515245 + 12345
	unsafe {
		(*seed) = ns
	}
	return ns & 0x7fffffff
}
import rand

const (
	rnd_count = 20
	seeds = [42, 256]
)

fn test_rand_reproducibility() {
	for seed in seeds {
		mut randoms1 := gen_randoms(seed)
		mut randoms2 := gen_randoms(seed)

		assert_randoms_equal(randoms1, randoms2)
	}
}

fn test_rand_r_reproducibility() {
	for seed in seeds {
		mut randoms1 := gen_randoms_r(seed)
		mut randoms2 := gen_randoms_r(seed)

		assert_randoms_equal(randoms1, randoms2)
	}
}

fn test_rand_r_seed_update() {
	seed := 10

	for _ in 0..rnd_count {
		prev_seed := seed
		_ := rand.rand_r(&seed)

		assert prev_seed != seed
	}
}

fn gen_randoms(seed int) []int {
	mut randoms := [0].repeat(rnd_count)
	rand.seed(seed)
	for i in 0..rnd_count {
		randoms[i] = rand.next(100)
	}
	return randoms
}

fn gen_randoms_r(seed int) []int {
	mut randoms := [0].repeat(rnd_count)
	for i in 0..rnd_count {
		randoms[i] = rand.rand_r(&seed)
	}
	return randoms
}

fn assert_randoms_equal(r1, r2 []int) {
	for i in 0..rnd_count {
		assert r1[i] == r2[i]
	}
}
module rand
// Ported from http://xoshiro.di.unimi.it/splitmix64.c
struct Splitmix64 {
mut:
	state u64
}

/**
 * new_splitmix64 - a Splitmix64 PRNG generator
 * @param seed the initial seed of the PRNG.
 * @return a new Splitmix64 PRNG instance
*/


pub fn new_splitmix64(seed u64) Splitmix64 {
	return Splitmix64{
		seed}
}

/**
 * Splitmix64.next - update the PRNG state and get back the next random number
 * @return the generated pseudo random number
*/


[inline]
pub fn (mut rng Splitmix64) next() u64 {
	rng.state += (0x9e3779b97f4a7c15)
	mut z := rng.state
	z = (z ^ ((z>>u64(30)))) * (0xbf58476d1ce4e5b9)
	z = (z ^ ((z>>u64(27)))) * (0x94d049bb133111eb)
	return z ^ (z>>(31))
}

/**
 * Splitmix64.bounded_next - Get the next random number < bound
 * @param bound - the returned random number will be < bound
 * @return the generated pseudo random number
*/


[inline]
pub fn (mut rng Splitmix64) bounded_next(bound u64) u64 {
	threshold := -bound % bound
	for {
		r := rng.next()
		if r >= threshold {
			return r % bound
		}
	}
	return u64(0)
}

import rand
import time

fn show_u64s(a []u64){
   mut res := []string{}
   for x in a {
	  res << x.str()
   }
   print('[')
   print(res.join(', '))
   println(']')
}

fn gen_randoms(seed i64, bound int) []u64 {
	mut randoms := [u64(0)].repeat(20)
	mut rnd := rand.new_splitmix64( u64(seed) )
	for i in 0..20 {
		randoms[i] = rnd.bounded_next(u64(bound))
	}
	return randoms
}

fn test_splitmix64_reproducibility() {
	t := time.ticks()
	println('t: $t')
	randoms1 := gen_randoms(t, 1000)
	randoms2 := gen_randoms(t, 1000)
	assert randoms1.len == randoms2.len
	show_u64s( randoms1 )
	show_u64s( randoms2 )
	len := randoms1.len
	for i in 0..len {
		assert randoms1[i] == randoms2[i]
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// JS version
// Need to be implemented
// Will serve as more advanced input method
// Based on the work of https://github.com/AmokHuginnsson/replxx

module readline

import os

// Only use standard os.get_line
// Need implementation for readline capabilities
pub fn (mut r Readline) read_line_utf8(prompt string) ?ustring {
  r.current = ''.ustring()
  r.cursor = 0
  r.prompt = prompt
  r.search_index = 0
  if r.previous_lines.len <= 1 {
    r.previous_lines << ''.ustring()
    r.previous_lines << ''.ustring()
  }
  else {
    r.previous_lines[0] = ''.ustring()
  }

  print(r.prompt)
  r.current = os.get_raw_line().ustring()

  r.previous_lines[0] = ''.ustring()
  r.search_index = 0
  if r.current.s == '' {
    return error('empty line')
  }
  return r.current
}

// Returns the string from the utf8 ustring
pub fn (mut r Readline) read_line(prompt string) ?string {
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s.s
}

// Standalone function without persistent functionnalities (eg: history)
// Returns utf8 based ustring
pub fn read_line_utf8(prompt string) ?ustring {
  mut r := Readline{}
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s
}

// Standalone function without persistent functionnalities (eg: history)
// Return string from utf8 ustring
pub fn read_line(prompt string) ?string {
  mut r := Readline{}
  s := r.read_line(prompt) or {
    return error(err)
  }
  return s
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Will serve as more advanced input method
// Based on the work of https://github.com/AmokHuginnsson/replxx

module readline

// Linux
// Used to change the terminal options
struct Termios {
mut:
  c_iflag int
  c_oflag int
  c_cflag int
  c_lflag int
  c_cc [12]int //NCCS == 12. Cant use the defined value here
}

// Linux
// Used to collect the screen information
struct Winsize {
  ws_row u16
  ws_col u16
  ws_xpixel u16
  ws_ypixel u16
}

pub struct Readline {
mut:
  is_raw bool
  orig_termios Termios // Linux
  current ustring // Line being edited
  cursor int // Cursor position
  overwrite bool
  cursor_row_offset int
  prompt string
  prompt_offset int
  previous_lines []ustring
  search_index int
  is_tty bool
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Mac version
// Need to be implemented
// Will serve as more advanced input method
// Based on the work of https://github.com/AmokHuginnsson/replxx

module readline

import os

#include <sys/termios.h>

// Only use standard os.get_line
// Need implementation for readline capabilities
pub fn (mut r Readline) read_line_utf8(prompt string) ?ustring {
  r.current = ''.ustring()
  r.cursor = 0
  r.prompt = prompt
  r.search_index = 0
  if r.previous_lines.len <= 1 {
    r.previous_lines << ''.ustring()
    r.previous_lines << ''.ustring()
  }
  else {
    r.previous_lines[0] = ''.ustring()
  }

  print(r.prompt)
  line := os.get_raw_line()

  if line.len >= 0 {
    r.current = line.ustring()
  }
  r.previous_lines[0] = ''.ustring()
  r.search_index = 0
  if r.current.s == '' {
    return error('empty line')
  }
  return r.current
}

// Returns the string from the utf8 ustring
pub fn (mut r Readline) read_line(prompt string) ?string {
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s.s
}

// Standalone function without persistent functionnalities (eg: history)
// Returns utf8 based ustring
pub fn read_line_utf8(prompt string) ?ustring {
  mut r := Readline{}
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s
}

// Standalone function without persistent functionnalities (eg: history)
// Return string from utf8 ustring
pub fn read_line(prompt string) ?string {
  mut r := Readline{}
  s := r.read_line(prompt) or {
    return error(err)
  }
  return s
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Linux version
// Will serve as more advanced input method
// Based on the work of https://github.com/AmokHuginnsson/replxx

module readline

import term

#include <termios.h>
#include <sys/ioctl.h>

// Defines actions to execute
enum Action {
  eof
  nothing
  insert_character
  commit_line
  delete_left
  delete_right
  move_cursor_left
  move_cursor_right
  move_cursor_begining
  move_cursor_end
  move_cursor_word_left
  move_cursor_word_right
  history_previous
  history_next
  overwrite
  clear_screen
  suspend
}

fn C.tcgetattr() int
fn C.tcsetattr() int
//fn C.ioctl() int
fn C.raise()

// Enable the raw mode of the terminal
// In raw mode all keypresses are directly sent to the program and no interpretation is done
// Catches the SIGUSER (CTRL+C) Signal
pub fn (mut r Readline) enable_raw_mode() {
  if C.tcgetattr(0, &r.orig_termios) == -1 {
    r.is_tty = false
    r.is_raw = false
    return
  }
  mut raw := r.orig_termios
  raw.c_iflag &= ~( C.BRKINT | C.ICRNL | C.INPCK | C.ISTRIP | C.IXON )
  raw.c_cflag |=  ( C.CS8 )
  raw.c_lflag &= ~( C.ECHO | C.ICANON | C.IEXTEN | C.ISIG )
  raw.c_cc[C.VMIN] = 1
  raw.c_cc[C.VTIME] = 0
  C.tcsetattr(0, C.TCSADRAIN, &raw)
  r.is_raw = true
  r.is_tty = true
}

// Enable the raw mode of the terminal
// Does not catch the SIGUSER (CTRL+C) Signal
pub fn (mut r Readline) enable_raw_mode_nosig() {
  if C.tcgetattr(0, &r.orig_termios) == -1 {
    r.is_tty = false
    r.is_raw = false
    return
  }
  mut raw := r.orig_termios
  raw.c_iflag &= ~( C.BRKINT | C.ICRNL | C.INPCK | C.ISTRIP | C.IXON )
  raw.c_cflag |=  ( C.CS8 )
  raw.c_lflag &= ~( C.ECHO | C.ICANON | C.IEXTEN )
  raw.c_cc[C.VMIN] = 1
  raw.c_cc[C.VTIME] = 0
  C.tcsetattr(0, C.TCSADRAIN, &raw)
  r.is_raw = true
  r.is_tty = true
}

// Disable the raw mode of the terminal
pub fn (mut r Readline) disable_raw_mode() {
  if r.is_raw {
    C.tcsetattr(0, C.TCSADRAIN, &r.orig_termios)
    r.is_raw = false
  }
}

// Read a single char
pub fn (r Readline) read_char() int {
  return utf8_getchar()
}

// Main function of the readline module
// Will loop and ingest characters until EOF or Enter
// Returns the completed line as utf8 ustring
// Will return an error if line is empty
pub fn (mut r Readline) read_line_utf8(prompt string) ?ustring {
  r.current = ''.ustring()
  r.cursor = 0
  r.prompt = prompt
  r.search_index = 0
  r.prompt_offset = get_prompt_offset(prompt)
  if r.previous_lines.len <= 1 {
    r.previous_lines << ''.ustring()
    r.previous_lines << ''.ustring()
  }
  else {
    r.previous_lines[0] = ''.ustring()
  }
  if !r.is_raw {
    r.enable_raw_mode()
  }

  print(r.prompt)
  for {
    C.fflush(C.stdout)
    c := r.read_char()
    a := r.analyse(c)
    if r.execute(a, c) {
      break
    }
  }

  r.previous_lines[0] = ''.ustring()
  r.search_index = 0
  r.disable_raw_mode()
  if r.current.s == '' {
    return error('empty line')
  }
  return r.current
}

// Returns the string from the utf8 ustring
pub fn (mut r Readline) read_line(prompt string) ?string {
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s.s
}

// Standalone function without persistent functionnalities (eg: history)
// Returns utf8 based ustring
pub fn read_line_utf8(prompt string) ?ustring {
  mut r := Readline{}
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s
}

// Standalone function without persistent functionnalities (eg: history)
// Return string from utf8 ustring
pub fn read_line(prompt string) ?string {
  mut r := Readline{}
  s := r.read_line(prompt) or {
    return error(err)
  }
  return s
}

fn get_prompt_offset(prompt string) int {
  mut len := 0

  for i := 0; i < prompt.len; i++ {
    if prompt[i] == `\e` {
      for ;i < prompt.len && prompt[i] != `m`; i++ {}
    } else {
      len = len + 1
    }
  }
  return prompt.len - len
}

fn (r Readline) analyse(c int) Action {
  match c {
    `\0`  { return .eof }
    0x3   { return .eof } // End of Text
    0x4   { return .eof } // End of Transmission
    255   { return .eof }
    `\n`  { return .commit_line }
    `\r`  { return .commit_line }
    `\f`  { return .clear_screen } // CTRL + L
    `\b`  { return .delete_left } // Backspace
    127   { return .delete_left } // DEL
    27    { return r.analyse_control() } // ESC
    1     { return .move_cursor_begining } // ^A
    5     { return .move_cursor_end } // ^E
    26    { return .suspend } // CTRL + Z, SUB
    else  { return if c >= ` ` { Action.insert_character } else { Action.nothing } }
  }
}

fn (r Readline) analyse_control() Action {
  c := r.read_char()

match c {
	`[` {
		sequence := r.read_char()
		match sequence {
			`C` { return .move_cursor_right }
			`D` { return .move_cursor_left }
			`B` { return .history_next }
			`A` { return .history_previous }
			`1` { return r.analyse_extended_control() }
			`2` { return r.analyse_extended_control_no_eat(sequence) }
			`3` { return r.analyse_extended_control_no_eat(sequence) }
			else {}
		}
	}
	else { }
}


/*
//TODO
match c {
	case `[`:
	sequence := r.read_char()
	match sequence {
	case `C`: return .move_cursor_right
	case `D`: return .move_cursor_left
	case `B`: return .history_next
	case `A`: return .history_previous
	case `1`: return r.analyse_extended_control()
	case `2`: return r.analyse_extended_control_no_eat(sequence)
	case `3`: return r.analyse_extended_control_no_eat(sequence)
	case `9`:
		foo()
		bar()
	else:
	}
	else:
}
*/




  return .nothing
}

fn (r Readline) analyse_extended_control() Action {
  r.read_char() // Removes ;
  c := r.read_char()
  match c {
    `5` {
      direction := r.read_char()
      match direction {
        `C` { return .move_cursor_word_right }
        `D` { return .move_cursor_word_left }
       else {}
      }
    }
    else {}
  }
  return .nothing
}

fn (r Readline) analyse_extended_control_no_eat(last_c byte) Action {
  c := r.read_char()
  match c {
    `~` {
      match last_c {
        `3` { return .delete_right } // Suppr key
        `2` { return .overwrite }
        else {}
      }
    }
    else {}
  }
  return .nothing
}

fn (mut r Readline) execute(a Action, c int) bool {
  match a {
    .eof                    { return r.eof() }
    .insert_character       { r.insert_character(c) }
    .commit_line            { return r.commit_line() }
    .delete_left            { r.delete_character() }
    .delete_right           { r.suppr_character() }
    .move_cursor_left       { r.move_cursor_left() }
    .move_cursor_right      { r.move_cursor_right() }
    .move_cursor_begining   { r.move_cursor_begining() }
    .move_cursor_end        { r.move_cursor_end() }
    .move_cursor_word_left  { r.move_cursor_word_left() }
    .move_cursor_word_right { r.move_cursor_word_right() }
    .history_previous       { r.history_previous() }
    .history_next           { r.history_next() }
    .overwrite              { r.switch_overwrite() }
    .clear_screen           { r.clear_screen() }
    .suspend                { r.suspend() }
    else {}
  }
  return false
}

fn get_screen_columns() int {
  ws := Winsize{}
  cols := if C.ioctl(1, C.TIOCGWINSZ, &ws) == -1 { 80 } else { int(ws.ws_col) }
  return cols
}

fn shift_cursor(xpos int, yoffset int) {
  if yoffset != 0 {
    if yoffset > 0 {
      term.cursor_down(yoffset)
    }
    else {
      term.cursor_up(- yoffset)
    }
  }
  // Absolute X position
  print('\x1b[${xpos + 1}G')
}

fn calculate_screen_position(x_in int, y_in int, screen_columns int, char_count int, inp []int) []int {
  mut out := inp
  mut x := x_in
  mut y := y_in
  out[0] = x
  out[1] = y
  for chars_remaining := char_count; chars_remaining > 0; {
    chars_this_row := if (x + chars_remaining) < screen_columns { chars_remaining } else { screen_columns - x }
    out[0] = x + chars_this_row
    out[1] = y
    chars_remaining -= chars_this_row
    x = 0
    y++
  }
  if out[0] == screen_columns {
    out[0] = 0
    out[1]++
  }
  return out
}

// Will redraw the line
fn (mut r Readline) refresh_line() {
  mut end_of_input := [0, 0]
  end_of_input = calculate_screen_position(r.prompt.len, 0, get_screen_columns(), r.current.len, end_of_input)
  end_of_input[1] += r.current.count('\n'.ustring())
  mut cursor_pos := [0, 0]
  cursor_pos = calculate_screen_position(r.prompt.len, 0, get_screen_columns(), r.cursor, cursor_pos)

  shift_cursor(0, -r.cursor_row_offset)
  term.erase_toend()
  print(r.prompt)
  print(r.current)
  if end_of_input[0] == 0 && end_of_input[1] > 0 {
    print('\n')
  }
  shift_cursor(cursor_pos[0] - r.prompt_offset, - (end_of_input[1] - cursor_pos[1]))
  r.cursor_row_offset = cursor_pos[1]
}

// End the line without a newline
fn (mut r Readline) eof() bool {
  r.previous_lines.insert(1, r.current)
  r.cursor = r.current.len
  if r.is_tty {
    r.refresh_line()
  }
  return true
}

fn (mut r Readline) insert_character(c int) {
  if !r.overwrite || r.cursor == r.current.len {
    r.current = r.current.left(r.cursor).ustring().add( utf32_to_str(u32(c)).ustring() ).add( r.current.right(r.cursor).ustring() )
  } else {
    r.current = r.current.left(r.cursor).ustring().add( utf32_to_str(u32(c)).ustring() ).add( r.current.right(r.cursor + 1).ustring() )
  }
  r.cursor++
  // Refresh the line to add the new character
  if r.is_tty {
    r.refresh_line()
  }
}

// Removes the character behind cursor.
fn (mut r Readline) delete_character() {
  if r.cursor <= 0 {
    return
  }
  r.cursor--
  r.current = r.current.left(r.cursor).ustring().add( r.current.right(r.cursor + 1).ustring() )
  r.refresh_line()
}

// Removes the character in front of cursor.
fn (mut r Readline) suppr_character() {
  if r.cursor > r.current.len {
    return
  }
  r.current = r.current.left(r.cursor).ustring().add( r.current.right(r.cursor + 1).ustring() )
  r.refresh_line()
}

// Add a line break then stops the main loop
fn (mut r Readline) commit_line() bool {
  r.previous_lines.insert(1, r.current)
  a := '\n'.ustring()
  r.current = r.current.add( a )
  r.cursor = r.current.len
  if r.is_tty {
    r.refresh_line()
    println('')
  }
  return true
}

fn (mut r Readline) move_cursor_left() {
  if r.cursor > 0 {
    r.cursor--
    r.refresh_line()
  }
}

fn (mut r Readline) move_cursor_right() {
  if r.cursor < r.current.len {
    r.cursor++
    r.refresh_line()
  }
}

fn (mut r Readline) move_cursor_begining() {
  r.cursor = 0
  r.refresh_line()
}

fn (mut r Readline) move_cursor_end() {
  r.cursor = r.current.len
  r.refresh_line()
}

// Check if the character is considered as a word-breaking character
fn (r Readline) is_break_character(c string) bool {
  break_characters := ' \t\v\f\a\b\r\n`~!@#$%^&*()-=+[{]}\\|;:\'",<.>/?'
  return break_characters.contains(c)
}

fn (mut r Readline) move_cursor_word_left() {
  if r.cursor > 0 {
    for ; r.cursor > 0 && r.is_break_character(r.current.at(r.cursor - 1)); r.cursor-- {}
    for ; r.cursor > 0 && !r.is_break_character(r.current.at(r.cursor - 1)); r.cursor-- {}
    r.refresh_line()
  }
}

fn (mut r Readline) move_cursor_word_right() {
  if r.cursor < r.current.len {
    for ; r.cursor < r.current.len && r.is_break_character(r.current.at(r.cursor)); r.cursor++ {}
    for ; r.cursor < r.current.len && !r.is_break_character(r.current.at(r.cursor)); r.cursor++ {}
    r.refresh_line()
  }
}

fn (mut r Readline) switch_overwrite() {
  r.overwrite = !r.overwrite
}

fn (mut r Readline) clear_screen() {
  term.set_cursor_position(1, 1)
  term.erase_clear()
  r.refresh_line()
}

fn (mut r Readline) history_previous() {
  if r.search_index + 2 >= r.previous_lines.len {
    return
  }
  if r.search_index == 0 {
    r.previous_lines[0] = r.current
  }
  r.search_index++
  r.current = r.previous_lines[r.search_index]
  r.cursor = r.current.len
  r.refresh_line()
}

fn (mut r Readline) history_next() {
  if r.search_index <= 0 {
    return
  }
  r.search_index--
  r.current = r.previous_lines[r.search_index]
  r.cursor = r.current.len
  r.refresh_line()
}

fn (mut r Readline) suspend() {
  C.raise(C.SIGSTOP)
  r.refresh_line()
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Mac version
// Need to be implemented
// Will serve as more advanced input method
// Based on the work of https://github.com/AmokHuginnsson/replxx

module readline

import os

#include <sys/termios.h>

// Only use standard os.get_line
// Need implementation for readline capabilities
pub fn (mut r Readline) read_line_utf8(prompt string) ?ustring {
  r.current = ''.ustring()
  r.cursor = 0
  r.prompt = prompt
  r.search_index = 0
  if r.previous_lines.len <= 1 {
    r.previous_lines << ''.ustring()
    r.previous_lines << ''.ustring()
  }
  else {
    r.previous_lines[0] = ''.ustring()
  }

  print(r.prompt)
  line := os.get_raw_line()

  if line.len >= 0 {
    r.current = line.ustring()
  }
  r.previous_lines[0] = ''.ustring()
  r.search_index = 0
  if r.current.s == '' {
    return error('empty line')
  }
  return r.current
}

// Returns the string from the utf8 ustring
pub fn (mut r Readline) read_line(prompt string) ?string {
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s.s
}

// Standalone function without persistent functionnalities (eg: history)
// Returns utf8 based ustring
pub fn read_line_utf8(prompt string) ?ustring {
  mut r := Readline{}
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s
}

// Standalone function without persistent functionnalities (eg: history)
// Return string from utf8 ustring
pub fn read_line(prompt string) ?string {
  mut r := Readline{}
  s := r.read_line(prompt) or {
    return error(err)
  }
  return s
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Windows version
// Need to be implemented
// Will serve as more advanced input method
// Based on the work of https://github.com/AmokHuginnsson/replxx

module readline

import os

// Only use standard os.get_line
// Need implementation for readline capabilities
pub fn (mut r Readline) read_line_utf8(prompt string) ?ustring {
  r.current = ''.ustring()
  r.cursor = 0
  r.prompt = prompt
  r.search_index = 0
  if r.previous_lines.len <= 1 {
    r.previous_lines << ''.ustring()
    r.previous_lines << ''.ustring()
  }
  else {
    r.previous_lines[0] = ''.ustring()
  }

  print(r.prompt)
  r.current = os.get_raw_line().ustring()

  r.previous_lines[0] = ''.ustring()
  r.search_index = 0
  if r.current.s == '' {
    return error('empty line')
  }
  return r.current
}

// Returns the string from the utf8 ustring
pub fn (mut r Readline) read_line(prompt string) ?string {
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s.s
}

// Standalone function without persistent functionnalities (eg: history)
// Returns utf8 based ustring
pub fn read_line_utf8(prompt string) ?ustring {
  mut r := Readline{}
  s := r.read_line_utf8(prompt) or {
    return error(err)
  }
  return s
}

// Standalone function without persistent functionnalities (eg: history)
// Return string from utf8 ustring
pub fn read_line(prompt string) ?string {
  mut r := Readline{}
  s := r.read_line(prompt) or {
    return error(err)
  }
  return s
}
# V RegEx (Regular expression) 0.9d

[TOC]

## introduction

Write here the introduction... not today!! -_-

## Basic assumption

In this release, during the writing of the code some assumptions are made and are valid for all the features.

1. The matching stops at the end of the string not at the newline chars.
2. The basic elements of this regex engine are the tokens, in a query string a simple char is a token. The token is the atomic unit of this regex engine.

## Match positional limiter

The module supports the following features:

- `$` `^` delimiter

`^` (Caret.) Matches at the start of the string

`$` Matches at the end of the string

## Tokens

The tokens are the atomic units used by this regex engine and can be ones of the following:

### Simple char

this token is a simple single character like `a`.

### Char class (cc)

The cc matches all the chars specified inside, it is delimited by square brackets `[ ]`

the sequence of chars in the class is evaluated with an OR operation.

For example, the following cc `[abc]` matches any char that is `a` or `b` or `c` but doesn't match `C` or `z`.

Inside a cc is possible to specify a "range" of chars, for example `[ad-f]` is equivalent to write `[adef]`. 

A cc can have different ranges at the same time like `[a-zA-z0-9]` that matches all the lowercase,uppercase and numeric chars.

It is possible negate the cc using the caret char at the start of the cc like: `[^abc]` that matches every char that is not `a` or `b` or `c`.

A cc can contain meta-chars like: `[a-z\d]` that matches all the lowercase latin chars `a-z` and all the digits `\d`.

It is possible to mix all the properties of the char class together.

**Note:** In order to match the `-` (minus) char, it must be located at the first position in the cc, for example  `[-_\d\a]` will match `-` minus, `_`underscore, `\d` numeric chars, `\a` lower case chars.

### Meta-chars

A meta-char is specified by a backslash before a char like `\w` in this case the meta-char is `w`.

A meta-char can match different type of chars.

* `\w` matches an alphanumeric char `[a-zA-Z0-9_]`
* `\W` matches a non alphanumeric char
* `\d` matches a digit `[0-9]`
* `\D` matches a non digit
* `\s`matches a space char, one of `[' ','\t','\n','\r','\v','\f']`
* `\S` matches a non space char
* `\a` matches only a lowercase char `[a-z]` 
* `\A` matches only an uppercase char `[A-Z]`

### Quantifier

Each token can have a quantifier that specify how many times the char can or must be matched.

#### **Short quantifier**

- `?` matches 0 or 1 time, `a?b` matches both `ab` or `b`
- `+` matches at minimum 1 time, `a+` matches both `aaa` or `a`
- `*` matches 0 or more time, `a*b` matches both `aaab` or `ab` or `b`

#### **Long quantifier**

- `{x}` matches exactly x time, `a{2}` matches `aa` but doesn't match `aaa` or `a`
- `{min,}` matches at minimum min time, `a{2,}` matches `aaa` or `aa` but doesn't match `a`
- `{,max}` matches at least 0 time and maximum max time, `a{,2}` matches `a` and `aa` but doesn't match `aaa`
- `{min,max}` matches from min times to max times, `a{2,3}` matches `aa` and `aaa` but doesn't match `a` or `aaaa`

a long quantifier may have a `greedy off` flag that is the `?` char after the brackets, `{2,4}?` means to match the minimum number possible tokens in this case 2.

### dot char

the dot is a particular meta char that matches  "any char", is more simple explain it with an example:

suppose to have `abccc ddeef` as source string to parse with regex, the following table show the query strings and the result of parsing source string.

| query string | result |
| ------------ | ------ |
| `.*c`        | `abc`  |
|  `.*dd`		 |  `abcc dd` |
| `ab.*e` | `abccc dde` |
| `ab.{3} .*e` | `abccc dde` |

the dot char matches any char until the next token match is satisfied.

### OR token

the token `|` is a logic OR operation between two consecutive tokens, `a|b` matches a char that is `a` or `b`.

The OR token can work in a "chained way": `a|(b)|cd ` test first `a` if the char is not `a` then test the group `(b)` and if the group doesn't match test the token `c`.

**note: The OR work at token level! It doesn't work at concatenation level!**

A query string like `abc|bde` is not equal to `(abc)|(bde)`!!  The OR work only on `c|b` not at char concatenation level.

### Groups

Groups are a method to create complex patterns with repetition of blocks of tokens.

The groups are delimited by round brackets `( )`, groups can be nested and can have a quantifier as all the tokens.

`c(pa)+z` match `cpapaz` or `cpaz` or `cpapapaz` .

`(c(pa)+z ?)+` matches `cpaz cpapaz cpapapaz` or `cpapaz` 

let analyze this last case, first we have the group `#0` that are the most outer round brackets `(...)+`, this group has a quantifier that say to match its content at least one time `+`. 

After we have a simple char token `c` and a second group that is the number `#1` :`(pa)+`, this group try to match the sequence `pa` at least one time as specified by the `+` quantifier.

After, we have another simple token `z` and another simple token ` ?` that is the space char (ascii code 32) followed by the `?` quantifier that say to capture the space char 0 or 1 time.

This explain because the `(c(pa)+z ?)+` query string can match `cpaz cpapaz cpapapaz` .

In this implementation the groups are "capture groups", it means that the last temporal result for each group can be retrieved from the `RE` struct.

The "capture groups" are store as couple of index in the field `groups` that is an `[]int` inside the `RE` struct. 

**example:**

```v
text := "cpaz cpapaz cpapapaz"
query:= r"(c(pa)+z ?)+"
re, _, _ := regex.regex(query) 

println(re.get_query())
// #0(c#1(pa)+z ?)+  // #0 and #1 are the ids of the groups, are shown if re.debug is 1 or 2

start, end := re.match_string(text)
// [start=0, end=20]  match => [cpaz cpapaz cpapapaz]

mut gi := 0
for gi < re.groups.len {
	if re.groups[gi] >= 0 {
		println("${gi/2} :[${text[re.groups[gi]..re.groups[gi+1]]}]")
	}
	gi += 2
}
// groups captured
// 0 :[cpapapaz]
// 1 :[pa]


```

**note:** *to show the `group id number` in the result of the `get_query()` the flag `debug` of the RE object must be `1` or `2`*

### Groups Continuous saving

In particular situations it is useful have a continuous save of the groups, this is possible initializing the saving array field in `RE` struct: `group_csave`.

This feature allow to collect data in a  continuous way.

In the example we pass a text followed by a integer list that we want collect. 
To achieve this task we can use the continuous saving of the group that save each captured group in a array that we set with: `re.group_csave = [-1].repeat(3*20+1)`.

The array will be filled with the following logic:

`re.group_csave[0]` number of total saved records

`re.group_csave[1+n*3]` id of the saved group
`re.group_csave[1+n*3]` start index in the source string of the saved group
`re.group_csave[1+n*3]` end index in the source string of the saved group

The regex save until finish or found that the array have no space. If the space ends no error is raised, further records will not be saved.

```v
fn example2() {
	test_regex()

	text := "tst: 01,23,45 ,56, 78"
	query:= r".*:(\s*\d+[\s,]*)+"

	mut re := regex.new_regex()
	//re.debug = 2
	re.group_csave = [-1].repeat(3*20+1)  // we expect max 20 records

	re_err, err_pos := re.compile(query)
	if re_err == regex.COMPILE_OK {
		q_str := re.get_query()
		println("Query: $q_str")
	
		start, end := re.match_string(text)
		if start < 0 {
			println("ERROR : ${re.get_parse_error_string(start)}, $start")
		} else {
			println("found in [$start, $end] => [${text[start..end]}]")
		}

		// groups capture
		mut gi := 0
		for gi < re.groups.len {
			if re.groups[gi] >= 0 {
				println("${gi/2} ${re.groups[gi]},${re.groups[gi+1]} :[${text[re.groups[gi]..re.groups[gi+1]]}]")
			}
			gi += 2
		}

		// continuous saving
		gi = 0
		println("num: ${re.group_csave[0]}")
		for gi < re.group_csave[0] {
			id := re.group_csave[1+gi*3]
			st := re.group_csave[1+gi*3+1]
			en := re.group_csave[1+gi*3+2]
			println("cg id: ${id} [${st}, ${en}] => [${text[st..en]}]")
			gi++
		}
	} else {
		println("query: $query")
		lc := "-".repeat(err_pos)
		println("err  : $lc^")
		err_str := re.get_parse_error_string(re_err)
		println("ERROR: $err_str")	
	}
}
```

The output will be:

```
Query: .*:(\s*\d+[\s,]*)+
found in [0, 21] => [tst: 01,23,45 ,56, 78]
0 19,21 :[78]
num: 5
cg id: 0 [4, 8] => [ 01,]
cg id: 0 [8, 11] => [23,]
cg id: 0 [11, 15] => [45 ,]
cg id: 0 [15, 19] => [56, ]
cg id: 0 [19, 21] => [78] 
```

### Named capturing groups

This regex module support partially the question mark `?` PCRE syntax for groups.

`(?:abcd)` **non capturing group**:  the content of the group will not be saved

`(?P<mygroup>abcdef)` **named group:** the group content is saved and labeled as `mygroup`

The label of the groups is saved in the `group_map` of the `RE` struct, this is a map from `string` to `int` where the value is the index in `group_csave` list of index.

Have a look at the example for the use of them.

example:

```v
fn main() {
	test_regex()

	text := "http://www.ciao.mondo/hello/pippo12_/pera.html"
	query:= r"(?P<format>https?)|(?:ftps?)://(?P<token>[\w_]+.)+"

	mut re := new_regex()
	re.debug = 2

	// must provide an array of the right size if want the continuos saving of the groups
	re.group_csave = [-1].repeat(3*20+1)

	re_err, err_pos := re.compile(query)
	if re_err == COMPILE_OK {
		q_str := re.get_query()
		println("O.Query: $query")
		println("Query  : $q_str")
		
		re.debug = 0	
		start, end := re.match_string(text)
		if start < 0 {
			err_str := re.get_parse_error_string(start)
			println("ERROR : $err_str, $start")
		} else {
			text1 := text[start..end]
			println("found in [$start, $end] => [$text1]")
		}

		// groups
		mut gi := 0
		for gi < re.groups.len {
			if re.groups[gi] >= 0 {
				println("${gi/2} ${re.groups[gi]},${re.groups[gi+1]} :[${text[re.groups[gi]..re.groups[gi+1]]}]")
			}
			gi += 2
		}
		// continuous saving
		gi = 0
		println("num of group item saved: ${re.group_csave[0]}")
		for gi < re.group_csave[0] {
			id := re.group_csave[1+gi*3]
			st := re.group_csave[1+gi*3+1]
			en := re.group_csave[1+gi*3+2]
			println("cg id: ${id} [${st}, ${en}] => [${text[st..en]}]")
			gi++
		}
		println("raw array: ${re.group_csave[0..gi*3+2-1]}")

		// named capturing groups
		println("named capturing groups:")
		for g_name in re.group_map.keys() {
			s,e := re.get_group(g_name)
			if s >= 0 && e > s {
				println("'${g_name}':[$s, $e] => '${text[s..e]}'")
			} else {
				println("Group [${g_name}] doesn't exist.")
			}
		}
		
	} else {
		println("query: $query")
		lc := "-".repeat(err_pos)
		println("err  : $lc^")
		err_str := re.get_parse_error_string(re_err)
		println("ERROR: $err_str")	
	}

}
```

Output:

```
O.Query: (?P<format>https?)|(?:ftps?)://(?P<token>[\w_]+.)+
Query  : #0(?P<format>https?)|{8,14}(?:ftps?)://#1(?P<token>[\w_]+.)+
found in [0, 46] => [http://www.ciao.mondo/hello/pippo12_/pera.html]
0 0,4 :[http]
1 42,46 :[html]
num of group item saved: 8
cg id: 0 [0, 4] => [http]
cg id: 1 [7, 11] => [www.]
cg id: 1 [11, 16] => [ciao.]
cg id: 1 [16, 22] => [mondo/]
cg id: 1 [22, 28] => [hello/]
cg id: 1 [28, 37] => [pippo12_/]
cg id: 1 [37, 42] => [pera.]
cg id: 1 [42, 46] => [html]
raw array: [8, 0, 0, 4, 1, 7, 11, 1, 11, 16, 1, 16, 22, 1, 22, 28, 1, 28, 37, 1, 37, 42, 1, 42, 46] 
named capturing groups:
'format':[0, 4] => 'http'
'token':[42, 46] => 'html'
```

## Flags

It is possible to set some flags in the regex parser that change the behavior of the parser itself.

```v
// example of flag settings
mut re := regex.new_regex()
re.flag = regex.F_BIN 

```

- `F_BIN`: parse a string as bytes, utf-8 management disabled.

- `F_EFM`: exit on the first char matches in the query, used by the find function.
- `F_MS`: matches only if the index of the start match is 0, same as `^` at the start of the query string.
- `F_ME`: matches only if the end index of the match is the last char of the input string, same as `$` end of query string.
- `F_NL`: stop the matching if found a new line char `\n` or `\r`

## Functions

### Initializer

These functions are helper that create the `RE` struct, a `RE` struct can be created manually if you needed.

#### **Simplified initializer**

```v
// regex create a regex object from the query string and compile it
pub fn regex(in_query string) (RE,int,int)
```

#### **Base initializer**

```v
// new_regex create a REgex of small size, usually sufficient for ordinary use
pub fn new_regex() RE

// new_regex_by_size create a REgex of large size, mult specify the scale factor of the memory that will be allocated
pub fn new_regex_by_size(mult int) RE
```
After a base initializer is used, the regex expression must be compiled with:
```v
// compile return (return code, index) where index is the index of the error in the query string if return code is an error code
pub fn (re mut RE) compile(in_txt string) (int,int)
```

### Operative Functions

These are the operative functions

```v
// match_string try to match the input string, return start and end index if found else start is -1
pub fn (re mut RE) match_string(in_txt string) (int,int)

// find try to find the first match in the input string, return start and end index if found else start is -1
pub fn (re mut RE) find(in_txt string) (int,int)

// find_all find all the "non overlapping" occurrences of the matching pattern, return a list of start end indexes
pub fn (re mut RE) find_all(in_txt string) []int

// replace return a string where the matches are replaced with the replace string, only non overlapped matches are used
pub fn (re mut RE) replace(in_txt string, repl string) string
```

## Debugging

This module has few small utilities to help the writing of regex expressions.

### **Syntax errors highlight**

the following example code show how to visualize the syntax errors in the compilation phase:

```v
query:= r"ciao da ab[ab-]"  // there is an error, a range not closed!!
mut re := new_regex()

// re_err ==> is the return value, if < 0 it is an error
// re_pos ==> if re_err < 0, re_pos is the error index in the query string 
re_err, err_pos := re.compile(query)

// print the error if one happen
if re_err != COMPILE_OK {
	println("query: $query")
    lc := "-".repeat(err_pos)
    println("err  : $lc^")
    err_str := re.get_parse_error_string(re_err)  // get the error string
    println("ERROR: $err_str")
}

// output!!

//query: ciao da ab[ab-]
//err  : ----------^
//ERROR: ERR_SYNTAX_ERROR

```

### **Compiled code**

It is possible view the compiled code calling the function `get_query()` the result will be something like this:

```
========================================
v RegEx compiler v 0.9c output:
PC:  0 ist: 7fffffff [a]      query_ch {  1,  1}
PC:  1 ist: 7fffffff [b]      query_ch {  1,MAX}
PC:  2 ist: 88000000 PROG_END {  0,  0}
========================================
```

`PC`:`int` is the program counter or step of execution, each single step is a token.

`ist`:`hex` is the token instruction id.

`[a]` is the char used by the token.

`query_ch` is the type of token.

`{m,n}` is the quantifier, the greedy off flag  `?`  will be showed if present in the token

### **Log debug**

The log debugger allow to print the status of the regex parser when the parser is running.

It is possible to have two different level of debug: 1 is normal while 2 is verbose.

here an example:

*normal*

list only the token instruction with their values

```
// re.flag = 1 // log level normal
flags: 00000000
#   2 s:     ist_load PC:   0=>7fffffff i,ch,len:[  0,'a',1] f.m:[ -1, -1] query_ch: [a]{1,1}:0 (#-1)
#   5 s:     ist_load PC:   1=>7fffffff i,ch,len:[  1,'b',1] f.m:[  0,  0] query_ch: [b]{2,3}:0? (#-1)
#   7 s:     ist_load PC:   1=>7fffffff i,ch,len:[  2,'b',1] f.m:[  0,  1] query_ch: [b]{2,3}:1? (#-1)
#  10 PROG_END
```

*verbose*

list all the instructions and states of the parser

```
flags: 00000000
#   0 s:        start PC: NA
#   1 s:     ist_next PC: NA
#   2 s:     ist_load PC:   0=>7fffffff i,ch,len:[  0,'a',1] f.m:[ -1, -1] query_ch: [a]{1,1}:0 (#-1)
#   3 s:  ist_quant_p PC:   0=>7fffffff i,ch,len:[  1,'b',1] f.m:[  0,  0] query_ch: [a]{1,1}:1 (#-1)
#   4 s:     ist_next PC: NA
#   5 s:     ist_load PC:   1=>7fffffff i,ch,len:[  1,'b',1] f.m:[  0,  0] query_ch: [b]{2,3}:0? (#-1)
#   6 s:  ist_quant_p PC:   1=>7fffffff i,ch,len:[  2,'b',1] f.m:[  0,  1] query_ch: [b]{2,3}:1? (#-1)
#   7 s:     ist_load PC:   1=>7fffffff i,ch,len:[  2,'b',1] f.m:[  0,  1] query_ch: [b]{2,3}:1? (#-1)
#   8 s:  ist_quant_p PC:   1=>7fffffff i,ch,len:[  3,'b',1] f.m:[  0,  2] query_ch: [b]{2,3}:2? (#-1)
#   9 s:     ist_next PC: NA
#  10 PROG_END
#  11 PROG_END
```

the columns have the following meaning:

`#   2` number of actual steps from the start of parsing

`s:     ist_next` state of the present step

`PC:   1` program counter of the step

`=>7fffffff ` hex code of the instruction 

`i,ch,len:[  0,'a',1]` `i` index in the source string, `ch` the char parsed, `len` the length in byte of the char parsed

`f.m:[  0,  1]` `f` index of the first match in the source string, `m` index that is actual matching

`query_ch: [b]` token in use and its char

`{2,3}:1?` quantifier `{min,max}`, `:1` is the actual counter of repetition, `?` is the greedy off flag if present

### **Custom Logger output**

The debug functions output uses the `stdout` as default, it is possible to  provide an alternative output setting a custom output function:

```v
// custom print function, the input will be the regex debug string
fn custom_print(txt string) {
	println("my log: $txt")
}

mut re := new_regex()
re.log_func = custom_print  // every debug output from now will call this function

```

## Example code

Here there is a simple code to perform some basically match of strings

```v
struct TestObj {
	source string // source string to parse
	query  string // regex query string
	s int         // expected match start index
	e int         // expected match end index
}
const (
tests = [
	TestObj{"this is a good.",r"this (\w+) a",0,9},
	TestObj{"this,these,those. over",r"(th[eio]se?[,. ])+",0,17},
	TestObj{"test1@post.pip.com, pera",r"[\w]+@([\w]+\.)+\w+",0,18},
	TestObj{"cpapaz ole. pippo,",r".*c.+ole.*pi",0,14},
	TestObj{"adce aabe",r"(a(ab)+)|(a(dc)+)e",0,4},
]
)

fn example() {
	for c,tst in tests {
		mut re := regex.new_regex()
		re_err, err_pos := re.compile(tst.query)
		if re_err == regex.COMPILE_OK {
			
			// print the query parsed with the groups ids
			re.debug = 1 // set debug on at minimum level
			println("#${c:2d} query parsed: ${re.get_query()}")
			re.debug = 0
			
			// do the match
			start, end := re.match_string(tst.source)
			if start >= 0 && end > start {
				println("#${c:2d} found in: [$start, $end] => [${tst.source[start..end]}]")
			}	
			
			// print the groups
			mut gi := 0
			for gi < re.groups.len {
				if re.groups[gi] >= 0 {
					println("group ${gi/2:2d} :[${tst.source[re.groups[gi]..re.groups[gi+1]]}]")
				}
				gi += 2
			}		
			println("")
		} else {
			// print the compile error
			println("query: $tst.query")
			lc := "-".repeat(err_pos-1)
			println("err  : $lc^")
			err_str := re.get_parse_error_string(re_err)
			println("ERROR: $err_str")
		}
	}
}

fn main() {
	example()
}
```

more example code is available in the test code for the `regex` module `vlib\regex\regex_test.v`.

/**********************************************************************
*
* regex 0.9e
*
* Copyright (c) 2019-2020 Dario Deledda. All rights reserved.
* Use of this source code is governed by an MIT license
* that can be found in the LICENSE file.
*
* This file contains regex module
*
* Know limitation:
* - find is implemented in a trivial way
* - not full compliant PCRE
* - not compliant POSIX ERE
*
*
**********************************************************************/
module regex
import strings

pub const(
	v_regex_version = "0.9e"      // regex module version

	max_code_len     = 256        // default small base code len for the regex programs
	max_quantifier   = 1073741824 // default max repetitions allowed for the quantifiers = 2^30

	// spaces chars (here only westerns!!) TODO: manage all the spaces from unicode
	spaces = [` `, `\t`, `\n`, `\r`, `\v`, `\f`]
	// new line chars for now only '\n'
	new_line_list = [`\n`,`\r`]

	// Results
	no_match_found          = -1

	// Errors
	compile_ok              =  0   // the regex string compiled, all ok
	err_char_unknown        = -2   // the char used is unknow to the system
	err_undefined           = -3   // the compiler symbol is undefined
	err_internal_error      = -4   // Bug in the regex system!!
	err_cc_alloc_overflow   = -5   // memory for char class full!!
	err_syntax_error        = -6   // syntax error in regex compiling
	err_groups_overflow     = -7   // max number of groups reached
	err_groups_max_nested   = -8   // max number of nested group reached
	err_group_not_balanced  = -9   // group not balanced
	err_group_qm_notation   = -10  // group invalid notation
)

const(
	//*************************************
	// regex program instructions
	//*************************************
	ist_simple_char  = u32(0x7FFFFFFF)   // single char instruction, 31 bit available to char

	// char class 11 0100 AA xxxxxxxx
	// AA = 00  regular class
	// AA = 01  Negated class ^ char
	ist_char_class       = 0xD1000000   // MASK
	ist_char_class_pos   = 0xD0000000   // char class normal [abc]
	ist_char_class_neg   = 0xD1000000   // char class negate [^abc]

	// dot char        10 0110 xx xxxxxxxx
	ist_dot_char         = 0x98000000   // match any char except \n

	// backslash chars 10 0100 xx xxxxxxxx
	ist_bsls_char        = 0x90000000   // backslash char

	// OR |            10 010Y xx xxxxxxxx
	ist_or_branch        = 0x91000000   // OR case

	// groups          10 010Y xx xxxxxxxx
	ist_group_start      = 0x92000000   // group start (
	ist_group_end        = 0x94000000   // group end   )

	// control instructions
	ist_prog_end         = u32(0x88000000)      //10 0010 xx xxxxxxxx
	//*************************************
)

/******************************************************************************
*
* General Utilities
*
******************************************************************************/
// utf8util_char_len calculate the length in bytes of a utf8 char
[inline]
fn utf8util_char_len(b byte) int {
	return (( 0xe5000000 >> (( b >> 3 ) & 0x1e )) & 3 ) + 1
}

// get_char get a char from position i and return an u32 with the unicode code
[inline]
fn (re RE) get_char(in_txt string, i int) (u32,int) {
	// ascii 8 bit
	if (re.flag & f_bin) !=0 ||
		in_txt.str[i] & 0x80 == 0
	{
		return u32(in_txt.str[i]), 1
	}
	// unicode char
	char_len := utf8util_char_len(in_txt.str[i])
	mut tmp := 0
	mut ch := u32(0)
	for tmp < char_len {
		ch = (ch << 8) | in_txt.str[i+tmp]
		tmp++
	}
	return ch,char_len
}

// get_charb get a char from position i and return an u32 with the unicode code
[inline]
fn (re RE) get_charb(in_txt byteptr, i int) (u32,int) {
	// ascii 8 bit
	if (re.flag & f_bin) !=0 ||
		in_txt[i] & 0x80 == 0
	{
		return u32(in_txt[i]), 1
	}
	// unicode char
	char_len := utf8util_char_len(in_txt[i])
	mut tmp := 0
	mut ch := u32(0)
	for tmp < char_len {
		ch = (ch << 8) | in_txt[i+tmp]
		tmp++
	}
	return ch,char_len
}

[inline]
fn is_alnum(in_char byte) bool {
	mut tmp := in_char - `A`
	if tmp >= 0x00 && tmp <= 25 { return true }
	tmp = in_char - `a`
	if tmp >= 0x00 && tmp <= 25 { return true }
	tmp = in_char - `0`
	if tmp >= 0x00 && tmp <= 9  { return true }
	if tmp == `_` { return true }
	return false
}

[inline]
fn is_not_alnum(in_char byte) bool {
	return !is_alnum(in_char)
}

[inline]
fn is_space(in_char byte) bool {
	return in_char in spaces
}

[inline]
fn is_not_space(in_char byte) bool {
	return !is_space(in_char)
}

[inline]
fn is_digit(in_char byte) bool {
	tmp := in_char - `0`
	return tmp <= 0x09 && tmp >= 0
}

[inline]
fn is_not_digit(in_char byte) bool {
	return !is_digit(in_char)
}

[inline]
fn is_wordchar(in_char byte) bool {
	return is_alnum(in_char) || in_char == `_`
}

[inline]
fn is_not_wordchar(in_char byte) bool {
	return !is_alnum(in_char)
}

[inline]
fn is_lower(in_char byte) bool {
	tmp := in_char - `a`
	return  tmp >= 0x00 && tmp <= 25
}

[inline]
fn is_upper(in_char byte) bool {
	tmp := in_char - `A`
	return  tmp >= 0x00 && tmp <= 25
}

pub fn (re RE) get_parse_error_string(err int) string {
	match err {
		compile_ok             { return "compile_ok" }
		no_match_found         { return "no_match_found" }
		err_char_unknown       { return "err_char_unknown" }
		err_undefined          { return "err_undefined" }
		err_internal_error     { return "err_internal_error" }
		err_cc_alloc_overflow  { return "err_cc_alloc_overflow" }
		err_syntax_error       { return "err_syntax_error" }
		err_groups_overflow    { return "err_groups_overflow" }
		err_groups_max_nested  { return "err_groups_max_nested" }
		err_group_not_balanced { return "err_group_not_balanced" }
		err_group_qm_notation  { return "err_group_qm_notation" }
		else { return "err_unknown" }
	}
}

// utf8_str convert and utf8 sequence to a printable string
[inline]
fn utf8_str(ch u32) string {
	mut i := 4
	mut res := ""
	for i > 0 {
		v := byte((ch >> ((i-1)*8)) & 0xFF)
		if v != 0{
			res += "${v:1c}"
		}
		i--
	}
	return res
}

// simple_log default log function
fn simple_log(txt string) {
	print(txt)
}

/******************************************************************************
*
* Token Structs
*
******************************************************************************/
pub type FnValidator fn (byte) bool
struct Token{
mut:
	ist u32 = u32(0)

	// char
	ch u32                 = u32(0)  // char of the token if any
	ch_len byte            = byte(0) // char len

	// Quantifiers / branch
	rep_min         int    = 0     // used also for jump next in the OR branch [no match] pc jump
	rep_max         int    = 0     // used also for jump next in the OR branch [   match] pc jump
	greedy          bool   = false // greedy quantifier flag

	// Char class
	cc_index        int    = -1

	// counters for quantifier check (repetitions)
	rep             int    = 0

	// validator function pointer
	validator FnValidator

	// groups variables
	group_rep          int = 0     // repetition of the group
	group_id           int = -1    // id of the group
	goto_pc            int = -1    // jump to this PC if is needed

	// OR flag for the token
	next_is_or bool        = false // true if the next token is an OR
}

[inline]
fn (mut tok Token) reset() {
	tok.rep = 0
}

/******************************************************************************
*
* Regex struct
*
******************************************************************************/
pub const (
	f_nl  = 0x00000001  // end the match when find a new line symbol
	f_ms  = 0x00000002  // match true only if the match is at the start of the string
	f_me  = 0x00000004  // match true only if the match is at the end of the string

	f_efm = 0x00000100  // exit on first token matched, used by search
	f_bin = 0x00000200  // work only on bytes, ignore utf-8

	// behaviour modifier flags
	//f_or  = 0x00010000  // the OR work with concatenation like PCRE
	f_src = 0x00020000  // search mode enabled
)

struct StateDotObj{
mut:
	i  int                = -1  // char index in the input buffer
	pc int                = -1  // program counter saved
	mi int                = -1  // match_index saved
	group_stack_index int = -1  // continuous save on capturing groups
}

pub type FnLog fn (string)

pub
struct RE {
pub mut:
	prog []Token

	// char classes storage
	cc []CharClass             // char class list
	cc_index int         = 0   // index

	// state index
	state_stack_index int= -1
	state_stack []StateDotObj


	// groups
	group_count int      = 0   // number of groups in this regex struct
	groups []int               // groups index results
	group_max_nested int = 3   // max nested group
	group_max int        = 8   // max allowed number of different groups

	group_csave []int    = []int{}  // groups continuous save array
	group_csave_index int= -1       // groups continuous save index

	group_map map[string]int   // groups names map

	// flags
	flag int             = 0   // flag for optional parameters

	// Debug/log
	debug int            = 0           // enable in order to have the unroll of the code 0 = NO_DEBUG, 1 = LIGHT 2 = VERBOSE
	log_func FnLog       = simple_log  // log function, can be customized by the user
	query string         = ""          // query string
}

// Reset RE object
//[inline]
fn (mut re RE) reset(){
	re.cc_index         = 0

	mut i := 0
	for i < re.prog.len {
		re.prog[i].group_rep          = 0 // clear repetition of the group
		re.prog[i].rep                = 0 // clear repetition of the token
		i++
	}
	re.groups = [-1].repeat(re.group_count*2)

	re.state_stack_index = -1

	// reset group_csave
	if re.group_csave.len > 0 {
		re.group_csave_index = 1
		re.group_csave[0] = 0     // reset the capture count
	}
}

// reset for search mode fail
// gcc bug, dont use [inline] or go 5 time slower
fn (mut re RE) reset_src(){
	mut i := 0
	for i < re.prog.len {
		re.prog[i].group_rep          = 0 // clear repetition of the group
		re.prog[i].rep                = 0 // clear repetition of the token
		i++
	}
	re.state_stack_index = -1
}

// get_group get a group boundaries by its name
pub fn (re RE) get_group(group_name string) (int, int) {
	if group_name in re.group_map {
		tmp_index := re.group_map[group_name]-1
		start := re.groups[tmp_index*2]
		end := re.groups[tmp_index*2+1]
		return start,end
	}
	return -1, -1
}

/******************************************************************************
*
* Backslashes chars
*
******************************************************************************/
struct BslsStruct {
	ch u32                   // meta char
	validator FnValidator    // validator function pointer
}

const(
	bsls_validator_array = [
		BslsStruct{`w`, is_alnum},
		BslsStruct{`W`, is_not_alnum},
		BslsStruct{`s`, is_space},
		BslsStruct{`S`, is_not_space},
		BslsStruct{`d`, is_digit},
		BslsStruct{`D`, is_not_digit},
		BslsStruct{`a`, is_lower},
		BslsStruct{`A`, is_upper},
	]

	// these chars are escape if preceded by a \
	bsls_escape_list = [ `\\`,`|`,`.`,`*`,`+`,`-`,`{`,`}`,`[`,`]` ]
)

enum BSLS_parse_state {
		start
		bsls_found
		bsls_char
		normal_char
}

// parse_bsls return (index, str_len) bsls_validator_array index, len of the backslash sequence if present
fn (re RE) parse_bsls(in_txt string, in_i int) (int,int){
	mut status := BSLS_parse_state.start
	mut i := in_i

	for i < in_txt.len {
		// get our char
		char_tmp,char_len := re.get_char(in_txt,i)
		ch := byte(char_tmp)

		if status == .start && ch == `\\` {
			status = .bsls_found
			i += char_len
			continue
		}

		// check if is our bsls char, for now only one length sequence
		if status == .bsls_found {
			for c,x in bsls_validator_array {
				if x.ch == ch {
					return c,i-in_i+1
				}
			}
			status = .normal_char
			continue
		}

		// no BSLS validator, manage as normal escape char char
		if status == .normal_char {
			if ch in bsls_escape_list {
				return no_match_found,i-in_i+1
			}
			return err_syntax_error,i-in_i+1
		}

		// at the present time we manage only one char after the \
		break

	}
	// not our bsls return KO
	return err_syntax_error, i
}

/******************************************************************************
*
* Char class
*
******************************************************************************/
const(
	cc_null = 0    // empty cc token
	cc_char = 1    // simple char: a
	cc_int  = 2    // char interval: a-z
	cc_bsls = 3    // backslash char
	cc_end  = 4    // cc sequence terminator
)

struct CharClass {
mut:
	cc_type int = cc_null      // type of cc token
	ch0 u32     = u32(0)       // first char of the interval a-b  a in this case
	ch1 u32     = u32(0)	   // second char of the interval a-b b in this case
	validator FnValidator      // validator function pointer
}

enum CharClass_parse_state {
	start
	in_char
	in_bsls
	separator
	finish
}

fn (re RE) get_char_class(pc int) string {
	buf := [byte(0)].repeat(re.cc.len)
	mut buf_ptr := &byte(&buf)

	mut cc_i := re.prog[pc].cc_index
	mut i := 0
	mut tmp := 0
	for cc_i >= 0 && cc_i < re.cc.len && re.cc[cc_i].cc_type != cc_end {

		if re.cc[cc_i].cc_type == cc_bsls {
			buf_ptr[i++] = `\\`
			buf_ptr[i++] = byte(re.cc[cc_i].ch0)
		}
		else if re.cc[cc_i].ch0 == re.cc[cc_i].ch1 {
			tmp = 3
			for tmp >= 0 {
				x := byte((re.cc[cc_i].ch0 >> (tmp*8)) & 0xFF)
				if x != 0 {
					buf_ptr[i++] = x
				}
				tmp--
			}
		}
		else {
			tmp = 3
			for tmp >= 0 {
				x := byte((re.cc[cc_i].ch0 >> (tmp*8)) & 0xFF)
				if x != 0 {
					buf_ptr[i++] = x
				}
				tmp--
			}
			buf_ptr[i++] = `-`
			tmp = 3
			for tmp >= 0 {
				x := byte((re.cc[cc_i].ch1 >> (tmp*8)) & 0xFF)
				if x != 0 {
					buf_ptr[i++] = x
				}
				tmp--
			}
		}
		cc_i++
	}
	buf_ptr[i] = byte(0)

	return tos_clone( buf_ptr )
}

fn (re RE) check_char_class(pc int, ch u32) bool {
	mut cc_i := re.prog[pc].cc_index
	for cc_i >= 0 && cc_i < re.cc.len && re.cc[cc_i].cc_type != cc_end {
		if re.cc[cc_i].cc_type == cc_bsls {
			if re.cc[cc_i].validator(byte(ch)) {
				return true
			}
		}
		else if ch >= re.cc[cc_i].ch0 && ch <= re.cc[cc_i].ch1 {
			return true
		}
		cc_i++
	}
	return false
}

// parse_char_class return (index, str_len, cc_type) of a char class [abcm-p], char class start after the [ char
fn (mut re RE) parse_char_class(in_txt string, in_i int) (int, int, u32) {
	mut status := CharClass_parse_state.start
	mut i := in_i

	mut tmp_index := re.cc_index
	res_index := re.cc_index

	mut cc_type := u32(ist_char_class_pos)

	for i < in_txt.len {

		// check if we are out of memory for char classes
		if tmp_index >= re.cc.len {
			return err_cc_alloc_overflow,0,u32(0)
		}

		// get our char
		char_tmp,char_len := re.get_char(in_txt,i)
		ch := byte(char_tmp)

		//println("CC #${i:3d} ch: ${ch:c}")

		// negation
		if status == .start && ch == `^` {
			cc_type = u32(ist_char_class_neg)
			i += char_len
			continue
		}

		// minus symbol
		if status == .start && ch == `-` {
			re.cc[tmp_index].cc_type = cc_char
			re.cc[tmp_index].ch0     = char_tmp
			re.cc[tmp_index].ch1     = char_tmp
			i += char_len
			tmp_index++
			continue
		}

		// bsls
		if (status == .start || status == .in_char) && ch == `\\` {
			//println("CC bsls.")
			status = .in_bsls
			i += char_len
			continue
		}

		if status == .in_bsls {
			//println("CC bsls validation.")
			for c,x in bsls_validator_array {
				if x.ch == ch {
					//println("CC bsls found [${ch:c}]")
					re.cc[tmp_index].cc_type   = cc_bsls
					re.cc[tmp_index].ch0       = bsls_validator_array[c].ch
					re.cc[tmp_index].ch1       = bsls_validator_array[c].ch
					re.cc[tmp_index].validator = bsls_validator_array[c].validator
					i += char_len
					tmp_index++
					status = .in_char
					break
				}
			}
			if status == .in_bsls {
				println("CC bsls not found [${ch:c}]")
				status = .in_char
			}else {
				continue
			}
		}

		// simple char
		if (status == .start || status == .in_char) &&
			ch != `-` && ch != `]`
		{
			status = .in_char

			re.cc[tmp_index].cc_type = cc_char
			re.cc[tmp_index].ch0     = char_tmp
			re.cc[tmp_index].ch1     = char_tmp

			i += char_len
			tmp_index++
			continue
		}

		// check range separator
		if status == .in_char && ch == `-` {
			status = .separator
			i += char_len
			continue
		}

		// check range end
		if status == .separator && ch != `]` && ch != `-` {
			status = .in_char
			re.cc[tmp_index-1].cc_type = cc_int
			re.cc[tmp_index-1].ch1     = char_tmp
			i += char_len
			continue
		}

		// char class end
		if status == .in_char && ch == `]` {
			re.cc[tmp_index].cc_type = cc_end
			re.cc[tmp_index].ch0     = 0
			re.cc[tmp_index].ch1     = 0
			re.cc_index = tmp_index+1

			return res_index, i-in_i+2, cc_type
		}

		i++
	}
	return err_syntax_error,0,u32(0)
}

/******************************************************************************
*
* Re Compiler
*
******************************************************************************/
//
// Quantifier
//
enum Quant_parse_state {
	start
	min_parse
	comma_checked
	max_parse
	greedy
	gredy_parse
	finish
}

// parse_quantifier return (min, max, str_len, greedy_flag) of a {min,max}? quantifier starting after the { char
fn (re RE) parse_quantifier(in_txt string, in_i int) (int, int, int, bool) {
	mut status := Quant_parse_state.start
	mut i := in_i

	mut q_min := 0 // default min in a {} quantifier is 1
	mut q_max := 0 // deafult max in a {} quantifier is max_quantifier

	mut ch := byte(0)

	for i < in_txt.len {
		ch = in_txt.str[i]

		//println("${ch:c} status: $status")

		// exit on no compatible char with {} quantifier
		if utf8util_char_len(ch) != 1 {
			return err_syntax_error,i,0,false
		}

		// min parsing skip if comma present
		if status == .start && ch == `,` {
			q_min = 0 // default min in a {} quantifier is 0
			status = .comma_checked
			i++
			continue
		}

		if status == .start && is_digit( ch ) {
			status = .min_parse
			q_min *= 10
			q_min += int(ch - `0`)
			i++
			continue
		}

		if status == .min_parse && is_digit( ch ) {
			q_min *= 10
			q_min += int(ch - `0`)
			i++
			continue
		}

		// we have parsed the min, now check the max
		if status == .min_parse && ch == `,` {
			status = .comma_checked
			i++
			continue
		}

		// single value {4}
		if status == .min_parse && ch == `}` {
			q_max = q_min

			status = .greedy
			continue
		}

		// end without max
		if status == .comma_checked && ch == `}` {
			q_max = max_quantifier

			status = .greedy
			continue
		}

		// start max parsing
		if status == .comma_checked && is_digit( ch ) {
			status = .max_parse
			q_max *= 10
			q_max += int(ch - `0`)
			i++
			continue
		}

		// parse the max
		if status == .max_parse && is_digit( ch ) {
			q_max *= 10
			q_max += int(ch - `0`)
			i++
			continue
		}

		// finished the quantifier
		if status == .max_parse && ch == `}` {
			status = .greedy
			continue
		}

		// check if greedy flag char ? is present
		if status == .greedy {
			if i+1 < in_txt.len {
				i++
				status = .gredy_parse
				continue
			}
			return q_min, q_max, i-in_i+2, false
		}

		// check the greedy flag
		if status == .gredy_parse {
			if ch == `?` {
				return q_min, q_max, i-in_i+2, true
			} else {
				i--
				return q_min, q_max, i-in_i+2, false
			}
		}

		// not  a {} quantifier, exit
		return err_syntax_error, i, 0, false
	}

	// not a conform {} quantifier
	return err_syntax_error, i, 0, false
}

//
// Groups
//
enum Group_parse_state {
	start
	q_mark      // (?
	q_mark1     // (?:|P  checking
	p_status    // (?P
	p_start     // (?P<
	p_end       // (?P<...>
	p_in_name   // (?P<...
	finish
}

// parse_groups parse a group for ? (question mark) syntax, if found, return (error, capture_flag, name_of_the_group, next_index)
fn (re RE) parse_groups(in_txt string, in_i int) (int, bool, string, int) {
	mut status := Group_parse_state.start
	mut i := in_i
	mut name := ''

	for i < in_txt.len && status != .finish {

		// get our char
		char_tmp,char_len := re.get_char(in_txt,i)
		ch := byte(char_tmp)

		// start
		if status == .start && ch == `(` {
			status = .q_mark
			i += char_len
			continue
		}

		// check for question marks
		if status == .q_mark && ch == `?` {
			status = .q_mark1
			i += char_len
			continue
		}

		// non capturing group
		if status == .q_mark1 && ch == `:` {
			i += char_len
			return 0, false, name, i
		}

		// enter in P section
		if status == .q_mark1 && ch == `P` {
			status = .p_status
			i += char_len
			continue
		}

		// not a valid q mark found
		if status == .q_mark1 {
			//println("NO VALID Q MARK")
			return -2 , true, name, i
		}

		if status == .p_status && ch == `<` {
			status = .p_start
			i += char_len
			continue
		}

		if status == .p_start && ch != `>` {
			status = .p_in_name
			name += "${ch:1c}" // TODO: manage utf8 chars
			i += char_len
			continue
		}

		// colect name
		if status == .p_in_name && ch != `>` && is_alnum(ch) {
			name += "${ch:1c}" // TODO: manage utf8 chars
			i += char_len
			continue
		}

		// end name
		if status == .p_in_name && ch == `>` {
			i += char_len
			return 0, true, name, i
		}

		// error on name group
		if status == .p_in_name {
			return -2 , true, name, i
		}

		// normal group, nothig to do, exit
		return  0 , true, name, i
	}
	/* UNREACHABLE */
	//println("ERROR!! NOT MEANT TO BE HERE!!1")
	return -2 , true, name, i
}

//
// main compiler
//
// compile return (return code, index) where index is the index of the error in the query string if return code is an error code
pub fn (mut re RE) compile(in_txt string) (int,int) {
	mut i        := 0      // input string index
	mut pc       := 0      // program counter
	mut tmp_code := u32(0)

	// group management variables
	mut group_count           := -1
	mut group_stack           := [0 ].repeat(re.group_max_nested)
	mut group_stack_txt_index := [-1].repeat(re.group_max_nested)
	mut group_stack_index     := -1

	re.query = in_txt      // save the query string

	i = 0
	for i < in_txt.len {
		tmp_code = u32(0)
		mut char_tmp := u32(0)
		mut char_len := 0
		//println("i: ${i:3d} ch: ${in_txt.str[i]:c}")

		char_tmp,char_len = re.get_char(in_txt,i)

		//
		// check special cases: $ ^
		//
		if char_len == 1 && i == 0 && byte(char_tmp) == `^` {
			re.flag = f_ms
			i = i + char_len
			continue
		}
		if char_len == 1 && i == (in_txt.len-1) && byte(char_tmp) == `$` {
			re.flag = f_me
			i = i + char_len
			continue
		}

		// ist_group_start
		if char_len == 1 && pc >= 0 && byte(char_tmp) == `(` {

			//check max groups allowed
			if group_count > re.group_max {
				return err_groups_overflow,i+1
			}
			group_stack_index++

			// check max nested groups allowed
			if group_stack_index > re.group_max_nested {
				return err_groups_max_nested,i+1
			}

			tmp_res, cgroup_flag, cgroup_name, next_i := re.parse_groups(in_txt,i)

			// manage question mark format error
			if tmp_res < -1 {
				return err_group_qm_notation,next_i
			}

			//println("Parse group: [$tmp_res, $cgroup_flag, ($i,$next_i), '${in_txt[i..next_i]}' ]")
			i = next_i

			if cgroup_flag == true {
				group_count++
			}

			// calculate the group id
			// if it is a named group, recycle the group id
			// NOTE: **** the group index is +1 because map return 0 when not found!! ****
			mut group_id := group_count
			if cgroup_name.len > 0 {
				//println("GROUP NAME: ${cgroup_name}")
				if cgroup_name in re.group_map{
					group_id = re.group_map[cgroup_name]-1
					group_count--
				} else {
					re.group_map[cgroup_name] = group_id+1
				}
			}

			group_stack_txt_index[group_stack_index] = i
			group_stack[group_stack_index] = pc

			re.prog[pc].ist = u32(0) | ist_group_start
			re.prog[pc].rep_min = 1
			re.prog[pc].rep_max = 1

			// set the group id
			if cgroup_flag == false {
				//println("NO CAPTURE GROUP")
				re.prog[pc].group_id = -1
			} else {
				re.prog[pc].group_id = group_id
			}

			pc = pc + 1
			continue

		}

		// ist_group_end
		if char_len==1 && pc > 0 && byte(char_tmp) == `)` {
			if group_stack_index < 0 {
				return err_group_not_balanced,i+1
			}

			goto_pc := group_stack[group_stack_index]
			group_stack_index--

			re.prog[pc].ist = u32(0) | ist_group_end
			re.prog[pc].rep_min = 1
			re.prog[pc].rep_max = 1

			re.prog[pc].goto_pc = goto_pc			          // PC where to jump if a group need
			re.prog[pc].group_id = re.prog[goto_pc].group_id  // id of this group, used for storing data

			re.prog[goto_pc].goto_pc = pc                     // start goto point to the end group pc
			//re.prog[goto_pc].group_id = group_count         // id of this group, used for storing data

			pc = pc + 1
			i = i + char_len
			continue
		}

		// ist_dot_char match any char except the following token
		if char_len==1 && pc >= 0 && byte(char_tmp) == `.` {
			re.prog[pc].ist = u32(0) | ist_dot_char
			re.prog[pc].rep_min = 1
			re.prog[pc].rep_max = 1
			pc = pc + 1
			i = i + char_len
			continue
		}

		// OR branch
		if char_len==1 && pc > 0 && byte(char_tmp) == `|` {
			// two consecutive ist_dot_char are an error
			if pc > 0 && re.prog[pc-1].ist == ist_or_branch {
				return err_syntax_error,i
			}
			re.prog[pc].ist = u32(0) | ist_or_branch
			pc = pc + 1
			i = i + char_len
			continue
		}

		// Quantifiers
		if char_len==1 && pc > 0{
			mut quant_flag := true
			match byte(char_tmp) {
				`?` {
					//println("q: ${char_tmp:c}")
					re.prog[pc-1].rep_min = 0
					re.prog[pc-1].rep_max = 1
				}

				`+` {
					//println("q: ${char_tmp:c}")
					re.prog[pc-1].rep_min = 1
					re.prog[pc-1].rep_max = max_quantifier
				}

				`*` {
					//println("q: ${char_tmp:c}")
					re.prog[pc-1].rep_min = 0
					re.prog[pc-1].rep_max = max_quantifier
				}

				`{` {
					min, max, tmp, greedy := re.parse_quantifier(in_txt, i+1)
					// it is a quantifier
					if min >= 0 {
						//println("{$min,$max}\n str:[${in_txt[i..i+tmp]}] greedy:$greedy")
						i = i + tmp
						re.prog[pc-1].rep_min = min
						re.prog[pc-1].rep_max = max
						re.prog[pc-1].greedy  = greedy
						continue
					}
					else {
						return min,i
					}
					// TODO: decide if the open bracket can be conform without the close bracket
					/*
					// no conform, parse as normal char
					else {
						quant_flag = false
					}
					*/
				}
				else{
					quant_flag = false
				}
			}

			if quant_flag {
				i = i + char_len
				continue
			}
		}

		// IST_CHAR_CLASS_*
		if char_len==1 && pc >= 0{
			if byte(char_tmp) == `[` {
				cc_index,tmp,cc_type := re.parse_char_class(in_txt, i+1)
				if cc_index >= 0 {
					//println("index: $cc_index str:${in_txt[i..i+tmp]}")
					i = i + tmp
					re.prog[pc].ist      = u32(0) | cc_type
					re.prog[pc].cc_index = cc_index
					re.prog[pc].rep_min  = 1
					re.prog[pc].rep_max  = 1
					pc = pc + 1
					continue
				}

				// cc_class vector memory full
				else if cc_index < 0 {
					return cc_index, i
				}
			}
		}

		// ist_bsls_char
		if char_len==1 && pc >= 0{
			if byte(char_tmp) == `\\` {
				bsls_index,tmp := re.parse_bsls(in_txt,i)
				//println("index: $bsls_index str:${in_txt[i..i+tmp]}")
				if bsls_index >= 0 {
					i = i + tmp
					re.prog[pc].ist       = u32(0) | ist_bsls_char
					re.prog[pc].rep_min   = 1
					re.prog[pc].rep_max   = 1
					re.prog[pc].validator = bsls_validator_array[bsls_index].validator
					re.prog[pc].ch      = bsls_validator_array[bsls_index].ch
					pc = pc + 1
					continue
				}
				// this is an escape char, skip the bsls and continue as a normal char
				else if bsls_index == no_match_found {
					i += char_len
					char_tmp,char_len = re.get_char(in_txt,i)
					// continue as simple char
				}
				// if not an escape or a bsls char then it is an error (at least for now!)
				else {
					return bsls_index,i+tmp
				}
			}
		}

		// ist_simple_char
		re.prog[pc].ist     = ist_simple_char
		re.prog[pc].ch      = char_tmp
		re.prog[pc].ch_len  = byte(char_len)
		re.prog[pc].rep_min = 1
		re.prog[pc].rep_max = 1
		//println("char: ${char_tmp:c}")
		pc = pc +1

		i+=char_len
	}

	// add end of the program
	re.prog[pc].ist = ist_prog_end

	// check for unbalanced groups
	if group_stack_index != -1 {
		return err_group_not_balanced, group_stack_txt_index[group_stack_index]+1
	}

	// check for OR at the end of the program
	if pc > 0 && re.prog[pc-1].ist == ist_or_branch {
		return err_syntax_error,in_txt.len
	}

	// store the number of groups in the query
	re.group_count = group_count+1

	//******************************************
	// Post processing
	//******************************************

	// count ist_dot_char to set the size of the state stack
	mut pc1 := 0
	mut tmp_count := 0
	for pc1 < pc {
		if re.prog[pc1].ist == ist_dot_char {
			tmp_count++
		}
		pc1++
	}

	// init the state stack
	re.state_stack = [StateDotObj{}].repeat(tmp_count+1)

	// OR branch
	// a|b|cd
	// d exit point
	// a,b,c branches
	// set the jump in the right places
	pc1 = 0
	for pc1 < pc-2 {
		// two consecutive OR are a syntax error
		if re.prog[pc1+1].ist == ist_or_branch && re.prog[pc1+2].ist == ist_or_branch {
			return err_syntax_error, i
		}

		// manange a|b chains like a|(b)|c|d...
		// standard solution
		if re.prog[pc1].ist != ist_or_branch &&
			re.prog[pc1+1].ist == ist_or_branch &&
			re.prog[pc1+2].ist != ist_or_branch
		{
			re.prog[pc1].next_is_or = true   // set that the next token is an  OR
			re.prog[pc1+1].rep_min = pc1+2   // failed match jump

			// match jump, if an OR chain the next token will be an OR token
			mut pc2 := pc1+2
			for pc2 < pc-1 {
				ist := re.prog[pc2].ist
				if  ist == ist_group_start {
					re.prog[pc1+1].rep_max = re.prog[pc2].goto_pc + 1
					break
				}
				if ist != ist_or_branch {
					re.prog[pc1+1].rep_max = pc2 + 1
					break
				}
				pc2++
			}
			//println("Compile OR postproc. [$pc1,OR ${pc1+1},$pc2]")
			pc1 = pc2
			continue
		}

		pc1++
	}

	//******************************************
	// DEBUG PRINT REGEX GENERATED CODE
	//******************************************
	if re.debug > 0 {
		gc := re.get_code()
		re.log_func( gc )
	}
	//******************************************

	return compile_ok, 0
}

// get_code return the compiled code as regex string, note: may be different from the source!
pub fn (re RE) get_code() string {
		mut pc1 := 0
		mut res := strings.new_builder(re.cc.len*2*re.prog.len)
		res.write("========================================\nv RegEx compiler v $v_regex_version output:\n")

		mut stop_flag := false

		for pc1 <= re.prog.len {
			tk := re.prog[pc1]
			res.write("PC:${pc1:3d}")

		    res.write(" ist: ")
		    res.write("${tk.ist:8x}".replace(" ","0") )
		    res.write(" ")
			ist :=tk.ist
			if ist == ist_bsls_char {
				res.write("[\\${tk.ch:1c}]     BSLS")
			} else if ist == ist_prog_end {
				res.write("PROG_END")
				stop_flag = true
			} else if ist == ist_or_branch {
				res.write("OR      ")
			} else if ist == ist_char_class_pos {
				res.write("[${re.get_char_class(pc1)}]     CHAR_CLASS_POS")
			} else if ist == ist_char_class_neg {
				res.write("[^${re.get_char_class(pc1)}]    CHAR_CLASS_NEG")
			} else if ist == ist_dot_char {
				res.write(".        DOT_CHAR")
			} else if ist == ist_group_start {
				res.write("(        GROUP_START #:${tk.group_id}")
				if tk.group_id == -1 {
					res.write(" ?:")
				} else {
					for x in re.group_map.keys() {
						if re.group_map[x] == (tk.group_id+1) {
							res.write(" ?P<${x}>")
							break
						}
					}
				}
			} else if ist == ist_group_end {
				res.write(")        GROUP_END   #:${tk.group_id}")
			} else if ist == ist_simple_char {
				res.write("[${tk.ch:1c}]      query_ch")
			}

			if tk.rep_max == max_quantifier {
				res.write(" {${tk.rep_min:3d},MAX}")
			}else{
				if ist == ist_or_branch {
					res.write(" if false go: ${tk.rep_min:3d} if true go: ${tk.rep_max:3d}")
				} else {
					res.write(" {${tk.rep_min:3d},${tk.rep_max:3d}}")
				}
				if tk.greedy == true {
					res.write("?")
				}
			}
			res.write("\n")
			if stop_flag {
				break
			}
			pc1++
		}

		res.write("========================================\n")
		return res.str()
}

// get_query return a string with a reconstruction of the query starting from the regex program code
pub fn (re RE) get_query() string {
	mut res := strings.new_builder(re.query.len*2)

	if (re.flag & f_ms) != 0 {
		res.write("^")
	}

	mut i := 0
	for i < re.prog.len && re.prog[i].ist != ist_prog_end && re.prog[i].ist != 0{
		tk := &re.prog[i]
		ch := tk.ist

		// GROUP start
		if ch == ist_group_start {
			if re.debug == 0 {
				res.write("(")
			} else {
				if tk.group_id == -1 {
					res.write("(?:")   // non capturing group
				} else {
					res.write("#${tk.group_id}(")
				}
			}

			for x in re.group_map.keys() {
				if re.group_map[x] == (tk.group_id+1) {
					res.write("?P<${x}>")
					break
				}
			}

			i++
			continue
		}

		// GROUP end
		if ch == ist_group_end {
			res.write(")")
		}

		// OR branch
		if ch == ist_or_branch {
			res.write("|")
			if re.debug > 0 {
				res.write("{${tk.rep_min},${tk.rep_max}}")
			}
			i++
			continue
		}

		// char class
		if ch == ist_char_class_neg || ch == ist_char_class_pos {
			res.write("[")
			if ch == ist_char_class_neg {
				res.write("^")
			}
			res.write("${re.get_char_class(i)}")
			res.write("]")
		}

		// bsls char
		if ch == ist_bsls_char {
			res.write("\\${tk.ch:1c}")
		}

		// ist_dot_char
		if ch == ist_dot_char {
			res.write(".")
		}

		// char alone
		if ch == ist_simple_char {
			if byte(ch) in bsls_escape_list {
				res.write("\\")
			}
			res.write("${tk.ch:c}")
		}

		// quantifier
		if !(tk.rep_min == 1 && tk.rep_max == 1) {
			if tk.rep_min == 0 && tk.rep_max == 1 {
				res.write("?")
			} else if tk.rep_min == 1 && tk.rep_max == max_quantifier {
				res.write("+")
			} else if tk.rep_min == 0 && tk.rep_max == max_quantifier {
				res.write("*")
			} else {
				if tk.rep_max == max_quantifier {
					res.write("{${tk.rep_min},MAX}")
				} else {
					res.write("{${tk.rep_min},${tk.rep_max}}")
				}
				if tk.greedy == true {
					res.write("?")
				}
			}
		}
		i++
	}
	if (re.flag & f_me) != 0 {
		res.write("$")
	}

	return res.str()
}

/******************************************************************************
*
* Matching
*
******************************************************************************/
enum Match_state{
	start = 0
	stop
	end
	new_line

	ist_load     // load and execute instruction
	ist_next     // go to next instruction
	ist_next_ks  // go to next instruction without clenaning the state
	ist_quant_p  // match positive ,quantifier check
	ist_quant_n  // match negative, quantifier check
	ist_quant_pg // match positive ,group quantifier check
	ist_quant_ng // match negative ,group quantifier check
}

fn state_str(s Match_state) string {
	match s{
		.start        { return "start" }
		.stop         { return "stop" }
		.end          { return "end" }
		.new_line     { return "new line" }

		.ist_load     { return "ist_load" }
		.ist_next     { return "ist_next" }
		.ist_next_ks  { return "ist_next_ks" }
		.ist_quant_p  { return "ist_quant_p" }
		.ist_quant_n  { return "ist_quant_n" }
		.ist_quant_pg { return "ist_quant_pg" }
		.ist_quant_ng { return "ist_quant_ng" }
	}
}

struct StateObj {
pub mut:
	match_flag bool = false
	match_index int = -1
	match_first int = -1
}

pub fn (mut re RE) match_base(in_txt byteptr, in_txt_len int ) (int,int) {
	// result status
	mut result := no_match_found     // function return
	mut first_match := -1             //index of the first match

	mut i := 0                       // source string index
	mut ch := u32(0)                 // examinated char
	mut char_len := 0                // utf8 examinated char len
	mut m_state := Match_state.start // start point for the matcher FSM

	mut pc := -1                     // program counter
	mut state := StateObj{}          // actual state
	mut ist := u32(0)                // actual instruction
	mut l_ist := u32(0)              // last matched instruction

	mut group_stack      := [-1].repeat(re.group_max)
	mut group_data       := [-1].repeat(re.group_max)

	mut group_index := -1            // group id used to know how many groups are open

	mut step_count := 0              // stats for debug
	mut dbg_line   := 0              // count debug line printed

	re.reset()

	if re.debug>0 {
		// print header
		mut h_buf := strings.new_builder(32)
		h_buf.write("flags: ")
		h_buf.write("${re.flag:8x}".replace(" ","0"))
		h_buf.write("\n")
		sss := h_buf.str()
		re.log_func(sss)
	}

	for m_state != .end {

		if pc >= 0 && pc < re.prog.len {
			ist = re.prog[pc].ist
		}else if pc >= re.prog.len {
			//println("ERROR!! PC overflow!!")
			return err_internal_error, i
		}

		//******************************************
		// DEBUG LOG
		//******************************************
		if re.debug>0 {
			mut buf2 := strings.new_builder(re.cc.len+128)

			// print all the instructions

			// end of the input text
			if i >= in_txt_len {
				buf2.write("# ${step_count:3d} END OF INPUT TEXT\n")
				sss := buf2.str()
				re.log_func(sss)
			}else{

				// print only the exe instruction
				if (re.debug == 1 && m_state == .ist_load) ||
					re.debug == 2
				{
					if ist == ist_prog_end {
						buf2.write("# ${step_count:3d} PROG_END\n")
					}
					else if ist == 0 || m_state in [.start,.ist_next,.stop] {
						buf2.write("# ${step_count:3d} s: ${state_str(m_state):12s} PC: NA\n")
					}else{
						ch, char_len = re.get_charb(in_txt,i)

						buf2.write("# ${step_count:3d} s: ${state_str(m_state):12s} PC: ${pc:3d}=>")
						buf2.write("${ist:8x}".replace(" ","0"))
						buf2.write(" i,ch,len:[${i:3d},'${utf8_str(ch)}',${char_len}] f.m:[${first_match:3d},${state.match_index:3d}] ")

						if ist == ist_simple_char {
							buf2.write("query_ch: [${re.prog[pc].ch:1c}]")
						} else {
							if ist == ist_bsls_char {
								buf2.write("BSLS [\\${re.prog[pc].ch:1c}]")
							} else if ist == ist_prog_end {
								buf2.write("PROG_END")
							} else if ist == ist_or_branch {
								buf2.write("OR")
							} else if ist == ist_char_class_pos {
								buf2.write("CHAR_CLASS_POS[${re.get_char_class(pc)}]")
							} else if ist == ist_char_class_neg {
								buf2.write("CHAR_CLASS_NEG[${re.get_char_class(pc)}]")
							} else if ist == ist_dot_char {
								buf2.write("DOT_CHAR")
							} else if ist == ist_group_start {
								tmp_gi :=re.prog[pc].group_id
								tmp_gr := re.prog[re.prog[pc].goto_pc].group_rep
								buf2.write("GROUP_START #:${tmp_gi} rep:${tmp_gr} ")
							} else if ist == ist_group_end {
								buf2.write("GROUP_END   #:${re.prog[pc].group_id} deep:${group_index}")
							}
						}
						if re.prog[pc].rep_max == max_quantifier {
							buf2.write("{${re.prog[pc].rep_min},MAX}:${re.prog[pc].rep}")
						} else {
							buf2.write("{${re.prog[pc].rep_min},${re.prog[pc].rep_max}}:${re.prog[pc].rep}")
						}
						if re.prog[pc].greedy == true {
							buf2.write("?")
						}
						buf2.write(" (#${group_index})\n")
					}
					sss2 := buf2.str()
					re.log_func( sss2 )
				}
			}
			step_count++
			dbg_line++
		}
		//******************************************

		// we're out of text, manage it
		if i >= in_txt_len || m_state == .new_line {

			// manage groups
			if group_index >= 0 && state.match_index >= 0 {
				//println("End text with open groups!")
				// close the groups
				for group_index >= 0 {
					tmp_pc := group_data[group_index]
					re.prog[tmp_pc].group_rep++
					//println("Closing group $group_index {${re.prog[tmp_pc].rep_min},${re.prog[tmp_pc].rep_max}}:${re.prog[tmp_pc].group_rep}")

					if re.prog[tmp_pc].group_rep >= re.prog[tmp_pc].rep_min && re.prog[tmp_pc].group_id >= 0{
						start_i   := group_stack[group_index]
	 					group_stack[group_index]=-1

	 					// save group results
						g_index := re.prog[tmp_pc].group_id*2
						if start_i >= 0 {
							re.groups[g_index] = start_i
						} else {
							re.groups[g_index] = 0
						}
						re.groups[g_index+1] = i

						// continuous save, save until we have space
						if re.group_csave_index > 0 {
							// check if we have space to save the record
							if (re.group_csave_index + 3) < re.group_csave.len {
								// incrment counter
								re.group_csave[0]++
								// save the record
								re.group_csave[re.group_csave_index++] = g_index >> 1          // group id
								re.group_csave[re.group_csave_index++] = re.groups[g_index]    // start
								re.group_csave[re.group_csave_index++] = re.groups[g_index+1]  // end
							}
						}

 					}

					group_index--
				}
			}

			// manage ist_dot_char

			m_state == .end
			break
			//return no_match_found,0
		}

		// starting and init
		if m_state == .start {
			pc = -1
			i = 0
			m_state = .ist_next
			continue
		}

		// ist_next, next instruction reseting its state
		if m_state == .ist_next {
			pc = pc + 1
			re.prog[pc].reset()
			// check if we are in the program bounds
			if pc < 0 || pc > re.prog.len {
				//println("ERROR!! PC overflow!!")
				return err_internal_error, i
			}
			m_state = .ist_load
			continue
		}

		// ist_next_ks, next instruction keeping its state
		if m_state == .ist_next_ks {
			pc = pc + 1
			// check if we are in the program bounds
			if pc < 0 || pc > re.prog.len {
				//println("ERROR!! PC overflow!!")
				return err_internal_error, i
			}
			m_state = .ist_load
			continue
		}

		// load the char
		ch, char_len = re.get_charb(in_txt,i)

		// check new line if flag f_nl enabled
		if (re.flag & f_nl) != 0 && char_len == 1 && byte(ch) in new_line_list {
			m_state = .new_line
			continue
		}

		// check if stop
		if m_state == .stop {

			// we are in search mode, don't exit until the end
			if re.flag & f_src != 0 && ist != ist_prog_end {
				pc = -1
				i += char_len
				m_state = .ist_next
				re.reset_src()
				state.match_index = -1
				first_match = -1
				continue
			}

			// if we are in restore state ,do it and restart
			//println("re.state_stack_index ${re.state_stack_index}")
			if re.state_stack_index >=0 && re.state_stack[re.state_stack_index].pc >= 0 {
				i = re.state_stack[re.state_stack_index].i
				pc = re.state_stack[re.state_stack_index].pc
				state.match_index =	re.state_stack[re.state_stack_index].mi
				group_index = re.state_stack[re.state_stack_index].group_stack_index

				m_state = .ist_load
				continue
			}

			if ist == ist_prog_end {
				return first_match,i
			}

			// exit on no match
			return result,0
		}

		// ist_load
		if m_state == .ist_load {

			// program end
			if ist == ist_prog_end {
				// if we are in match exit well

				if group_index >= 0 && state.match_index >= 0 {
					group_index = -1
				}

				// we have a DOT MATCH on going
				//println("ist_prog_end l_ist: ${l_ist:08x}", l_ist)
				if re.state_stack_index>=0 && l_ist == ist_dot_char {
					m_state = .stop
					continue
				}

				re.state_stack_index = -1
				m_state = .stop
				continue

			}

			// check GROUP start, no quantifier is checkd for this token!!
			else if ist == ist_group_start {
				group_index++
				group_data[group_index] = re.prog[pc].goto_pc  // save where is ist_group_end, we will use it for escape
				group_stack[group_index]=i                     // index where we start to manage
				//println("group_index $group_index rep ${re.prog[re.prog[pc].goto_pc].group_rep}")

				m_state = .ist_next
				continue
			}

			// check GROUP end
			else if ist == ist_group_end {
				// we are in matching streak
				if state.match_index >= 0 {
					// restore txt index stack and save the group data

					//println("g.id: ${re.prog[pc].group_id} group_index: ${group_index}")
					if group_index >= 0 && re.prog[pc].group_id >= 0 {
	 					start_i   := group_stack[group_index]
	 					//group_stack[group_index]=-1

	 					// save group results
						g_index := re.prog[pc].group_id*2
						if start_i >= 0 {
							re.groups[g_index] = start_i
						} else {
							re.groups[g_index] = 0
						}
						re.groups[g_index+1] = i
						//println("GROUP ${re.prog[pc].group_id} END [${re.groups[g_index]}, ${re.groups[g_index+1]}]")

						// continuous save, save until we have space
						if re.group_csave_index > 0 {
							// check if we have space to save the record
							if (re.group_csave_index + 3) < re.group_csave.len {
								// incrment counter
								re.group_csave[0]++
								// save the record
								re.group_csave[re.group_csave_index++] = g_index >> 1          // group id
								re.group_csave[re.group_csave_index++] = re.groups[g_index]    // start
								re.group_csave[re.group_csave_index++] = re.groups[g_index+1]  // end
							}
						}
					}

					re.prog[pc].group_rep++ // increase repetitions
					//println("GROUP $group_index END ${re.prog[pc].group_rep}")
					m_state = .ist_quant_pg
					continue

				}

				m_state = .ist_quant_ng
				continue
			}

			// check OR
			else if ist == ist_or_branch {
				if state.match_index >= 0 {
					pc = re.prog[pc].rep_max
					//println("ist_or_branch True pc: $pc")
				}else{
					pc = re.prog[pc].rep_min
					//println("ist_or_branch False pc: $pc")
				}
				re.prog[pc].reset()
				m_state == .ist_load
				continue
			}

			// check ist_dot_char
			else if ist == ist_dot_char {
				//println("ist_dot_char rep: ${re.prog[pc].rep}")
				state.match_flag = true
				l_ist = u32(ist_dot_char)

				if first_match < 0 {
					first_match = i
				}
				state.match_index = i
				re.prog[pc].rep++

				//if re.prog[pc].rep >= re.prog[pc].rep_min && re.prog[pc].rep <= re.prog[pc].rep_max {
				if re.prog[pc].rep >= 0 && re.prog[pc].rep <= re.prog[pc].rep_max {
					//println("DOT CHAR save state : ${re.state_stack_index}")
					// save the state

					// manage first dot char
					if re.state_stack_index < 0 {
						re.state_stack_index++
					}

					re.state_stack[re.state_stack_index].pc = pc
					re.state_stack[re.state_stack_index].mi = state.match_index
					re.state_stack[re.state_stack_index].group_stack_index = group_index
				} else {
					re.state_stack[re.state_stack_index].pc = -1
					re.state_stack[re.state_stack_index].mi = -1
					re.state_stack[re.state_stack_index].group_stack_index = -1
				}

				if re.prog[pc].rep >= 1 && re.state_stack_index >= 0 {
					re.state_stack[re.state_stack_index].i  = i + char_len
				}

				// manage * and {0,} quantifier
				if re.prog[pc].rep_min > 0 {
					i += char_len // next char
					l_ist = u32(ist_dot_char)
				}

				m_state = .ist_next
				continue

			}

			// char class IST
			else if ist == ist_char_class_pos || ist == ist_char_class_neg {
				state.match_flag = false
				mut cc_neg := false

				if ist == ist_char_class_neg {
					cc_neg = true
				}
				mut cc_res := re.check_char_class(pc,ch)

				if cc_neg {
					cc_res = !cc_res
				}

				if cc_res {
					state.match_flag = true
					l_ist = u32(ist_char_class_pos)

					if first_match < 0 {
						first_match = i
					}

					state.match_index = i

					re.prog[pc].rep++ // increase repetitions
					i += char_len // next char
					m_state = .ist_quant_p
					continue
				}
				m_state = .ist_quant_n
				continue
			}

			// check bsls
			else if ist == ist_bsls_char {
				state.match_flag = false
				tmp_res := re.prog[pc].validator(byte(ch))
				//println("BSLS in_ch: ${ch:c} res: $tmp_res")
				if tmp_res {
					state.match_flag = true
					l_ist = u32(ist_bsls_char)

					if first_match < 0 {
						first_match = i
					}

					state.match_index = i

					re.prog[pc].rep++ // increase repetitions
					i += char_len // next char
					m_state = .ist_quant_p
					continue
				}
				m_state = .ist_quant_n
				continue
			}

			// simple char IST
			else if ist == ist_simple_char {
				//println("ist_simple_char")
				state.match_flag = false

				if re.prog[pc].ch == ch
				{
					state.match_flag = true
					l_ist = ist_simple_char

					if first_match < 0 {
						first_match = i
					}
					//println("state.match_index: ${state.match_index}")
					state.match_index = i

					re.prog[pc].rep++ // increase repetitions
					i += char_len // next char
					m_state = .ist_quant_p
					continue
				}
				m_state = .ist_quant_n
				continue
			}
			/* UNREACHABLE */
			//println("PANIC2!! state: $m_state")
			return err_internal_error, i

		}

		/***********************************
		* Quantifier management
		***********************************/
		// ist_quant_ng
		if m_state == .ist_quant_ng {

			// we are finished here
			if group_index < 0 {
				//println("Early stop!")
				result = no_match_found
				m_state = .stop
				continue
			}

			tmp_pc := group_data[group_index]    // PC to the end of the group token
			rep    := re.prog[tmp_pc].group_rep  // use a temp variable
			re.prog[tmp_pc].group_rep = 0        // clear the repetitions

			//println(".ist_quant_ng group_pc_end: $tmp_pc rep: $rep")

			if rep >= re.prog[tmp_pc].rep_min {
				//println("ist_quant_ng GROUP CLOSED OK group_index: $group_index")

				i = group_stack[group_index]
				pc = tmp_pc
				group_index--
				m_state = .ist_next
				continue
			}
			else if re.prog[tmp_pc].next_is_or {
				//println("ist_quant_ng OR Negative branch")

				i = group_stack[group_index]
				pc = re.prog[tmp_pc+1].rep_min -1
				group_index--
				m_state = .ist_next
				continue
			}
			else if rep>0 && rep < re.prog[tmp_pc].rep_min {
				//println("ist_quant_ng UNDER THE MINIMUM g.i: $group_index")

				// check if we are inside a group, if yes exit from the nested groups
				if group_index > 0{
					group_index--
					pc = tmp_pc
					m_state = .ist_quant_ng //.ist_next
					continue
				}

				if group_index == 0 {
					group_index--
					pc = tmp_pc // TEST
					m_state = .ist_next
					continue
				}

				result = no_match_found
				m_state = .stop
				continue
			}
			else if rep==0 && rep < re.prog[tmp_pc].rep_min {
				//println("ist_quant_ng c_zero UNDER THE MINIMUM g.i: $group_index")

				if group_index > 0{
					group_index--
					pc = tmp_pc
					m_state = .ist_quant_ng //.ist_next
					continue
				}

				result = no_match_found
				m_state = .stop
				continue
			}

			//println("DO NOT STAY HERE!! {${re.prog[tmp_pc].rep_min},${re.prog[tmp_pc].rep_max}}:$rep")
			/* UNREACHABLE */
			return err_internal_error, i

		}
		// ist_quant_pg
		else if m_state == .ist_quant_pg {
			//println(".ist_quant_pg")
			mut tmp_pc := pc
			if group_index >= 0 {
				tmp_pc = group_data[group_index]
			}

			rep := re.prog[tmp_pc].group_rep

			if rep < re.prog[tmp_pc].rep_min {
				//println("ist_quant_pg UNDER RANGE")
				pc = re.prog[tmp_pc].goto_pc
				m_state = .ist_next
				continue
			}
			else if rep == re.prog[tmp_pc].rep_max {
				//println("ist_quant_pg MAX RANGE")
				re.prog[tmp_pc].group_rep = 0 // clear the repetitions
				group_index--
				m_state = .ist_next
				continue
			}
			else if rep >= re.prog[tmp_pc].rep_min {
				//println("ist_quant_pg IN RANGE group_index:$group_index")

				// check greedy flag, if true exit on minimum
				if re.prog[tmp_pc].greedy == true {
					re.prog[tmp_pc].group_rep = 0 // clear the repetitions
					group_index--
					m_state = .ist_next
					continue
				}

				pc = re.prog[tmp_pc].goto_pc - 1
				group_index--
				m_state = .ist_next
				continue
			}

			/* UNREACHABLE */
			//println("PANIC3!! state: $m_state")
			return err_internal_error, i
		}

		// ist_quant_n
		else if m_state == .ist_quant_n {
			rep := re.prog[pc].rep
			//println("Here!! PC $pc is_next_or: ${re.prog[pc].next_is_or}")

			// zero quantifier * or ?
			if rep == 0 && re.prog[pc].rep_min == 0 {
				//println("ist_quant_n c_zero RANGE MIN")
				m_state = .ist_next // go to next ist
				continue
			}
			// match + or *
			else if rep >= re.prog[pc].rep_min {
				//println("ist_quant_n MATCH RANGE")
				m_state = .ist_next
				continue
			}

			// check the OR if present
			if re.prog[pc].next_is_or {
				//println("OR present on failing")
				state.match_index = -1
				m_state = .ist_next
				continue
			}

			// we are in a group manage no match from here
			if group_index >= 0 {
				//println("ist_quant_n FAILED insied a GROUP group_index:$group_index")
				m_state = .ist_quant_ng
				continue
			}

			// no other options
			//println("ist_quant_n no_match_found")
			result = no_match_found
			m_state = .stop
			continue
			//return no_match_found, 0
		}

		// ist_quant_p
		else if m_state == .ist_quant_p {
			// exit on first match
			if (re.flag & f_efm) != 0 {
				return i,i+1
			}

			rep := re.prog[pc].rep

			// under range
			if rep > 0 && rep < re.prog[pc].rep_min {
				//println("ist_quant_p UNDER RANGE")
				m_state = .ist_load // continue the loop
				continue
			}

			// range ok, continue loop
			else if rep >= re.prog[pc].rep_min && rep < re.prog[pc].rep_max {
				//println("ist_quant_p IN RANGE")

				// check greedy flag, if true exit on minimum
				if re.prog[pc].greedy == true {
					m_state = .ist_next
					continue
				}
				m_state = .ist_load
				continue
			}

			// max reached
			else if rep == re.prog[pc].rep_max {
				//println("ist_quant_p MAX RANGE")
				m_state = .ist_next
				continue
			}

		}
		/* UNREACHABLE */
		//println("PANIC4!! state: $m_state")
		return err_internal_error, i
	}

	// Check the results
	if state.match_index >= 0 {
		if group_index < 0 {
			//println("OK match,natural end [$first_match,$i]")
			return first_match, i
		} else {
			//println("Skip last group")
			return first_match,group_stack[group_index--]
		}
	}
	//println("no_match_found, natural end")
	return no_match_found, 0
}

/******************************************************************************
*
* Public functions
*
******************************************************************************/

//
// Inits
//

// regex create a regex object from the query string
pub fn regex(in_query string) (RE,int,int){
	mut re := RE{}
	re.prog = [Token{}].repeat(in_query.len+1)
	re.cc = [CharClass{}].repeat(in_query.len+1)
	re.group_max_nested = 8

	re_err,err_pos := re.compile(in_query)
	return re, re_err, err_pos
}

// new_regex create a RE of small size, usually sufficient for ordinary use
pub fn new_regex() RE {
	return new_regex_by_size(1)
}

// new_regex_by_size create a RE of large size, mult specify the scale factor of the memory that will be allocated
pub fn new_regex_by_size(mult int) RE {
	mut re := RE{}
	re.prog = [Token{}].repeat(max_code_len*mult)       // max program length, default 256 istructions
	re.cc = [CharClass{}].repeat(max_code_len*mult)     // char class list
	re.group_max_nested = 3*mult                        // max nested group

	return re
}

//
// Matchers
//

pub fn (mut re RE) match_string(in_txt string) (int,int) {
	start, end := re.match_base(in_txt.str,in_txt.len)
	if start >= 0 && end > start {
		if (re.flag & f_ms) != 0 && start > 0 {
			return no_match_found, 0
		}
		if (re.flag & f_me) != 0 && end < in_txt.len {
			if in_txt[end] in new_line_list {
				return start, end
			}
			return no_match_found, 0
		}
		return start, end
	}
	return start, end
}

//
// Finders
//

// find try to find the first match in the input string
pub fn (mut re RE) find(in_txt string) (int,int) {
	old_flag := re.flag
	re.flag |= f_src  // enable search mode
	start, end := re.match_base(in_txt.str, in_txt.len)
	re.flag = old_flag
	if start >= 0 && end > start {
		return start,end
	}
	return no_match_found, 0
}

// find all the non overlapping occurrences of the match pattern
pub fn (mut re RE) find_all(in_txt string) []int {
	mut i := 0
	mut res := []int{}
	mut ls := -1
	for i < in_txt.len {
		s,e := re.find(in_txt[i..])
		if s >= 0 && e > s && i+s > ls {
			//println("find match in: ${i+s},${i+e} [${in_txt[i+s..i+e]}] ls:$ls")
			res << i+s
			res << i+e
			ls = i+s
			i = i+e
			continue
		} else {
			i++
		}

	}
	return res
}

// replace return a string where the matches are replaced with the replace string
pub fn (mut re RE) replace(in_txt string, repl string) string {
	pos := re.find_all(in_txt)
	if pos.len > 0 {
		mut res := ""
		mut i := 0

		mut s1 := 0
		mut e1 := in_txt.len

		for i < pos.len {
			e1 = pos[i]
			res += in_txt[s1..e1] + repl
			s1 = pos[i+1]
			i += 2
		}

		res += in_txt[s1..]
		return res
	}
	return in_txt
}
import regex

/******************************************************************************
*
* Test section
*
******************************************************************************/
struct TestItem {
	src string
	q string
	s int = 0
	e int = 0
}

const(
match_test_suite = [

	// positive
	TestItem{"this is a good.",r"this",0,4},
	TestItem{"this is a good.",r"good",10,14},
	TestItem{"this is a good.",r"go+d",10,14},
	TestItem{"this is a good.",r"g[oae]+d",10,14},
	TestItem{"this is a goed.",r"g[oae]+d",10,14},
	TestItem{"this is a good.",r"g[oae]*d",10,14},
	TestItem{"this is a goaezd.",r"g[ea-cm-z]*d",10,16},
	TestItem{"this is a good.",r"this (\w+) a",0,9},
	TestItem{"this is a good.",r"this( \w+){2} g",0,11},
	TestItem{"this is a good.",r"( ?\w+){,1}",0,4},
	TestItem{"this is a good.",r"( ?\w+)+",0,14},
	TestItem{"this is a good.",r"this( \w+)+",0,14},
	TestItem{"this is a good sample.",r"( ?\w+){,2}",0,7},
	TestItem{"this is a good sample.",r"( ?\w+){,3}",0,9},
	TestItem{"this is a good sample.",r"( ?\w+){,4}",0,14},
	TestItem{"this is a good sample.",r"( ?\w+){,5}",0,21},
	TestItem{"this is a good sample.",r"( ?\w+){2,3}",0,9},
	TestItem{"this is a good sample.",r"(\s?\w+){2,3}",0,9},
	TestItem{"this these those.",r"(th[ei]se?\s|\.)+",0,11},
	TestItem{"this these those ",r"(th[eio]se? ?)+",0,17},
	TestItem{"this these those ",r"(th[eio]se? )+",0,17},
	TestItem{"this,these,those. over",r"(th[eio]se?[,. ])+",0,17},
	TestItem{"soday,this,these,those. over",r"(th[eio]se?[,. ])+",6,23},

	TestItem{"cpapaz",r"(c(pa)+z)",0,6},
	TestItem{"this is a cpapaz over",r"(c(pa)+z)",10,16},
	TestItem{"this is a cpapapez over",r"(c(p[ae])+z)",10,18},
	TestItem{"test@post.pip.com",r"[a-z0-9_]+@([a-z0-9_]+\.?)+",0,17},
	TestItem{"test1@post.pip.com, pera",r"[\w]+@([\w]+\.)+\w+",0,18},
	TestItem{"pippo@pera.com ",r"[a-z0-9_]+@([a-z0-9_]+\.?)+",0,14},
	TestItem{"adce aabe",r"(a(ab)+)|(a(dc)+)e",0,4},
	TestItem{"zadce aabe",r"(a(ab)+)|(a(dc)+)e",1,5},
	TestItem{"abbz accz addz.",r"c|(d)|e|(ab+)",0,3},
	TestItem{"this those these ciao",r"((t[hieo]+se?)\s*)+",0,17},
	TestItem{"this ciao",r"((t[hieo]+se?)\s*)+",0,5},
	TestItem{"this cpapaz adce aabe",r"(c(pa)+z)(\s[\a]+){2}",5,21},
	TestItem{"1234this cpapaz adce aabe",r"(c(pa)+z)(\s[\a]+){2}$",9,25},
	TestItem{"this cpapaz adce aabe third",r"(c(pa)+z)(\s[\a]+){2}",5,21},
	TestItem{"123cpapaz ole. pippo",r"(c(pa)+z)(\s+\a+[\.,]?)+",3,20},

	TestItem{"this is a good sample.",r".*i(\w)+",0,4},
	TestItem{"soday,this,these,those. over",r".*,(th[eio]se?[,. ])+",0,23},
	TestItem{"soday,this,these,thesa.thesi over",r".*,(th[ei]se?[,. ])+(thes[ai][,. ])+",0,29},
	TestItem{"cpapaz ole. pippo,",r".*(c(pa)+z)(\s+\a+[\.,]?)+",0,18},
	TestItem{"cpapaz ole. pippo",r".*(c(pa)+z)(\s+\a+[\.,]?)+",0,17},
	TestItem{"cpapaz ole. pippo, 852",r".*(c(pa)+z)(\s+\a+[\.,]?)+",0,18},
	TestItem{"123cpapaz ole. pippo",r".*(c(pa)+z)(\s+\a+[\.,]?)+",0,20},
	TestItem{"...cpapaz ole. pippo",r".*(c(pa)+z)(\s+\a+[\.,]?)+",0,20},

	TestItem{"cpapaz ole. pippo,",r".*c.+ole.*pi",0,14},
	TestItem{"cpapaz ole. pipipo,",r".*c.+ole.*p([ip])+o",0,18},
	TestItem{"cpapaz ole. pipipo",r"^.*c.+ol?e.*p([ip])+o$",0,18},
	TestItem{"abbb",r"ab{2,3}?",0,3},
	TestItem{" pippo pera",r"\s(.*)pe(.*)",0,11},
	TestItem{" abb",r"\s(.*)",0,4},

	TestItem{"/home/us_er/pippo/info-01.txt", r"(/?[-\w_]+)*\.txt$",0,29}


	// negative
	TestItem{"zthis ciao",r"((t[hieo]+se?)\s*)+",-1,0},
	TestItem{"this is a good.",r"thes",-1,0},
	TestItem{"test1post.pip.com, pera",r"[\w]+@([\w]+\.)+\w+",-1,0},
	TestItem{"this cpapaz adce",r"(c(pa)+z)(\s[\a]+){2}",-1,0},
	TestItem{"this cpapaz adce aabe third",r"(c(pa)+z)(\s[\a]+){2}$",-1,0},
	TestItem{"1234this cpapaz adce aabe ter",r"(c(pa)+z)(\s[\a]+){2}$",-1,0},
	TestItem{"cpapaz ole. pipipo,",r"^.*c.+ol?e.*p([ip])+o$",-1,0},
	TestItem{"/home/us_er/pippo/info-01.jpeg", r"(/?[-\w_]+)*\.txt$",-1,0}

	// check unicode
	TestItem{"this is a       test",r".*a [- ]+",0,34},
	TestItem{"123      test",r"[-\s]+",3,23},
]
)

struct TestItemFa {
	src string
	q string
	r []int
}

const (
match_test_suite_fa = [
	// find_all tests
	TestItemFa{
		"oggi pippo  andato a casa di pluto ed ha trovato pippo",
		r"p[iplut]+o",
		[5, 10, 31, 36, 51, 56]
	},
	TestItemFa{
		"oggi pibao  andato a casa di pbababao ed ha trovato pibabababao",
		r"(pi?(ba)+o)",
		[5, 10, 31, 39, 54, 65]
	},

]
)

struct TestItemRe {
	src string
	q string
	rep string
	r string
}
const (
match_test_suite_re = [
	// replace tests
	TestItemRe{
		"oggi pibao  andato a casa di pbababao ed ha trovato pibabababao",
		r"(pi?(ba)+o)",
		"CIAO",
		"oggi CIAO  andato a casa di CIAO ed ha trovato CIAO"
	},
	TestItemRe{
		"Today is a good day and tomorrow will be for sure.",
		r"[Tt]o\w+",
		"CIAO",
		"CIAO is a good day and CIAO will be for sure."
	}
]
)

struct TestItemCGroup {
	src string
	q string
	s int = 0
	e int = 0
	cg []int
	cgn map[string]int
}
const (
cgroups_test_suite = [
	TestItemCGroup{
		"http://www.ciao.mondo/hello/pippo12_/pera.html",
		r"(?P<format>https?)|(?:ftps?)://(?P<token>[\w_]+.)+",0,46,
		[8, 0, 0, 4, 1, 7, 11, 1, 11, 16, 1, 16, 22, 1, 22, 28, 1, 28, 37, 1, 37, 42, 1, 42, 46],
		{'format':int(0),'token':1}
	},
	TestItemCGroup{
		"http://www.ciao.mondo/hello/pippo12_/pera.html",
		r"(?P<format>https?)|(?P<format>ftps?)://(?P<token>[\w_]+.)+",0,46,
		[8, 0, 0, 4, 1, 7, 11, 1, 11, 16, 1, 16, 22, 1, 22, 28, 1, 28, 37, 1, 37, 42, 1, 42, 46],
		{'format':int(0),'token':1}
	},
	TestItemCGroup{
		"http://www.ciao.mondo/hello/pippo12_/pera.html",
		r"(?P<format>https?)|(?P<format>ftps?)://([\w_]+.)+",0,46,
		[8, 0, 0, 4, 1, 7, 11, 1, 11, 16, 1, 16, 22, 1, 22, 28, 1, 28, 37, 1, 37, 42, 1, 42, 46],
		{'format':int(0)}
	},
]
)

fn test_regex(){
	// check capturing groups
	for c,to in cgroups_test_suite {
		// debug print
		//println("#$c [$to.src] q[$to.q] ($to.s, $to.e)")

		mut re, re_err, _ := regex.regex(to.q)
		re.group_csave = [-1].repeat(3*20+1)

		if re_err == regex.compile_ok {
			start, end := re.match_string(to.src)

			mut tmp_str := ""
			if start >= 0 && end  > start{
				tmp_str = to.src[start..end]
			}

			if start != to.s || end != to.e {
				println("#$c [$to.src] q[$to.q] res[$tmp_str] $start, $end")
				println("ERROR!")
				//C.printf("ERROR!! res:(%d, %d) refh:(%d, %d)\n",start, end, to.s, to.e)
				assert false
				break
			}

			// check cgroups
			if re.group_csave.len == 0 || re.group_csave[0] != to.cg[0] {
				println("Capturing group len error!")
				assert false
			}

			// check captured groups
			mut ln := re.group_csave[0]*3
			for ln > 0 {
				if re.group_csave[ln] != to.cg[ln] {
					assert false
				}
				ln--
			}

			// check named captured groups
			for k in to.cgn.keys() {
				if to.cgn[k] != (re.group_map[k]-1) { // we have -1 because the map not found is 0, in groups we start from 0 and we store using +1
					println("Named capturing group error! [$k]")
					assert false
				}
			}

		}
	}

	// check find_all
	for _,to in match_test_suite_fa{
		// debug print
		//println("#$c [$to.src] q[$to.q] $to.r")

		mut re, re_err, err_pos := regex.regex(to.q)
		if re_err == regex.compile_ok {
			res := re.find_all(to.src)
			if res.len != to.r.len {
				println("ERROR: find_all, array of different size.")
				assert false
			}

			for c1,i in res {
				if i != to.r[c1] {
					println("ERROR: find_all, different indexes.")
					assert false
				}
			}

		} else {
			println("query: $to.q")
			lc := "-".repeat(err_pos-1)
			println("err  : $lc^")
			err_str := re.get_parse_error_string(re_err)
			println("ERROR: $err_str")
			assert false
		}
	}

	// check replace
	for _,to in match_test_suite_re{
		// debug print
		//println("#$c [$to.src] q[$to.q] $to.r")

		mut re, re_err, err_pos := regex.regex(to.q)
		if re_err == regex.compile_ok {
			res := re.replace(to.src,to.rep)
			if res != to.r {
				println("ERROR: replace.")
				assert false
			}

		} else {
			println("query: $to.q")
			lc := "-".repeat(err_pos-1)
			println("err  : $lc^")
			err_str := re.get_parse_error_string(re_err)
			println("ERROR: $err_str")
			assert false
		}
	}

	// check match and find
	for c,to in match_test_suite {
		// debug print
		//println("#$c [$to.src] q[$to.q] $to.s")

		// test the find
		if to.s > 0 {
			mut re, re_err, err_pos := regex.regex(to.q)
			if re_err == regex.compile_ok {
				//q_str := re.get_query()
				//println("Query: $q_str")
				start,end := re.find(to.src)

				if start != to.s || end != to.e {
					err_str := re.get_parse_error_string(start)
					println("ERROR : $err_str")
					assert false
				} else {
					//tmp_str := text[start..end]
					//println("found in [$start, $end] => [$tmp_str]")
					assert true
				}

			} else {
				println("query: $to.q")
				lc := "-".repeat(err_pos-1)
				println("err  : $lc^")
				err_str := re.get_parse_error_string(re_err)
				println("ERROR: $err_str")
				assert false
			}
			continue
		}

		// test the match
		mut re := regex.new_regex()
		//re.debug = true

		re_err,err_pos := re.compile(to.q)
		if re_err == regex.compile_ok {
			//println("#$c [$to.src] q[$to.q]")
			start, end := re.match_string(to.src)

			mut tmp_str := ""
			if start >= 0 && end  > start{
				tmp_str = to.src[start..end]
			}

			if start != to.s || end != to.e {
				println("#$c [$to.src] q[$to.q] res[$tmp_str] $start, $end")
				println("ERROR!")
				//C.printf("ERROR!! res:(%d, %d) refh:(%d, %d)\n",start, end, to.s, to.e)
				assert false
				break
			}

			// rerun to test consistency
			tmp_str1 := to.src.clone()
			start1, end1 := re.match_string(tmp_str1)
			if start1 != start || end1 != end {
				println("two run ERROR!!")
				assert false
				break
			}

		} else {
			println("query: $to.q")
			lc := "-".repeat(err_pos-1)
			println("err  : $lc^")
			err_str := re.get_parse_error_string(re_err)
			println("ERROR: $err_str")
			assert false
			break
		}
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module runtime

import os

//$if linux {
fn C.sysconf(name int) i64
//}

//$if windows {
fn C.GetCurrentProcessorNumber() u32
//}

pub fn nr_cpus() int {
	$if windows {
		return nr_cpus_win()
	}
	return nr_cpus_nix()
}

pub fn nr_jobs() int {
	mut cpus := nr_cpus()
	// allow for overrides, for example using `VJOBS=32 ./v test .`
	vjobs := os.getenv('VJOBS').int()
	if vjobs > 0 {
		cpus = vjobs
	}
	return cpus
}

pub fn is_32bit() bool {
	mut x := false
	$if x32 { x = true }
	return x
}

pub fn is_64bit() bool {
	mut x := false
	$if x64 { x = true }
	return x
}

pub fn is_little_endian() bool {
	mut x := false
	$if little_endian { x = true }
	return x
}

pub fn is_big_endian() bool {
	mut x := false
	$if big_endian { x = true }
	return x
}
module runtime
module runtime
module runtime

fn nr_cpus_nix() int {
	$if linux {
		return int(C.sysconf(C._SC_NPROCESSORS_ONLN))
	}
	$if macos {
		return int(C.sysconf(C._SC_NPROCESSORS_ONLN))
	}
	$if solaris {
		return int(C.sysconf(C._SC_NPROCESSORS_ONLN))
	}
	return 1
}

fn nr_cpus_win() int {
	eprintln('nr_cpus_win should be callable only for windows')
	return 1
}
import runtime

fn test_nr_cpus() {
	nr_cpus := runtime.nr_cpus()
	assert nr_cpus > 0
}

fn test_is_32bit(){
	x := runtime.is_32bit().str()
	assert x == 'true' || x == 'false'
}

fn test_is_64bit(){
	x := runtime.is_64bit().str()
	assert x == 'true' || x == 'false'
}

fn test_is_little_endian(){
	x := runtime.is_little_endian().str()
	assert x == 'true' || x == 'false'
}

fn test_is_big_endian(){
	x := runtime.is_big_endian().str()
	assert x == 'true' || x == 'false'
}

fn test_is_big_endian_different_than_is_little_endian(){
	assert runtime.is_big_endian() != runtime.is_little_endian()
}

fn test_is_32bit_different_than_is_64bit(){	
	assert runtime.is_32bit() != runtime.is_64bit()
}
module runtime

import os

fn nr_cpus_win() int {
	mut nr := int(C.GetCurrentProcessorNumber())
	if nr == 0 {
		nr = os.getenv('NUMBER_OF_PROCESSORS').int()
	}
	return nr
}

fn nr_cpus_nix() int {
	eprintln('nr_cpus_nix should be callable only for nix platforms')
	return 1
}
module sokol

import sokol.c
import sokol.f

pub const (
  used_import = c.used_import + f.used_import
)
module c

pub const (
  used_import = 1
)

#flag -I @VROOT/thirdparty/sokol
#flag -I @VROOT/thirdparty/sokol/util

#flag darwin -fobjc-arc
#flag linux -lX11 -lGL

#flag windows -lgdi32

// METAL
#flag darwin -DSOKOL_METAL
#flag darwin -framework Metal -framework Cocoa -framework MetalKit -framework QuartzCore

// OPENGL
#flag linux -DSOKOL_GLCORE33
#flag windows -DSOKOL_GLCORE33
//#flag darwin -framework OpenGL -framework Cocoa -framework QuartzCore


// for simplicity, all header includes are here because import order matters and we dont have any way
// to ensure import order with V yet
#define SOKOL_IMPL
#define SOKOL_NO_ENTRY
#include "sokol_app.h"

#define SOKOL_IMPL
#define SOKOL_NO_DEPRECATED
#include "sokol_gfx.h"

#define SOKOL_GL_IMPL
#include "util/sokol_gl.h"
module f

import fontstash

pub const (
  used_import = 1 + fontstash.used_import
)

#flag windows -I @VROOT/thirdparty/freetype/include
#flag windows -L @VROOT/thirdparty/freetype/win64

#flag linux -I/usr/include/freetype2
#flag darwin -I/usr/local/include/freetype2
// MacPorts
#flag darwin -I/opt/local/include/freetype2
#flag darwin -L/opt/local/lib
#flag freebsd -I/usr/local/include/freetype2
#flag freebsd -Wl -L/usr/local/lib

#flag -lfreetype
#flag darwin -lpng -lbz2 -lz

#flag linux -I.

#include "ft2build.h"

#define FONS_USE_FREETYPE
#define SOKOL_FONTSTASH_IMPL
#include "util/sokol_fontstash.h"
module gfx

pub enum Backend {
    glcore33
    gles2
    gles3
    d3d11
    metal_ios
    metal_macos
    metal_simulator
    dummy
}

pub enum PixelFormat {
    _default    /* value 0 reserved for default-init */
    @none

    r8
    r8sn
    r8ui
    r8si

    r16
    r16sn
    r16ui
    r16si
    r16f
    rg8
    rg8sn
    rg8ui
    rg8si

    r32ui
    r32si
    r32f
    rg16
    rg16sn
    rg16ui
    rg16si
    rg16f
    rgba8
    rgba8sn
    rgba8ui
    rgba8si
    bgra8
    rgb10a2
    rg11b10f

    rg32ui
    rg32si
    rg32f
    rgba16
    rgba16sn
    rgba16ui
    rgba16si
    rgba16f

    rgba32ui
    rgba32si
    rgba32f

    depth
    depth_stencil

    bc1_rgba
    bc2_rgba
    bc3_rgba
    bc4_r
    bc4_rsn
    bc5_rg
    bc5_rgsn
    bc6h_rgbf
    bc6h_rgbuf
    bc7_rgba
    pvrtc_rgb_2bpp
    pvrtc_rgb_4bpp
    pvrtc_rgba_2bpp
    pvrtc_rgba_4bpp
    etc2_rgb8
    etc2_rgb8a1
    etc2_rgba8
    etc2_rg11
    etc2_rg11sn

    _num
}

pub enum ResourceState {
    initial
    alloc
    valid
    failed
    invalid
}

pub enum Usage {
    _default      /* value 0 reserved for default-init */
    immutable
    dynamic
    stream
    _num
}

pub enum BufferType {
    _default         /* value 0 reserved for default-init */
    vertexbuffer
    indexbuffer
    _num
}

pub enum IndexType {
    _default   /* value 0 reserved for default-init */
    @none
    uint16
    uint32
    _num
}

pub enum ImageType {
    _default  /* value 0 reserved for default-init */
    _2d
    cube
    _3d
    array
    _num
}

pub enum CubeFace {
    pos_x
    neg_x
    pos_y
    neg_y
    pos_z
    neg_z
    num
}

pub enum ShaderStage {
	vs
	fs
}

pub enum PrimitiveType {
    _default  /* value 0 reserved for default-init */
    points
    lines
    line_strip
    triangles
    triangle_strip
    _num
}

pub enum Filter {
    _default /* value 0 reserved for default-init */
    nearest
    linear
    nearest_mipmap_nearest
    nearest_mipmap_linear
    linear_mipmap_nearest
    linear_mipmap_linear
    _num
}

pub enum Wrap {
    _default   /* value 0 reserved for default-init */
    repeat
    clamp_to_edge
    clamp_to_border
    mirrored_repeat
    _num
}

pub enum BorderColor {
    _default    /* value 0 reserved for default-init */
    transparent_black
    opaque_black
    opaque_white
    _num
}

pub enum VertexFormat {
    invalid
    float
    float2
    float3
    float4
    byte4
    byte4n
    ubyte4
    ubyte4n
    short2
    short2n
    ushort2n
    short4
    short4n
    ushort4n
    uint10_n2
    _num
}

pub enum VertexStep {
    _default     /* value 0 reserved for default-init */
    per_vertex
    per_instance
    _num
}

pub enum UniformType {
    invalid
    float
    float2
    float3
    float4
    mat4
    _num
}

pub enum CullMode {
    _default   /* value 0 reserved for default-init */
    @none
    front
    back
    _num
}

pub enum FaceWinding {
    _facewinding_default    /* value 0 reserved for default-init */
    facewinding_ccw
    facewinding_cw
    _facewinding_num
}

pub enum CompareFunc {
    _default    /* value 0 reserved for default-init */
    never
    less
    equal
    less_equal
    greater
    not_equal
    greater_equal
    always
    _num
}

pub enum StencilOp {
    _default      /* value 0 reserved for default-init */
    keep
    zero
    replace
    incr_clamp
    decr_clamp
    invert
    incr_wrap
    decr_wrap
    _num
}

pub enum BlendFactor {
    _default    /* value 0 reserved for default-init */
    zero
    one
    src_color
    one_minus_src_color
    src_alpha
    one_minus_src_alpha
    dst_color
    one_minus_dst_color
    dst_alpha
    one_minus_dst_alpha
    src_alpha_saturated
    blend_color
    one_minus_blend_color
    blend_alpha
    one_minus_blend_alpha
    _num
}

pub enum BlendOp {
    _default    /* value 0 reserved for default-init */
    add
    subtract
    reverse_subtract
    _num
}

pub enum ColorMask {
    _default = 0      /* value 0 reserved for default-init */
    @none = 0x10     /* special value for 'all channels disabled */
    r = 1
    g = 2
    b = 4
    a = 8
    rgb = 0x7
    rgba = 0xF
}

pub enum Action {
    _default
    clear
    load
    dontcare
    _num
}
module gfx

// setup and misc functions
[inline]
pub fn setup(desc &C.sg_desc) {
	C.sg_setup(desc)
}

[inline]
pub fn shutdown() {
	C.sg_shutdown()
}

[inline]
pub fn reset_state_cache() {
	C.sg_reset_state_cache()
}

// resource creation, destruction and updating
[inline]
pub fn make_buffer(desc &C.sg_buffer_desc) C.sg_buffer {
	return C.sg_make_buffer(desc)
}

[inline]
pub fn make_image(desc &C.sg_image_desc) C.sg_image {
	return C.sg_make_image(desc)
}

[inline]
pub fn make_shader(desc &C.sg_shader_desc) C.sg_shader {
	return C.sg_make_shader(desc)
}

[inline]
pub fn make_pipeline(desc &C.sg_pipeline_desc) C.sg_pipeline {
	return C.sg_make_pipeline(desc)
}

[inline]
pub fn make_pass(desc &C.sg_pass_desc) C.sg_pass {
	return C.sg_make_pass(desc)
}

[inline]
pub fn destroy_buffer(buf C.sg_buffer) {
	C.sg_destroy_buffer(buf)
}

[inline]
pub fn destroy_image(img C.sg_image) {
	C.sg_destroy_image(img)
}

[inline]
pub fn destroy_shader(shd C.sg_shader) {
	C.sg_destroy_shader(shd)
}

[inline]
pub fn destroy_pipeline(pip C.sg_pipeline) {
	C.sg_destroy_pipeline(pip)
}

[inline]
pub fn destroy_pass(pass C.sg_pass) {
	C.sg_destroy_pass(pass)
}

[inline]
pub fn update_buffer(buf C.sg_buffer, ptr voidptr, num_bytes int) {
	C.sg_update_buffer(buf, ptr, num_bytes)
}

[inline]
pub fn update_image(img C.sg_image, content &C.sg_image_content) {
	C.sg_update_image(img, content)
}

[inline]
pub fn append_buffer(buf C.sg_buffer, ptr voidptr, num_bytes int) int {
	return C.sg_append_buffer(buf, ptr, num_bytes)
}

[inline]
pub fn query_buffer_overflow(buf C.sg_buffer) bool {
	return C.sg_query_buffer_overflow(buf)
}

// rendering functions
[inline]
pub fn begin_default_pass(actions &C.sg_pass_action, width int, height int) {
	C.sg_begin_default_pass(actions, width, height)
}

[inline]
pub fn begin_pass(pass C.sg_pass, actions &C.sg_pass_action) {
	C.sg_begin_pass(pass, actions)
}

[inline]
pub fn apply_viewport(x int, y int, width int, height int, origin_top_left bool) {
	C.sg_apply_viewport(x, y, width, height, origin_top_left)
}

[inline]
pub fn apply_scissor_rect(x int, y int, width int, height int, origin_top_left bool) {
	C.sg_apply_scissor_rect(x, y, width, height, origin_top_left)
}

[inline]
pub fn apply_pipeline(pip C.sg_pipeline) {
	C.sg_apply_pipeline(pip)
}

[inline]
pub fn apply_bindings(bindings &C.sg_bindings) {
	C.sg_apply_bindings(bindings)
}

[inline]
pub fn apply_uniforms(stage int, ub_index int, data voidptr, num_bytes int) {
	C.sg_apply_uniforms(stage, ub_index, data, num_bytes)
}

[inline]
pub fn draw(base_element int, num_elements int, num_instances int) {
	C.sg_draw(base_element, num_elements, num_instances)
}

[inline]
pub fn end_pass() {
	C.sg_end_pass()
}

[inline]
pub fn commit() {
	C.sg_commit()
}

// getting information
[inline]
pub fn query_desc() C.sg_desc {
	return C.sg_query_desc()
}

[inline]
pub fn query_backend() Backend {
	return C.sg_query_backend()
}

[inline]
pub fn query_features() C.sg_features {
	return C.sg_query_features()
}

[inline]
pub fn query_limits() C.sg_limits {
	return C.sg_query_limits()
}

[inline]
pub fn query_pixelformat(fmt PixelFormat) C.sg_pixelformat_info {
	return C.sg_query_pixelformat(fmt)
}

/* get current state of a resource (INITIAL, ALLOC, VALID, FAILED, INVALID) */
[inline]
pub fn query_buffer_state(buf C.sg_buffer) C.sg_resource_state {
	return C.sg_query_buffer_state(buf)
}

[inline]
pub fn query_image_state(img C.sg_image) C.sg_resource_state {
	return C.sg_query_image_state(img)
}

[inline]
pub fn query_shader_state(shd C.sg_shader) C.sg_resource_state {
	return C.sg_query_shader_state(shd)
}

[inline]
pub fn query_pipeline_state(pip C.sg_pipeline) C.sg_resource_state {
	return C.sg_query_pipeline_state(pip)
}

[inline]
pub fn query_pass_state(pass C.sg_pass) C.sg_resource_state {
	return C.sg_query_pass_state(pass)
}

// get runtime information about a resource
[inline]
pub fn query_buffer_info(buf C.sg_buffer) C.sg_buffer_info {
	return C.sg_query_buffer_info(buf)
}

[inline]
pub fn query_image_info(img C.sg_image) C.sg_image_info {
	return C.sg_query_image_info(img)
}

[inline]
pub fn query_shader_info(shd C.sg_shader) C.sg_shader_info {
	return C.sg_query_shader_info(shd)
}

[inline]
pub fn query_pipeline_info(pip C.sg_pipeline) C.sg_pipeline_info {
	return C.sg_query_pipeline_info(pip)
}

[inline]
pub fn query_pass_info(pass C.sg_pass) C.sg_pass_info {
	return C.sg_query_pass_info(pass)
}

// get resource creation desc struct with their default values replaced
[inline]
pub fn query_buffer_defaults(desc &C.sg_buffer) C.sg_buffer_desc {
	return C.sg_query_buffer_defaults(desc)
}

[inline]
pub fn query_image_defaults(desc &C.sg_image) C.sg_image_desc {
	return C.sg_query_image_defaults(desc)
}

[inline]
pub fn query_shader_defaults(desc &C.sg_shader) C.sg_shader_desc {
	return C.sg_query_shader_defaults(desc)
}

[inline]
pub fn query_pipeline_defaults(desc &C.sg_pipeline) C.sg_pipeline_desc {
	return C.sg_query_pipeline_defaults(desc)
}

[inline]
pub fn query_pass_defaults(desc &C.sg_pass) C.sg_pass_desc {
	return C.sg_query_pass_defaults(desc)
}

/* rendering contexts (optional) */
[inline]
pub fn setup_context() C.sg_context {
	return C.sg_setup_context()
}

[inline]
pub fn activate_context(ctx_id C.sg_context) {
	C.sg_activate_context(ctx_id)
}

[inline]
pub fn discard_context(ctx_id C.sg_context) {
	C.sg_discard_context(ctx_id)
}
module gfx

// setup and misc functions
fn C.sg_setup(desc &C.sg_desc)
fn C.sg_shutdown()
fn C.sg_reset_state_cache()

// resource creation, destruction and updating
fn C.sg_make_buffer(desc &C.sg_buffer_desc) C.sg_buffer
fn C.sg_make_image(desc &C.sg_image_desc) C.sg_image
fn C.sg_make_shader(desc &C.sg_shader_desc) C.sg_shader
fn C.sg_make_pipeline(desc &C.sg_pipeline_desc) C.sg_pipeline
fn C.sg_make_pass(desc &C.sg_pass_desc) C.sg_pass
fn C.sg_destroy_buffer(buf C.sg_buffer)
fn C.sg_destroy_image(img C.sg_image)
fn C.sg_destroy_shader(shd C.sg_shader)
fn C.sg_destroy_pipeline(pip C.sg_pipeline)
fn C.sg_destroy_pass(pass C.sg_pass)
fn C.sg_update_buffer(buf C.sg_buffer, ptr voidptr, num_bytes int)
fn C.sg_update_image(img C.sg_image, content &C.sg_image_content)
fn C.sg_append_buffer(buf C.sg_buffer, ptr voidptr, num_bytes int) int
fn C.sg_query_buffer_overflow(buf C.sg_buffer) bool

// rendering functions
fn C.sg_begin_default_pass(actions &C.sg_pass_action, width int, height int)
fn C.sg_begin_pass(pass C.sg_pass, actions &C.sg_pass_action)
fn C.sg_apply_viewport(x int, y int, width int, height int, origin_top_left bool)
fn C.sg_apply_scissor_rect(x int, y int, width int, height int, origin_top_left bool)
fn C.sg_apply_pipeline(pip C.sg_pipeline)
fn C.sg_apply_bindings(bindings &C.sg_bindings)
fn C.sg_apply_uniforms(stage int /*sg_shader_stage*/, ub_index int, data voidptr, num_bytes int)
fn C.sg_draw(base_element int, num_elements int, num_instances int)
fn C.sg_end_pass()
fn C.sg_commit()

// getting information
fn C.sg_query_desc() C.sg_desc
fn C.sg_query_backend() Backend
fn C.sg_query_features() C.sg_features
fn C.sg_query_limits() C.sg_limits
fn C.sg_query_pixelformat(fmt PixelFormat) C.sg_pixelformat_info

/* get current state of a resource (INITIAL, ALLOC, VALID, FAILED, INVALID) */
fn C.sg_query_buffer_state(buf C.sg_buffer) C.sg_resource_state
fn C.sg_query_image_state(img C.sg_image) C.sg_resource_state
fn C.sg_query_shader_state(shd C.sg_shader) C.sg_resource_state
fn C.sg_query_pipeline_state(pip C.sg_pipeline) C.sg_resource_state
fn C.sg_query_pass_state(pass C.sg_pass) C.sg_resource_state

// get runtime information about a resource
fn C.sg_query_buffer_info(buf C.sg_buffer) C.sg_buffer_info
fn C.sg_query_image_info(img C.sg_image) C.sg_image_info
fn C.sg_query_shader_info(shd C.sg_shader) C.sg_shader_info
fn C.sg_query_pipeline_info(pip C.sg_pipeline) C.sg_pipeline_info
fn C.sg_query_pass_info(pass C.sg_pass) C.sg_pass_info

// get resource creation desc struct with their default values replaced
fn C.sg_query_buffer_defaults(desc &C.sg_buffer) C.sg_buffer_desc
fn C.sg_query_image_defaults(desc &C.sg_image) C.sg_image_desc
fn C.sg_query_shader_defaults(desc &C.sg_shader) C.sg_shader_desc
fn C.sg_query_pipeline_defaults(desc &C.sg_pipeline) C.sg_pipeline_desc
fn C.sg_query_pass_defaults(desc &C.sg_pass) C.sg_pass_desc

/* rendering contexts (optional) */
fn C.sg_setup_context() C.sg_context
fn C.sg_activate_context(ctx_id C.sg_context)
fn C.sg_discard_context(ctx_id C.sg_context)
module gfx

pub struct C.sg_desc {
    _start_canary u32
    buffer_pool_size int
    image_pool_size int
    shader_pool_size int
    pipeline_pool_size int
    pass_pool_size int
    context_pool_size int
    /* GL specific */
    gl_force_gles2 bool
    /* Metal-specific */
    mtl_device voidptr
    mtl_renderpass_descriptor_cb fn() voidptr
    mtl_drawable_cb fn() voidptr
    mtl_global_uniform_buffer_size int
    mtl_sampler_cache_size int
    /* D3D11-specific */
    d3d11_device voidptr
    d3d11_device_context voidptr
    d3d11_render_target_view_cb fn() voidptr
    d3d11_depth_stencil_view_cb fn() voidptr
    _end_canary u32
}

pub struct C.sg_pipeline_desc {
pub mut:
	_start_canary u32
    layout C.sg_layout_desc
    shader C.sg_shader
    primitive_type PrimitiveType
    index_type IndexType
    depth_stencil C.sg_depth_stencil_state
    blend C.sg_blend_state
    rasterizer C.sg_rasterizer_state
    label byteptr
    _end_canary u32
}

pub struct C.sg_pipeline_info {

}

pub struct C.sg_pipeline {
pub:
    id u32
}
pub fn (p C.sg_pipeline) free() { C.sg_destroy_pipeline(p) }


pub struct C.sg_bindings {
pub mut:
    _start_canary u32
    vertex_buffers [8]C.sg_buffer
    vertex_buffer_offsets [8]int
    index_buffer C.sg_buffer
    index_buffer_offset int
    vs_images [8]C.sg_image
    fs_images [8]C.sg_image
    _end_canary u32
}

pub fn (mut b C.sg_bindings) set_vert_image(index int, img C.sg_image) {
    b.vs_images[index] = img
}

pub fn (mut b C.sg_bindings) set_frag_image(index int, img C.sg_image) {
    b.fs_images[index] = img
}

pub fn (b &C.sg_bindings) update_vert_buffer(index int, data voidptr, element_size int, element_count int) {
    C.sg_update_buffer(b.vertex_buffers[index], data, element_size * element_count)
}

pub fn (b &C.sg_bindings) append_vert_buffer(index int, data voidptr, element_size int, element_count int) int {
    return C.sg_append_buffer(b.vertex_buffers[index], data, element_size * element_count)
}

pub fn (b &C.sg_bindings) update_index_buffer(data voidptr, element_size int, element_count int) {
    C.sg_update_buffer(b.index_buffer, data, element_size * element_count)
}

pub fn (b &C.sg_bindings) append_index_buffer(data voidptr, element_size int, element_count int) int {
    return C.sg_append_buffer(b.index_buffer, data, element_size * element_count)
}


pub struct C.sg_shader_desc {
pub mut:
    _start_canary u32
    attrs [16]C.sg_shader_attr_desc
    vs C.sg_shader_stage_desc
    fs C.sg_shader_stage_desc
    label byteptr
    _end_canary u32
}

pub fn (mut desc C.sg_shader_desc) set_vert_src(src string) &C.sg_shader_desc {
    desc.vs.source = src.str
    return desc
}

pub fn (mut desc C.sg_shader_desc) set_frag_src(src string) &C.sg_shader_desc {
    desc.fs.source = src.str
    return desc
}

pub fn (mut desc C.sg_shader_desc) set_vert_image(index int, name string) &C.sg_shader_desc {
    desc.vs.images[index].name = name.str
    desc.vs.images[index].@type = ._2d
    return desc
}

pub fn (mut desc C.sg_shader_desc) set_frag_image(index int, name string) &C.sg_shader_desc {
    desc.fs.images[index].name = name.str
    desc.fs.images[index].@type = ._2d
    return desc
}

pub fn (mut desc C.sg_shader_desc) set_vert_uniform_block_size(block_index, size int) &C.sg_shader_desc {
    desc.vs.uniform_blocks[block_index].size = size
    return desc
}

pub fn (mut desc C.sg_shader_desc) set_frag_uniform_block_size(block_index, size int) &C.sg_shader_desc {
    desc.fs.uniform_blocks[block_index].size = size
    return desc
}

pub fn (mut desc C.sg_shader_desc) set_vert_uniform(block_index int, uniform_index int, name string, @type UniformType, array_count int) &C.sg_shader_desc {
    desc.vs.uniform_blocks[block_index].uniforms[uniform_index].name = name.str
	desc.vs.uniform_blocks[block_index].uniforms[uniform_index].@type = @type
    return desc
}

pub fn (mut desc C.sg_shader_desc) set_frag_uniform(block_index int, uniform_index int, name string, @type UniformType, array_count int) &C.sg_shader_desc {
    desc.fs.uniform_blocks[block_index].uniforms[uniform_index].name = name.str
	desc.fs.uniform_blocks[block_index].uniforms[uniform_index].@type = @type
    return desc
}

pub fn (desc &C.sg_shader_desc) make_shader() C.sg_shader {
    return C.sg_make_shader(desc)
}


pub struct C.sg_shader_attr_desc {
pub mut:
    name byteptr           /* GLSL vertex attribute name (only required for GLES2) */
    sem_name byteptr       /* HLSL semantic name */
    sem_index int          /* HLSL semantic index */
}

pub struct C.sg_shader_stage_desc {
pub mut:
    source byteptr
    byte_code &byte
    byte_code_size int
    entry byteptr
    uniform_blocks [4]C.sg_shader_uniform_block_desc
    images [12]C.sg_shader_image_desc
}

pub fn (mut desc C.sg_shader_stage_desc) set_image(index int, name string) C.sg_shader_stage_desc {
    desc.images[index].name = name.str
    desc.images[index].@type = ._2d
    return desc
}


pub struct C.sg_shader_uniform_block_desc {
pub mut:
    size int
    uniforms [16]C.sg_shader_uniform_desc
}

pub struct C.sg_shader_uniform_desc {
pub mut:
    name byteptr
    @type UniformType
    array_count int
}

pub struct C.sg_shader_image_desc {
pub mut:
    name byteptr
    @type ImageType
}

pub struct C.sg_shader_info {}

pub struct C.sg_context {
    id u32
}

pub struct C.sg_shader {
pub:
    id u32
}
pub fn (s C.sg_shader) free() { C.sg_destroy_shader(s) }


pub struct C.sg_pass_desc {
pub mut:
    _start_canary u32
    color_attachments [4]C.sg_attachment_desc
    depth_stencil_attachment C.sg_attachment_desc
    label byteptr
    _end_canary u32
}

pub struct C.sg_pass_info {
    info C.sg_slot_info
}

pub struct C.sg_pass_action {
pub mut:
    _start_canary u32
    colors [4]C.sg_color_attachment_action
    depth C.sg_depth_attachment_action
    stencil C.sg_stencil_attachment_action
    _end_canary u32
}

pub struct C.sg_pass {
    id u32
}
pub fn (p C.sg_pass) free() { C.sg_destroy_pass(p) }


pub struct C.sg_buffer_desc {
pub mut:
    _start_canary u32
    size int
    @type BufferType
    usage Usage
    content byteptr
    label byteptr
    /* GL specific */
    gl_buffers [2]u32
    /* Metal specific */
    mtl_buffers [2]voidptr
    /* D3D11 specific */
    d3d11_buffer voidptr
    _end_canary u32
}

pub struct C.sg_buffer_info {}

pub struct C.sg_buffer {
    id u32
}
pub fn (b C.sg_buffer) free() { C.sg_destroy_buffer(b) }


pub union DepthLayers {
    depth int
    layers int
}

pub struct C.sg_image_desc {
pub mut:
    _start_canary u32
    @type ImageType
    render_target bool
    width int
    height int

    depth DepthLayers
    // depth int
    // union {
    //     int depth;
    //     int layers;
    // };
    num_mipmaps int
    usage Usage
    pixel_format PixelFormat
    sample_count int
    min_filter Filter
    mag_filter Filter
    wrap_u Wrap
    wrap_v Wrap
    wrap_w Wrap
    border_color BorderColor
    max_anisotropy u32
    min_lod f32
    max_lod f32
    content C.sg_image_content
    label byteptr
    /* GL specific */
    gl_textures [2]u32
    /* Metal specific */
    mtl_textures [2]voidptr
    /* D3D11 specific */
    d3d11_texture voidptr
    _end_canary u32
}

pub struct C.sg_image_info {
pub mut:
    slot C.sg_slot_info            /* resource pool slot info */
    upd_frame_index u32            /* frame index of last sg_update_image() */
    num_slots int                  /* number of renaming-slots for dynamically updated images */
    active_slot int                /* currently active write-slot for dynamically updated images */
}

pub struct C.sg_image {
pub:
    id u32
}
pub fn (i C.sg_image) free() { C.sg_destroy_image(i) }


pub struct C.sg_image_content {
pub mut:
    subimage [6][16]C.sg_subimage_content
}

pub struct C.sg_subimage_content {
pub mut:
    ptr voidptr     /* pointer to subimage data */
    size int        /* size in bytes of pointed-to subimage data */
}

pub struct C.sg_features {
pub:
    instancing bool              /* hardware instancing supported */
    origin_top_left bool         /* framebuffer and texture origin is in top left corner */
    multiple_render_targets bool /* offscreen render passes can have multiple render targets attached */
    msaa_render_targets bool     /* offscreen render passes support MSAA antialiasing */
    imagetype_3d bool            /* creation of SG_IMAGETYPE_3D images is supported */
    imagetype_array bool         /* creation of SG_IMAGETYPE_ARRAY images is supported */
    image_clamp_to_border bool   /* border color and clamp-to-border UV-wrap mode is supported */
}

pub struct C.sg_limits {
pub:
    max_image_size_2d u32         /* max width/height of SG_IMAGETYPE_2D images */
    max_image_size_cube u32       /* max width/height of SG_IMAGETYPE_CUBE images */
    max_image_size_3d u32         /* max width/height/depth of SG_IMAGETYPE_3D images */
    max_image_size_array u32      /* max width/height pf SG_IMAGETYPE_ARRAY images */
    max_image_array_layers u32    /* max number of layers in SG_IMAGETYPE_ARRAY images */
    max_vertex_attrs u32          /* <= SG_MAX_VERTEX_ATTRIBUTES (only on some GLES2 impls) */
}

pub struct C.sg_layout_desc {
pub mut:
    buffers [8]C.sg_buffer_layout_desc
    attrs [16]C.sg_vertex_attr_desc
}

pub struct C.sg_buffer_layout_desc {
pub mut:
    stride int
    step_func VertexStep
    step_rate int
}

pub struct C.sg_vertex_attr_desc {
pub mut:
    buffer_index int
    offset int
    format VertexFormat
}

pub struct C.sg_depth_stencil_state {
    stencil_front sg_stencil_state
    stencil_back sg_stencil_state
    depth_compare_func CompareFunc
    depth_write_enabled bool
    stencil_enabled bool
    stencil_read_mask byte
    stencil_write_mask byte
    stencil_ref byte
}

pub struct C.sg_stencil_state {
    fail_op StencilOp
    depth_fail_op StencilOp
    pass_op StencilOp
    compare_func CompareFunc
}

pub struct C.sg_blend_state {
    enabled bool
    src_factor_rgb BlendFactor
    dst_factor_rgb BlendFactor
    op_rgb BlendOp
    src_factor_alpha BlendFactor
    dst_factor_alpha BlendFactor
    op_alpha BlendOp
    color_write_mask byte
    color_attachment_count int
    color_format PixelFormat
    depth_format PixelFormat
    blend_color [4]f32
}

pub struct C.sg_rasterizer_state {
pub mut:
    alpha_to_coverage_enabled bool
    cull_mode CullMode
    face_winding FaceWinding
    sample_count int
    depth_bias f32
    depth_bias_slope_scale f32
    depth_bias_clamp f32
}


pub struct C.sg_color_attachment_action {
pub mut:
    action Action
    val [4]f32
}

/*
pub fn (mut action C.sg_color_attachment_action) set_color_values(r, g, b, a f32) {
    action.val[0] = r
    action.val[1] = g
    action.val[2] = b
    action.val[3] = a
}
*/

pub struct C.sg_depth_attachment_action {
pub mut:
    action Action
    val f32
}

pub struct C.sg_stencil_attachment_action {
pub mut:
    action Action
    val byte
}

pub struct C.sg_pixelformat_info {
pub:
    sample bool        /* pixel format can be sampled in shaders */
    filter bool        /* pixel format can be sampled with filtering */
    render bool        /* pixel format can be used as render target */
    blend bool         /* alpha-blending is supported */
    msaa bool          /* pixel format can be used as MSAA render target */
    depth bool         /* pixel format is a depth format */
}

pub struct C.sg_attachment_desc {
pub mut:
    image C.sg_image
    mip_level int
    face int

    // image sg_image
    // mip_level int
    // union {
    //     face int
    //     layer int
    //     slice int
    // }
}
module gfx

pub fn create_clear_pass(r, g, b, a f32) C.sg_pass_action {
	mut color_action := C.sg_color_attachment_action {
		action: C.SG_ACTION_CLEAR
	}
	//color_action.set_color_values(r, g, b, a)
color_action.val[0] = r
    color_action.val[1] = g
    color_action.val[2] = b
    color_action.val[3] = a

	mut pass_action := C.sg_pass_action{}
	pass_action.colors[0] = color_action
	return pass_action
}
module sapp

pub enum EventType {
    invalid
    key_down
    key_up
    char
    mouse_down
    mouse_up
    mouse_scroll
    mouse_move
    mouse_enter
    mouse_leave
    touches_began
    touches_moved
    touches_ended
    touches_cancelled
    resized
    iconified
    restored
    suspended
    resumed
    update_cursor
    quit_requested
    clipboard_pasted
    num
}

pub enum MouseButton {
    invalid = -1
    left = 0
    right = 1
    middle = 2
}

pub enum Modifier {
    shift = 1   //(1<<0)
    ctrl = 2    //(1<<1)
    alt =  4    //(1<<2)
    super = 8   //(1<<3)
}

pub enum KeyCode {
    invalid          = 0
    space            = 32
    apostrophe       = 39  /* ' */
    comma            = 44  /* , */
    minus            = 45  /* - */
    period           = 46  /* . */
    slash            = 47  /* / */
    _0                = 48
    _1                = 49
    _2                = 50
    _3                = 51
    _4                = 52
    _5                = 53
    _6                = 54
    _7                = 55
    _8                = 56
    _9                = 57
    semicolon        = 59  /* ; */
    equal            = 61  /* = */
    a                = 65
    b                = 66
    c                = 67
    d                = 68
    e                = 69
    f                = 70
    g                = 71
    h                = 72
    i                = 73
    j                = 74
    k                = 75
    l                = 76
    m                = 77
    n                = 78
    o                = 79
    p                = 80
    q                = 81
    r                = 82
    s                = 83
    t                = 84
    u                = 85
    v                = 86
    w                = 87
    x                = 88
    y                = 89
    z                = 90
    left_bracket     = 91  /* [ */
    backslash        = 92  /* \ */
    right_bracket    = 93  /* ] */
    grave_accent     = 96  /* ` */
    world_1          = 161 /* non-us #1 */
    world_2          = 162 /* non-us #2 */
    escape           = 256
    enter            = 257
    tab              = 258
    backspace        = 259
    insert           = 260
    delete           = 261
    right            = 262
    left             = 263
    down             = 264
    up               = 265
    page_up          = 266
    page_down        = 267
    home             = 268
    end              = 269
    caps_lock        = 280
    scroll_lock      = 281
    num_lock         = 282
    print_screen     = 283
    pause            = 284
    f1               = 290
    f2               = 291
    f3               = 292
    f4               = 293
    f5               = 294
    f6               = 295
    f7               = 296
    f8               = 297
    f9               = 298
    f10              = 299
    f11              = 300
    f12              = 301
    f13              = 302
    f14              = 303
    f15              = 304
    f16              = 305
    f17              = 306
    f18              = 307
    f19              = 308
    f20              = 309
    f21              = 310
    f22              = 311
    f23              = 312
    f24              = 313
    f25              = 314
    kp_0             = 320
    kp_1             = 321
    kp_2             = 322
    kp_3             = 323
    kp_4             = 324
    kp_5             = 325
    kp_6             = 326
    kp_7             = 327
    kp_8             = 328
    kp_9             = 329
    kp_decimal       = 330
    kp_divide        = 331
    kp_multiply      = 332
    kp_subtract      = 333
    kp_add           = 334
    kp_enter         = 335
    kp_equal         = 336
    left_shift       = 340
    left_control     = 341
    left_alt         = 342
    left_super       = 343
    right_shift      = 344
    right_control    = 345
    right_alt        = 346
    right_super      = 347
    menu             = 348
}
module sapp

/* returns true after sokol-app has been initialized */
[inline]
pub fn isvalid() bool {
	return C.sapp_isvalid()
}

/* returns the current framebuffer width in pixels */
[inline]
pub fn width() int {
	return C.sapp_width()
}

/* returns the current framebuffer height in pixels */
[inline]
pub fn height() int {
	return C.sapp_height()
}

/* returns true when high_dpi was requested and actually running in a high-dpi scenario */
[inline]
pub fn high_dpi() bool {
	return C.sapp_high_dpi()
}

/* returns the dpi scaling factor (window pixels to framebuffer pixels) */
[inline]
pub fn dpi_scale() f32 {
	return C.sapp_dpi_scale()
}

/* show or hide the mobile device onscreen keyboard */
[inline]
pub fn show_keyboard(visible bool) {
	C.sapp_show_keyboard(visible)
}

/* return true if the mobile device onscreen keyboard is currently shown */
[inline]
pub fn keyboard_shown() bool {
	return C.sapp_keyboard_shown()
}

/* show or hide the mouse cursor */
[inline]
pub fn show_mouse(visible bool) {
	C.sapp_show_mouse(visible)
}

/* show or hide the mouse cursor */
[inline]
pub fn mouse_shown() bool {
	return C.sapp_mouse_shown()
}

/* return the userdata pointer optionally provided in sapp_desc */
[inline]
pub fn userdata() voidptr {
	return C.sapp_userdata()
}

/* return a copy of the sapp_desc structure */
[inline]
pub fn query_desc() C.sapp_desc {
	return C.sapp_query_desc()
}

/* initiate a "soft quit" (sends SAPP_EVENTTYPE_QUIT_REQUESTED) */
[inline]
pub fn request_quit() {
	C.sapp_request_quit()
}

/* cancel a pending quit (when SAPP_EVENTTYPE_QUIT_REQUESTED has been received) */
[inline]
pub fn cancel_quit() {
	C.sapp_cancel_quit()
}

/* intiate a "hard quit" (quit application without sending SAPP_EVENTTYPE_QUIT_REQUSTED) */
[inline]
pub fn quit() {
	C.sapp_quit()
}

/* call from inside event callback to consume the current event (don't forward to platform) */
[inline]
pub fn consume_event() {
	C.sapp_consume_event()
}

/* get the current frame counter (for comparison with sapp_event.frame_count) */
[inline]
pub fn frame_count() u64 {
	return C.sapp_frame_count()
}

/* write string into clipboard */
[inline]
pub fn set_clipboard_string(str byteptr) {
	C.sapp_set_clipboard_string(str)
}

/* read string from clipboard (usually during SAPP_EVENTTYPE_CLIPBOARD_PASTED) */
[inline]
pub fn get_clipboard_string() byteptr {
	return C.sapp_get_clipboard_string()
}

/* special run-function for SOKOL_NO_ENTRY (in standard mode this is an empty stub) */
[inline]
pub fn run(desc &C.sapp_desc) int {
	return C.sapp_run(desc)
}

/* GL: return true when GLES2 fallback is active (to detect fallback from GLES3) */
[inline]
pub fn gles2() bool {
	return C.sapp_gles2()
}

/* HTML5: enable or disable the hardwired "Leave Site?" dialog box */
[inline]
pub fn html5_ask_leave_site(ask bool) {
	C.sapp_html5_ask_leave_site(ask)
}

/* Metal: get ARC-bridged pointer to Metal device object */
[inline]
pub fn metal_get_device() voidptr {
	return C.sapp_metal_get_device()
}

/* Metal: get ARC-bridged pointer to this frame's renderpass descriptor */
[inline]
pub fn metal_get_renderpass_descriptor() voidptr {
	return C.sapp_metal_get_renderpass_descriptor()
}

/* Metal: get ARC-bridged pointer to current drawable */
[inline]
pub fn metal_get_drawable() voidptr {
	return C.sapp_metal_get_drawable()
}

/* macOS: get ARC-bridged pointer to macOS NSWindow */
[inline]
pub fn macos_get_window() voidptr {
	return C.sapp_macos_get_window()
}

/* iOS: get ARC-bridged pointer to iOS UIWindow */
[inline]
pub fn ios_get_window() voidptr {
	return C.sapp_ios_get_window()
}

/* D3D11: get pointer to ID3D11Device object */
[inline]
pub fn d3d11_get_device() voidptr {
	return C.sapp_d3d11_get_device()
}

/* D3D11: get pointer to ID3D11DeviceContext object */
[inline]
pub fn d3d11_get_device_context() voidptr {
	return C.sapp_d3d11_get_device_context()
}

/* D3D11: get pointer to ID3D11RenderTargetView object */
[inline]
pub fn d3d11_get_render_target_view() voidptr {
	return C.sapp_d3d11_get_render_target_view()
}

/* D3D11: get pointer to ID3D11DepthStencilView */
[inline]
pub fn d3d11_get_depth_stencil_view() voidptr {
	return C.sapp_d3d11_get_depth_stencil_view()
}

/* Win32: get the HWND window handle */
[inline]
pub fn win32_get_hwnd() voidptr {
	return C.sapp_win32_get_hwnd()
}

/* Android: get native activity handle */
[inline]
pub fn android_get_native_activity() voidptr {
	return C.sapp_android_get_native_activity()
}
module sapp

/* returns true after sokol-app has been initialized */
fn C.sapp_isvalid() bool
/* returns the current framebuffer width in pixels */
fn C.sapp_width() int
/* returns the current framebuffer height in pixels */
fn C.sapp_height() int
/* returns true when high_dpi was requested and actually running in a high-dpi scenario */
fn C.sapp_high_dpi() bool
/* returns the dpi scaling factor (window pixels to framebuffer pixels) */
fn C.sapp_dpi_scale() f32
/* show or hide the mobile device onscreen keyboard */
fn C.sapp_show_keyboard(visible bool)
/* return true if the mobile device onscreen keyboard is currently shown */
fn C.sapp_keyboard_shown() bool
/* show or hide the mouse cursor */
fn C.sapp_show_mouse(visible bool)
/* show or hide the mouse cursor */
fn C.sapp_mouse_shown() bool
/* return the userdata pointer optionally provided in sapp_desc */
fn C.sapp_userdata() voidptr
/* return a copy of the sapp_desc structure */
fn C.sapp_query_desc() C.sapp_desc
/* initiate a "soft quit" (sends SAPP_EVENTTYPE_QUIT_REQUESTED) */
fn C.sapp_request_quit()
/* cancel a pending quit (when SAPP_EVENTTYPE_QUIT_REQUESTED has been received) */
fn C.sapp_cancel_quit()
/* intiate a "hard quit" (quit application without sending SAPP_EVENTTYPE_QUIT_REQUSTED) */
fn C.sapp_quit()
/* call from inside event callback to consume the current event (don't forward to platform) */
fn C.sapp_consume_event()
/* get the current frame counter (for comparison with sapp_event.frame_count) */
fn C.sapp_frame_count() u64
/* write string into clipboard */
fn C.sapp_set_clipboard_string(str byteptr)
/* read string from clipboard (usually during SAPP_EVENTTYPE_CLIPBOARD_PASTED) */
fn C.sapp_get_clipboard_string() byteptr

/* special run-function for SOKOL_NO_ENTRY (in standard mode this is an empty stub) */
fn C.sapp_run(desc &C.sapp_desc) int

/* GL: return true when GLES2 fallback is active (to detect fallback from GLES3) */
fn C.sapp_gles2() bool

/* HTML5: enable or disable the hardwired "Leave Site?" dialog box */
fn C.sapp_html5_ask_leave_site(ask bool)

/* Metal: get ARC-bridged pointer to Metal device object */
fn C.sapp_metal_get_device() voidptr
/* Metal: get ARC-bridged pointer to this frame's renderpass descriptor */
fn C.sapp_metal_get_renderpass_descriptor() voidptr
/* Metal: get ARC-bridged pointer to current drawable */
fn C.sapp_metal_get_drawable() voidptr
/* macOS: get ARC-bridged pointer to macOS NSWindow */
fn C.sapp_macos_get_window() voidptr
/* iOS: get ARC-bridged pointer to iOS UIWindow */
fn C.sapp_ios_get_window() voidptr

/* D3D11: get pointer to ID3D11Device object */
fn C.sapp_d3d11_get_device() voidptr
/* D3D11: get pointer to ID3D11DeviceContext object */
fn C.sapp_d3d11_get_device_context() voidptr
/* D3D11: get pointer to ID3D11RenderTargetView object */
fn C.sapp_d3d11_get_render_target_view() voidptr
/* D3D11: get pointer to ID3D11DepthStencilView */
fn C.sapp_d3d11_get_depth_stencil_view() voidptr
/* Win32: get the HWND window handle */
fn C.sapp_win32_get_hwnd() voidptr
/* Android: get native activity handle */
fn C.sapp_android_get_native_activity() voidptr
module sapp

pub struct C.sapp_desc {
pub:
	init_cb fn()					/* these are the user-provided callbacks without user data */
	frame_cb fn()
	cleanup_cb fn()
	event_cb fn(&C.sapp_event) //&sapp_event)
	fail_cb fn(byteptr)

    user_data voidptr                /* these are the user-provided callbacks with user data */
	init_userdata_cb fn(voidptr)
	frame_userdata_cb fn(voidptr)
	cleanup_userdata_cb fn(voidptr)
	event_userdata_cb fn(&C.sapp_event, voidptr)
	fail_userdata_cb fn(byteptr,voidptr)

    width int                          /* the preferred width of the window / canvas */
    height int                         /* the preferred height of the window / canvas */
    sample_count int                   /* MSAA sample count */
    swap_interval int                  /* the preferred swap interval (ignored on some platforms) */
    high_dpi bool                      /* whether the rendering canvas is full-resolution on HighDPI displays */
    fullscreen bool                    /* whether the window should be created in fullscreen mode */
    alpha bool                         /* whether the framebuffer should have an alpha channel (ignored on some platforms) */
    window_title byteptr	           /* the window title as UTF-8 encoded string */
    user_cursor bool                   /* if true, user is expected to manage cursor image in SAPP_EVENTTYPE_UPDATE_CURSOR */
    enable_clipboard bool              /* enable clipboard access, default is false */
    clipboard_size int                 /* max size of clipboard content in bytes */

    html5_canvas_name byteptr          /* the name (id) of the HTML5 canvas element, default is "canvas" */
    html5_canvas_resize bool           /* if true, the HTML5 canvas size is set to sapp_desc.width/height, otherwise canvas size is tracked */
    html5_preserve_drawing_buffer bool /* HTML5 only: whether to preserve default framebuffer content between frames */
    html5_premultiplied_alpha bool     /* HTML5 only: whether the rendered pixels use premultiplied alpha convention */
    html5_ask_leave_site bool          /* initial state of the internal html5_ask_leave_site flag (see sapp_html5_ask_leave_site()) */
    ios_keyboard_resizes_canvas bool   /* if true, showing the iOS keyboard shrinks the canvas */
    gl_force_gles2 bool                /* if true, setup GLES2/WebGL even if GLES3/WebGL2 is available */
}

pub struct C.sapp_event {
pub:
    frame_count u64
    @type EventType
    key_code KeyCode
    char_code u32
    key_repeat bool
    modifiers u32
    mouse_button MouseButton
    mouse_x f32
    mouse_y f32
    scroll_x f32
    scroll_y f32
    num_touches int
    touches [8]C.sapp_touchpoint
    window_width int
    window_height int
    framebuffer_width int
    framebuffer_height int
}
pub fn (e &C.sapp_event) str() string {
    return 'evt: frame_count=$e.frame_count, type=${e.@type}'
}

pub struct C.sapp_touchpoint {
pub:
    identifier u64
    pos_x f32
    pos_y f32
    changed bool
}
module sfons

import fontstash

const (
	// keep v from warning about unused imports
	used_import = fontstash.used_import + 1
)

[inline]
pub fn create(width int, height int, flags int) &C.FONScontext {
	return C.sfons_create(width, height, flags)
}

[inline]
pub fn destroy(ctx &C.FONScontext) {
	C.sfons_destroy(ctx)
}

[inline]
pub fn rgba(r byte, g byte, b byte, a byte) u32 {
	return C.sfons_rgba(r, g, b, a)
}

[inline]
pub fn flush(ctx &C.FONScontext) {
	C.sfons_flush(ctx)
}

module sfons

fn C.sfons_create(width int, height int, flags int) &C.FONScontext
fn C.sfons_destroy(ctx &FONScontext)
fn C.sfons_rgba(r byte, g byte, b byte, a byte) u32
fn C.sfons_flush(ctx &FONScontext)
module sgl


/* setup/shutdown/misc */
[inline]
pub fn setup(desc &C.sgl_desc_t) {
	C.sgl_setup(desc)
}

[inline]
pub fn shutdown() {
	C.sgl_shutdown()
}

[inline]
pub fn error() C.sgl_error_t {
	return C.sgl_error()
}

[inline]
pub fn defaults() {
	C.sgl_defaults()
}

[inline]
pub fn rad(deg f32) f32 {
	return C.sgl_rad(deg)
}

[inline]
pub fn deg(rad f32) f32 {
	return C.sgl_deg(rad)
}

/* create and destroy pipeline objects */
[inline]
pub fn make_pipeline(desc &C.sg_pipeline_desc) C.sgl_pipeline {
	return C.sgl_make_pipeline(desc)
}

[inline]
pub fn destroy_pipeline(pip C.sgl_pipeline) {
	C.sgl_destroy_pipeline(pip)
}

/* render state functions */
[inline]
pub fn viewport(x int, y int, w int, h int, origin_top_left bool) {
	C.sgl_viewport(x, y, w, h, origin_top_left)
}

[inline]
pub fn scissor_rect(x int, y int, w int, h int, origin_top_left bool) {
	C.sgl_scissor_rect(x, y, w, h, origin_top_left)
}

[inline]
pub fn enable_texture() {
	C.sgl_enable_texture()
}

[inline]
pub fn disable_texture() {
	C.sgl_disable_texture()
}

[inline]
pub fn texture(img C.sg_image) {
	C.sgl_texture(img)
}

/* pipeline stack functions */
[inline]
pub fn default_pipeline() {
	C.sgl_default_pipeline()
}

[inline]
pub fn load_pipeline(pip C.sgl_pipeline) {
	C.sgl_load_pipeline(pip)
}

[inline]
pub fn push_pipeline() {
	C.sgl_push_pipeline()
}

[inline]
pub fn pop_pipeline() {
	C.sgl_pop_pipeline()
}

/* matrix stack functions */
[inline]
pub fn matrix_mode_modelview() {
	C.sgl_matrix_mode_modelview()
}

[inline]
pub fn matrix_mode_projection() {
	C.sgl_matrix_mode_projection()
}

[inline]
pub fn matrix_mode_texture() {
	C.sgl_matrix_mode_texture()
}

[inline]
pub fn load_identity() {
	C.sgl_load_identity()
}

[inline]
pub fn load_matrix(m []f32) {
	C.sgl_load_matrix(m.data)
}

[inline]
pub fn load_transpose_matrix(m []f32) {
	C.sgl_load_transpose_matrix(m.data)
}

[inline]
pub fn mult_matrix(m []f32) {
	C.sgl_mult_matrix(m.data)
}

[inline]
pub fn mult_transpose_matrix(m []f32) {
	C.sgl_mult_transpose_matrix(m.data)
}

[inline]
pub fn rotate(angle_rad f32, x f32, y f32, z f32) {
	C.sgl_rotate(angle_rad, x, y, z)
}

[inline]
pub fn scale(x f32, y f32, z f32) {
	C.sgl_scale(x, y, z)
}

[inline]
pub fn translate(x f32, y f32, z f32) {
	C.sgl_translate(x, y, z)
}

[inline]
pub fn frustum(l f32, r f32, b f32, t f32, n f32, f f32) {
	C.sgl_frustum(l, r, b, t, n, f)
}

[inline]
pub fn ortho(l f32, r f32, b f32, t f32, n f32, f f32) {
	C.sgl_ortho(l, r, b, t, n, f)
}

[inline]
pub fn perspective(fov_y f32, aspect f32, z_near f32, z_far f32) {
	C.sgl_perspective(fov_y, aspect, z_near, z_far)
}

[inline]
pub fn lookat(eye_x f32, eye_y f32, eye_z f32, center_x f32, center_y f32, center_z f32, up_x f32, up_y f32, up_z f32) {
	C.sgl_lookat(eye_x, eye_y, eye_z, center_x, center_y, center_z, up_x, up_y, up_z)
}

[inline]
pub fn push_matrix() {
	C.sgl_push_matrix()
}

[inline]
pub fn pop_matrix() {
	C.sgl_pop_matrix()
}

/* these functions only set the internal 'current texcoord / color' (valid inside or outside begin/end) */
[inline]
pub fn t2f(u f32, v f32) {
	C.sgl_t2f(u, v)
}

[inline]
pub fn c3f(r f32, g f32, b f32) {
	C.sgl_c3f(r, g, b)
}

[inline]
pub fn c4f(r f32, g f32, b f32, a f32) {
	C.sgl_c4f(r, g, b, a)
}

[inline]
pub fn c3b(r byte, g byte, b byte) {
	C.sgl_c3b(r, g, b)
}

[inline]
pub fn c4b(r byte, g byte, b byte, a byte) {
	C.sgl_c4b(r, g, b, a)
}

[inline]
pub fn c1i(rgba u32) {
	C.sgl_c1i(rgba)
}

/* define primitives, each begin/end is one draw command */
[inline]
pub fn begin_points() {
	C.sgl_begin_points()
}

[inline]
pub fn begin_lines() {
	C.sgl_begin_lines()
}

[inline]
pub fn begin_line_strip() {
	C.sgl_begin_line_strip()
}

[inline]
pub fn begin_triangles() {
	C.sgl_begin_triangles()
}

[inline]
pub fn begin_triangle_strip() {
	C.sgl_begin_triangle_strip()
}

[inline]
pub fn begin_quads() {
	C.sgl_begin_quads()
}

[inline]
pub fn v2f(x f32, y f32) {
	C.sgl_v2f(x, y)
}

[inline]
pub fn v3f(x f32, y f32, z f32) {
	C.sgl_v3f(x, y, z)
}

[inline]
pub fn v2f_t2f(x f32, y f32, u f32, v f32) {
	C.sgl_v2f_t2f(x, y, u, v)
}

[inline]
pub fn v3f_t2f(x f32, y f32, z f32, u f32, v f32) {
	C.sgl_v3f_t2f(x, y, z, u, v)
}

[inline]
pub fn v2f_c3f(x f32, y f32, r f32, g f32, b f32) {
	C.sgl_v2f_c3f(x, y, r, g, b)
}

[inline]
pub fn v2f_c3b(x f32, y f32, r byte, g byte, b byte) {
	C.sgl_v2f_c3b(x, y, r, g, b)
}

[inline]
pub fn v2f_c4f(x f32, y f32, r f32, g f32, b f32, a f32) {
	C.sgl_v2f_c4f(x, y, r, g, b, a)
}

[inline]
pub fn v2f_c4b(x f32, y f32, r byte, g byte, b byte, a byte) {
	C.sgl_v2f_c4b(x, y, r, g, b, a)
}

[inline]
pub fn v2f_c1i(x f32, y f32, rgba u32) {
	C.sgl_v2f_c1i(x, y, rgba)
}

[inline]
pub fn v3f_c3f(x f32, y f32, z f32, r f32, g f32, b f32) {
	C.sgl_v3f_c3f(x, y, z, r, g, b)
}

[inline]
pub fn v3f_c3b(x f32, y f32, z f32, r byte, g byte, b byte) {
	C.sgl_v3f_c3b(x, y, z, r, g, b)
}

[inline]
pub fn v3f_c4f(x f32, y f32, z f32, r f32, g f32, b f32, a f32) {
	C.sgl_v3f_c4f(x, y, z, r, g, b, a)
}

[inline]
pub fn v3f_c4b(x f32, y f32, z f32, r byte, g byte, b byte, a byte) {
	C.sgl_v3f_c4b(x, y, z, r, g, b, a)
}

[inline]
pub fn v3f_c1i(x f32, y f32, z f32, rgba u32) {
	C.sgl_v3f_c1i(x, y, z, rgba)
}

[inline]
pub fn v2f_t2f_c3f(x f32, y f32, u f32, v f32, r f32, g f32, b f32) {
	C.sgl_v2f_t2f_c3f(x, y, u, v, r, g, b)
}

[inline]
pub fn v2f_t2f_c3b(x f32, y f32, u f32, v f32, r byte, g byte, b byte) {
	C.sgl_v2f_t2f_c3b(x, y, u, v, r, g, b)
}

[inline]
pub fn v2f_t2f_c4f(x f32, y f32, u f32, v f32, r f32, g f32, b f32, a f32) {
	C.sgl_v2f_t2f_c4f(x, y, u, v, r, g, b, a)
}

[inline]
pub fn v2f_t2f_c4b(x f32, y f32, u f32, v f32, r byte, g byte, b byte, a byte) {
	C.sgl_v2f_t2f_c4b(x, y, u, v, r, g, b, a)
}

[inline]
pub fn v2f_t2f_c1i(x f32, y f32, u f32, v f32, rgba u32) {
	C.sgl_v2f_t2f_c1i(x, y, u, v, rgba)
}

[inline]
pub fn v3f_t2f_c3f(x f32, y f32, z f32, u f32, v f32, r f32, g f32, b f32) {
	C.sgl_v3f_t2f_c3f(x, y, z, u, v, r, g, b)
}

[inline]
pub fn v3f_t2f_c3b(x f32, y f32, z f32, u f32, v f32, r byte, g byte, b byte) {
	C.sgl_v3f_t2f_c3b(x, y, z, u, v, r, g, b)
}

[inline]
pub fn v3f_t2f_c4f(x f32, y f32, z f32, u f32, v f32, r f32, g f32, b f32, a f32) {
	C.sgl_v3f_t2f_c4f(x, y, z, u, v, r, g, b, a)
}

[inline]
pub fn v3f_t2f_c4b(x f32, y f32, z f32, u f32, v f32, r byte, g byte, b byte, a byte) {
	C.sgl_v3f_t2f_c4b(x, y, z, u, v, r, g, b, a)
}

[inline]
pub fn v3f_t2f_c1i(x f32, y f32, z f32, u f32, v f32, rgba u32) {
	C.sgl_v3f_t2f_c1i(x, y, z, u, v, rgba)
}

[inline]
pub fn end() {
	C.sgl_end()
}

/* render everything */
[inline]
pub fn draw() {
	C.sgl_draw()
}

module sgl

/* setup/shutdown/misc */
fn C.sgl_setup(desc &C.sgl_desc_t)
fn C.sgl_shutdown()
fn C.sgl_error() C.sgl_error_t
fn C.sgl_defaults()
fn C.sgl_rad(deg f32) f32
fn C.sgl_deg(rad f32) f32

/* create and destroy pipeline objects */
fn C.sgl_make_pipeline(desc &C.sg_pipeline_desc) C.sgl_pipeline
fn C.sgl_destroy_pipeline(pip C.sgl_pipeline)

/* render state functions */
fn C.sgl_viewport(x int, y int, w int, h int, origin_top_left bool)
fn C.sgl_scissor_rect(x int, y int, w int, h int, origin_top_left bool)
fn C.sgl_enable_texture()
fn C.sgl_disable_texture()
fn C.sgl_texture(img C.sg_image)

/* pipeline stack functions */
fn C.sgl_default_pipeline()
fn C.sgl_load_pipeline(pip C.sgl_pipeline)
fn C.sgl_push_pipeline()
fn C.sgl_pop_pipeline()

/* matrix stack functions */
fn C.sgl_matrix_mode_modelview()
fn C.sgl_matrix_mode_projection()
fn C.sgl_matrix_mode_texture()
fn C.sgl_load_identity()
fn C.sgl_load_matrix(m []f32) // should be [16]f32
fn C.sgl_load_transpose_matrix(m []f32) // should be [16]f32
fn C.sgl_mult_matrix(m []f32)
fn C.sgl_mult_transpose_matrix(m []f32) // should be [16]f32
fn C.sgl_rotate(angle_rad f32, x f32, y f32, z f32)
fn C.sgl_scale(x f32, y f32, z f32)
fn C.sgl_translate(x f32, y f32, z f32)
fn C.sgl_frustum(l f32, r f32, b f32, t f32, n f32, f f32)
fn C.sgl_ortho(l f32, r f32, b f32, t f32, n f32, f f32)
fn C.sgl_perspective(fov_y f32, aspect f32, z_near f32, z_far f32)
fn C.sgl_lookat(eye_x f32, eye_y f32, eye_z f32, center_x f32, center_y f32, center_z f32, up_x f32, up_y f32, up_z f32)
fn C.sgl_push_matrix()
fn C.sgl_pop_matrix()

/* these functions only set the internal 'current texcoord / color' (valid inside or outside begin/end) */
fn C.sgl_t2f(u f32, v f32)
fn C.sgl_c3f(r f32, g f32, b f32)
fn C.sgl_c4f(r f32, g f32, b f32, a f32)
fn C.sgl_c3b(r byte, g byte, b byte)
fn C.sgl_c4b(r byte, g byte, b byte, a byte)
fn C.sgl_c1i(rgba u32)

/* define primitives, each begin/end is one draw command */
fn C.sgl_begin_points()
fn C.sgl_begin_lines()
fn C.sgl_begin_line_strip()
fn C.sgl_begin_triangles()
fn C.sgl_begin_triangle_strip()
fn C.sgl_begin_quads()
fn C.sgl_v2f(x f32, y f32)
fn C.sgl_v3f(x f32, y f32, z f32)
fn C.sgl_v2f_t2f(x f32, y f32, u f32, v f32)
fn C.sgl_v3f_t2f(x f32, y f32, z f32, u f32, v f32)
fn C.sgl_v2f_c3f(x f32, y f32, r f32, g f32, b f32)
fn C.sgl_v2f_c3b(x f32, y f32, r byte, g byte, b byte)
fn C.sgl_v2f_c4f(x f32, y f32, r f32, g f32, b f32, a f32)
fn C.sgl_v2f_c4b(x f32, y f32, r byte, g byte, b byte, a byte)
fn C.sgl_v2f_c1i(x f32, y f32, rgba u32)
fn C.sgl_v3f_c3f(x f32, y f32, z f32, r f32, g f32, b f32)
fn C.sgl_v3f_c3b(x f32, y f32, z f32, r byte, g byte, b byte)
fn C.sgl_v3f_c4f(x f32, y f32, z f32, r f32, g f32, b f32, a f32)
fn C.sgl_v3f_c4b(x f32, y f32, z f32, r byte, g byte, b byte, a byte)
fn C.sgl_v3f_c1i(x f32, y f32, z f32, rgba u32)
fn C.sgl_v2f_t2f_c3f(x f32, y f32, u f32, v f32, r f32, g f32, b f32)
fn C.sgl_v2f_t2f_c3b(x f32, y f32, u f32, v f32, r byte, g byte, b byte)
fn C.sgl_v2f_t2f_c4f(x f32, y f32, u f32, v f32, r f32, g f32, b f32, a f32)
fn C.sgl_v2f_t2f_c4b(x f32, y f32, u f32, v f32, r byte, g byte, b byte, a byte)
fn C.sgl_v2f_t2f_c1i(x f32, y f32, u f32, v f32, rgba u32)
fn C.sgl_v3f_t2f_c3f(x f32, y f32, z f32, u f32, v f32, r f32, g f32, b f32)
fn C.sgl_v3f_t2f_c3b(x f32, y f32, z f32, u f32, v f32, r byte, g byte, b byte)
fn C.sgl_v3f_t2f_c4f(x f32, y f32, z f32, u f32, v f32, r f32, g f32, b f32, a f32)
fn C.sgl_v3f_t2f_c4b(x f32, y f32, z f32, u f32, v f32, r byte, g byte, b byte, a byte)
fn C.sgl_v3f_t2f_c1i(x f32, y f32, z f32, u f32, v f32, rgba u32)
fn C.sgl_end()

/* render everything */
fn C.sgl_draw()
module sgl

// should be in a proper module
pub enum SglError {
    no_error
	vertices_full
	commands_full
	stack_overflow
	stack_underfloat
}

pub struct C.sgl_pipeline {
	id u32
}

pub struct C.sgl_desc_t {
    max_vertices int       /* size for vertex buffer */
    max_commands int       /* size of uniform- and command-buffers */
    pipeline_pool_size int /* size of the internal pipeline pool, default is 64 */
    color_format C.sg_pixel_format
    depth_format C.sg_pixel_format
    sample_count int
    face_winding C.sg_face_winding /* default front face winding is CCW */
}

# to use module `sqlite`, install `sqlite-devel` first.

for **Fedora 31**:

     sudo dnf -y install `sqlite-devel`


 for **Ubuntu 20.04**:
     sudo apt install -y `libsqlite3-dev`
     

module sqlite

#flag -lsqlite3
#flag freebsd -I/usr/local/include
#flag freebsd -Wl -L/usr/local/lib -lsqlite3
#include "sqlite3.h"

struct C.sqlite3 {}
struct C.sqlite3_stmt {}

pub struct DB {
mut:
	conn &C.sqlite3
}

pub struct Row {
pub mut:
	vals []string
}

fn C.sqlite3_column_text(voidptr, int) byteptr
fn C.sqlite3_column_int(voidptr, int) int
fn C.sqlite3_open()
fn C.sqlite3_step() int
fn C.sqlite3_prepare_v2()
fn C.sqlite3_finalize()
fn C.sqlite3_column_count(voidptr) int

// Opens the connection with a database.
pub fn connect(path string) DB {
	db := &C.sqlite3(0)
	C.sqlite3_open(path.str, &db)
	return DB{
		conn: db
	}
}

// Returns a single cell with value int.
pub fn (db DB) q_int(query string) int {
	stmt := &C.sqlite3_stmt(0)
	C.sqlite3_prepare_v2(db.conn, query.str, -1, &stmt, 0)
	C.sqlite3_step(stmt)
	res := C.sqlite3_column_int(stmt, 0)
	C.sqlite3_finalize(stmt)
	return res
}

// Returns a single cell with value string.
pub fn (db DB) q_string(query string) string {
	stmt := &C.sqlite3_stmt(0)
	C.sqlite3_prepare_v2(db.conn, query.str, -1, &stmt, 0)
	C.sqlite3_step(stmt)
	res := tos_clone(C.sqlite3_column_text(stmt, 0))
	C.sqlite3_finalize(stmt)
	return res
}


// Execute the query on db, return an array of all the results, alongside any result code.
// Result codes: https://www.sqlite.org/rescode.html
pub fn (db DB) exec(query string) ([]Row,int) {
	stmt := &C.sqlite3_stmt(0)
	C.sqlite3_prepare_v2(db.conn, query.str, -1, &stmt, 0)
	nr_cols := C.sqlite3_column_count(stmt)
	mut res := 0
	mut rows := []Row{}
	for {
		res = C.sqlite3_step(stmt)
		// Result Code SQLITE_ROW; Another row is available
		if res != 100 {
			break
		}
		mut row := Row{}
		for i in 0 .. nr_cols {
			val := tos_clone(C.sqlite3_column_text(stmt, i))
			row.vals << val
		}
		rows << row
	}
	return rows,res
}

// Execute a query, handle error code
// Return the first row from the resulting table
pub fn (db DB) exec_one(query string) ?Row {
	rows,code := db.exec(query)
	if rows.len == 0 || code != 101 {
		return error('SQL Error: Rows #$rows.len Return code $code')
	}
	return rows[0]
}

// In case you don't expect any result, but still want an error code
// e.g. INSERT INTO ... VALUES (...)
pub fn (db DB) exec_none(query string) int {
	_,code := db.exec(query)
	return code
}

/* TODO
pub fn (db DB) exec_param(query string, param string) []Row {
}
*/
import sqlite

fn test_sqlite() {
	$if !linux {
		return
	}
	db := sqlite.connect(':memory:')
	db.exec("drop table if exists users")
	db.exec("create table users (id integer primary key, name text default '');")

	db.exec("insert into users (name) values ('Sam')")
	db.exec("insert into users (name) values ('Peter')")
	db.exec("insert into users (name) values ('Kate')")

	nr_users := db.q_int('select count(*) from users')
	assert nr_users == 3

	name := db.q_string('select name from users where id = 1')
	assert name == 'Sam'

	users, mut code := db.exec('select * from users')
	assert users.len == 3
	assert code == 101

	code = db.exec_none('vacuum')
	assert code == 101

	user := db.exec_one('select * from users where id = 3') or {
		panic(err)
	}
	assert user.vals.len == 2
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module stbi

// note we might need special case for this
// import gl

#flag -I @VROOT/thirdparty/stb_image
#include "stb_image.h"
#flag @VROOT/thirdparty/stb_image/stbi.o

pub struct Image {
pub mut:
	width       int
	height      int
	nr_channels int
	ok          bool
	data        voidptr
	ext         string
}

fn C.stbi_load() voidptr
fn C.stbi_load_from_memory() voidptr
fn C.stbi_image_free()
fn C.stbi_set_flip_vertically_on_load()

pub fn load(path string) Image {
	ext := path.all_after_last('.')
	mut res := Image {
		ok: true
		ext: ext
		data: 0
	}
	flag := if ext == 'png' { C.STBI_rgb_alpha } else { 0 }
	res.data = C.stbi_load(path.str, &res.width, &res.height,	&res.nr_channels, flag)
	if isnil(res.data) {
		println('stbi image failed to load')
		exit(1)
	}
	return res
}

//pub fn load_from_memory(buf []byte) Image {
pub fn load_from_memory(buf byteptr) Image {
	mut res := Image {
		ok: true
		data: 0
	}
	flag := C.STBI_rgb_alpha
	res.data = C.stbi_load_from_memory(buf, 3812, &res.width, &res.height,	&res.nr_channels, flag)
	if isnil(res.data) {
		println('stbi image failed to load from memory')
		exit(1)
	}
	return res
}


pub fn (img Image) free() {
	C.stbi_image_free(img.data)
}

pub fn (img Image) tex_image_2d() {
	mut rgb_flag := C.GL_RGB
	if img.ext == 'png' {
		rgb_flag = C.GL_RGBA
	}
	C.glTexImage2D(C.GL_TEXTURE_2D, 0, rgb_flag, img.width, img.height, 0,
		rgb_flag, C.GL_UNSIGNED_BYTE,	img.data)
}

pub fn set_flip_vertically_on_load(val bool) {
	C.stbi_set_flip_vertically_on_load(val)
}

/**********************************************************************
*
* atof util
*
* Copyright (c) 2019 Dario Deledda. All rights reserved.
* Use of this source code is governed by an MIT license
* that can be found in the LICENSE file.
*
* This file contains utilities for convert a string in a f64 variable
* IEEE 754 standard is used
*
* Know limitation:
* - limited to 18 significant digits
*
* The code is inspired by:
* Grzegorz Kraszewski krashan@teleinfo.pb.edu.pl
* URL: http://krashan.ppa.pl/articles/stringtofloat/
* Original license: MIT
*
**********************************************************************/
module strconv

union Float64u {
mut:
	f f64
	u u64
}

/**********************************************************************
*
* 96 bit operation utilities
* Note: when u128 will be available these function can be refactored
*
**********************************************************************/

// right logical shift 96 bit
fn lsr96(s2 u32, s1 u32, s0 u32) (u32,u32,u32) {
	mut r0 := u32(0)
	mut r1 := u32(0)
	mut r2 := u32(0)
	r0 = (s0>>1) | ((s1 & u32(1))<<31)
	r1 = (s1>>1) | ((s2 & u32(1))<<31)
	r2 = s2>>1
	return r2,r1,r0
}

// left logical shift 96 bit
fn lsl96(s2 u32, s1 u32, s0 u32) (u32,u32,u32) {
	mut r0 := u32(0)
	mut r1 := u32(0)
	mut r2 := u32(0)
	r2 = (s2<<1) | ((s1 & (u32(1)<<31))>>31)
	r1 = (s1<<1) | ((s0 & (u32(1)<<31))>>31)
	r0 = s0<<1
	return r2,r1,r0
}

// sum on 96 bit
fn add96(s2 u32, s1 u32, s0 u32, d2 u32, d1 u32, d0 u32) (u32,u32,u32) {
	mut w := u64(0)
	mut r0 := u32(0)
	mut r1 := u32(0)
	mut r2 := u32(0)
	w = u64(s0) + u64(d0)
	r0 = u32(w)
	w >>= 32
	w += u64(s1) + u64(d1)
	r1 = u32(w)
	w >>= 32
	w += u64(s2) + u64(d2)
	r2 = u32(w)
	return r2,r1,r0
}

// subtraction on 96 bit
fn sub96(s2 u32, s1 u32, s0 u32, d2 u32, d1 u32, d0 u32) (u32,u32,u32) {
	mut w := u64(0)
	mut r0 := u32(0)
	mut r1 := u32(0)
	mut r2 := u32(0)
	w = u64(s0) - u64(d0)
	r0 = u32(w)
	w >>= 32
	w += u64(s1) - u64(d1)
	r1 = u32(w)
	w >>= 32
	w += u64(s2) - u64(d2)
	r2 = u32(w)
	return r2,r1,r0
}

/**********************************************************************
*
* Constants
*
**********************************************************************/


const (
//
// f64 constants
//
	digits = 18
	double_plus_zero = u64(0x0000000000000000)
	double_minus_zero = u64(0x8000000000000000)
	double_plus_infinity = u64(0x7FF0000000000000)
	double_minus_infinity = u64(0xFFF0000000000000)
	//
	// parser state machine states
	//
	fsm_a = 0
	fsm_b = 1
	fsm_c = 2
	fsm_d = 3
	fsm_e = 4
	fsm_f = 5
	fsm_g = 6
	fsm_h = 7
	fsm_i = 8
	fsm_stop = 9
	//
	// Possible parser return values.
	//
	parser_ok = 0 // parser finished OK
	parser_pzero = 1 // no digits or number is smaller than +-2^-1022
	parser_mzero = 2 // number is negative, module smaller
	parser_pinf = 3 // number is higher than +HUGE_VAL
	parser_minf = 4 // number is lower than -HUGE_VAL
	//
	// char constants
	// Note: Modify these if working with non-ASCII encoding
	//
	c_dpoint = `.`
	c_plus = `+`
	c_minus = `-`
	c_zero = `0`
	c_nine = `9`
	c_ten = u32(10)
)
/**********************************************************************
*
* Utility
*
**********************************************************************/

// NOTE: Modify these if working with non-ASCII encoding
fn is_digit(x byte) bool {
	return (x >= c_zero && x <= c_nine) == true
}

fn is_space(x byte) bool {
	return ((x >= 0x89 && x <= 0x13) || x == 0x20) == true
}

fn is_exp(x byte) bool {
	return (x == `E` || x == `e`) == true
}

/**********************************************************************
*
* Support struct
*
**********************************************************************/

// The structure is filled by parser, then given to converter.
pub struct PrepNumber {
pub mut:
	negative bool // 0 if positive number, 1 if negative
	exponent int // power of 10 exponent
	mantissa u64 // integer mantissa
}
/**********************************************************************
*
* String parser
* NOTE: #TOFIX need one char after the last char of the number
*
**********************************************************************/

// parser return a support struct with all the parsing information for the converter
fn parser(s string) (int,PrepNumber) {
	mut state := fsm_a
	mut digx := 0
	mut c := ` ` // initial value for kicking off the state machine
	mut result := parser_ok
	mut expneg := false
	mut expexp := 0
	mut i := 0
	mut pn := PrepNumber{
	}
	for state != fsm_stop {
		match state {
			// skip starting spaces
			fsm_a {
				if is_space(c) == true {
					c = s[i++]
				}
				else {
					state = fsm_b
				}
			}
			// check for the sign or point
			fsm_b {
				state = fsm_c
				if c == c_plus {
					c = s[i++]
					//i++
				}
				else if c == c_minus {
					pn.negative = true
					c = s[i++]
				}
				else if is_digit(c) {
				}
				else if c == c_dpoint {
				}
				else {
					state = fsm_stop
				}
			}
			// skip the inital zeros
			fsm_c {
				if c == c_zero {
					c = s[i++]
				}
				else if c == c_dpoint {
					c = s[i++]
					state = fsm_d
				}
				else {
					state = fsm_e
				}
			}
			// reading leading zeros in the fractional part of mantissa
			fsm_d {
				if c == c_zero {
					c = s[i++]
					if pn.exponent > -2147483647 {
						pn.exponent--
					}
				}
				else {
					state = fsm_f
				}
			}
			// reading integer part of mantissa
			fsm_e {
				if is_digit(c) {
					if digx < digits {
						pn.mantissa *= 10
						pn.mantissa += u64(c - c_zero)
						digx++
					}
					else if pn.exponent < 2147483647 {
						pn.exponent++
					}
					c = s[i++]
				}
				else if c == c_dpoint {
					c = s[i++]
					state = fsm_f
				}
				else {
					state = fsm_f
				}
			}
			// reading fractional part of mantissa
			fsm_f {
				if is_digit(c) {
					if digx < digits {
						pn.mantissa *= 10
						pn.mantissa += u64(c - c_zero)
						pn.exponent--
						digx++
					}
					c = s[i++]
				}
				else if is_exp(c) {
					c = s[i++]
					state = fsm_g
				}
				else {
					state = fsm_g
				}
			}
			// reading sign of exponent
			fsm_g {
				if c == c_plus {
					c = s[i++]
				}
				else if c == c_minus {
					expneg = true
					c = s[i++]
				}
				state = fsm_h
			}
			// skipping leading zeros of exponent
			fsm_h {
				if c == c_zero {
					c = s[i++]
				}
				else {
					state = fsm_i
				}
			}
			// reading exponent digits
			fsm_i {
				if is_digit(c) {
					if expexp < 214748364 {
						expexp *= 10
						expexp += int(c - c_zero)
					}
					c = s[i++]
				}
				else {
					state = fsm_stop
				}
			}
			else {
			}}
		// C.printf("len: %d i: %d str: %s \n",s.len,i,s[..i])
		if i >= s.len {
			state = fsm_stop
		}
	}
	if expneg {
		expexp = -expexp
	}
	pn.exponent += expexp
	if pn.mantissa == 0 {
		if pn.negative {
			result = parser_mzero
		}
		else {
			result = parser_pzero
		}
	}
	else if pn.exponent > 309 {
		if pn.negative {
			result = parser_minf
		}
		else {
			result = parser_pinf
		}
	}
	else if pn.exponent < -328 {
		if pn.negative {
			result = parser_mzero
		}
		else {
			result = parser_pzero
		}
	}
	return result,pn
}

/**********************************************************************
*
* Converter to the bit form of the f64 number
*
**********************************************************************/

// converter return a u64 with the bit image of the f64 number
fn converter(pn mut PrepNumber) u64 {
	mut binexp := 92
	mut s2 := u32(0) // 96-bit precision integer
	mut s1 := u32(0)
	mut s0 := u32(0)
	mut q2 := u32(0) // 96-bit precision integer
	mut q1 := u32(0)
	mut q0 := u32(0)
	mut r2 := u32(0) // 96-bit precision integer
	mut r1 := u32(0)
	mut r0 := u32(0)
	mask28 := u32(0xF<<28)
	mut result := u64(0)
	// working on 3 u32 to have 96 bit precision
	s0 = u32(pn.mantissa & u64(0x00000000FFFFFFFF))
	s1 = u32(pn.mantissa>>32)
	s2 = u32(0)
	// so we take the decimal exponent off
	for pn.exponent > 0 {
		q2,q1,q0 = lsl96(s2, s1, s0) // q = s * 2
		r2,r1,r0 = lsl96(q2, q1, q0) // r = s * 4 <=> q * 2
		s2,s1,s0 = lsl96(r2, r1, r0) // s = s * 8 <=> r * 2
		s2,s1,s0 = add96(s2, s1, s0, q2, q1, q0) // s = (s * 8) + (s * 2) <=> s*10
		pn.exponent--
		for (s2 & mask28) != 0 {
			q2,q1,q0 = lsr96(s2, s1, s0)
			binexp++
			s2 = q2
			s1 = q1
			s0 = q0
		}
	}
	for pn.exponent < 0 {
		for !((s2 & (u32(1)<<31)) != 0) {
			q2,q1,q0 = lsl96(s2, s1, s0)
			binexp--
			s2 = q2
			s1 = q1
			s0 = q0
		}
		q2 = s2 / c_ten
		r1 = s2 % c_ten
		r2 = (s1>>8) | (r1<<24)
		q1 = r2 / c_ten
		r1 = r2 % c_ten
		r2 = ((s1 & u32(0xFF))<<16) | (s0>>16) | (r1<<24)
		r0 = r2 / c_ten
		r1 = r2 % c_ten
		q1 = (q1<<8) | ((r0 & u32(0x00FF0000))>>16)
		q0 = r0<<16
		r2 = (s0 & u32(0xFFFF)) | (r1<<16)
		q0 |= r2 / c_ten
		s2 = q2
		s1 = q1
		s0 = q0
		pn.exponent++
	}
	// C.printf("mantissa before normalization: %08x%08x%08x binexp: %d \n", s2,s1,s0,binexp)
	// normalization, the 28 bit in s2 must the leftest one in the variable
	if s2 != 0 || s1 != 0 || s0 != 0 {
		for (s2 & mask28) == 0 {
			q2,q1,q0 = lsl96(s2, s1, s0)
			binexp--
			s2 = q2
			s1 = q1
			s0 = q0
		}
	}
	// rounding if needed
	/*
	* "round half to even" algorithm
	* Example for f32, just a reminder
	*
	* If bit 54 is 0, round down
	* If bit 54 is 1
	*	If any bit beyond bit 54 is 1, round up
	*	If all bits beyond bit 54 are 0 (meaning the number is halfway between two floating-point numbers)
	*		If bit 53 is 0, round down
	*		If bit 53 is 1, round up
	*/
	/* test case 1 complete
	s2=0x1FFFFFFF
	s1=0xFFFFFF80
	s0=0x0
	*/

	/* test case 1 check_round_bit
	s2=0x18888888
	s1=0x88888880
	s0=0x0
	*/

	/* test case  check_round_bit + normalization
	s2=0x18888888
	s1=0x88888F80
	s0=0x0
	*/

	// C.printf("mantissa before rounding: %08x%08x%08x binexp: %d \n", s2,s1,s0,binexp)
	// s1 => 0xFFFFFFxx only F are rapresented
	nbit := 7
	check_round_bit := u32(1)<<u32(nbit)
	check_round_mask := u32(0xFFFFFFFF)<<u32(nbit)
	if (s1 & check_round_bit) != 0 {
		// C.printf("need round!! cehck mask: %08x\n", s1 & ~check_round_mask )
		if (s1 & ~check_round_mask) != 0 {
			// C.printf("Add 1!\n")
			s2,s1,s0 = add96(s2, s1, s0, 0, check_round_bit, 0)
		}
		else {
			// C.printf("All 0!\n")
			if (s1 & (check_round_bit<<u32(1))) != 0 {
				// C.printf("Add 1 form -1 bit control!\n")
				s2,s1,s0 = add96(s2, s1, s0, 0, check_round_bit, 0)
			}
		}
		s1 = s1 & check_round_mask
		s0 = u32(0)
		// recheck normalization
		if s2 & (mask28<<u32(1)) != 0 {
			// C.printf("Renormalize!!")
			q2,q1,q0 = lsr96(s2, s1, s0)
			binexp--
			s2 = q2
			s1 = q1
			s0 = q0
		}
	}
	// tmp := ( u64(s2 & ~mask28) << 24) | ((u64(s1) + u64(128)) >> 8)
	// C.printf("mantissa after rounding : %08x%08x%08x binexp: %d \n", s2,s1,s0,binexp)
	// C.printf("Tmp result: %016x\n",tmp)
	// end rounding
	// offset the binary exponent IEEE 754
	binexp += 1023
	if binexp > 2046 {
		if pn.negative {
			result = double_minus_infinity
		}
		else {
			result = double_plus_infinity
		}
	}
	else if binexp < 1 {
		if pn.negative {
			result = double_minus_zero
		}
		else {
			result = double_plus_zero
		}
	}
	else if s2 != 0 {
		mut q := u64(0)
		binexs2 := u64(binexp)<<52
		q = (u64(s2 & ~mask28)<<24) | ((u64(s1) + u64(128))>>8) | binexs2
		if pn.negative {
			q |= (u64(1)<<63)
		}
		result = q
	}
	return result
}

/**********************************************************************
*
* Public functions
*
**********************************************************************/

// atof64 return a f64 from a string doing a parsing operation
pub fn atof64(s string) f64 {
	mut pn := PrepNumber{
	}
	mut res_parsing := 0
	mut res  := Float64u{}

	res_parsing,pn = parser(s + ' ') // TODO: need an extra char for now
	// println(pn)
	match res_parsing {
		parser_ok {
			res.u = converter(mut pn)
		}
		parser_pzero {
			res.u = double_plus_zero
		}
		parser_mzero {
			res.u = double_minus_zero
		}
		parser_pinf {
			res.u = double_plus_infinity
		}
		parser_minf {
			res.u = double_minus_infinity
		}
		else {
		}}
	return res.f
}
/**********************************************************************
*
* String to float Test
*
**********************************************************************/
import strconv
import strconv.atofq

fn test_atof() {
	//
	// test set
	//

	// float64
	src_num := [
		f64(0.3),
		-0.3,
		0.004,
		-0.004,
		0.0,
		-0.0,
		31234567890123
	]

	// strings
	src_num_str := [
		'0.3',
		'-0.3',
		'0.004',
		'-0.004',
		'0.0',
		'-0.0',
		'31234567890123',
	]

	// check conversion case 1 string <=> string
	for c,x in src_num {
		// slow atof
		assert strconv.atof64(src_num_str[c]).strlong() == x.strlong()


		// quick atof
		mut s1 := (atofq.atof_quick(src_num_str[c]).str())
		mut s2 := (x.str())
		delta := s1.f64() - s2.f64()
		//println("$s1 $s2 $delta")
		assert delta < f64(1e-16)

		// test C.atof
		n1 := x.strsci(18)
		n2 := f64(C.atof(src_num_str[c].str)).strsci(18)
		//println("$n1 $n2")
		assert n1 == n2
	}

	// check conversion case 2 string <==> f64
	// we don't test atof_quick beacuse we already know the rounding error
	for c,x  in src_num_str {
		b := src_num[c].strlong()
		a1 := strconv.atof64(x).strlong()
		assert a1 == b
	}

	// special cases
	mut f1 := f64(0.0)
	mut ptr := &u64(&f1)
	ptr = &u64(&f1)

	// double_plus_zero
	f1=0.0
	assert *ptr == u64(0x0000000000000000)
	// double_minus_zero
	f1=-0.0
	assert *ptr == u64(0x8000000000000000)
	println("DONE!")
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
// TODO: use optionals, or some way to return default with error.
module strconv

const (
// int_size is the size in bits of an int or uint value.
// int_size = 32 << (~u32(0) >> 63)
// max_u64 = u64(u64(1 << 63) - 1)
	int_size = 32
	max_u64 = u64(C.UINT64_MAX)// as u64 // use this until we add support
)

pub fn byte_to_lower(c byte) byte {
	return c | (`x` - `X`)
}

// common_parse_uint is called by parse_uint and allows the parsing
// to stop on non or invalid digit characters and return the result so far
pub fn common_parse_uint(s string, _base int, _bit_size int, error_on_non_digit bool, error_on_high_digit bool) u64 {
	mut bit_size := _bit_size
	mut base := _base
	if s.len < 1 || !underscore_ok(s) {
		// return error('parse_uint: syntax error $s')
		return u64(0)
	}
	base0 := base == 0
	mut start_index := 0
	if 2 <= base && base <= 36 {
		// valid base; nothing to do
	}
	else if base == 0 {
		// Look for octal, hex prefix.
		base = 10
		if s[0] == `0` {
			if s.len >= 3 && byte_to_lower(s[1]) == `b` {
				base = 2
				start_index += 2
			}
			else if s.len >= 3 && byte_to_lower(s[1]) == `o` {
				base = 8
				start_index += 2
			}
			else if s.len >= 3 && byte_to_lower(s[1]) == `x` {
				base = 16
				start_index += 2
			}
			// manage leading zeros in decimal base's numbers
			else if s.len >= 2 && (s[1] >= `0` && s[1] <= `9`) {
				base = 10
				start_index++
			}
			else {
				base = 8
				start_index++
			}
		}
	}
	else {
		// return error('parse_uint: base error $s - $base')
		return u64(0)
	}
	if bit_size == 0 {
		bit_size = int_size
	}
	else if bit_size < 0 || bit_size > 64 {
		// return error('parse_uint: bitsize error $s - $bit_size')
		return u64(0)
	}
	// Cutoff is the smallest number such that cutoff*base > maxUint64.
	// Use compile-time constants for common cases.
	cutoff := max_u64 / u64(base) + u64(1)
	max_val := if bit_size == 64 { max_u64 } else { (u64(1)<<u64(bit_size)) - u64(1) }
	mut underscores := false
	mut n := u64(0)
	for i in start_index .. s.len {
		c := s[i]
		cl := byte_to_lower(c)
		mut d := byte(0)
		if c == `_` && base0 {
			// underscore_ok already called
			underscores = true
			continue
		}
		else if `0` <= c && c <= `9` {
			d = c - `0`
		}
		else if `a` <= cl && cl <= `z` {
			d = cl - `a` + 10
		}
		else {
			if error_on_non_digit {
				// return error('parse_uint: syntax error $s')
				return u64(0)
			}
			else {
				break
			}
		}
		if d >= byte(base) {
			if error_on_high_digit {
				// return error('parse_uint: syntax error $s')
				return u64(0)
			}
			else {
				break
			}
		}
		if n >= cutoff {
			// n*base overflows
			// return error('parse_uint: range error $s')
			return max_val
		}
		n *= u64(base)
		n1 := n + u64(d)
		if n1 < n || n1 > max_val {
			// n+v overflows
			// return error('parse_uint: range error $s')
			return max_val
		}
		n = n1
	}
	if underscores && !underscore_ok(s) {
		// return error('parse_uint: syntax error $s')
		return u64(0)
	}
	return n
}

// parse_uint is like parse_int but for unsigned numbers.
pub fn parse_uint(s string, _base int, _bit_size int) u64 {
	return common_parse_uint(s, _base, _bit_size, true, true)
}

// common_parse_int is called by parse int and allows the parsing
// to stop on non or invalid digit characters and return the result so far
pub fn common_parse_int(_s string, base int, _bit_size int, error_on_non_digit bool, error_on_high_digit bool) i64 {
	mut s := _s
	mut bit_size := _bit_size
	if s.len < 1 {
		// return error('parse_int: syntax error $s')
		return i64(0)
	}
	// Pick off leading sign.
	mut neg := false
	if s[0] == `+` {
		s = s[1..]
	}
	else if s[0] == `-` {
		neg = true
		s = s[1..]
	}
	// Convert unsigned and check range.
	// un := parse_uint(s, base, bit_size) or {
	// return i64(0)
	// }
	un := common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit)
	if un == 0 {
		return i64(0)
	}
	if bit_size == 0 {
		bit_size = int_size
	}
	// TODO: check should u64(bit_size-1) be size of int (32)?
	cutoff := u64(1)<<u64(bit_size - 1)
	if !neg && un >= cutoff {
		// return error('parse_int: range error $s0')
		return i64(cutoff - u64(1))
	}
	if neg && un > cutoff {
		// return error('parse_int: range error $s0')
		return -i64(cutoff)
	}
	return if neg { -i64(un) } else { i64(un) }
}

// parse_int interprets a string s in the given base (0, 2 to 36) and
// bit size (0 to 64) and returns the corresponding value i.
//
// If the base argument is 0, the true base is implied by the string's
// prefix: 2 for "0b", 8 for "0" or "0o", 16 for "0x", and 10 otherwise.
// Also, for argument base 0 only, underscore characters are permitted
// as defined by the Go syntax for integer literals.
//
// The bitSize argument specifies the integer type
// that the result must fit into. Bit sizes 0, 8, 16, 32, and 64
// correspond to int, int8, int16, int32, and int64.
// If bitSize is below 0 or above 64, an error is returned.
pub fn parse_int(_s string, base int, _bit_size int) i64 {
	return common_parse_int(_s, base, _bit_size, true, true)
}

// atoi is equivalent to parse_int(s, 10, 0), converted to type int.
pub fn atoi(s string) int {
	if (int_size == 32 && (0 < s.len && s.len < 10)) || (int_size == 64 && (0 < s.len && s.len < 19)) {
		// Fast path for small integers that fit int type.
		mut start_idx := 0
		if s[0] == `-` || s[0] == `+` {
			start_idx++
			if s.len - start_idx < 1 {
				// return 0, &NumError{fnAtoi, s0, ErrSyntax}
				return 0
			}
		}
		mut n := 0
		for i in start_idx .. s.len {
			ch := s[i] - `0`
			if ch > 9 {
				// return 0, &NumError{fnAtoi, s0, ErrSyntax}
				return 0
			}
			n = n * 10 + int(ch)
		}
		return if s[0] == `-` { -n } else { n }
	}
	// Slow path for invalid, big, or underscored integers.
	int64 := parse_int(s, 10, 0)
	return int(int64)
}

// underscore_ok reports whether the underscores in s are allowed.
// Checking them in this one function lets all the parsers skip over them simply.
// Underscore must appear only between digits or between a base prefix and a digit.
fn underscore_ok(s string) bool {
	// saw tracks the last character (class) we saw:
	// ^ for beginning of number,
	// 0 for a digit or base prefix,
	// _ for an underscore,
	// ! for none of the above.
	mut saw := `^`
	mut i := 0
	// Optional sign.
	if s.len >= 1 && (s[0] == `-` || s[0] == `+`) {
		i++
	}
	// Optional base prefix.
	mut hex := false
	if s.len - i >= 2 && s[i] == `0` && (byte_to_lower(s[i + 1]) == `b` || byte_to_lower(s[i + 1]) == `o` || byte_to_lower(s[i + 1]) == `x`) {
		saw = `0` // base prefix counts as a digit for "underscore as digit separator"
		hex = byte_to_lower(s[i + 1]) == `x`
		i += 2
	}
	// Number proper.
	for ; i < s.len; i++ {
		// Digits are always okay.
		if (`0` <= s[i] && s[i] <= `9`) || (hex && `a` <= byte_to_lower(s[i]) && byte_to_lower(s[i]) <= `f`) {
			saw = `0`
			continue
		}
		// Underscore must follow digit.
		if s[i] == `_` {
			if saw != `0` {
				return false
			}
			saw = `_`
			continue
		}
		// Underscore must also be followed by digit.
		if saw == `_` {
			return false
		}
		// Saw non-digit, non-underscore.
		saw = `!`
	}
	return saw != `_`
}

import strconv

fn test_atoi() {
	assert strconv.atoi('16') == 16
	assert strconv.atoi('+16') == 16
	assert strconv.atoi('-16') == -16
	assert strconv.atoi('str') == 0
	assert strconv.atoi('') == 0
}

fn test_parse_int() {
	// Different bases
	assert strconv.parse_int('16', 16, 0) == 0x16
	assert strconv.parse_int('16', 8, 0) == 0o16
	assert strconv.parse_int('11', 2, 0) == 3
	// Different bit sizes
	assert strconv.parse_int('127', 10, 8) == 127
	assert strconv.parse_int('128', 10, 8) == 127
	assert strconv.parse_int('32767', 10, 16) == 32767
	assert strconv.parse_int('32768', 10, 16) == 32767
	assert strconv.parse_int('2147483647', 10, 32) == 2147483647
	assert strconv.parse_int('2147483648', 10, 32) == 2147483647
	assert strconv.parse_int('9223372036854775807', 10, 64) == 9223372036854775807
	assert strconv.parse_int('9223372036854775808', 10, 64) == 9223372036854775807
	// Invalid bit sizes
	assert strconv.parse_int('123', 10, 65) == 0
	assert strconv.parse_int('123', 10, -1) == 0
}
# v_printf/v_sprintf

These are v implementations of the C language `printf` and `sprintf` functions.

***Note: These functions are platform dependent in C, but in V they are platform independent.***

### v_sprintf

`v_sprintf` has a variable number of parameters. The first is a format string to control the appearance of the final string. Each format specifier (%s, %d, etc.) in the format string is replaced by the textual version of the following parameters.

```v
import strconv
fn main() {
	a := "World"
	s := strconv.v_sprintf("Hello %s!", a)
	println(s)
}
```

```
Hello World!
```

### v_printf

`v_printf` creates the same modified string as `v_sprintf`, using the same format specifiers, but it will immediately print the modified string to stdout instead of returning a string.

### Syntax

The syntax for a format specifier is:

```
%[parameter][flags][width][.precision][length]type
```

#### Flags field

The Flags field may be zero or more (in any order) of:

| Character   | Description                                                  |
| ----------- | ------------------------------------------------------------ |
| `-` (minus) | Left-align the output of this specifier. (The default is to right-align the output.) |
| `+` (plus)  | Prepends a plus for positive signed-numeric types. positive = `+`, negative = `-`. (The default doesn't prepend anything to positive numbers.) |
| `0` (zero)  | When the 'width' option is specified, prepends zeros for numeric types. (The default prepends spaces.) For example, `printf("%4X",3)` produces `   3`, while `printf("%04X",3)` produces `0003`. |

#### Width field

The Width field specifies a *maximum* number of characters to output, and is typically used to pad fixed-width fields in tabulated output, it causes truncation of oversized fields.

The width field may be omitted, or it may be a numeric integer value, or may also be specified by a parameter when indicated by an asterisk `*`. For example, `v_printf("%*.s", 5, my_string)` will result in `   mystring` being printed, with a total width of 5 characters.

#### Length field 

The Length field can be omitted or be any of:

| Character | Description                                                  |
| --------- | ------------------------------------------------------------ |
| `hh`      | For integer types, causes `printf` to expect an `byte` or `i8` argument. |
| `h`       | For integer types, causes `printf` to expect an `int16` or `u16` argument. |
| `l`       | For integer types, causes `printf` to expect an `i64` or `u64` argument. |
| `ll`      | For integer types, causes `printf` to expect an `i64` or `u64` argument. |
|           |                                                              |
|           |                                                              |

#### Type field 

The Type field can be any of:

| Character | Description                                                  |
| --------- | ------------------------------------------------------------ |
| `%`       | Prints a literal `%` character (this type doesn't accept any flags, width, precision, length fields). |
| `d`, `i`  | `int` as a signed `int` `%d` and `%i` are synonymous for output. The size of the argument is specified by the length field. |
| `u`       | `unsigned int`. The size of the argument is specified by the length field. |
| `f`, `F`  | `double` in normal notation. `f` and `F` only differs in how the strings are printed: lowercase or uppercase. |
| `e`, `E`  | `double` in scientific notation.`e` and `E` only differs in how the strings are printed: lowercase or uppercase. |
| `g`, `G`  | `double` in automatic notation.`g` and `G` only differs in how the strings are printed: lowercase or uppercase. |
| `x`, `X`  | `unsigned int` as a hexadecimal number. `x` uses lower-case letters and `X` uses upper-case. |
| `s`       | string                                                       |
| `p`       | `void *` (pointer to void) in an implementation-defined format. |
| `c`       | `char` (character).                                          |

## Examples

various types

```v
a0  := u32(10)
b0  := 200
c0  := byte(12)
s0  := "ciAo"
ch0 := `B`
f0  := 0.312345
f1  := 200000.0
sc0 := "ciao: [%-08u] %d %hhd [%8s] [%08X] [%-20.4f] [%-20.4f] [%c]"
temp_s = strconv.v_sprintf(sc0    ,a0 ,b0 ,c0 ,s0, b0 ,f0, f1, ch0)
println(temp_s)
```

```
ciao: [10      ] 200 12 [    ciAo] [000000C8] [0.3123              ] [200000.0000         ] [B]
```

integer

```v
a := byte(12)
b := i16(13)
c := 14
d := i64(15)
sc1 := "==>%hhd %hd %d %ld"
temp_s = strconv.v_sprintf(sc1, a ,b ,c, d)
println(temp_s)
```

```
==>12 13 14 15
```

unsigned integer

```v
a1 := byte(0xff)
b1 := u16(0xffff)
c1 := u32(0xffff_ffff)
d1 := u64(-1)
sc2 := "%hhu %hu %u %lu"
temp_s = strconv.v_sprintf(sc2, a1 ,b1 ,c1, d1)
println(temp_s)
```

```
255 65535 4294967295 18446744073709551615
```

hexadecimal

```v
a1 := byte(0xff)
b1 := i16(0xffff)
c1 := u32(0xffff_ffff)
d1 := u64(-1)
sc3 := "%hhx %hx %x %lx"
temp_s = strconv.v_sprintf(sc3, a1 ,b1 ,c1, d1)
println(temp_s)
```

```
ff ffff ffffffff ffffffffffffffff
```

hexadecimal

```v
a2 := 125
sc7 := "[%9x] [%9X] [%-9x] [%-9X] [%09x] [%09X]"
temp_s = strconv.v_sprintf(sc7, a2, a2, a2, a2, a2, a2)
println(temp_s)
```

```
[       7d] [       7D] [7d       ] [7D       ] [00000007d] [00000007D]
```

floating points

```v
f0  := 0.312345
f1  := 200000.0
f2  := -1234.300e6
f3  := 1234.300e-6
sc4 := "[%-20.3e] [%20.3e] [%-020.3e] [%-020.3E] [%-020.3e] [%-020.3e]"
temp_s = strconv.v_sprintf(sc4, f0, f1, f1, f1, f2, f3)
println(temp_s)
```

```
[3.123e-01           ] [           2.000e+05] [2.000e+05           ] [2.000E+05           ] [-1.234e+09          ] [1.234e-03           ]
```

float automatic notations

```v
mut ft := -1e-7
mut x  := 0
sc8    := "[%20g][%20G]|"
for x < 12 {
	temp_s = strconv.v_sprintf(sc8, ft, ft)
	println("$temp_s\n")
	ft = ft * 10.0
	x++
}
```

```
[              -1e-07][              -1E-07]|
[              -1e-06][              -1E-06]|
[              -1e-05][              -1E-05]|
[             -0.0001][             -0.0001]|
[              -0.001][              -0.001]|
[               -0.01][               -0.01]|
[                -0.1][                -0.1]|
[                  -1][                  -1]|
[                 -10][                 -10]|
[                -100][                -100]|
[               -1000][               -1000]|
[              -10000][              -10000]|

```

## Utility functions

The format module also has some utility functions:

```v
// calling struct
struct BF_param {
  pad_ch       byte       = ` `     // padding char
  len0         int        = -1      // default len for whole the number or string
  len1         int        = 6       // number of decimal digits, if needed
  positive     bool       = true    // mandatory: the sign of the number passed   
  sign_flag    bool       = false   // flag for print sign as prefix in padding
  allign       Align_text = .right  // alignment of the string
  rm_tail_zero bool       = false   // remove the tail zeros from floats
}

// utilities
fn format_dec(d u64, p BF_param) string
fn format_fl(f f64, p BF_param) string
fn format_es(f f64, p BF_param) string
fn remove_tail_zeros(s string) string
```

`format_dec` format the integer number using the parameters in the `BF_param` struct.

`format_fl` format a float number in normal notation using the parameters in the `BF_param` struct.

`format_es format a float number in scientific notation using the parameters in the `BF_param` struct.

`remove_tail_zeros` removes the tailing zeros from a floating point number as string. 
/**********************************************************************
*
* printf/sprintf V implementation
*
* Copyright (c) 2020 Dario Deledda. All rights reserved.
* Use of this source code is governed by an MIT license
* that can be found in the LICENSE file.
*
* This file contains the printf/sprintf functions
*
**********************************************************************/
module strconv
import strconv.ftoa
import strings

enum Char_parse_state {
	start
	norm_char
	field_char
	pad_ch
	len_set_start
	len_set_in

	check_type
	check_float
	check_float_in

	reset_params
}

enum Align_text {
	right = 0
	left
	center
}

/******************************************************************************
*
* Float conversion utility
*
******************************************************************************/
const(
	// rounding value
	dec_round = [
		f64(0.44),
		0.044,
		0.0044,
		0.00044,
		0.000044,
		0.0000044,
		0.00000044,
		0.000000044,
		0.0000000044,
		0.00000000044,
		0.000000000044,
		0.0000000000044,
		0.00000000000044,
		0.000000000000044,
		0.0000000000000044,
		0.00000000000000044,
		0.000000000000000044,
		0.0000000000000000044,
		0.00000000000000000044,
		0.000000000000000000044,
	]
)

// max float 1.797693134862315708145274237317043567981e+308

pub fn f64_to_str_lnd(f f64, dec_digit int) string {
	// we add the rounding value
	s := ftoa.f64_to_str(f + dec_round[dec_digit], 18)
	// check for +inf -inf Nan
	if s.len > 2 && (s[0] == `n` || s[1] == `i`) {
		return s
	}

	m_sgn_flag := false
	mut sgn        := 1
	mut b          := [26]byte 
	mut d_pos      := 1
	mut i          := 0
	mut i1         := 0
	mut exp        := 0
	mut exp_sgn    := 1

	mut dot_res_sp := -1

	// get sign and deciaml parts
	for c in s {
		if c == `-` {
			sgn = -1
			i++
		} else if c == `+` {
			sgn = 1
			i++
		}
		else if c >= `0` && c <= `9` {
			b[i1++] = c
			i++
		} else if c == `.` {
			if sgn > 0 {
				d_pos = i
			} else {
				d_pos = i-1
			}
			i++
		} else if c == `e` {
			i++
			break
		} else {
			return "[Float conversion error!!]"
		}
	}
	b[i1] = 0

	// get exponent
	if s[i] == `-` {
		exp_sgn = -1
		i++
	} else if s[i] == `+` {
		exp_sgn = 1
		i++
	}
	for c in s[i..] {
		exp = exp * 10 + int(c-`0`)
	}

	// allocate exp+32 chars for the return string
	//mut res := []byte{len:exp+32,init:`0`}
	mut res := [`0`].repeat(exp+32) // TODO: Slow!! is there other possibilities to allocate this?
	mut r_i := 0  // result string buffer index

	//println("s:${sgn} b:${b[0]} es:${exp_sgn} exp:${exp}")

	if sgn == 1 {
		if m_sgn_flag {
			res[r_i++] = `+`
		}
	} else {
		res[r_i++] = `-`
	}

	i = 0
	if exp_sgn >= 0 {
		for b[i] != 0 {
			res[r_i++] = b[i]
			i++
			if i >= d_pos && exp >= 0 {
				if exp == 0 {
					dot_res_sp = r_i
					res[r_i++] = `.`
				}
				exp--
			}
		}
		for exp >= 0 {
			res[r_i++] = `0`
			exp--
		}
		//println("exp: $exp $r_i $dot_res_sp")
	} else {
		mut dot_p := true
		for exp > 0 {
			res[r_i++] = `0`
			exp--
			if dot_p  {
				dot_res_sp = r_i
				res[r_i++] = `.`
				dot_p = false
			}
		}
		for b[i] != 0 {
			res[r_i++] = b[i]
			i++
		}
	}
	//println("r_i-d_pos: ${r_i - d_pos}")
	if dot_res_sp >= 0 {
		if (r_i - dot_res_sp) > dec_digit {
			r_i = dot_res_sp + dec_digit + 1
		}
		res[r_i] = 0
		//println("result: [${tos(&res[0],r_i)}]")
		return tos(&res[0],r_i)
	} else {
		if dec_digit > 0 {
			mut c := 0
			res[r_i++] = `.`
			for c < dec_digit {
				res[r_i++] = `0`
				c++
			}
			res[r_i] = 0
		}
		return tos(&res[0],r_i)
	}
}

/******************************************************************************
*
* Single format functions
*
******************************************************************************/
struct BF_param {
	pad_ch       byte       = ` `     // padding char
	len0         int        = -1      // default len for whole the number or string
	len1         int        = 6       // number of decimal digits, if needed
	positive     bool       = true    // mandatory: the sign of the number passed
	sign_flag    bool       = false   // flag for print sign as prefix in padding
	allign       Align_text = .right  // alignment of the string
	rm_tail_zero bool       = false   // remove the tail zeros from floats
}

pub fn format_str(s string, p BF_param) string {
	dif := p.len0 - s.len
	if dif <= 0 {
		return s
	}
	mut res := strings.new_builder(s.len + dif)
	if p.allign == .right {
		for i1 :=0; i1 < dif; i1++ {
			res.write_b(p.pad_ch)
		}
	}
	res.write(s)
	if p.allign == .left {
		for i1 :=0; i1 < dif; i1++ {
			res.write_b(p.pad_ch)
		}
	}
	return res.str()
}

// max int64 9223372036854775807 
pub fn format_dec(d u64, p BF_param) string {
	mut s := ""
	mut res := strings.new_builder(20)
	mut sign_len_diff := 0
	if p.pad_ch == `0` {
		if p.positive {
			if p.sign_flag { 
				res.write_b(`+`)
				sign_len_diff = -1
			}
		} else {
			res.write_b(`-`)
			sign_len_diff = -1
		}
		s = d.str()
	} else {
		if p.positive {
			if p.sign_flag {
				s = "+" + d.str()
			} else {
				s = d.str()
			}
		} else {
			s = "-" + d.str()
		}
	}
	dif := p.len0 - s.len + sign_len_diff

	if p.allign == .right {
		for i1 :=0; i1 < dif; i1++ {
			res.write_b(p.pad_ch)
		}
	}
	res.write(s)
	if p.allign == .left {
		for i1 :=0; i1 < dif; i1++ {
			res.write_b(p.pad_ch)
		}
	}
	return res.str()
}

pub fn format_fl(f f64, p BF_param) string {
	mut s  := ""
	mut fs := f64_to_str_lnd(if f >= 0.0 {f} else {-f}, p.len1)
	
	// error!!
	if fs[0] == `[` {
		return fs
	}
	
	if p.rm_tail_zero {
		fs = remove_tail_zeros(fs)
	}
	mut res := strings.new_builder( if p.len0 > fs.len { p.len0 } else { fs.len })

	mut sign_len_diff := 0
	if p.pad_ch == `0` {
		if p.positive {
			if p.sign_flag { 
				res.write_b(`+`)
				sign_len_diff = -1
			}
		} else {
			res.write_b(`-`)
			sign_len_diff = -1
		}
		s = fs
	} else {
		if p.positive {
			if p.sign_flag {
				s = "+" + fs
			} else {
				s = fs
			}
		} else {
			s = "-" + fs
		}
	}

	dif := p.len0 - s.len + sign_len_diff

	if p.allign == .right {
		for i1 :=0; i1 < dif; i1++ {
			res.write_b(p.pad_ch)
		}
	}
	res.write(s)
	if p.allign == .left {
		for i1 :=0; i1 < dif; i1++ {
			res.write_b(p.pad_ch)
		}
	}

	return res.str()
}

pub fn format_es(f f64, p BF_param) string {
	mut s := ""
	mut fs := ftoa.f64_to_str_pad(if f> 0 {f} else {-f},p.len1)
	if p.rm_tail_zero {
		fs = remove_tail_zeros(fs)
	}
	mut res := strings.new_builder( if p.len0 > fs.len { p.len0 } else { fs.len })

	mut sign_len_diff := 0
	if p.pad_ch == `0` {
		if p.positive {
			if p.sign_flag { 
				res.write_b(`+`)
				sign_len_diff = -1
			}
		} else {
			res.write_b(`-`)
			sign_len_diff = -1
		}
		s = fs
	} else {
		if p.positive {
			if p.sign_flag {
				s = "+" + fs
			} else {
				s = fs
			}
		} else {
			s = "-" + fs
		}
	}

	dif := p.len0 - s.len + sign_len_diff
	if p.allign == .right {
		for i1 :=0; i1 < dif; i1++ {
			res.write_b(p.pad_ch)
		}
	}
	res.write(s)
	if p.allign == .left {
		for i1 :=0; i1 < dif; i1++ {
			res.write_b(p.pad_ch)
		}
	}
	return res.str()
}

pub fn remove_tail_zeros(s string) string {
	mut i := 0
	mut last_zero_start := -1
	mut dot_pos         := -1
	mut in_decimal := false
	mut prev_ch := byte(0)
	for i < s.len {
		ch := s.str[i]
		if ch == `.` {
			in_decimal = true
			dot_pos = i
		}
		else if in_decimal {
			if ch == `0` && prev_ch != `0` {
				last_zero_start = i
			} else if ch >= `1` && ch <= `9` {
				last_zero_start = -1
			} else if ch == `e` {
				break
			}
		}
		prev_ch = ch
		i++
	}

	mut tmp := ""
	if last_zero_start > 0 {
		if last_zero_start == dot_pos+1 {
			tmp = s[..dot_pos] + s [i..]
		}else {
			tmp = s[..last_zero_start] + s [i..]
		}
	} else {
		tmp = s
	}
	if tmp.str[tmp.len-1] == `.` {
		return tmp[..tmp.len-1]
	}
	return tmp
}

/******************************************************************************
*
* Main functions
*
******************************************************************************/
pub fn v_printf(str string, pt ... voidptr) {
	print(v_sprintf(str, pt))
}

pub fn v_sprintf(str string, pt ... voidptr) string{

	mut res := strings.new_builder(pt.len * 16)

	mut i            := 0                // main strign index
	mut p_index      := 0                // parameter index
	mut sign         := false            // sign flag
	mut allign       := Align_text.right
	mut len0         := -1               // forced length, if -1 free length
	mut len1         := -1               // decimal part for floats
	def_len1         := 6                // default value for len1
	mut pad_ch       := ` `              // pad char
	mut th_separator := false            // thousands separator flag

	// prefix chars for Length field 
	mut ch1 := `0`  // +1 char if present else `0`
	mut ch2 := `0`  // +2 char if present else `0`

	mut status := Char_parse_state.norm_char
	for i < str.len {
		if status == .reset_params {
			sign         = false
			allign       = .right
			len0         = -1
			len1         = -1
			pad_ch       = ` `
			th_separator = false
			status = .norm_char
			ch1 = `0`
			ch2 = `0`
			continue
		}

		ch := str[i]
		if ch != `%` && status == .norm_char {
			res.write_b(ch)
			i++
			continue
		}
		if ch == `%` && status == .norm_char {
			status = .field_char
			i++
			continue
		}

		// single char, manage it here
		if ch == `c` && status == .field_char {
			d1 := *(&byte(pt[p_index]))
			res.write_b(d1)
			status = .reset_params
			p_index++
			i++
			continue
		}

		// pointer, manage it here
		if ch == `p` && status == .field_char {
			res.write("0x"+ptr_str(pt[p_index]))
			status = .reset_params
			p_index++
			i++
			continue
		}

		if status == .field_char {
			mut fc_ch1 := `0`
			mut fc_ch2 := `0`
			if (i + 1) < str.len {
				fc_ch1 = str[i+1]
				if (i + 2) < str.len {
					fc_ch2 = str[i+2]
				}
			}
			if ch == `+` {
				sign = true
				i++
				continue
			} else if ch == `-` {
				allign = .left
				i++
				continue
			} else if ch in [`0`,` `] {
				if allign == .right {
					pad_ch = ch
				}
				i++
				continue
			} else if ch == `'` {
				th_separator = true
				i++
				continue
			} else if ch == `.` && fc_ch1 >= `1` && fc_ch1 <= `9` {
				status = .check_float
				i++
				continue
			} 
			// manage "%.*s" precision field
			else if ch == `.` && fc_ch1 == `*` && fc_ch2 == `s` {
				len := *(&int(pt[p_index]))
				p_index++
				mut s := *(&string(pt[p_index]))
				s = s[..len]
				p_index++
				res.write(s)
				status = .reset_params
				i += 3
				continue
			}
			status = .len_set_start
			continue
		}

		if status == .len_set_start {
			if ch >= `1` && ch <= `9` {
				len0 = int(ch - `0`)
				status = .len_set_in
				i++
				continue
			}
			if ch == `.` {
				status = .check_float
				i++
				continue
			}
			status = .check_type
			continue
		}

		if status == .len_set_in {
			if ch >= `0` && ch <= `9` {
				len0 *= 10
				len0 += int(ch - `0`)
				i++
				continue
			}
			if ch == `.` {
				status = .check_float
				i++
				continue
			}
			status = .check_type
			continue
		}

		if status == .check_float {
			if ch >= `0` && ch <= `9` {
				len1 = int(ch - `0`)
				status = .check_float_in
				i++
				continue
			}
			status = .check_type
			continue
		}

		if status == .check_float_in {
			if ch >= `0` && ch <= `9` {
				len1 *= 10
				len1 += int(ch - `0`)
				i++
				continue
			}
			status = .check_type
			continue
		}

		if status == .check_type {

			if ch == `l` {
				if ch1 == `0` {
					ch1 = `l`
					i++
					continue
				} else {
					ch2 = `l`
					i++
					continue
				}
			}
			else if ch == `h` {
				if ch1 == `0` {
					ch1 = `h`
					i++
					continue
				} else {
					ch2 = `h`
					i++
					continue
				}
			}

			// signed integer
			else if ch in [`d`,`i`] {
				mut d1 := u64(0)
				mut positive := true

				//println("$ch1 $ch2")
				match ch1 {
					// h for 16 bit int
					// hh fot 8 bit int
					`h` {
						if ch2 == `h` {
							x := *(&i8(pt[p_index]))
							positive = if x >= 0 { true } else { false }
							d1 = if positive { u64(x) } else { u64(-x) }
						} else {
							x := *(&i16(pt[p_index]))
							positive = if x >= 0 { true } else { false }
							d1 = if positive { u64(x) } else { u64(-x) }
						}
					}
					// l  i64
					// ll i64 for now
					`l` {
						// placeholder for future 128bit integer code
						/*
						if ch2 == `l` {
							x := *(&i128(pt[p_index]))
							positive = if x >= 0 { true } else { false }
							d1 = if positive { u128(x) } else { u128(-x) }
						} else {
							x := *(&i64(pt[p_index]))
							positive = if x >= 0 { true } else { false }
							d1 = if positive { u64(x) } else { u64(-x) }
						}
						*/
						x := *(&i64(pt[p_index]))
						positive = if x >= 0 { true } else { false }
						d1 = if positive { u64(x) } else { u64(-x) }
					}
					// defualt int
					else {
						x := *(&int(pt[p_index]))
						positive = if x >= 0 { true } else { false }
						d1 = if positive { u64(x) } else { u64(-x) }
					}

				}

				res.write(format_dec(d1,{pad_ch: pad_ch, len0: len0, len1: 0, positive: positive, sign_flag: sign, allign: allign}))
				status = .reset_params
				p_index++
				i++
				ch1 = `0`
				ch2 = `0`
				continue
			}

			// unsigned integer
			else if ch == `u` {
				mut d1 := u64(0)
				positive := true

				match ch1 {
					// h for 16 bit unsigned int
					// hh fot 8 bit unsigned int
					`h` {
						if ch2 == `h` {
							d1 = u64(*(&byte(pt[p_index])))
						} else {
							d1 = u64(*(&u16(pt[p_index])))
						}
					}
					// l  u64
					// ll u64 for now
					`l` {
						// placeholder for future 128bit integer code
						/*
						if ch2 == `l` {
							d1 = u128(*(&u128(pt[p_index])))
						} else {
							d1 = u64(*(&u64(pt[p_index])))
						}
						*/
						d1 = u64(*(&u64(pt[p_index])))
					}
					// defualt int
					else {
						d1 = u64(*(&u32(pt[p_index])))
					}
				}

				res.write(format_dec(d1,{pad_ch: pad_ch, len0: len0, len1: 0, positive: positive, sign_flag: sign, allign: allign}))
				status = .reset_params
				p_index++
				i++
				continue
			}

			// hex
			else if ch in [`x`, `X`] {
				mut s := ""

				match ch1 {
					// h for 16 bit int
					// hh fot 8 bit int
					`h` {
						if ch2 == `h` {
							x := *(&i8(pt[p_index]))
							s = x.hex()
						} else {
							x := *(&i16(pt[p_index]))
							s = x.hex()
						}
					}
					// l  i64
					// ll i64 for now
					`l` {
						// placeholder for future 128bit integer code
						/*
						if ch2 == `l` {
							x := *(&i128(pt[p_index]))
							s = x.hex()
						} else {
							x := *(&i64(pt[p_index]))
							s = x.hex()
						}
						*/
						x := *(&i64(pt[p_index]))
						s = x.hex()
					} 
					else {
						x := *(&int(pt[p_index]))
						s = x.hex()
					}
				}

				if ch == `X` {
					s = s.to_upper()
				}

				res.write(format_str(s,{pad_ch: pad_ch, len0: len0, len1: 0, positive: true, sign_flag: false, allign: allign}))
				status = .reset_params
				p_index++
				i++
				continue
			}

			// float and double
			if ch in [`f`, `F`] {
				x := *(&f64(pt[p_index]))
				mut positive := x >= f64(0.0)
				len1 = if len1 >= 0 { len1 } else { def_len1 }
				s := format_fl(f64(x), {pad_ch: pad_ch, len0: len0, len1: len1, positive: positive, sign_flag: sign, allign: allign})
				res.write(if ch == `F` {s.to_upper()} else {s})
				status = .reset_params
				p_index++
				i++
				continue
			}
			else if ch in [`e`, `E`] {
				x := *(&f64(pt[p_index]))
				mut positive := x >= f64(0.0)
				len1 = if len1 >= 0 { len1 } else { def_len1 }
				s := format_es(f64(x), {pad_ch: pad_ch, len0: len0, len1: len1, positive: positive, sign_flag: sign, allign: allign})
				res.write(if ch == `E` {s.to_upper()} else {s})
				status = .reset_params
				p_index++
				i++
				continue
			}
			else if ch in [`g`, `G`] {
				x := *(&f64(pt[p_index]))
				mut positive := x >= f64(0.0)
				mut s := ""
				tx := fabs(x)
				if tx < 999_999.0 && tx >= 0.00001 {
					//println("Here g format_fl [$tx]")
					len1 = if len1 >= 0 { len1+1 } else { def_len1 }
					s = format_fl(x, {pad_ch: pad_ch, len0: len0, len1: len1, positive: positive, sign_flag: sign, allign: allign, rm_tail_zero: true})
				} else {
					len1 = if len1 >= 0 { len1+1 } else { def_len1 }
					s = format_es(x, {pad_ch: pad_ch, len0: len0, len1: len1, positive: positive, sign_flag: sign, allign: allign, rm_tail_zero: true})
				}
				res.write(if ch == `G` {s.to_upper()} else {s})
				status = .reset_params
				p_index++
				i++
				continue
			}

			// string
			else if ch == `s` {
				s1 := *(&string(pt[p_index]))
				pad_ch = ` `
				res.write(format_str(s1, {pad_ch: pad_ch, len0: len0, len1: 0, positive: true, sign_flag: false, allign: allign}))
				status = .reset_params
				p_index++
				i++
				continue
			}
		}

		status = .reset_params
		p_index++
		i++
	}

	return res.str()
}

fn fabs(x f64) f64 {
	if x < 0.0 {
		return -x
	}
	return x
}
import os
import strconv

fn test_format(){
	mut temp_s := ""
	mut tmp_str:= ""
	a0  := u32(10)
	b0  := 200
	c0  := byte(12)
	s0  := "ciAo"
	ch0 := `B`
	f0  := 0.312345
	f1  := 200000.0
	f2  := -1234.300e6
	f3  := 1234.300e-6
	
	sc0 := "ciao: [%-08u] %d %hhd [%8s] [%08X] [%-20.4f] [%-20.4f] [%c]"
	temp_s = strconv.v_sprintf(sc0    ,a0 ,b0 ,c0 ,s0, b0 ,f0, f1, ch0)
	tmp_str = "ciao: [10      ] 200 12 [    ciAo] [000000C8] [0.3123              ] [200000.0000         ] [B]"
	//C.printf(sc0.str,a0 ,b0 ,c0 ,s0.str ,b0 ,f0, f1, ch0)
	//println("\n$temp_s")
	assert tmp_str == temp_s

	a := byte(12)
	b := i16(13)
	c := 14
	d := i64(15)
	sc1 := "==>%hhd %hd %d %ld"
	temp_s = strconv.v_sprintf(sc1, a ,b ,c, d)
	tmp_str = "==>12 13 14 15"
	//C.printf(sc1.str, a ,b ,c, d)
	//println("\n$temp_s")
	assert tmp_str == temp_s

	a1 := byte(0xff)
	b1 := i16(0xffff)
	c1 := u32(0xffff_ffff)
	d1 := u64(-1)
	sc2 := "%hhu %hu %u %lu"
	temp_s = strconv.v_sprintf(sc2, a1 ,b1 ,c1, d1)
	tmp_str = "255 65535 4294967295 18446744073709551615"
	//C.printf(sc2.str, a1 ,b1 ,c1, d1)
	//println("\n$temp_s")
	assert tmp_str == temp_s
	
	sc3 := "%hhx %hx %x %lx"
	temp_s = strconv.v_sprintf(sc3, a1 ,b1 ,c1, d1)
	tmp_str = "ff ffff ffffffff ffffffffffffffff"
	//C.printf(sc3.str, a1 ,b1 ,c1, d1)
	//println("\n$temp_s")
	assert tmp_str == temp_s

	sc4 := "[%-20.3e] [%20.3e] [%-020.3e] [%-020.3E] [%-020.3e] [%-020.3e]"
	temp_s = strconv.v_sprintf(sc4, f0, f1, f1, f1, f2, f3)
	tmp_str = "[3.123e-01           ] [           2.000e+05] [2.000e+05           ] [2.000E+05           ] [-1.234e+09          ] [1.234e-03           ]"
	//C.printf(sc4.str, f0, f1, f1, f1, f2, f3)
	//println("\n$temp_s")
	assert tmp_str == temp_s

	sc5 := "[%.3f] [%0.3f] [%0.3F] [%0.3f] [%0.3F]"
	temp_s = strconv.v_sprintf(sc5, f0, f1, f1, f2, f3, f3)
	tmp_str = "[0.312] [200000.000] [200000.000] [-1234300000.000] [0.001]"
	//C.printf(sc5.str, f0, f1, f1, f2, f3, f3)
	//println("\n$temp_s")
	assert tmp_str == temp_s
	
	ml  := 3
	sc6 := "%.*s [%05hhX]"
	temp_s = strconv.v_sprintf(sc6, ml, s0    , a)
	tmp_str = "ciA [0000C]"
	//C.printf(sc6.str, ml, s0.str, a)
	//println("\n$temp_s")
	assert tmp_str == temp_s

	a2 := 125
	sc7 := "[%9x] [%9X] [%-9x] [%-9X] [%09x] [%09X]"
	temp_s = strconv.v_sprintf(sc7, a2, a2, a2, a2, a2, a2)
	tmp_str = "[       7d] [       7D] [7d       ] [7D       ] [00000007d] [00000007D]"
	//C.printf(sc7.str, a2, a2, a2, a2, a2, a2)
	//println("\n$temp_s")
	assert tmp_str == temp_s

	g_test := [
		"[              -1e-07][              -1E-07]|",
		"[              -1e-06][              -1E-06]|",
		"[              -1e-05][              -1E-05]|",
		"[             -0.0001][             -0.0001]|",
		"[              -0.001][              -0.001]|",
		"[               -0.01][               -0.01]|",
		"[                -0.1][                -0.1]|",
		"[                  -1][                  -1]|",
		"[                 -10][                 -10]|",
		"[                -100][                -100]|",
		"[               -1000][               -1000]|",
		"[              -10000][              -10000]|"
	]

	mut ft := -1e-7
	mut x  := 0
	mut cnt:= 0
	sc8    := "[%20g][%20G]|"
	for x < 12 {
		temp_s = strconv.v_sprintf(sc8, ft, ft)
		//C.printf(sc8.str, ft, ft)
		//println("\n$temp_s")
		assert temp_s == g_test[cnt]
		ft = ft * 10.0
		x++
		cnt++
	}
}
/**********************************************************************
*
* atof util
*
* Copyright (c) 2019 Dario Deledda. All rights reserved.
* Use of this source code is governed by an MIT license
* that can be found in the LICENSE file.
*
* This file contains utilities for convert a string in a f64 variable in a very quick way
* IEEE 754 standard is used
*
* Know limitation:
* - round to 0 approximation
* - loos of precision with big exponents
*
*
**********************************************************************/

module atofq

// same used in atof, here only for references
const(
	double_plus_zero        = u64(0x0000000000000000)
	double_minus_zero       = u64(0x8000000000000000)
	double_plus_infinity    = u64(0x7FF0000000000000)
	double_minus_infinity   = u64(0xFFF0000000000000)
)

union Float64u {
mut:
	f f64
	u u64
}

// atof_quick return a f64 number from a string in a quick way
pub fn atof_quick(s string) f64 {
	mut f := Float64u{} // result
	mut sign := f64(1.0) // result sign
	mut i := 0 // index
	// skip white spaces
	for i < s.len && s[i] == ` ` {
		i++
	}
	// check sign
	if i < s.len {
		if s[i] == `-` {
			sign = -1.0
			i++
		}
		else if s[i] == `+` {
			i++
		}
	}
	// infinite
	if s[i] == `i` && i + 2 < s.len && s[i + 1] == `n` && s[i + 2] == `f` {
		if sign > 0.0 {
			f.u = double_plus_infinity
		}
		else {
			f.u = double_minus_infinity
		}
		return f.f
	}
	// skip zeros
	for i < s.len && s[i] == `0` {
		i++
		// we have a zero, manage it
		if i >= s.len {
			if sign > 0.0 {
				f.u = double_plus_zero
			}
			else {
				f.u = double_minus_zero
			}
			return f.f
		}
	}
	// integer part
	for i < s.len && (s[i] >= `0` && s[i] <= `9`) {
		f.f *= f64(10.0)
		f.f += f64(s[i] - `0`)
		i++
	}
	// decimal point
	if i < s.len && s[i] == `.` {
		i++
		mut frac_mul := f64(0.1)
		for i < s.len && (s[i] >= `0` && s[i] <= `9`) {
			f.f += f64(s[i] - `0`) * frac_mul
			frac_mul *= f64(0.1)
			i++
		}
	}
	// exponent management
	if i < s.len && (s[i] == `e` || s[i] == `E`) {
		i++
		mut exp := 0
		mut exp_sign := 1
		// negative exponent
		if i < s.len {
			if s[i] == `-` {
				exp_sign = -1
				i++
			}
			else if s[i] == `+` {
				i++
			}
		}
		// skip zeros
		for i < s.len && s[i] == `0` {
			i++
		}
		for i < s.len && (s[i] >= `0` && s[i] <= `9`) {
			exp *= 10
			exp += int(s[i] - `0`)
			i++
		}
		if exp_sign == 1 {
			if exp > pos_exp.len {
				if sign > 0 {
					f.u = double_plus_infinity
				}
				else {
					f.u = double_minus_infinity
				}
				return f.f
			}
			tmp_mul := Float64u{u: pos_exp[exp]}
			// C.printf("exp: %d  [0x%016llx] %f,",exp,pos_exp[exp],tmp_mul)
			f.f = f.f * tmp_mul.f
		}
		else {
			if exp > neg_exp.len {
				if sign > 0 {
					f.u = double_plus_zero
				}
				else {
					f.u = double_minus_zero
				}
				return f.f
			}
			tmp_mul := Float64u{u: neg_exp[exp]}

			// C.printf("exp: %d  [0x%016llx] %f,",exp,pos_exp[exp],tmp_mul)
			f.f = f.f * tmp_mul.f
		}
	}
	f.f = f.f * sign
	return f.f
}

const (
// positive exp of 10 binary form
	pos_exp = [u64(0x3ff0000000000000), u64(0x4024000000000000), u64(0x4059000000000000), u64(0x408f400000000000), u64(0x40c3880000000000), u64(0x40f86a0000000000), u64(0x412e848000000000), u64(0x416312d000000000), u64(0x4197d78400000000), u64(0x41cdcd6500000000), u64(0x4202a05f20000000), u64(0x42374876e8000000), u64(0x426d1a94a2000000), u64(0x42a2309ce5400000), u64(0x42d6bcc41e900000), u64(0x430c6bf526340000), u64(0x4341c37937e08000), u64(0x4376345785d8a000), u64(0x43abc16d674ec800), u64(0x43e158e460913d00), u64(0x4415af1d78b58c40), u64(0x444b1ae4d6e2ef50), u64(0x4480f0cf064dd592), u64(0x44b52d02c7e14af6), u64(0x44ea784379d99db4), u64(0x45208b2a2c280291), u64(0x4554adf4b7320335), u64(0x4589d971e4fe8402), u64(0x45c027e72f1f1281), u64(0x45f431e0fae6d721), u64(0x46293e5939a08cea), u64(0x465f8def8808b024), u64(0x4693b8b5b5056e17), u64(0x46c8a6e32246c99c), u64(0x46fed09bead87c03), u64(0x4733426172c74d82), u64(0x476812f9cf7920e3), u64(0x479e17b84357691b), u64(0x47d2ced32a16a1b1), u64(0x48078287f49c4a1d), u64(0x483d6329f1c35ca5), u64(0x48725dfa371a19e7), u64(0x48a6f578c4e0a061), u64(0x48dcb2d6f618c879), u64(0x4911efc659cf7d4c), u64(0x49466bb7f0435c9e), u64(0x497c06a5ec5433c6), u64(0x49b18427b3b4a05c), u64(0x49e5e531a0a1c873), u64(0x4a1b5e7e08ca3a8f), u64(0x4a511b0ec57e649a), u64(0x4a8561d276ddfdc0), u64(0x4ababa4714957d30), u64(0x4af0b46c6cdd6e3e), u64(0x4b24e1878814c9ce), u64(0x4b5a19e96a19fc41), u64(0x4b905031e2503da9), u64(0x4bc4643e5ae44d13), u64(0x4bf97d4df19d6057), u64(0x4c2fdca16e04b86d), u64(0x4c63e9e4e4c2f344), u64(0x4c98e45e1df3b015), u64(0x4ccf1d75a5709c1b), u64(0x4d03726987666191), u64(0x4d384f03e93ff9f5), u64(0x4d6e62c4e38ff872), u64(0x4da2fdbb0e39fb47), u64(0x4dd7bd29d1c87a19), u64(0x4e0dac74463a989f), u64(0x4e428bc8abe49f64), u64(0x4e772ebad6ddc73d), u64(0x4eacfa698c95390c), u64(0x4ee21c81f7dd43a7), u64(0x4f16a3a275d49491), u64(0x4f4c4c8b1349b9b5), u64(0x4f81afd6ec0e1411), u64(0x4fb61bcca7119916), u64(0x4feba2bfd0d5ff5b), u64(0x502145b7e285bf99), u64(0x50559725db272f7f), u64(0x508afcef51f0fb5f), u64(0x50c0de1593369d1b), u64(0x50f5159af8044462), u64(0x512a5b01b605557b), u64(0x516078e111c3556d), u64(0x5194971956342ac8), u64(0x51c9bcdfabc1357a), u64(0x5200160bcb58c16c), u64(0x52341b8ebe2ef1c7), u64(0x526922726dbaae39), u64(0x529f6b0f092959c7), u64(0x52d3a2e965b9d81d), u64(0x53088ba3bf284e24), u64(0x533eae8caef261ad), u64(0x53732d17ed577d0c), u64(0x53a7f85de8ad5c4f), u64(0x53ddf67562d8b363), u64(0x5412ba095dc7701e), u64(0x5447688bb5394c25), u64(0x547d42aea2879f2e), u64(0x54b249ad2594c37d), u64(0x54e6dc186ef9f45c), u64(0x551c931e8ab87173), u64(0x5551dbf316b346e8), u64(0x558652efdc6018a2), u64(0x55bbe7abd3781eca), u64(0x55f170cb642b133f), u64(0x5625ccfe3d35d80e), u64(0x565b403dcc834e12), u64(0x569108269fd210cb), u64(0x56c54a3047c694fe), u64(0x56fa9cbc59b83a3d), u64(0x5730a1f5b8132466), u64(0x5764ca732617ed80), u64(0x5799fd0fef9de8e0), u64(0x57d03e29f5c2b18c), u64(0x58044db473335def), u64(0x583961219000356b), u64(0x586fb969f40042c5), u64(0x58a3d3e2388029bb), u64(0x58d8c8dac6a0342a), u64(0x590efb1178484135), u64(0x59435ceaeb2d28c1), u64(0x59783425a5f872f1), u64(0x59ae412f0f768fad), u64(0x59e2e8bd69aa19cc), u64(0x5a17a2ecc414a03f), u64(0x5a4d8ba7f519c84f), u64(0x5a827748f9301d32), u64(0x5ab7151b377c247e), u64(0x5aecda62055b2d9e), u64(0x5b22087d4358fc82), u64(0x5b568a9c942f3ba3), u64(0x5b8c2d43b93b0a8c), u64(0x5bc19c4a53c4e697), u64(0x5bf6035ce8b6203d), u64(0x5c2b843422e3a84d), u64(0x5c6132a095ce4930), u64(0x5c957f48bb41db7c), u64(0x5ccadf1aea12525b), u64(0x5d00cb70d24b7379), u64(0x5d34fe4d06de5057), u64(0x5d6a3de04895e46d), u64(0x5da066ac2d5daec4), u64(0x5dd4805738b51a75), u64(0x5e09a06d06e26112), u64(0x5e400444244d7cab), u64(0x5e7405552d60dbd6), u64(0x5ea906aa78b912cc), u64(0x5edf485516e7577f), u64(0x5f138d352e5096af), u64(0x5f48708279e4bc5b), u64(0x5f7e8ca3185deb72), u64(0x5fb317e5ef3ab327), u64(0x5fe7dddf6b095ff1), u64(0x601dd55745cbb7ed), u64(0x6052a5568b9f52f4), u64(0x60874eac2e8727b1), u64(0x60bd22573a28f19d), u64(0x60f2357684599702), u64(0x6126c2d4256ffcc3), u64(0x615c73892ecbfbf4), u64(0x6191c835bd3f7d78), u64(0x61c63a432c8f5cd6), u64(0x61fbc8d3f7b3340c), u64(0x62315d847ad00087), u64(0x6265b4e5998400a9), u64(0x629b221effe500d4), u64(0x62d0f5535fef2084), u64(0x630532a837eae8a5), u64(0x633a7f5245e5a2cf), u64(0x63708f936baf85c1), u64(0x63a4b378469b6732), u64(0x63d9e056584240fe), u64(0x64102c35f729689f), u64(0x6444374374f3c2c6), u64(0x647945145230b378), u64(0x64af965966bce056), u64(0x64e3bdf7e0360c36), u64(0x6518ad75d8438f43), u64(0x654ed8d34e547314), u64(0x6583478410f4c7ec), u64(0x65b819651531f9e8), u64(0x65ee1fbe5a7e7861), u64(0x6622d3d6f88f0b3d), u64(0x665788ccb6b2ce0c), u64(0x668d6affe45f818f), u64(0x66c262dfeebbb0f9), u64(0x66f6fb97ea6a9d38), u64(0x672cba7de5054486), u64(0x6761f48eaf234ad4), u64(0x679671b25aec1d89), u64(0x67cc0e1ef1a724eb), u64(0x680188d357087713), u64(0x6835eb082cca94d7), u64(0x686b65ca37fd3a0d), u64(0x68a11f9e62fe4448), u64(0x68d56785fbbdd55a), u64(0x690ac1677aad4ab1), u64(0x6940b8e0acac4eaf), u64(0x6974e718d7d7625a), u64(0x69aa20df0dcd3af1), u64(0x69e0548b68a044d6), u64(0x6a1469ae42c8560c), u64(0x6a498419d37a6b8f), u64(0x6a7fe52048590673), u64(0x6ab3ef342d37a408), u64(0x6ae8eb0138858d0a), u64(0x6b1f25c186a6f04c), u64(0x6b537798f4285630), u64(0x6b88557f31326bbb), u64(0x6bbe6adefd7f06aa), u64(0x6bf302cb5e6f642a), u64(0x6c27c37e360b3d35), u64(0x6c5db45dc38e0c82), u64(0x6c9290ba9a38c7d1), u64(0x6cc734e940c6f9c6), u64(0x6cfd022390f8b837), u64(0x6d3221563a9b7323), u64(0x6d66a9abc9424feb), u64(0x6d9c5416bb92e3e6), u64(0x6dd1b48e353bce70), u64(0x6e0621b1c28ac20c), u64(0x6e3baa1e332d728f), u64(0x6e714a52dffc6799), u64(0x6ea59ce797fb817f), u64(0x6edb04217dfa61df), u64(0x6f10e294eebc7d2c), u64(0x6f451b3a2a6b9c76), u64(0x6f7a6208b5068394), u64(0x6fb07d457124123d), u64(0x6fe49c96cd6d16cc), u64(0x7019c3bc80c85c7f), u64(0x70501a55d07d39cf), u64(0x708420eb449c8843), u64(0x70b9292615c3aa54), u64(0x70ef736f9b3494e9), u64(0x7123a825c100dd11), u64(0x7158922f31411456), u64(0x718eb6bafd91596b), u64(0x71c33234de7ad7e3), u64(0x71f7fec216198ddc), u64(0x722dfe729b9ff153), u64(0x7262bf07a143f6d4), u64(0x72976ec98994f489), u64(0x72cd4a7bebfa31ab), u64(0x73024e8d737c5f0b), u64(0x7336e230d05b76cd), u64(0x736c9abd04725481), u64(0x73a1e0b622c774d0), u64(0x73d658e3ab795204), u64(0x740bef1c9657a686), u64(0x74417571ddf6c814), u64(0x7475d2ce55747a18), u64(0x74ab4781ead1989e), u64(0x74e10cb132c2ff63), u64(0x75154fdd7f73bf3c), u64(0x754aa3d4df50af0b), u64(0x7580a6650b926d67), u64(0x75b4cffe4e7708c0), u64(0x75ea03fde214caf1), u64(0x7620427ead4cfed6), u64(0x7654531e58a03e8c), u64(0x768967e5eec84e2f), u64(0x76bfc1df6a7a61bb), u64(0x76f3d92ba28c7d15), u64(0x7728cf768b2f9c5a), u64(0x775f03542dfb8370), u64(0x779362149cbd3226), u64(0x77c83a99c3ec7eb0), u64(0x77fe494034e79e5c), u64(0x7832edc82110c2f9), u64(0x7867a93a2954f3b8), u64(0x789d9388b3aa30a5), u64(0x78d27c35704a5e67), u64(0x79071b42cc5cf601), u64(0x793ce2137f743382), u64(0x79720d4c2fa8a031), u64(0x79a6909f3b92c83d), u64(0x79dc34c70a777a4d), u64(0x7a11a0fc668aac70), u64(0x7a46093b802d578c), u64(0x7a7b8b8a6038ad6f), u64(0x7ab137367c236c65), u64(0x7ae585041b2c477f), u64(0x7b1ae64521f7595e), u64(0x7b50cfeb353a97db), u64(0x7b8503e602893dd2), u64(0x7bba44df832b8d46), u64(0x7bf06b0bb1fb384c), u64(0x7c2485ce9e7a065f), u64(0x7c59a742461887f6), u64(0x7c9008896bcf54fa), u64(0x7cc40aabc6c32a38), u64(0x7cf90d56b873f4c7), u64(0x7d2f50ac6690f1f8), u64(0x7d63926bc01a973b), u64(0x7d987706b0213d0a), u64(0x7dce94c85c298c4c), u64(0x7e031cfd3999f7b0), u64(0x7e37e43c8800759c), u64(0x7e6ddd4baa009303), u64(0x7ea2aa4f4a405be2), u64(0x7ed754e31cd072da), u64(0x7f0d2a1be4048f90), u64(0x7f423a516e82d9ba), u64(0x7f76c8e5ca239029), u64(0x7fac7b1f3cac7433), u64(0x7fe1ccf385ebc8a0)]
	// negative exp of 10 binary form
	neg_exp = [u64(0x3ff0000000000000), u64(0x3fb999999999999a), u64(0x3f847ae147ae147b), u64(0x3f50624dd2f1a9fc), u64(0x3f1a36e2eb1c432d), u64(0x3ee4f8b588e368f1), u64(0x3eb0c6f7a0b5ed8d), u64(0x3e7ad7f29abcaf48), u64(0x3e45798ee2308c3a), u64(0x3e112e0be826d695), u64(0x3ddb7cdfd9d7bdbb), u64(0x3da5fd7fe1796495), u64(0x3d719799812dea11), u64(0x3d3c25c268497682), u64(0x3d06849b86a12b9b), u64(0x3cd203af9ee75616), u64(0x3c9cd2b297d889bc), u64(0x3c670ef54646d497), u64(0x3c32725dd1d243ac), u64(0x3bfd83c94fb6d2ac), u64(0x3bc79ca10c924223), u64(0x3b92e3b40a0e9b4f), u64(0x3b5e392010175ee6), u64(0x3b282db34012b251), u64(0x3af357c299a88ea7), u64(0x3abef2d0f5da7dd9), u64(0x3a88c240c4aecb14), u64(0x3a53ce9a36f23c10), u64(0x3a1fb0f6be506019), u64(0x39e95a5efea6b347), u64(0x39b4484bfeebc2a0), u64(0x398039d665896880), u64(0x3949f623d5a8a733), u64(0x3914c4e977ba1f5c), u64(0x38e09d8792fb4c49), u64(0x38aa95a5b7f87a0f), u64(0x38754484932d2e72), u64(0x3841039d428a8b8f), u64(0x380b38fb9daa78e4), u64(0x37d5c72fb1552d83), u64(0x37a16c262777579c), u64(0x376be03d0bf225c7), u64(0x37364cfda3281e39), u64(0x3701d7314f534b61), u64(0x36cc8b8218854567), u64(0x3696d601ad376ab9), u64(0x366244ce242c5561), u64(0x362d3ae36d13bbce), u64(0x35f7624f8a762fd8), u64(0x35c2b50c6ec4f313), u64(0x358dee7a4ad4b81f), u64(0x3557f1fb6f10934c), u64(0x352327fc58da0f70), u64(0x34eea6608e29b24d), u64(0x34b8851a0b548ea4), u64(0x34839dae6f76d883), u64(0x344f62b0b257c0d2), u64(0x34191bc08eac9a41), u64(0x33e41633a556e1ce), u64(0x33b011c2eaabe7d8), u64(0x3379b604aaaca626), u64(0x3344919d5556eb52), u64(0x3310747ddddf22a8), u64(0x32da53fc9631d10d), u64(0x32a50ffd44f4a73d), u64(0x3270d9976a5d5297), u64(0x323af5bf109550f2), u64(0x32059165a6ddda5b), u64(0x31d1411e1f17e1e3), u64(0x319b9b6364f30304), u64(0x316615e91d8f359d), u64(0x3131ab20e472914a), u64(0x30fc45016d841baa), u64(0x30c69d9abe034955), u64(0x309217aefe690777), u64(0x305cf2b1970e7258), u64(0x3027288e1271f513), u64(0x2ff286d80ec190dc), u64(0x2fbda48ce468e7c7), u64(0x2f87b6d71d20b96c), u64(0x2f52f8ac174d6123), u64(0x2f1e5aacf2156838), u64(0x2ee8488a5b445360), u64(0x2eb36d3b7c36a91a), u64(0x2e7f152bf9f10e90), u64(0x2e48ddbcc7f40ba6), u64(0x2e13e497065cd61f), u64(0x2ddfd424d6faf031), u64(0x2da97683df2f268d), u64(0x2d745ecfe5bf520b), u64(0x2d404bd984990e6f), u64(0x2d0a12f5a0f4e3e5), u64(0x2cd4dbf7b3f71cb7), u64(0x2ca0aff95cc5b092), u64(0x2c6ab328946f80ea), u64(0x2c355c2076bf9a55), u64(0x2c0116805effaeaa), u64(0x2bcb5733cb32b111), u64(0x2b95df5ca28ef40d), u64(0x2b617f7d4ed8c33e), u64(0x2b2bff2ee48e0530), u64(0x2af665bf1d3e6a8d), u64(0x2ac1eaff4a98553d), u64(0x2a8cab3210f3bb95), u64(0x2a56ef5b40c2fc77), u64(0x2a225915cd68c9f9), u64(0x29ed5b561574765b), u64(0x29b77c44ddf6c516), u64(0x2982c9d0b1923745), u64(0x294e0fb44f50586e), u64(0x29180c903f7379f2), u64(0x28e33d4032c2c7f5), u64(0x28aec866b79e0cba), u64(0x2878a0522c7e7095), u64(0x2843b374f06526de), u64(0x280f8587e7083e30), u64(0x27d9379fec069826), u64(0x27a42c7ff0054685), u64(0x277023998cd10537), u64(0x2739d28f47b4d525), u64(0x2704a8729fc3ddb7), u64(0x26d086c219697e2c), u64(0x269a71368f0f3047), u64(0x2665275ed8d8f36c), u64(0x2630ec4be0ad8f89), u64(0x25fb13ac9aaf4c0f), u64(0x25c5a956e225d672), u64(0x2591544581b7dec2), u64(0x255bba08cf8c979d), u64(0x25262e6d72d6dfb0), u64(0x24f1bebdf578b2f4), u64(0x24bc6463225ab7ec), u64(0x2486b6b5b5155ff0), u64(0x24522bc490dde65a), u64(0x241d12d41afca3c3), u64(0x23e7424348ca1c9c), u64(0x23b29b69070816e3), u64(0x237dc574d80cf16b), u64(0x2347d12a4670c123), u64(0x23130dbb6b8d674f), u64(0x22de7c5f127bd87e), u64(0x22a8637f41fcad32), u64(0x227382cc34ca2428), u64(0x223f37ad21436d0c), u64(0x2208f9574dcf8a70), u64(0x21d3faac3e3fa1f3), u64(0x219ff779fd329cb9), u64(0x216992c7fdc216fa), u64(0x2134756ccb01abfb), u64(0x21005df0a267bcc9), u64(0x20ca2fe76a3f9475), u64(0x2094f31f8832dd2a), u64(0x2060c27fa028b0ef), u64(0x202ad0cc33744e4b), u64(0x1ff573d68f903ea2), u64(0x1fc1297872d9cbb5), u64(0x1f8b758d848fac55), u64(0x1f55f7a46a0c89dd), u64(0x1f2192e9ee706e4b), u64(0x1eec1e43171a4a11), u64(0x1eb67e9c127b6e74), u64(0x1e81fee341fc585d), u64(0x1e4ccb0536608d61), u64(0x1e1708d0f84d3de7), u64(0x1de26d73f9d764b9), u64(0x1dad7becc2f23ac2), u64(0x1d779657025b6235), u64(0x1d42deac01e2b4f7), u64(0x1d0e3113363787f2), u64(0x1cd8274291c6065b), u64(0x1ca3529ba7d19eaf), u64(0x1c6eea92a61c3118), u64(0x1c38bba884e35a7a), u64(0x1c03c9539d82aec8), u64(0x1bcfa885c8d117a6), u64(0x1b99539e3a40dfb8), u64(0x1b6442e4fb671960), u64(0x1b303583fc527ab3), u64(0x1af9ef3993b72ab8), u64(0x1ac4bf6142f8eefa), u64(0x1a90991a9bfa58c8), u64(0x1a5a8e90f9908e0d), u64(0x1a253eda614071a4), u64(0x19f0ff151a99f483), u64(0x19bb31bb5dc320d2), u64(0x1985c162b168e70e), u64(0x1951678227871f3e), u64(0x191bd8d03f3e9864), u64(0x18e6470cff6546b6), u64(0x18b1d270cc51055f), u64(0x187c83e7ad4e6efe), u64(0x1846cfec8aa52598), u64(0x18123ff06eea847a), u64(0x17dd331a4b10d3f6), u64(0x17a75c1508da432b), u64(0x1772b010d3e1cf56), u64(0x173de6815302e556), u64(0x1707eb9aa8cf1dde), u64(0x16d322e220a5b17e), u64(0x169e9e369aa2b597), u64(0x16687e92154ef7ac), u64(0x16339874ddd8c623), u64(0x15ff5a549627a36c), u64(0x15c91510781fb5f0), u64(0x159410d9f9b2f7f3), u64(0x15600d7b2e28c65c), u64(0x1529af2b7d0e0a2d), u64(0x14f48c22ca71a1bd), u64(0x14c0701bd527b498), u64(0x148a4cf9550c5426), u64(0x14550a6110d6a9b8), u64(0x1420d51a73deee2d), u64(0x13eaee90b964b047), u64(0x13b58ba6fab6f36c), u64(0x13813c85955f2923), u64(0x134b9408eefea839), u64(0x1316100725988694), u64(0x12e1a66c1e139edd), u64(0x12ac3d79c9b8fe2e), u64(0x12769794a160cb58), u64(0x124212dd4de70913), u64(0x120ceafbafd80e85), u64(0x11d72262f3133ed1), u64(0x11a281e8c275cbda), u64(0x116d9ca79d89462a), u64(0x1137b08617a104ee), u64(0x1102f39e794d9d8b), u64(0x10ce5297287c2f45), u64(0x1098421286c9bf6b), u64(0x1063680ed23aff89), u64(0x102f0ce4839198db), u64(0x0ff8d71d360e13e2), u64(0x0fc3df4a91a4dcb5), u64(0x0f8fcbaa82a16121), u64(0x0f596fbb9bb44db4), u64(0x0f245962e2f6a490), u64(0x0ef047824f2bb6da), u64(0x0eba0c03b1df8af6), u64(0x0e84d6695b193bf8), u64(0x0e50ab877c142ffa), u64(0x0e1aac0bf9b9e65c), u64(0x0de5566ffafb1eb0), u64(0x0db111f32f2f4bc0), u64(0x0d7b4feb7eb212cd), u64(0x0d45d98932280f0a), u64(0x0d117ad428200c08), u64(0x0cdbf7b9d9cce00d), u64(0x0ca65fc7e170b33e), u64(0x0c71e6398126f5cb), u64(0x0c3ca38f350b22df), u64(0x0c06e93f5da2824c), u64(0x0bd25432b14ecea3), u64(0x0b9d53844ee47dd1), u64(0x0b677603725064a8), u64(0x0b32c4cf8ea6b6ec), u64(0x0afe07b27dd78b14), u64(0x0ac8062864ac6f43), u64(0x0a9338205089f29c), u64(0x0a5ec033b40fea93), u64(0x0a2899c2f6732210), u64(0x09f3ae3591f5b4d9), u64(0x09bf7d228322baf5), u64(0x098930e868e89591), u64(0x0954272053ed4474), u64(0x09201f4d0ff10390), u64(0x08e9cbae7fe805b3), u64(0x08b4a2f1ffecd15c), u64(0x0880825b3323dab0), u64(0x084a6a2b85062ab3), u64(0x081521bc6a6b555c), u64(0x07e0e7c9eebc444a), u64(0x07ab0c764ac6d3a9), u64(0x0775a391d56bdc87), u64(0x07414fa7ddefe3a0), u64(0x070bb2a62fe638ff), u64(0x06d62884f31e93ff), u64(0x06a1ba03f5b21000), u64(0x066c5cd322b67fff), u64(0x0636b0a8e891ffff), u64(0x060226ed86db3333), u64(0x05cd0b15a491eb84), u64(0x05973c115074bc6a), u64(0x05629674405d6388), u64(0x052dbd86cd6238d9), u64(0x04f7cad23de82d7b), u64(0x04c308a831868ac9), u64(0x048e74404f3daadb), u64(0x04585d003f6488af), u64(0x04237d99cc506d59), u64(0x03ef2f5c7a1a488e), u64(0x03b8f2b061aea072), u64(0x0383f559e7bee6c1), u64(0x034feef63f97d79c), u64(0x03198bf832dfdfb0), u64(0x02e46ff9c24cb2f3), u64(0x02b059949b708f29), u64(0x027a28edc580e50e), u64(0x0244ed8b04671da5), u64(0x0210be08d0527e1d), u64(0x01dac9a7b3b7302f), u64(0x01a56e1fc2f8f359), u64(0x017124e63593f5e1), u64(0x013b6e3d22865634), u64(0x0105f1ca820511c3), u64(0x00d18e3b9b374169), u64(0x009c16c5c5253575), u64(0x0066789e3750f791), u64(0x0031fa182c40c60d), u64(0x000730d67819e8d2), u64(0x0000b8157268fdaf), u64(0x000012688b70e62b), u64(0x000001d74124e3d1), u64(0x0000002f201d49fb), u64(0x00000004b6695433), u64(0x0000000078a42205), u64(0x000000000c1069cd), u64(0x000000000134d761), u64(0x00000000001ee257), u64(0x00000000000316a2), u64(0x0000000000004f10), u64(0x00000000000007e8), u64(0x00000000000000ca), u64(0x0000000000000014), u64(0x0000000000000002)]
)
/**********************************************************************
*
* Float to string Test
*
**********************************************************************/
import strconv.ftoa
import math

union Ufloat32 {
mut:
	f f32 = f32(0)
	b u32
}

union Ufloat64 {
mut:
	f f64 = f64(0)
	b u64
}

fn f64_from_bits1(b u64) f64 {
	mut x := Ufloat64{}
	x.b = b
	//C.printf("bin: %016llx\n",x.f)
	return x.f
}

fn f32_from_bits1(b u32) f32 {
	mut x := Ufloat32{}
	x.b = b
	//C.printf("bin: %08x\n",x.f)
	return x.f
}

fn test_float_to_str() {
	test_cases_f32 := [
		f32_from_bits1(0x0000_0000), // +0
		f32_from_bits1(0x8000_0000), // -0
		f32_from_bits1(0xFFC0_0001), // sNan
		f32_from_bits1(0xFF80_0001), // qNan
		f32_from_bits1(0x7F80_0000), // +inf
		f32_from_bits1(0xFF80_0000), // -inf
		1,
		-1,
		10,
		-10,
		0.3,
		-0.3,
		1000000,
		123456.7,
		123e35,
		-123.45,
		1e23,
		f32_from_bits1(0x0080_0000), // smallest float32
		math.max_f32,
		383260575764816448,
	]

	exp_result_f32 := [
		"0e+00",
		"-0e+00",
		"nan",
		"nan",
		"+inf",
		"-inf",
		"1.e+00",
		"-1.e+00",
		"1.e+01",
		"-1.e+01",
		"3.e-01",
		"-3.e-01",
		"1.e+06",
		"1.234567e+05",
		"1.23e+37",
		"-1.2345e+02",
		"1.e+23",
		"1.1754944e-38", // aprox from 1.1754943508  1038,
		"3.4028235e+38",
		"3.8326058e+17",
	]

	test_cases_f64 := [
		f64_from_bits1(0x0000_0000_0000_0000), // +0
		f64_from_bits1(0x8000_0000_0000_0000), // -0
		f64_from_bits1(0x7FF0_0000_0000_0001), // sNan
		f64_from_bits1(0x7FF8_0000_0000_0001), // qNan
		f64_from_bits1(0x7FF0_0000_0000_0000), // +inf
		f64_from_bits1(0xFFF0_0000_0000_0000), // -inf
		1,
		-1,
		10,
		-10,
		0.3,
		-0.3,
		1000000,
		123456.7,
		123e45,
		-123.45,
		1e23,
		f64_from_bits1(0x0010_0000_0000_0000), // smallest float64
		math.max_f32,
		383260575764816448,
		383260575764816448,
		// C failing cases
		123e300,
		123e-300,
		5.e-324,
		-5.e-324,
	]

	exp_result_f64 := [
		"0e+00",
		"-0e+00",
		"nan",
		"nan",
		"+inf",
		"-inf",
		"1.e+00",
		"-1.e+00",
		"1.e+01",
		"-1.e+01",
		"3.e-01",
		"-3.e-01",
		"1.e+06",
		"1.234567e+05",
		"1.23e+47",
		"-1.2345e+02",
		"1.e+23",
		"2.2250738585072014e-308",
		"3.4028234663852886e+38",
		"3.8326057576481645e+17",
		"3.8326057576481645e+17",

		"1.23e+302", // this test is failed from C sprintf!!
		"1.23e-298",
		"5.e-324",
		"-5.e-324",
	]

	// test f32
	for c,x in test_cases_f32 {
		println(x)
		s  := ftoa.f32_to_str(x,8)
		s1 := exp_result_f32[c]
		//println("$s1 $s")
		assert s == s1
	}

	// test f64
	for c,x in test_cases_f64 {
		s  := ftoa.f64_to_str(x,17)
		s1 := exp_result_f64[c]
		//println("$s1 $s")
		assert s == s1
	}

	// test long format
	for exp := 1 ; exp < 120 ; exp++ {
		a := ftoa.f64_to_str_l(("1e"+exp.str()).f64())
		//println(a)
		assert a.len == exp + 1

		b := ftoa.f64_to_str_l(("1e-"+exp.str()).f64())
		//println(b)
		assert b.len == exp + 2
	}

	// test rounding str conversion
	//println( ftoa.f64_to_str(0.3456789123456, 4) )
	//assert ftoa.f64_to_str(0.3456789123456, 4)=="3.4568e-01"
	//assert ftoa.f32_to_str(0.345678, 3)=="3.457e-01"
}
/**********************************************************************
*
* f32 to string
*
* Copyright (c) 2019-2020 Dario Deledda. All rights reserved.
* Use of this source code is governed by an MIT license
* that can be found in the LICENSE file.
*
* This file contains the f32 to string functions
*
* These functions are based on the work of:
* Publication:PLDI 2018: Proceedings of the 39th ACM SIGPLAN
* Conference on Programming Language Design and ImplementationJune 2018
* Pages 270282 https://doi.org/10.1145/3192366.3192369
*
* inspired by the Go version here:
* https://github.com/cespare/ryu/tree/ba56a33f39e3bbbfa409095d0f9ae168a595feea
*
**********************************************************************/
module ftoa

// dec32 is a floating decimal type representing m * 10^e.
struct Dec32 {
mut:
	m u32 = 0
	e int = 0
}

// support union for convert f32 to u32
union Uf32 {
mut:
	f f32 = 0
	u u32
}

// pow of ten table used by n_digit reduction
const(
	ten_pow_table_32 = [
		u32(1),
		u32(10),
		u32(100),
		u32(1000),
		u32(10000),
		u32(100000),
		u32(1000000),
		u32(10000000),
		u32(100000000),
		u32(1000000000),
		u32(10000000000),
		u32(100000000000),
	]
)

/******************************************************************************
*
* Conversion Functions
*
******************************************************************************/
const(
	mantbits32  = u32(23)
	expbits32   = u32(8)
	bias32      = u32(127) // f32 exponent bias
	maxexp32    = 255
)

// max 46 char
// -3.40282346638528859811704183484516925440e+38
fn (d Dec32) get_string_32(neg bool, i_n_digit int, i_pad_digit int) string {
	n_digit          := i_n_digit + 1
	pad_digit        := i_pad_digit + 1
	mut out          := d.m
	mut out_len      := decimal_len_32(out)
	out_len_original := out_len

	mut fw_zeros := 0
	if pad_digit > out_len {
		fw_zeros = pad_digit -out_len
	}

	mut buf := [byte(0)].repeat(out_len + 5 + 1 +1) // sign + mant_len + . +  e + e_sign + exp_len(2) + \0
	mut i := 0

	if neg {
		buf[i]=`-`
		i++
	}

	mut disp := 0
	if out_len <= 1 {
		disp = 1
	}

	if n_digit < out_len {
		//println("orig: ${out_len_original}")
		out += ten_pow_table_32[out_len - n_digit - 1] * 5  // round to up
		out /= ten_pow_table_32[out_len - n_digit]
		out_len = n_digit
	}

	y := i + out_len
	mut x := 0
	for x < (out_len-disp-1) {
		buf[y - x] = `0` + byte(out%10)
		out /= 10
		i++
		x++
	}

	if out_len >= 1 {
		buf[y - x] = `.`
		x++
		i++
	}

	if y-x >= 0 {
		buf[y - x] = `0` + byte(out%10)
		i++
	}

	for fw_zeros > 0 {
		buf[i++] = `0`
		fw_zeros--
	}

	/*
	x=0
	for x<buf.len {
		C.printf("d:%c\n",buf[x])
		x++
	}
	C.printf("\n")
	*/

	buf[i]=`e`
	i++

	mut exp := d.e + out_len_original - 1
	if exp < 0 {
		buf[i]=`-`
		i++
		exp = -exp
	} else {
		buf[i]=`+`
		i++
	}

	// Always print two digits to match strconv's formatting.
	d1 := exp % 10
	d0 := exp / 10
	buf[i]=`0` + byte(d0)
	i++
	buf[i]=`0` + byte(d1)
	i++
	buf[i]=0

	/*
	x=0
	for x<buf.len {
		C.printf("d:%c\n",buf[x])
		x++
	}
	*/
	return tos(byteptr(&buf[0]), i)
}

fn f32_to_decimal_exact_int(i_mant u32, exp u32) (Dec32,bool) {
	mut d := Dec32{}
	e := exp - bias32
	if e > mantbits32 {
		return d, false
	}
	shift := mantbits32 - e
	mant := i_mant | 0x0080_0000 // implicit 1
	//mant := i_mant | (1 << mantbits32) // implicit 1
	d.m = mant >> shift
	if (d.m << shift) != mant {
		return d, false
	}
	for (d.m % 10) == 0 {
		d.m /= 10
		d.e++
	}
	return d, true
}

pub fn f32_to_decimal(mant u32, exp u32) Dec32 {
	mut e2 := 0
	mut m2 := u32(0)
	if exp == 0 {
		// We subtract 2 so that the bounds computation has
		// 2 additional bits.
		e2 = 1 - bias32 - mantbits32 - 2
		m2 = mant
	} else {
		e2 = int(exp) - bias32 - mantbits32 - 2
		m2 = (u32(1) << mantbits32) | mant
	}
	even          := (m2 & 1) == 0
	accept_bounds := even

	// Step 2: Determine the interval of valid decimal representations.
	mv       := u32(4 * m2)
	mp       := u32(4 * m2 + 2)
	mm_shift := bool_to_u32(mant != 0 || exp <= 1)
	mm       := u32(4 * m2 - 1 - mm_shift)

	mut vr                   := u32(0)
	mut vp                   := u32(0)
	mut vm                   := u32(0)
	mut e10                  := 0
	mut vm_is_trailing_zeros := false
	mut vr_is_trailing_zeros := false
	mut last_removed_digit   := byte(0)

	if e2 >= 0 {
		q := log10_pow2(e2)
		e10 = int(q)
		k := pow5_inv_num_bits_32 + pow5_bits(int(q)) - 1
		i := -e2 + int(q) + k

		vr = mul_pow5_invdiv_pow2(mv, q, i)
		vp = mul_pow5_invdiv_pow2(mp, q, i)
		vm = mul_pow5_invdiv_pow2(mm, q, i)
		if q != 0 && (vp-1)/10 <= vm/10 {
			// We need to know one removed digit even if we are not
			// going to loop below. We could use q = X - 1 above,
			// except that would require 33 bits for the result, and
			// we've found that 32-bit arithmetic is faster even on
			// 64-bit machines.
			l := pow5_inv_num_bits_32 + pow5_bits(int(q - 1)) - 1
			last_removed_digit = byte(mul_pow5_invdiv_pow2(mv, q - 1, -e2 + int(q - 1) + l) % 10)
		}
		if q <= 9 {
			// The largest power of 5 that fits in 24 bits is 5^10,
			// but q <= 9 seems to be safe as well. Only one of mp,
			// mv, and mm can be a multiple of 5, if any.
			if mv%5 == 0 {
				vr_is_trailing_zeros = multiple_of_power_of_five_32(mv, q)
			} else if accept_bounds {
				vm_is_trailing_zeros = multiple_of_power_of_five_32(mm, q)
			} else if multiple_of_power_of_five_32(mp, q) {
				vp--
			}
		}
	} else {
		q := log10_pow5(-e2)
		e10 = int(q) + e2
		i := -e2 - int(q)
		k := pow5_bits(i) - pow5_num_bits_32
		mut j := int(q) - k
		vr = mul_pow5_div_pow2(mv, u32(i), j)
		vp = mul_pow5_div_pow2(mp, u32(i), j)
		vm = mul_pow5_div_pow2(mm, u32(i), j)
		if q != 0 && ((vp-1)/10) <= vm/10 {
			j = int(q) - 1 - (pow5_bits(i + 1) - pow5_num_bits_32)
			last_removed_digit = byte(mul_pow5_div_pow2(mv, u32(i + 1), j) % 10)
		}
		if q <= 1 {
			// {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at
			// least q trailing 0 bits. mv = 4 * m2, so it always
			// has at least two trailing 0 bits.
			vr_is_trailing_zeros = true
			if accept_bounds {
				// mm = mv - 1 - mm_shift, so it has 1 trailing 0 bit
				// if mm_shift == 1.
				vm_is_trailing_zeros = mm_shift == 1
			} else {
				// mp = mv + 2, so it always has at least one
				// trailing 0 bit.
				vp--
			}
		} else if q < 31 {
			vr_is_trailing_zeros = multiple_of_power_of_two_32(mv, q - 1)
		}
	}

	// Step 4: Find the shortest decimal representation
	// in the interval of valid representations.
	mut removed := 0
	mut out     := u32(0)
	if vm_is_trailing_zeros || vr_is_trailing_zeros {
		// General case, which happens rarely (~4.0%).
		for vp/10 > vm/10 {
			vm_is_trailing_zeros = vm_is_trailing_zeros && (vm % 10) == 0
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0)
			last_removed_digit = byte(vr % 10)
			vr /= 10
			vp /= 10
			vm /= 10
			removed++
		}
		if vm_is_trailing_zeros {
			for vm%10 == 0 {
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0)
				last_removed_digit = byte(vr % 10)
				vr /= 10
				vp /= 10
				vm /= 10
				removed++
			}
		}
		if vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0 {
			// Round even if the exact number is .....50..0.
			last_removed_digit = 4
		}
		out = vr
		// We need to take vr + 1 if vr is outside bounds
		// or we need to round up.
		if (vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5 {
			out++
		}
	} else {
		// Specialized for the common case (~96.0%). Percentages below
		// are relative to this. Loop iterations below (approximately):
		// 0: 13.6%, 1: 70.7%, 2: 14.1%, 3: 1.39%, 4: 0.14%, 5+: 0.01%
		for vp/10 > vm/10 {
			last_removed_digit = byte(vr % 10)
			vr /= 10
			vp /= 10
			vm /= 10
			removed++
		}
		// We need to take vr + 1 if vr is outside bounds
		// or we need to round up.
		out = vr + bool_to_u32(vr == vm || last_removed_digit >= 5)
	}

	return Dec32{m: out e: e10 + removed}
}

// f32_to_str return a string in scientific notation with max n_digit after the dot
pub fn f32_to_str(f f32, n_digit int) string {
	mut u1 := Uf32{}
	u1.f = f
	u := u1.u

	neg   := (u>>(mantbits32+expbits32)) != 0
	mant  := u & ((u32(1)<<mantbits32) - u32(1))
	exp   := (u >> mantbits32) & ((u32(1)<<expbits32) - u32(1))

	//println("${neg} ${mant} e ${exp-bias32}")

	// Exit early for easy cases.
	if (exp == maxexp32) || (exp == 0 && mant == 0) {
		return get_string_special(neg, exp == 0, mant == 0)
	}

	mut d, ok := f32_to_decimal_exact_int(mant, exp)
	if !ok {
		//println("with exp form")
		d = f32_to_decimal(mant, exp)
	}

	//println("${d.m} ${d.e}")
	return d.get_string_32(neg, n_digit,0)
}

// f32_to_str return a string in scientific notation with max n_digit after the dot
pub fn f32_to_str_pad(f f32, n_digit int) string {
	mut u1 := Uf32{}
	u1.f = f
	u := u1.u

	neg   := (u>>(mantbits32+expbits32)) != 0
	mant  := u & ((u32(1)<<mantbits32) - u32(1))
	exp   := (u >> mantbits32) & ((u32(1)<<expbits32) - u32(1))

	//println("${neg} ${mant} e ${exp-bias32}")

	// Exit early for easy cases.
	if (exp == maxexp32) || (exp == 0 && mant == 0) {
		return get_string_special(neg, exp == 0, mant == 0)
	}

	mut d, ok := f32_to_decimal_exact_int(mant, exp)
	if !ok {
		//println("with exp form")
		d = f32_to_decimal(mant, exp)
	}

	//println("${d.m} ${d.e}")
	return d.get_string_32(neg, n_digit, n_digit)
}
/**********************************************************************
*
* f32 to string
*
* Copyright (c) 2019-2020 Dario Deledda. All rights reserved.
* Use of this source code is governed by an MIT license
* that can be found in the LICENSE file.
*
* This file contains the f64 to string functions
*
* These functions are based on the work of:
* Publication:PLDI 2018: Proceedings of the 39th ACM SIGPLAN
* Conference on Programming Language Design and ImplementationJune 2018
* Pages 270282 https://doi.org/10.1145/3192366.3192369
*
* inspired by the Go version here:
* https://github.com/cespare/ryu/tree/ba56a33f39e3bbbfa409095d0f9ae168a595feea
*
**********************************************************************/
module ftoa

struct Uint128 {
mut:
	lo u64 = u64(0)
	hi u64 = u64(0)
}

// dec64 is a floating decimal type representing m * 10^e.
struct Dec64 {
mut:
	m u64 = 0
	e int = 0
}

// support union for convert f64 to u64
union Uf64 {
mut:
	f f64 = 0
	u u64
}

// pow of ten table used by n_digit reduction
const(
	ten_pow_table_64 = [
		u64(1),
		u64(10),
		u64(100),
		u64(1000),
		u64(10000),
		u64(100000),
		u64(1000000),
		u64(10000000),
		u64(100000000),
		u64(1000000000),
		u64(10000000000),
		u64(100000000000),
		u64(1000000000000),
		u64(10000000000000),
		u64(100000000000000),
		u64(1000000000000000),
		u64(10000000000000000),
		u64(100000000000000000),
		u64(1000000000000000000),
		u64(10000000000000000000),
	]
)

/******************************************************************************
*
* Conversion Functions
*
******************************************************************************/
const(
	mantbits64  = u32(52)
	expbits64   = u32(11)
	bias64      = u32(1023) // f64 exponent bias
	maxexp64    = 2047
)

fn (d Dec64) get_string_64(neg bool, i_n_digit int, i_pad_digit int) string {
	mut n_digit          := i_n_digit + 1
	pad_digit        := i_pad_digit + 1
	mut out          := d.m
	mut d_exp        := d.e
	mut out_len      := decimal_len_64(out)
	out_len_original := out_len

	mut fw_zeros := 0
	if pad_digit > out_len {
		fw_zeros = pad_digit - out_len
	}

	mut buf := [byte(0)].repeat(out_len + 6 + 1 +1 + fw_zeros) // sign + mant_len + . +  e + e_sign + exp_len(2) + \0
	mut i := 0

	if neg {
		buf[i]=`-`
		i++
	}

	mut disp := 0
	if out_len <= 1 {
		disp = 1
	}

	// rounding last used digit
	if n_digit < out_len {
		//println("out:[$out]")
		out += ten_pow_table_64[out_len - n_digit - 1] * 5   // round to up
		out /= ten_pow_table_64[out_len - n_digit ]
		//println("out1:[$out] ${d.m / ten_pow_table_64[out_len - n_digit ]}")
		if d.m / ten_pow_table_64[out_len - n_digit ] < out {
			d_exp += 1
			n_digit += 1
		}

		//println("cmp: ${d.m/ten_pow_table_64[out_len - n_digit ]} ${out/ten_pow_table_64[out_len - n_digit ]}")

		out_len = n_digit
		//println("orig: ${out_len_original} new len: ${out_len} out:[$out]")
	}

	y := i + out_len
	mut x := 0
	for x < (out_len-disp-1) {
		buf[y - x] = `0` + byte(out%10)
		out /= 10
		i++
		x++
	}

	if out_len >= 1 {
		buf[y - x] = `.`
		x++
		i++
	}

	if y-x >= 0 {
		buf[y - x] = `0` + byte(out%10)
		i++
	}

	for fw_zeros > 0 {
		buf[i++] = `0`
		fw_zeros--
	}

	/*
	x=0
	for x<buf.len {
		C.printf("d:%c\n",buf[x])
		x++
	}
	C.printf("\n")
	*/

	buf[i]=`e`
	i++

	mut exp := d_exp + out_len_original - 1
	if exp < 0 {
		buf[i]=`-`
		i++
		exp = -exp
	} else {
		buf[i]=`+`
		i++
	}

	// Always print at least two digits to match strconv's formatting.
	d2 := exp % 10
	exp /= 10
	d1 := exp % 10
	d0 := exp / 10
	if d0 > 0 {
		buf[i]=`0` + byte(d0)
		i++
	}
	buf[i]=`0` + byte(d1)
	i++
	buf[i]=`0` + byte(d2)
	i++
	buf[i]=0


	/*
	x=0
	for x<buf.len {
		C.printf("d:%c\n",buf[x])
		x++
	}
	*/
	return tos(byteptr(&buf[0]), i)
}

fn f64_to_decimal_exact_int(i_mant u64, exp u64) (Dec64, bool) {
	mut d := Dec64{}
	e := exp - bias64
	if e > mantbits64 {
		return d, false
	}
	shift := mantbits64 - e
	mant  := i_mant | u64(0x0010_0000_0000_0000) // implicit 1
	//mant  := i_mant | (1 << mantbits64) // implicit 1
	d.m = mant >> shift
	if (d.m << shift) != mant {
		return d, false
	}

	for (d.m % 10) == 0 {
		d.m /= 10
		d.e++
	}
	return d, true
}

fn f64_to_decimal(mant u64, exp u64) Dec64 {
	mut e2 := 0
	mut m2 := u64(0)
	if exp == 0 {
		// We subtract 2 so that the bounds computation has
		// 2 additional bits.
		e2 = 1 - bias64 - mantbits64 - 2
		m2 = mant
	} else {
		e2 = int(exp) - bias64 - mantbits64 - 2
		m2 = (u64(1)<<mantbits64) | mant
	}
	even          := (m2 & 1) == 0
	accept_bounds := even

	// Step 2: Determine the interval of valid decimal representations.
	mv       := u64(4 * m2)
	mm_shift := bool_to_u64(mant != 0 || exp <= 1)

	// Step 3: Convert to a decimal power base uing 128-bit arithmetic.
	mut vr           := u64(0)
	mut vp           := u64(0)
	mut vm           := u64(0)
	mut e10          := 0
	mut vm_is_trailing_zeros := false
	mut vr_is_trailing_zeros := false

	if e2 >= 0 {
		// This expression is slightly faster than max(0, log10Pow2(e2) - 1).
		q := log10_pow2(e2) - bool_to_u32(e2 > 3)
		e10 = int(q)
		k := pow5_inv_num_bits_64 + pow5_bits(int(q)) - 1
		i := -e2 + int(q) + k

		mul := pow5_inv_split_64[q]
		vr = mul_shift_64(u64(4) * m2                    , mul, i)
		vp = mul_shift_64(u64(4) * m2 + u64(2)           , mul, i)
		vm = mul_shift_64(u64(4) * m2 - u64(1) - mm_shift, mul, i)
		if q <= 21 {
			// This should use q <= 22, but I think 21 is also safe.
			// Smaller values may still be safe, but it's more
			// difficult to reason about them. Only one of mp, mv,
			// and mm can be a multiple of 5, if any.
			if mv%5 == 0 {
				vr_is_trailing_zeros = multiple_of_power_of_five_64(mv, q)
			} else if accept_bounds {
				// Same as min(e2 + (^mm & 1), pow5Factor64(mm)) >= q
				// <=> e2 + (^mm & 1) >= q && pow5Factor64(mm) >= q
				// <=> true && pow5Factor64(mm) >= q, since e2 >= q.
				vm_is_trailing_zeros = multiple_of_power_of_five_64(mv-1-mm_shift, q)
			} else if multiple_of_power_of_five_64(mv+2, q) {
				vp--
			}
		}
	} else {
		// This expression is slightly faster than max(0, log10Pow5(-e2) - 1).
		q := log10_pow5(-e2) - bool_to_u32(-e2 > 1)
		e10 = int(q) + e2
		i := -e2 - int(q)
		k := pow5_bits(i) - pow5_num_bits_64
		mut j := int(q) - k
		mul := pow5_split_64[i]
		vr = mul_shift_64(u64(4) * m2                    , mul, j)
		vp = mul_shift_64(u64(4) * m2 + u64(2)           , mul, j)
		vm = mul_shift_64(u64(4) * m2 - u64(1) - mm_shift, mul, j)
		if q <= 1 {
			// {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.
			// mv = 4 * m2, so it always has at least two trailing 0 bits.
			vr_is_trailing_zeros = true
			if accept_bounds {
				// mm = mv - 1 - mmShift, so it has 1 trailing 0 bit iff mmShift == 1.
				vm_is_trailing_zeros = (mm_shift == 1)
			} else {
				// mp = mv + 2, so it always has at least one trailing 0 bit.
				vp--
			}
		} else if q < 63 { // TODO(ulfjack/cespare): Use a tighter bound here.
			// We need to compute min(ntz(mv), pow5Factor64(mv) - e2) >= q - 1
			// <=> ntz(mv) >= q - 1 && pow5Factor64(mv) - e2 >= q - 1
			// <=> ntz(mv) >= q - 1 (e2 is negative and -e2 >= q)
			// <=> (mv & ((1 << (q - 1)) - 1)) == 0
			// We also need to make sure that the left shift does not overflow.
			vr_is_trailing_zeros = multiple_of_power_of_two_64(mv, q - 1)
		}
	}

	// Step 4: Find the shortest decimal representation
	// in the interval of valid representations.
	mut removed            := 0
	mut last_removed_digit := byte(0)
	mut out                := u64(0)
	// On average, we remove ~2 digits.
	if vm_is_trailing_zeros || vr_is_trailing_zeros {
		// General case, which happens rarely (~0.7%).
		for {
			vp_div_10 := vp / 10
			vm_div_10  := vm / 10
			if vp_div_10 <= vm_div_10 {
				break
			}
			vm_mod_10 := vm % 10
			vr_div_10 := vr / 10
			vr_mod_10 := vr % 10
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0
			vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0)
			last_removed_digit = byte(vr_mod_10)
			vr = vr_div_10
			vp = vp_div_10
			vm = vm_div_10
			removed++
		}
		if vm_is_trailing_zeros {
			for {
				vm_div_10 := vm / 10
				vm_mod_10 := vm % 10
				if vm_mod_10 != 0 {
					break
				}
				vp_div_10 := vp / 10
				vr_div_10 := vr / 10
				vr_mod_10 := vr % 10
				vr_is_trailing_zeros = vr_is_trailing_zeros && (last_removed_digit == 0)
				last_removed_digit = byte(vr_mod_10)
				vr = vr_div_10
				vp = vp_div_10
				vm = vm_div_10
				removed++
			}
		}
		if vr_is_trailing_zeros && (last_removed_digit == 5) && (vr % 2) == 0 {
			// Round even if the exact number is .....50..0.
			last_removed_digit = 4
		}
		out = vr
		// We need to take vr + 1 if vr is outside bounds
		// or we need to round up.
		if (vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5 {
			out++
		}
	} else {
		// Specialized for the common case (~99.3%).
		// Percentages below are relative to this.
		mut round_up := false
		for vp / 100 > vm / 100 {
			// Optimization: remove two digits at a time (~86.2%).
			round_up = (vr % 100) >= 50
			vr /= 100
			vp /= 100
			vm /= 100
			removed += 2
		}
		// Loop iterations below (approximately), without optimization above:
		// 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%
		// Loop iterations below (approximately), with optimization above:
		// 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%
		for vp / 10 > vm / 10 {
			round_up = (vr % 10) >= 5
			vr /= 10
			vp /= 10
			vm /= 10
			removed++
		}
		// We need to take vr + 1 if vr is outside bounds
		// or we need to round up.
		out = vr + bool_to_u64(vr == vm || round_up)
	}

	return Dec64{m: out, e: e10 + removed}
}

// f64_to_str return a string in scientific notation with max n_digit after the dot
pub fn f64_to_str(f f64, n_digit int) string {
	mut u1 := Uf64{}
	u1.f = f
	u := u1.u

	neg   := (u>>(mantbits64+expbits64)) != 0
	mant  := u & ((u64(1)<<mantbits64) - u64(1))
	exp   := (u >> mantbits64) & ((u64(1)<<expbits64) - u64(1))
	//println("s:${neg} mant:${mant} exp:${exp} float:${f} byte:${u1.u:016lx}")

	// Exit early for easy cases.
	if (exp == maxexp64) || (exp == 0 && mant == 0) {
		return get_string_special(neg, exp == 0, mant == 0)
	}

	mut d, ok := f64_to_decimal_exact_int(mant, exp)
	if !ok {
		//println("to_decimal")
		d = f64_to_decimal(mant, exp)
	}
	//println("${d.m} ${d.e}")
	return d.get_string_64(neg, n_digit, 0)
}

// f64_to_str return a string in scientific notation with max n_digit after the dot
pub fn f64_to_str_pad(f f64, n_digit int) string {
	mut u1 := Uf64{}
	u1.f = f
	u := u1.u

	neg   := (u>>(mantbits64+expbits64)) != 0
	mant  := u & ((u64(1)<<mantbits64) - u64(1))
	exp   := (u >> mantbits64) & ((u64(1)<<expbits64) - u64(1))
	//println("s:${neg} mant:${mant} exp:${exp} float:${f} byte:${u1.u:016lx}")

	// Exit early for easy cases.
	if (exp == maxexp64) || (exp == 0 && mant == 0) {
		return get_string_special(neg, exp == 0, mant == 0)
	}

	mut d, ok := f64_to_decimal_exact_int(mant, exp)
	if !ok {
		//println("to_decimal")
		d = f64_to_decimal(mant, exp)
	}
	//println("DEBUG: ${d.m} ${d.e}")
	return d.get_string_64(neg, n_digit, n_digit)
}
/**********************************************************************
*
* f32/f64 ftoa functions
*
* Copyright (c) 2019-2020 Dario Deledda. All rights reserved.
* Use of this source code is governed by an MIT license
* that can be found in the LICENSE file.
*
* This file contains the f32/f64 ftoa functions
*
* These functions are based on the work of:
* Publication:PLDI 2018: Proceedings of the 39th ACM SIGPLAN 
* Conference on Programming Language Design and ImplementationJune 2018 
* Pages 270282 https://doi.org/10.1145/3192366.3192369
*
* inspired by the Go version here: 
* https://github.com/cespare/ryu/tree/ba56a33f39e3bbbfa409095d0f9ae168a595feea
*
**********************************************************************/
module ftoa

[inline]
pub fn ftoa_64(f f64) string {
	return f64_to_str(f,17)
}

[inline]
pub fn ftoa_long_64(f f64) string {
	return f64_to_str_l(f)
}

[inline]
pub fn ftoa_32(f f32) string {
	return f32_to_str(f,8)
}

[inline]
pub fn ftoa_long_32(f f32) string {
	return f32_to_str_l(f)
}
module ftoa

const(
pow5_num_bits_32     = 61
pow5_inv_num_bits_32 = 59
pow5_num_bits_64     = 121
pow5_inv_num_bits_64 = 122

powers_of_10 = [
	u64(1e0),
	u64(1e1),
	u64(1e2),
	u64(1e3),
	u64(1e4),
	u64(1e5),
	u64(1e6),
	u64(1e7),
	u64(1e8),
	u64(1e9),
	u64(1e10),
	u64(1e11),
	u64(1e12),
	u64(1e13),
	u64(1e14),
	u64(1e15),
	u64(1e16),
	u64(1e17)
	// We only need to find the length of at most 17 digit numbers.
]

pow5_split_32 = [
	u64(1152921504606846976), u64(1441151880758558720), u64(1801439850948198400), u64(2251799813685248000),
	u64(1407374883553280000), u64(1759218604441600000), u64(2199023255552000000), u64(1374389534720000000),
	u64(1717986918400000000), u64(2147483648000000000), u64(1342177280000000000), u64(1677721600000000000),
	u64(2097152000000000000), u64(1310720000000000000), u64(1638400000000000000), u64(2048000000000000000),
	u64(1280000000000000000), u64(1600000000000000000), u64(2000000000000000000), u64(1250000000000000000),
	u64(1562500000000000000), u64(1953125000000000000), u64(1220703125000000000), u64(1525878906250000000),
	u64(1907348632812500000), u64(1192092895507812500), u64(1490116119384765625), u64(1862645149230957031),
	u64(1164153218269348144), u64(1455191522836685180), u64(1818989403545856475), u64(2273736754432320594),
	u64(1421085471520200371), u64(1776356839400250464), u64(2220446049250313080), u64(1387778780781445675),
	u64(1734723475976807094), u64(2168404344971008868), u64(1355252715606880542), u64(1694065894508600678),
	u64(2117582368135750847), u64(1323488980084844279), u64(1654361225106055349), u64(2067951531382569187),
	u64(1292469707114105741), u64(1615587133892632177), u64(2019483917365790221)
]

pow5_inv_split_32 = [
	u64(576460752303423489), u64(461168601842738791), u64(368934881474191033), u64(295147905179352826),
	u64(472236648286964522), u64(377789318629571618), u64(302231454903657294), u64(483570327845851670),
	u64(386856262276681336), u64(309485009821345069), u64(495176015714152110), u64(396140812571321688),
	u64(316912650057057351), u64(507060240091291761), u64(405648192073033409), u64(324518553658426727),
	u64(519229685853482763), u64(415383748682786211), u64(332306998946228969), u64(531691198313966350),
	u64(425352958651173080), u64(340282366920938464), u64(544451787073501542), u64(435561429658801234),
	u64(348449143727040987), u64(557518629963265579), u64(446014903970612463), u64(356811923176489971),
	u64(570899077082383953), u64(456719261665907162), u64(365375409332725730)
]

pow5_split_64 =[
	Uint128{u64(0x0000000000000000), u64(0x0100000000000000)},
	Uint128{u64(0x0000000000000000), u64(0x0140000000000000)},
	Uint128{u64(0x0000000000000000), u64(0x0190000000000000)},
	Uint128{u64(0x0000000000000000), u64(0x01f4000000000000)},
	Uint128{u64(0x0000000000000000), u64(0x0138800000000000)},
	Uint128{u64(0x0000000000000000), u64(0x0186a00000000000)},
	Uint128{u64(0x0000000000000000), u64(0x01e8480000000000)},
	Uint128{u64(0x0000000000000000), u64(0x01312d0000000000)},
	Uint128{u64(0x0000000000000000), u64(0x017d784000000000)},
	Uint128{u64(0x0000000000000000), u64(0x01dcd65000000000)},
	Uint128{u64(0x0000000000000000), u64(0x012a05f200000000)},
	Uint128{u64(0x0000000000000000), u64(0x0174876e80000000)},
	Uint128{u64(0x0000000000000000), u64(0x01d1a94a20000000)},
	Uint128{u64(0x0000000000000000), u64(0x012309ce54000000)},
	Uint128{u64(0x0000000000000000), u64(0x016bcc41e9000000)},
	Uint128{u64(0x0000000000000000), u64(0x01c6bf5263400000)},
	Uint128{u64(0x0000000000000000), u64(0x011c37937e080000)},
	Uint128{u64(0x0000000000000000), u64(0x016345785d8a0000)},
	Uint128{u64(0x0000000000000000), u64(0x01bc16d674ec8000)},
	Uint128{u64(0x0000000000000000), u64(0x01158e460913d000)},
	Uint128{u64(0x0000000000000000), u64(0x015af1d78b58c400)},
	Uint128{u64(0x0000000000000000), u64(0x01b1ae4d6e2ef500)},
	Uint128{u64(0x0000000000000000), u64(0x010f0cf064dd5920)},
	Uint128{u64(0x0000000000000000), u64(0x0152d02c7e14af68)},
	Uint128{u64(0x0000000000000000), u64(0x01a784379d99db42)},
	Uint128{u64(0x4000000000000000), u64(0x0108b2a2c2802909)},
	Uint128{u64(0x9000000000000000), u64(0x014adf4b7320334b)},
	Uint128{u64(0x7400000000000000), u64(0x019d971e4fe8401e)},
	Uint128{u64(0x0880000000000000), u64(0x01027e72f1f12813)},
	Uint128{u64(0xcaa0000000000000), u64(0x01431e0fae6d7217)},
	Uint128{u64(0xbd48000000000000), u64(0x0193e5939a08ce9d)},
	Uint128{u64(0x2c9a000000000000), u64(0x01f8def8808b0245)},
	Uint128{u64(0x3be0400000000000), u64(0x013b8b5b5056e16b)},
	Uint128{u64(0x0ad8500000000000), u64(0x018a6e32246c99c6)},
	Uint128{u64(0x8d8e640000000000), u64(0x01ed09bead87c037)},
	Uint128{u64(0xb878fe8000000000), u64(0x013426172c74d822)},
	Uint128{u64(0x66973e2000000000), u64(0x01812f9cf7920e2b)},
	Uint128{u64(0x403d0da800000000), u64(0x01e17b84357691b6)},
	Uint128{u64(0xe826288900000000), u64(0x012ced32a16a1b11)},
	Uint128{u64(0x622fb2ab40000000), u64(0x0178287f49c4a1d6)},
	Uint128{u64(0xfabb9f5610000000), u64(0x01d6329f1c35ca4b)},
	Uint128{u64(0x7cb54395ca000000), u64(0x0125dfa371a19e6f)},
	Uint128{u64(0x5be2947b3c800000), u64(0x016f578c4e0a060b)},
	Uint128{u64(0x32db399a0ba00000), u64(0x01cb2d6f618c878e)},
	Uint128{u64(0xdfc9040047440000), u64(0x011efc659cf7d4b8)},
	Uint128{u64(0x17bb450059150000), u64(0x0166bb7f0435c9e7)},
	Uint128{u64(0xddaa16406f5a4000), u64(0x01c06a5ec5433c60)},
	Uint128{u64(0x8a8a4de845986800), u64(0x0118427b3b4a05bc)},
	Uint128{u64(0xad2ce16256fe8200), u64(0x015e531a0a1c872b)},
	Uint128{u64(0x987819baecbe2280), u64(0x01b5e7e08ca3a8f6)},
	Uint128{u64(0x1f4b1014d3f6d590), u64(0x0111b0ec57e6499a)},
	Uint128{u64(0xa71dd41a08f48af4), u64(0x01561d276ddfdc00)},
	Uint128{u64(0xd0e549208b31adb1), u64(0x01aba4714957d300)},
	Uint128{u64(0x828f4db456ff0c8e), u64(0x010b46c6cdd6e3e0)},
	Uint128{u64(0xa33321216cbecfb2), u64(0x014e1878814c9cd8)},
	Uint128{u64(0xcbffe969c7ee839e), u64(0x01a19e96a19fc40e)},
	Uint128{u64(0x3f7ff1e21cf51243), u64(0x0105031e2503da89)},
	Uint128{u64(0x8f5fee5aa43256d4), u64(0x014643e5ae44d12b)},
	Uint128{u64(0x7337e9f14d3eec89), u64(0x0197d4df19d60576)},
	Uint128{u64(0x1005e46da08ea7ab), u64(0x01fdca16e04b86d4)},
	Uint128{u64(0x8a03aec4845928cb), u64(0x013e9e4e4c2f3444)},
	Uint128{u64(0xac849a75a56f72fd), u64(0x018e45e1df3b0155)},
	Uint128{u64(0x17a5c1130ecb4fbd), u64(0x01f1d75a5709c1ab)},
	Uint128{u64(0xeec798abe93f11d6), u64(0x013726987666190a)},
	Uint128{u64(0xaa797ed6e38ed64b), u64(0x0184f03e93ff9f4d)},
	Uint128{u64(0x1517de8c9c728bde), u64(0x01e62c4e38ff8721)},
	Uint128{u64(0xad2eeb17e1c7976b), u64(0x012fdbb0e39fb474)},
	Uint128{u64(0xd87aa5ddda397d46), u64(0x017bd29d1c87a191)},
	Uint128{u64(0x4e994f5550c7dc97), u64(0x01dac74463a989f6)},
	Uint128{u64(0xf11fd195527ce9de), u64(0x0128bc8abe49f639)},
	Uint128{u64(0x6d67c5faa71c2456), u64(0x0172ebad6ddc73c8)},
	Uint128{u64(0x88c1b77950e32d6c), u64(0x01cfa698c95390ba)},
	Uint128{u64(0x957912abd28dfc63), u64(0x0121c81f7dd43a74)},
	Uint128{u64(0xbad75756c7317b7c), u64(0x016a3a275d494911)},
	Uint128{u64(0x298d2d2c78fdda5b), u64(0x01c4c8b1349b9b56)},
	Uint128{u64(0xd9f83c3bcb9ea879), u64(0x011afd6ec0e14115)},
	Uint128{u64(0x50764b4abe865297), u64(0x0161bcca7119915b)},
	Uint128{u64(0x2493de1d6e27e73d), u64(0x01ba2bfd0d5ff5b2)},
	Uint128{u64(0x56dc6ad264d8f086), u64(0x01145b7e285bf98f)},
	Uint128{u64(0x2c938586fe0f2ca8), u64(0x0159725db272f7f3)},
	Uint128{u64(0xf7b866e8bd92f7d2), u64(0x01afcef51f0fb5ef)},
	Uint128{u64(0xfad34051767bdae3), u64(0x010de1593369d1b5)},
	Uint128{u64(0x79881065d41ad19c), u64(0x015159af80444623)},
	Uint128{u64(0x57ea147f49218603), u64(0x01a5b01b605557ac)},
	Uint128{u64(0xb6f24ccf8db4f3c1), u64(0x01078e111c3556cb)},
	Uint128{u64(0xa4aee003712230b2), u64(0x014971956342ac7e)},
	Uint128{u64(0x4dda98044d6abcdf), u64(0x019bcdfabc13579e)},
	Uint128{u64(0xf0a89f02b062b60b), u64(0x010160bcb58c16c2)},
	Uint128{u64(0xacd2c6c35c7b638e), u64(0x0141b8ebe2ef1c73)},
	Uint128{u64(0x98077874339a3c71), u64(0x01922726dbaae390)},
	Uint128{u64(0xbe0956914080cb8e), u64(0x01f6b0f092959c74)},
	Uint128{u64(0xf6c5d61ac8507f38), u64(0x013a2e965b9d81c8)},
	Uint128{u64(0x34774ba17a649f07), u64(0x0188ba3bf284e23b)},
	Uint128{u64(0x01951e89d8fdc6c8), u64(0x01eae8caef261aca)},
	Uint128{u64(0x40fd3316279e9c3d), u64(0x0132d17ed577d0be)},
	Uint128{u64(0xd13c7fdbb186434c), u64(0x017f85de8ad5c4ed)},
	Uint128{u64(0x458b9fd29de7d420), u64(0x01df67562d8b3629)},
	Uint128{u64(0xcb7743e3a2b0e494), u64(0x012ba095dc7701d9)},
	Uint128{u64(0x3e5514dc8b5d1db9), u64(0x017688bb5394c250)},
	Uint128{u64(0x4dea5a13ae346527), u64(0x01d42aea2879f2e4)},
	Uint128{u64(0xb0b2784c4ce0bf38), u64(0x01249ad2594c37ce)},
	Uint128{u64(0x5cdf165f6018ef06), u64(0x016dc186ef9f45c2)},
	Uint128{u64(0xf416dbf7381f2ac8), u64(0x01c931e8ab871732)},
	Uint128{u64(0xd88e497a83137abd), u64(0x011dbf316b346e7f)},
	Uint128{u64(0xceb1dbd923d8596c), u64(0x01652efdc6018a1f)},
	Uint128{u64(0xc25e52cf6cce6fc7), u64(0x01be7abd3781eca7)},
	Uint128{u64(0xd97af3c1a40105dc), u64(0x01170cb642b133e8)},
	Uint128{u64(0x0fd9b0b20d014754), u64(0x015ccfe3d35d80e3)},
	Uint128{u64(0xd3d01cde90419929), u64(0x01b403dcc834e11b)},
	Uint128{u64(0x6462120b1a28ffb9), u64(0x01108269fd210cb1)},
	Uint128{u64(0xbd7a968de0b33fa8), u64(0x0154a3047c694fdd)},
	Uint128{u64(0x2cd93c3158e00f92), u64(0x01a9cbc59b83a3d5)},
	Uint128{u64(0x3c07c59ed78c09bb), u64(0x010a1f5b81324665)},
	Uint128{u64(0x8b09b7068d6f0c2a), u64(0x014ca732617ed7fe)},
	Uint128{u64(0x2dcc24c830cacf34), u64(0x019fd0fef9de8dfe)},
	Uint128{u64(0xdc9f96fd1e7ec180), u64(0x0103e29f5c2b18be)},
	Uint128{u64(0x93c77cbc661e71e1), u64(0x0144db473335deee)},
	Uint128{u64(0x38b95beb7fa60e59), u64(0x01961219000356aa)},
	Uint128{u64(0xc6e7b2e65f8f91ef), u64(0x01fb969f40042c54)},
	Uint128{u64(0xfc50cfcffbb9bb35), u64(0x013d3e2388029bb4)},
	Uint128{u64(0x3b6503c3faa82a03), u64(0x018c8dac6a0342a2)},
	Uint128{u64(0xca3e44b4f9523484), u64(0x01efb1178484134a)},
	Uint128{u64(0xbe66eaf11bd360d2), u64(0x0135ceaeb2d28c0e)},
	Uint128{u64(0x6e00a5ad62c83907), u64(0x0183425a5f872f12)},
	Uint128{u64(0x0980cf18bb7a4749), u64(0x01e412f0f768fad7)},
	Uint128{u64(0x65f0816f752c6c8d), u64(0x012e8bd69aa19cc6)},
	Uint128{u64(0xff6ca1cb527787b1), u64(0x017a2ecc414a03f7)},
	Uint128{u64(0xff47ca3e2715699d), u64(0x01d8ba7f519c84f5)},
	Uint128{u64(0xbf8cde66d86d6202), u64(0x0127748f9301d319)},
	Uint128{u64(0x2f7016008e88ba83), u64(0x017151b377c247e0)},
	Uint128{u64(0x3b4c1b80b22ae923), u64(0x01cda62055b2d9d8)},
	Uint128{u64(0x250f91306f5ad1b6), u64(0x012087d4358fc827)},
	Uint128{u64(0xee53757c8b318623), u64(0x0168a9c942f3ba30)},
	Uint128{u64(0x29e852dbadfde7ac), u64(0x01c2d43b93b0a8bd)},
	Uint128{u64(0x3a3133c94cbeb0cc), u64(0x0119c4a53c4e6976)},
	Uint128{u64(0xc8bd80bb9fee5cff), u64(0x016035ce8b6203d3)},
	Uint128{u64(0xbaece0ea87e9f43e), u64(0x01b843422e3a84c8)},
	Uint128{u64(0x74d40c9294f238a7), u64(0x01132a095ce492fd)},
	Uint128{u64(0xd2090fb73a2ec6d1), u64(0x0157f48bb41db7bc)},
	Uint128{u64(0x068b53a508ba7885), u64(0x01adf1aea12525ac)},
	Uint128{u64(0x8417144725748b53), u64(0x010cb70d24b7378b)},
	Uint128{u64(0x651cd958eed1ae28), u64(0x014fe4d06de5056e)},
	Uint128{u64(0xfe640faf2a8619b2), u64(0x01a3de04895e46c9)},
	Uint128{u64(0x3efe89cd7a93d00f), u64(0x01066ac2d5daec3e)},
	Uint128{u64(0xcebe2c40d938c413), u64(0x014805738b51a74d)},
	Uint128{u64(0x426db7510f86f518), u64(0x019a06d06e261121)},
	Uint128{u64(0xc9849292a9b4592f), u64(0x0100444244d7cab4)},
	Uint128{u64(0xfbe5b73754216f7a), u64(0x01405552d60dbd61)},
	Uint128{u64(0x7adf25052929cb59), u64(0x01906aa78b912cba)},
	Uint128{u64(0x1996ee4673743e2f), u64(0x01f485516e7577e9)},
	Uint128{u64(0xaffe54ec0828a6dd), u64(0x0138d352e5096af1)},
	Uint128{u64(0x1bfdea270a32d095), u64(0x018708279e4bc5ae)},
	Uint128{u64(0xa2fd64b0ccbf84ba), u64(0x01e8ca3185deb719)},
	Uint128{u64(0x05de5eee7ff7b2f4), u64(0x01317e5ef3ab3270)},
	Uint128{u64(0x0755f6aa1ff59fb1), u64(0x017dddf6b095ff0c)},
	Uint128{u64(0x092b7454a7f3079e), u64(0x01dd55745cbb7ecf)},
	Uint128{u64(0x65bb28b4e8f7e4c3), u64(0x012a5568b9f52f41)},
	Uint128{u64(0xbf29f2e22335ddf3), u64(0x0174eac2e8727b11)},
	Uint128{u64(0x2ef46f9aac035570), u64(0x01d22573a28f19d6)},
	Uint128{u64(0xdd58c5c0ab821566), u64(0x0123576845997025)},
	Uint128{u64(0x54aef730d6629ac0), u64(0x016c2d4256ffcc2f)},
	Uint128{u64(0x29dab4fd0bfb4170), u64(0x01c73892ecbfbf3b)},
	Uint128{u64(0xfa28b11e277d08e6), u64(0x011c835bd3f7d784)},
	Uint128{u64(0x38b2dd65b15c4b1f), u64(0x0163a432c8f5cd66)},
	Uint128{u64(0xc6df94bf1db35de7), u64(0x01bc8d3f7b3340bf)},
	Uint128{u64(0xdc4bbcf772901ab0), u64(0x0115d847ad000877)},
	Uint128{u64(0xd35eac354f34215c), u64(0x015b4e5998400a95)},
	Uint128{u64(0x48365742a30129b4), u64(0x01b221effe500d3b)},
	Uint128{u64(0x0d21f689a5e0ba10), u64(0x010f5535fef20845)},
	Uint128{u64(0x506a742c0f58e894), u64(0x01532a837eae8a56)},
	Uint128{u64(0xe4851137132f22b9), u64(0x01a7f5245e5a2ceb)},
	Uint128{u64(0x6ed32ac26bfd75b4), u64(0x0108f936baf85c13)},
	Uint128{u64(0x4a87f57306fcd321), u64(0x014b378469b67318)},
	Uint128{u64(0x5d29f2cfc8bc07e9), u64(0x019e056584240fde)},
	Uint128{u64(0xfa3a37c1dd7584f1), u64(0x0102c35f729689ea)},
	Uint128{u64(0xb8c8c5b254d2e62e), u64(0x014374374f3c2c65)},
	Uint128{u64(0x26faf71eea079fb9), u64(0x01945145230b377f)},
	Uint128{u64(0xf0b9b4e6a48987a8), u64(0x01f965966bce055e)},
	Uint128{u64(0x5674111026d5f4c9), u64(0x013bdf7e0360c35b)},
	Uint128{u64(0x2c111554308b71fb), u64(0x018ad75d8438f432)},
	Uint128{u64(0xb7155aa93cae4e7a), u64(0x01ed8d34e547313e)},
	Uint128{u64(0x326d58a9c5ecf10c), u64(0x013478410f4c7ec7)},
	Uint128{u64(0xff08aed437682d4f), u64(0x01819651531f9e78)},
	Uint128{u64(0x3ecada89454238a3), u64(0x01e1fbe5a7e78617)},
	Uint128{u64(0x873ec895cb496366), u64(0x012d3d6f88f0b3ce)},
	Uint128{u64(0x290e7abb3e1bbc3f), u64(0x01788ccb6b2ce0c2)},
	Uint128{u64(0xb352196a0da2ab4f), u64(0x01d6affe45f818f2)},
	Uint128{u64(0xb0134fe24885ab11), u64(0x01262dfeebbb0f97)},
	Uint128{u64(0x9c1823dadaa715d6), u64(0x016fb97ea6a9d37d)},
	Uint128{u64(0x031e2cd19150db4b), u64(0x01cba7de5054485d)},
	Uint128{u64(0x21f2dc02fad2890f), u64(0x011f48eaf234ad3a)},
	Uint128{u64(0xaa6f9303b9872b53), u64(0x01671b25aec1d888)},
	Uint128{u64(0xd50b77c4a7e8f628), u64(0x01c0e1ef1a724eaa)},
	Uint128{u64(0xc5272adae8f199d9), u64(0x01188d357087712a)},
	Uint128{u64(0x7670f591a32e004f), u64(0x015eb082cca94d75)},
	Uint128{u64(0xd40d32f60bf98063), u64(0x01b65ca37fd3a0d2)},
	Uint128{u64(0xc4883fd9c77bf03e), u64(0x0111f9e62fe44483)},
	Uint128{u64(0xb5aa4fd0395aec4d), u64(0x0156785fbbdd55a4)},
	Uint128{u64(0xe314e3c447b1a760), u64(0x01ac1677aad4ab0d)},
	Uint128{u64(0xaded0e5aaccf089c), u64(0x010b8e0acac4eae8)},
	Uint128{u64(0xd96851f15802cac3), u64(0x014e718d7d7625a2)},
	Uint128{u64(0x8fc2666dae037d74), u64(0x01a20df0dcd3af0b)},
	Uint128{u64(0x39d980048cc22e68), u64(0x010548b68a044d67)},
	Uint128{u64(0x084fe005aff2ba03), u64(0x01469ae42c8560c1)},
	Uint128{u64(0x4a63d8071bef6883), u64(0x0198419d37a6b8f1)},
	Uint128{u64(0x9cfcce08e2eb42a4), u64(0x01fe52048590672d)},
	Uint128{u64(0x821e00c58dd309a7), u64(0x013ef342d37a407c)},
	Uint128{u64(0xa2a580f6f147cc10), u64(0x018eb0138858d09b)},
	Uint128{u64(0x8b4ee134ad99bf15), u64(0x01f25c186a6f04c2)},
	Uint128{u64(0x97114cc0ec80176d), u64(0x0137798f428562f9)},
	Uint128{u64(0xfcd59ff127a01d48), u64(0x018557f31326bbb7)},
	Uint128{u64(0xfc0b07ed7188249a), u64(0x01e6adefd7f06aa5)},
	Uint128{u64(0xbd86e4f466f516e0), u64(0x01302cb5e6f642a7)},
	Uint128{u64(0xace89e3180b25c98), u64(0x017c37e360b3d351)},
	Uint128{u64(0x1822c5bde0def3be), u64(0x01db45dc38e0c826)},
	Uint128{u64(0xcf15bb96ac8b5857), u64(0x01290ba9a38c7d17)},
	Uint128{u64(0xc2db2a7c57ae2e6d), u64(0x01734e940c6f9c5d)},
	Uint128{u64(0x3391f51b6d99ba08), u64(0x01d022390f8b8375)},
	Uint128{u64(0x403b393124801445), u64(0x01221563a9b73229)},
	Uint128{u64(0x904a077d6da01956), u64(0x016a9abc9424feb3)},
	Uint128{u64(0x745c895cc9081fac), u64(0x01c5416bb92e3e60)},
	Uint128{u64(0x48b9d5d9fda513cb), u64(0x011b48e353bce6fc)},
	Uint128{u64(0x5ae84b507d0e58be), u64(0x01621b1c28ac20bb)},
	Uint128{u64(0x31a25e249c51eeee), u64(0x01baa1e332d728ea)},
	Uint128{u64(0x5f057ad6e1b33554), u64(0x0114a52dffc67992)},
	Uint128{u64(0xf6c6d98c9a2002aa), u64(0x0159ce797fb817f6)},
	Uint128{u64(0xb4788fefc0a80354), u64(0x01b04217dfa61df4)},
	Uint128{u64(0xf0cb59f5d8690214), u64(0x010e294eebc7d2b8)},
	Uint128{u64(0x2cfe30734e83429a), u64(0x0151b3a2a6b9c767)},
	Uint128{u64(0xf83dbc9022241340), u64(0x01a6208b50683940)},
	Uint128{u64(0x9b2695da15568c08), u64(0x0107d457124123c8)},
	Uint128{u64(0xc1f03b509aac2f0a), u64(0x0149c96cd6d16cba)},
	Uint128{u64(0x726c4a24c1573acd), u64(0x019c3bc80c85c7e9)},
	Uint128{u64(0xe783ae56f8d684c0), u64(0x0101a55d07d39cf1)},
	Uint128{u64(0x616499ecb70c25f0), u64(0x01420eb449c8842e)},
	Uint128{u64(0xf9bdc067e4cf2f6c), u64(0x019292615c3aa539)},
	Uint128{u64(0x782d3081de02fb47), u64(0x01f736f9b3494e88)},
	Uint128{u64(0x4b1c3e512ac1dd0c), u64(0x013a825c100dd115)},
	Uint128{u64(0x9de34de57572544f), u64(0x018922f31411455a)},
	Uint128{u64(0x455c215ed2cee963), u64(0x01eb6bafd91596b1)},
	Uint128{u64(0xcb5994db43c151de), u64(0x0133234de7ad7e2e)},
	Uint128{u64(0x7e2ffa1214b1a655), u64(0x017fec216198ddba)},
	Uint128{u64(0x1dbbf89699de0feb), u64(0x01dfe729b9ff1529)},
	Uint128{u64(0xb2957b5e202ac9f3), u64(0x012bf07a143f6d39)},
	Uint128{u64(0x1f3ada35a8357c6f), u64(0x0176ec98994f4888)},
	Uint128{u64(0x270990c31242db8b), u64(0x01d4a7bebfa31aaa)},
	Uint128{u64(0x5865fa79eb69c937), u64(0x0124e8d737c5f0aa)},
	Uint128{u64(0xee7f791866443b85), u64(0x016e230d05b76cd4)},
	Uint128{u64(0x2a1f575e7fd54a66), u64(0x01c9abd04725480a)},
	Uint128{u64(0x5a53969b0fe54e80), u64(0x011e0b622c774d06)},
	Uint128{u64(0xf0e87c41d3dea220), u64(0x01658e3ab7952047)},
	Uint128{u64(0xed229b5248d64aa8), u64(0x01bef1c9657a6859)},
	Uint128{u64(0x3435a1136d85eea9), u64(0x0117571ddf6c8138)},
	Uint128{u64(0x4143095848e76a53), u64(0x015d2ce55747a186)},
	Uint128{u64(0xd193cbae5b2144e8), u64(0x01b4781ead1989e7)},
	Uint128{u64(0xe2fc5f4cf8f4cb11), u64(0x0110cb132c2ff630)},
	Uint128{u64(0x1bbb77203731fdd5), u64(0x0154fdd7f73bf3bd)},
	Uint128{u64(0x62aa54e844fe7d4a), u64(0x01aa3d4df50af0ac)},
	Uint128{u64(0xbdaa75112b1f0e4e), u64(0x010a6650b926d66b)},
	Uint128{u64(0xad15125575e6d1e2), u64(0x014cffe4e7708c06)},
	Uint128{u64(0x585a56ead360865b), u64(0x01a03fde214caf08)},
	Uint128{u64(0x37387652c41c53f8), u64(0x010427ead4cfed65)},
	Uint128{u64(0x850693e7752368f7), u64(0x014531e58a03e8be)},
	Uint128{u64(0x264838e1526c4334), u64(0x01967e5eec84e2ee)},
	Uint128{u64(0xafda4719a7075402), u64(0x01fc1df6a7a61ba9)},
	Uint128{u64(0x0de86c7008649481), u64(0x013d92ba28c7d14a)},
	Uint128{u64(0x9162878c0a7db9a1), u64(0x018cf768b2f9c59c)},
	Uint128{u64(0xb5bb296f0d1d280a), u64(0x01f03542dfb83703)},
	Uint128{u64(0x5194f9e568323906), u64(0x01362149cbd32262)},
	Uint128{u64(0xe5fa385ec23ec747), u64(0x0183a99c3ec7eafa)},
	Uint128{u64(0x9f78c67672ce7919), u64(0x01e494034e79e5b9)},
	Uint128{u64(0x03ab7c0a07c10bb0), u64(0x012edc82110c2f94)},
	Uint128{u64(0x04965b0c89b14e9c), u64(0x017a93a2954f3b79)},
	Uint128{u64(0x45bbf1cfac1da243), u64(0x01d9388b3aa30a57)},
	Uint128{u64(0x8b957721cb92856a), u64(0x0127c35704a5e676)},
	Uint128{u64(0x2e7ad4ea3e7726c4), u64(0x0171b42cc5cf6014)},
	Uint128{u64(0x3a198a24ce14f075), u64(0x01ce2137f7433819)},
	Uint128{u64(0xc44ff65700cd1649), u64(0x0120d4c2fa8a030f)},
	Uint128{u64(0xb563f3ecc1005bdb), u64(0x016909f3b92c83d3)},
	Uint128{u64(0xa2bcf0e7f14072d2), u64(0x01c34c70a777a4c8)},
	Uint128{u64(0x65b61690f6c847c3), u64(0x011a0fc668aac6fd)},
	Uint128{u64(0xbf239c35347a59b4), u64(0x016093b802d578bc)},
	Uint128{u64(0xeeec83428198f021), u64(0x01b8b8a6038ad6eb)},
	Uint128{u64(0x7553d20990ff9615), u64(0x01137367c236c653)},
	Uint128{u64(0x52a8c68bf53f7b9a), u64(0x01585041b2c477e8)},
	Uint128{u64(0x6752f82ef28f5a81), u64(0x01ae64521f7595e2)},
	Uint128{u64(0x8093db1d57999890), u64(0x010cfeb353a97dad)},
	Uint128{u64(0xe0b8d1e4ad7ffeb4), u64(0x01503e602893dd18)},
	Uint128{u64(0x18e7065dd8dffe62), u64(0x01a44df832b8d45f)},
	Uint128{u64(0x6f9063faa78bfefd), u64(0x0106b0bb1fb384bb)},
	Uint128{u64(0x4b747cf9516efebc), u64(0x01485ce9e7a065ea)},
	Uint128{u64(0xde519c37a5cabe6b), u64(0x019a742461887f64)},
	Uint128{u64(0x0af301a2c79eb703), u64(0x01008896bcf54f9f)},
	Uint128{u64(0xcdafc20b798664c4), u64(0x0140aabc6c32a386)},
	Uint128{u64(0x811bb28e57e7fdf5), u64(0x0190d56b873f4c68)},
	Uint128{u64(0xa1629f31ede1fd72), u64(0x01f50ac6690f1f82)},
	Uint128{u64(0xa4dda37f34ad3e67), u64(0x013926bc01a973b1)},
	Uint128{u64(0x0e150c5f01d88e01), u64(0x0187706b0213d09e)},
	Uint128{u64(0x919a4f76c24eb181), u64(0x01e94c85c298c4c5)},
	Uint128{u64(0x7b0071aa39712ef1), u64(0x0131cfd3999f7afb)},
	Uint128{u64(0x59c08e14c7cd7aad), u64(0x017e43c8800759ba)},
	Uint128{u64(0xf030b199f9c0d958), u64(0x01ddd4baa0093028)},
	Uint128{u64(0x961e6f003c1887d7), u64(0x012aa4f4a405be19)},
	Uint128{u64(0xfba60ac04b1ea9cd), u64(0x01754e31cd072d9f)},
	Uint128{u64(0xfa8f8d705de65440), u64(0x01d2a1be4048f907)},
	Uint128{u64(0xfc99b8663aaff4a8), u64(0x0123a516e82d9ba4)},
	Uint128{u64(0x3bc0267fc95bf1d2), u64(0x016c8e5ca239028e)},
	Uint128{u64(0xcab0301fbbb2ee47), u64(0x01c7b1f3cac74331)},
	Uint128{u64(0x1eae1e13d54fd4ec), u64(0x011ccf385ebc89ff)},
	Uint128{u64(0xe659a598caa3ca27), u64(0x01640306766bac7e)},
	Uint128{u64(0x9ff00efefd4cbcb1), u64(0x01bd03c81406979e)},
	Uint128{u64(0x23f6095f5e4ff5ef), u64(0x0116225d0c841ec3)},
	Uint128{u64(0xecf38bb735e3f36a), u64(0x015baaf44fa52673)},
	Uint128{u64(0xe8306ea5035cf045), u64(0x01b295b1638e7010)},
	Uint128{u64(0x911e4527221a162b), u64(0x010f9d8ede39060a)},
	Uint128{u64(0x3565d670eaa09bb6), u64(0x015384f295c7478d)},
	Uint128{u64(0x82bf4c0d2548c2a3), u64(0x01a8662f3b391970)},
	Uint128{u64(0x51b78f88374d79a6), u64(0x01093fdd8503afe6)},
	Uint128{u64(0xe625736a4520d810), u64(0x014b8fd4e6449bdf)},
	Uint128{u64(0xdfaed044d6690e14), u64(0x019e73ca1fd5c2d7)},
	Uint128{u64(0xebcd422b0601a8cc), u64(0x0103085e53e599c6)},
	Uint128{u64(0xa6c092b5c78212ff), u64(0x0143ca75e8df0038)},
	Uint128{u64(0xd070b763396297bf), u64(0x0194bd136316c046)},
	Uint128{u64(0x848ce53c07bb3daf), u64(0x01f9ec583bdc7058)},
	Uint128{u64(0x52d80f4584d5068d), u64(0x013c33b72569c637)},
	Uint128{u64(0x278e1316e60a4831), u64(0x018b40a4eec437c5)}
]

pow5_inv_split_64 = [
	Uint128{u64(0x0000000000000001), u64(0x0400000000000000)},
	Uint128{u64(0x3333333333333334), u64(0x0333333333333333)},
	Uint128{u64(0x28f5c28f5c28f5c3), u64(0x028f5c28f5c28f5c)},
	Uint128{u64(0xed916872b020c49c), u64(0x020c49ba5e353f7c)},
	Uint128{u64(0xaf4f0d844d013a93), u64(0x0346dc5d63886594)},
	Uint128{u64(0x8c3f3e0370cdc876), u64(0x029f16b11c6d1e10)},
	Uint128{u64(0xd698fe69270b06c5), u64(0x0218def416bdb1a6)},
	Uint128{u64(0xf0f4ca41d811a46e), u64(0x035afe535795e90a)},
	Uint128{u64(0xf3f70834acdae9f1), u64(0x02af31dc4611873b)},
	Uint128{u64(0x5cc5a02a23e254c1), u64(0x0225c17d04dad296)},
	Uint128{u64(0xfad5cd10396a2135), u64(0x036f9bfb3af7b756)},
	Uint128{u64(0xfbde3da69454e75e), u64(0x02bfaffc2f2c92ab)},
	Uint128{u64(0x2fe4fe1edd10b918), u64(0x0232f33025bd4223)},
	Uint128{u64(0x4ca19697c81ac1bf), u64(0x0384b84d092ed038)},
	Uint128{u64(0x3d4e1213067bce33), u64(0x02d09370d4257360)},
	Uint128{u64(0x643e74dc052fd829), u64(0x024075f3dceac2b3)},
	Uint128{u64(0x6d30baf9a1e626a7), u64(0x039a5652fb113785)},
	Uint128{u64(0x2426fbfae7eb5220), u64(0x02e1dea8c8da92d1)},
	Uint128{u64(0x1cebfcc8b9890e80), u64(0x024e4bba3a487574)},
	Uint128{u64(0x94acc7a78f41b0cc), u64(0x03b07929f6da5586)},
	Uint128{u64(0xaa23d2ec729af3d7), u64(0x02f394219248446b)},
	Uint128{u64(0xbb4fdbf05baf2979), u64(0x025c768141d369ef)},
	Uint128{u64(0xc54c931a2c4b758d), u64(0x03c7240202ebdcb2)},
	Uint128{u64(0x9dd6dc14f03c5e0b), u64(0x0305b66802564a28)},
	Uint128{u64(0x4b1249aa59c9e4d6), u64(0x026af8533511d4ed)},
	Uint128{u64(0x44ea0f76f60fd489), u64(0x03de5a1ebb4fbb15)},
	Uint128{u64(0x6a54d92bf80caa07), u64(0x0318481895d96277)},
	Uint128{u64(0x21dd7a89933d54d2), u64(0x0279d346de4781f9)},
	Uint128{u64(0x362f2a75b8622150), u64(0x03f61ed7ca0c0328)},
	Uint128{u64(0xf825bb91604e810d), u64(0x032b4bdfd4d668ec)},
	Uint128{u64(0xc684960de6a5340b), u64(0x0289097fdd7853f0)},
	Uint128{u64(0xd203ab3e521dc33c), u64(0x02073accb12d0ff3)},
	Uint128{u64(0xe99f7863b696052c), u64(0x033ec47ab514e652)},
	Uint128{u64(0x87b2c6b62bab3757), u64(0x02989d2ef743eb75)},
	Uint128{u64(0xd2f56bc4efbc2c45), u64(0x0213b0f25f69892a)},
	Uint128{u64(0x1e55793b192d13a2), u64(0x0352b4b6ff0f41de)},
	Uint128{u64(0x4b77942f475742e8), u64(0x02a8909265a5ce4b)},
	Uint128{u64(0xd5f9435905df68ba), u64(0x022073a8515171d5)},
	Uint128{u64(0x565b9ef4d6324129), u64(0x03671f73b54f1c89)},
	Uint128{u64(0xdeafb25d78283421), u64(0x02b8e5f62aa5b06d)},
	Uint128{u64(0x188c8eb12cecf681), u64(0x022d84c4eeeaf38b)},
	Uint128{u64(0x8dadb11b7b14bd9b), u64(0x037c07a17e44b8de)},
	Uint128{u64(0x7157c0e2c8dd647c), u64(0x02c99fb46503c718)},
	Uint128{u64(0x8ddfcd823a4ab6ca), u64(0x023ae629ea696c13)},
	Uint128{u64(0x1632e269f6ddf142), u64(0x0391704310a8acec)},
	Uint128{u64(0x44f581ee5f17f435), u64(0x02dac035a6ed5723)},
	Uint128{u64(0x372ace584c1329c4), u64(0x024899c4858aac1c)},
	Uint128{u64(0xbeaae3c079b842d3), u64(0x03a75c6da27779c6)},
	Uint128{u64(0x6555830061603576), u64(0x02ec49f14ec5fb05)},
	Uint128{u64(0xb7779c004de6912b), u64(0x0256a18dd89e626a)},
	Uint128{u64(0xf258f99a163db512), u64(0x03bdcf495a9703dd)},
	Uint128{u64(0x5b7a614811caf741), u64(0x02fe3f6de212697e)},
	Uint128{u64(0xaf951aa00e3bf901), u64(0x0264ff8b1b41edfe)},
	Uint128{u64(0x7f54f7667d2cc19b), u64(0x03d4cc11c5364997)},
	Uint128{u64(0x32aa5f8530f09ae3), u64(0x0310a3416a91d479)},
	Uint128{u64(0xf55519375a5a1582), u64(0x0273b5cdeedb1060)},
	Uint128{u64(0xbbbb5b8bc3c3559d), u64(0x03ec56164af81a34)},
	Uint128{u64(0x2fc916096969114a), u64(0x03237811d593482a)},
	Uint128{u64(0x596dab3ababa743c), u64(0x0282c674aadc39bb)},
	Uint128{u64(0x478aef622efb9030), u64(0x0202385d557cfafc)},
	Uint128{u64(0xd8de4bd04b2c19e6), u64(0x0336c0955594c4c6)},
	Uint128{u64(0xad7ea30d08f014b8), u64(0x029233aaaadd6a38)},
	Uint128{u64(0x24654f3da0c01093), u64(0x020e8fbbbbe454fa)},
	Uint128{u64(0x3a3bb1fc346680eb), u64(0x034a7f92c63a2190)},
	Uint128{u64(0x94fc8e635d1ecd89), u64(0x02a1ffa89e94e7a6)},
	Uint128{u64(0xaa63a51c4a7f0ad4), u64(0x021b32ed4baa52eb)},
	Uint128{u64(0xdd6c3b607731aaed), u64(0x035eb7e212aa1e45)},
	Uint128{u64(0x1789c919f8f488bd), u64(0x02b22cb4dbbb4b6b)},
	Uint128{u64(0xac6e3a7b2d906d64), u64(0x022823c3e2fc3c55)},
	Uint128{u64(0x13e390c515b3e23a), u64(0x03736c6c9e606089)},
	Uint128{u64(0xdcb60d6a77c31b62), u64(0x02c2bd23b1e6b3a0)},
	Uint128{u64(0x7d5e7121f968e2b5), u64(0x0235641c8e52294d)},
	Uint128{u64(0xc8971b698f0e3787), u64(0x0388a02db0837548)},
	Uint128{u64(0xa078e2bad8d82c6c), u64(0x02d3b357c0692aa0)},
	Uint128{u64(0xe6c71bc8ad79bd24), u64(0x0242f5dfcd20eee6)},
	Uint128{u64(0x0ad82c7448c2c839), u64(0x039e5632e1ce4b0b)},
	Uint128{u64(0x3be023903a356cfa), u64(0x02e511c24e3ea26f)},
	Uint128{u64(0x2fe682d9c82abd95), u64(0x0250db01d8321b8c)},
	Uint128{u64(0x4ca4048fa6aac8ee), u64(0x03b4919c8d1cf8e0)},
	Uint128{u64(0x3d5003a61eef0725), u64(0x02f6dae3a4172d80)},
	Uint128{u64(0x9773361e7f259f51), u64(0x025f1582e9ac2466)},
	Uint128{u64(0x8beb89ca6508fee8), u64(0x03cb559e42ad070a)},
	Uint128{u64(0x6fefa16eb73a6586), u64(0x0309114b688a6c08)},
	Uint128{u64(0xf3261abef8fb846b), u64(0x026da76f86d52339)},
	Uint128{u64(0x51d691318e5f3a45), u64(0x03e2a57f3e21d1f6)},
	Uint128{u64(0x0e4540f471e5c837), u64(0x031bb798fe8174c5)},
	Uint128{u64(0xd8376729f4b7d360), u64(0x027c92e0cb9ac3d0)},
	Uint128{u64(0xf38bd84321261eff), u64(0x03fa849adf5e061a)},
	Uint128{u64(0x293cad0280eb4bff), u64(0x032ed07be5e4d1af)},
	Uint128{u64(0xedca240200bc3ccc), u64(0x028bd9fcb7ea4158)},
	Uint128{u64(0xbe3b50019a3030a4), u64(0x02097b309321cde0)},
	Uint128{u64(0xc9f88002904d1a9f), u64(0x03425eb41e9c7c9a)},
	Uint128{u64(0x3b2d3335403daee6), u64(0x029b7ef67ee396e2)},
	Uint128{u64(0x95bdc291003158b8), u64(0x0215ff2b98b6124e)},
	Uint128{u64(0x892f9db4cd1bc126), u64(0x035665128df01d4a)},
	Uint128{u64(0x07594af70a7c9a85), u64(0x02ab840ed7f34aa2)},
	Uint128{u64(0x6c476f2c0863aed1), u64(0x0222d00bdff5d54e)},
	Uint128{u64(0x13a57eacda3917b4), u64(0x036ae67966562217)},
	Uint128{u64(0x0fb7988a482dac90), u64(0x02bbeb9451de81ac)},
	Uint128{u64(0xd95fad3b6cf156da), u64(0x022fefa9db1867bc)},
	Uint128{u64(0xf565e1f8ae4ef15c), u64(0x037fe5dc91c0a5fa)},
	Uint128{u64(0x911e4e608b725ab0), u64(0x02ccb7e3a7cd5195)},
	Uint128{u64(0xda7ea51a0928488d), u64(0x023d5fe9530aa7aa)},
	Uint128{u64(0xf7310829a8407415), u64(0x039566421e7772aa)},
	Uint128{u64(0x2c2739baed005cde), u64(0x02ddeb68185f8eef)},
	Uint128{u64(0xbcec2e2f24004a4b), u64(0x024b22b9ad193f25)},
	Uint128{u64(0x94ad16b1d333aa11), u64(0x03ab6ac2ae8ecb6f)},
	Uint128{u64(0xaa241227dc2954db), u64(0x02ef889bbed8a2bf)},
	Uint128{u64(0x54e9a81fe35443e2), u64(0x02593a163246e899)},
	Uint128{u64(0x2175d9cc9eed396a), u64(0x03c1f689ea0b0dc2)},
	Uint128{u64(0xe7917b0a18bdc788), u64(0x03019207ee6f3e34)},
	Uint128{u64(0xb9412f3b46fe393a), u64(0x0267a8065858fe90)},
	Uint128{u64(0xf535185ed7fd285c), u64(0x03d90cd6f3c1974d)},
	Uint128{u64(0xc42a79e57997537d), u64(0x03140a458fce12a4)},
	Uint128{u64(0x03552e512e12a931), u64(0x02766e9e0ca4dbb7)},
	Uint128{u64(0x9eeeb081e3510eb4), u64(0x03f0b0fce107c5f1)},
	Uint128{u64(0x4bf226ce4f740bc3), u64(0x0326f3fd80d304c1)},
	Uint128{u64(0xa3281f0b72c33c9c), u64(0x02858ffe00a8d09a)},
	Uint128{u64(0x1c2018d5f568fd4a), u64(0x020473319a20a6e2)},
	Uint128{u64(0xf9ccf48988a7fba9), u64(0x033a51e8f69aa49c)},
	Uint128{u64(0xfb0a5d3ad3b99621), u64(0x02950e53f87bb6e3)},
	Uint128{u64(0x2f3b7dc8a96144e7), u64(0x0210d8432d2fc583)},
	Uint128{u64(0xe52bfc7442353b0c), u64(0x034e26d1e1e608d1)},
	Uint128{u64(0xb756639034f76270), u64(0x02a4ebdb1b1e6d74)},
	Uint128{u64(0x2c451c735d92b526), u64(0x021d897c15b1f12a)},
	Uint128{u64(0x13a1c71efc1deea3), u64(0x0362759355e981dd)},
	Uint128{u64(0x761b05b2634b2550), u64(0x02b52adc44bace4a)},
	Uint128{u64(0x91af37c1e908eaa6), u64(0x022a88b036fbd83b)},
	Uint128{u64(0x82b1f2cfdb417770), u64(0x03774119f192f392)},
	Uint128{u64(0xcef4c23fe29ac5f3), u64(0x02c5cdae5adbf60e)},
	Uint128{u64(0x3f2a34ffe87bd190), u64(0x0237d7beaf165e72)},
	Uint128{u64(0x984387ffda5fb5b2), u64(0x038c8c644b56fd83)},
	Uint128{u64(0xe0360666484c915b), u64(0x02d6d6b6a2abfe02)},
	Uint128{u64(0x802b3851d3707449), u64(0x024578921bbccb35)},
	Uint128{u64(0x99dec082ebe72075), u64(0x03a25a835f947855)},
	Uint128{u64(0xae4bcd358985b391), u64(0x02e8486919439377)},
	Uint128{u64(0xbea30a913ad15c74), u64(0x02536d20e102dc5f)},
	Uint128{u64(0xfdd1aa81f7b560b9), u64(0x03b8ae9b019e2d65)},
	Uint128{u64(0x97daeece5fc44d61), u64(0x02fa2548ce182451)},
	Uint128{u64(0xdfe258a51969d781), u64(0x0261b76d71ace9da)},
	Uint128{u64(0x996a276e8f0fbf34), u64(0x03cf8be24f7b0fc4)},
	Uint128{u64(0xe121b9253f3fcc2a), u64(0x030c6fe83f95a636)},
	Uint128{u64(0xb41afa8432997022), u64(0x02705986994484f8)},
	Uint128{u64(0xecf7f739ea8f19cf), u64(0x03e6f5a4286da18d)},
	Uint128{u64(0x23f99294bba5ae40), u64(0x031f2ae9b9f14e0b)},
	Uint128{u64(0x4ffadbaa2fb7be99), u64(0x027f5587c7f43e6f)},
	Uint128{u64(0x7ff7c5dd1925fdc2), u64(0x03feef3fa6539718)},
	Uint128{u64(0xccc637e4141e649b), u64(0x033258ffb842df46)},
	Uint128{u64(0xd704f983434b83af), u64(0x028ead9960357f6b)},
	Uint128{u64(0x126a6135cf6f9c8c), u64(0x020bbe144cf79923)},
	Uint128{u64(0x83dd685618b29414), u64(0x0345fced47f28e9e)},
	Uint128{u64(0x9cb12044e08edcdd), u64(0x029e63f1065ba54b)},
	Uint128{u64(0x16f419d0b3a57d7d), u64(0x02184ff405161dd6)},
	Uint128{u64(0x8b20294dec3bfbfb), u64(0x035a19866e89c956)},
	Uint128{u64(0x3c19baa4bcfcc996), u64(0x02ae7ad1f207d445)},
	Uint128{u64(0xc9ae2eea30ca3adf), u64(0x02252f0e5b39769d)},
	Uint128{u64(0x0f7d17dd1add2afd), u64(0x036eb1b091f58a96)},
	Uint128{u64(0x3f97464a7be42264), u64(0x02bef48d41913bab)},
	Uint128{u64(0xcc790508631ce850), u64(0x02325d3dce0dc955)},
	Uint128{u64(0xe0c1a1a704fb0d4d), u64(0x0383c862e3494222)},
	Uint128{u64(0x4d67b4859d95a43e), u64(0x02cfd3824f6dce82)},
	Uint128{u64(0x711fc39e17aae9cb), u64(0x023fdc683f8b0b9b)},
	Uint128{u64(0xe832d2968c44a945), u64(0x039960a6cc11ac2b)},
	Uint128{u64(0xecf575453d03ba9e), u64(0x02e11a1f09a7bcef)},
	Uint128{u64(0x572ac4376402fbb1), u64(0x024dae7f3aec9726)},
	Uint128{u64(0x58446d256cd192b5), u64(0x03af7d985e47583d)},
	Uint128{u64(0x79d0575123dadbc4), u64(0x02f2cae04b6c4697)},
	Uint128{u64(0x94a6ac40e97be303), u64(0x025bd5803c569edf)},
	Uint128{u64(0x8771139b0f2c9e6c), u64(0x03c62266c6f0fe32)},
	Uint128{u64(0x9f8da948d8f07ebd), u64(0x0304e85238c0cb5b)},
	Uint128{u64(0xe60aedd3e0c06564), u64(0x026a5374fa33d5e2)},
	Uint128{u64(0xa344afb9679a3bd2), u64(0x03dd5254c3862304)},
	Uint128{u64(0xe903bfc78614fca8), u64(0x031775109c6b4f36)},
	Uint128{u64(0xba6966393810ca20), u64(0x02792a73b055d8f8)},
	Uint128{u64(0x2a423d2859b4769a), u64(0x03f510b91a22f4c1)},
	Uint128{u64(0xee9b642047c39215), u64(0x032a73c7481bf700)},
	Uint128{u64(0xbee2b680396941aa), u64(0x02885c9f6ce32c00)},
	Uint128{u64(0xff1bc53361210155), u64(0x0206b07f8a4f5666)},
	Uint128{u64(0x31c6085235019bbb), u64(0x033de73276e5570b)},
	Uint128{u64(0x27d1a041c4014963), u64(0x0297ec285f1ddf3c)},
	Uint128{u64(0xeca7b367d0010782), u64(0x021323537f4b18fc)},
	Uint128{u64(0xadd91f0c8001a59d), u64(0x0351d21f3211c194)},
	Uint128{u64(0xf17a7f3d3334847e), u64(0x02a7db4c280e3476)},
	Uint128{u64(0x279532975c2a0398), u64(0x021fe2a3533e905f)},
	Uint128{u64(0xd8eeb75893766c26), u64(0x0366376bb8641a31)},
	Uint128{u64(0x7a5892ad42c52352), u64(0x02b82c562d1ce1c1)},
	Uint128{u64(0xfb7a0ef102374f75), u64(0x022cf044f0e3e7cd)},
	Uint128{u64(0xc59017e8038bb254), u64(0x037b1a07e7d30c7c)},
	Uint128{u64(0x37a67986693c8eaa), u64(0x02c8e19feca8d6ca)},
	Uint128{u64(0xf951fad1edca0bbb), u64(0x023a4e198a20abd4)},
	Uint128{u64(0x28832ae97c76792b), u64(0x03907cf5a9cddfbb)},
	Uint128{u64(0x2068ef21305ec756), u64(0x02d9fd9154a4b2fc)},
	Uint128{u64(0x19ed8c1a8d189f78), u64(0x0247fe0ddd508f30)},
	Uint128{u64(0x5caf4690e1c0ff26), u64(0x03a66349621a7eb3)},
	Uint128{u64(0x4a25d20d81673285), u64(0x02eb82a11b48655c)},
	Uint128{u64(0x3b5174d79ab8f537), u64(0x0256021a7c39eab0)},
	Uint128{u64(0x921bee25c45b21f1), u64(0x03bcd02a605caab3)},
	Uint128{u64(0xdb498b5169e2818e), u64(0x02fd735519e3bbc2)},
	Uint128{u64(0x15d46f7454b53472), u64(0x02645c4414b62fcf)},
	Uint128{u64(0xefba4bed545520b6), u64(0x03d3c6d35456b2e4)},
	Uint128{u64(0xf2fb6ff110441a2b), u64(0x030fd242a9def583)},
	Uint128{u64(0x8f2f8cc0d9d014ef), u64(0x02730e9bbb18c469)},
	Uint128{u64(0xb1e5ae015c80217f), u64(0x03eb4a92c4f46d75)},
	Uint128{u64(0xc1848b344a001acc), u64(0x0322a20f03f6bdf7)},
	Uint128{u64(0xce03a2903b3348a3), u64(0x02821b3f365efe5f)},
	Uint128{u64(0xd802e873628f6d4f), u64(0x0201af65c518cb7f)},
	Uint128{u64(0x599e40b89db2487f), u64(0x0335e56fa1c14599)},
	Uint128{u64(0xe14b66fa17c1d399), u64(0x029184594e3437ad)},
	Uint128{u64(0x81091f2e7967dc7a), u64(0x020e037aa4f692f1)},
	Uint128{u64(0x9b41cb7d8f0c93f6), u64(0x03499f2aa18a84b5)},
	Uint128{u64(0xaf67d5fe0c0a0ff8), u64(0x02a14c221ad536f7)},
	Uint128{u64(0xf2b977fe70080cc7), u64(0x021aa34e7bddc592)},
	Uint128{u64(0x1df58cca4cd9ae0b), u64(0x035dd2172c9608eb)},
	Uint128{u64(0xe4c470a1d7148b3c), u64(0x02b174df56de6d88)},
	Uint128{u64(0x83d05a1b1276d5ca), u64(0x022790b2abe5246d)},
	Uint128{u64(0x9fb3c35e83f1560f), u64(0x0372811ddfd50715)},
	Uint128{u64(0xb2f635e5365aab3f), u64(0x02c200e4b310d277)},
	Uint128{u64(0xf591c4b75eaeef66), u64(0x0234cd83c273db92)},
	Uint128{u64(0xef4fa125644b18a3), u64(0x0387af39371fc5b7)},
	Uint128{u64(0x8c3fb41de9d5ad4f), u64(0x02d2f2942c196af9)},
	Uint128{u64(0x3cffc34b2177bdd9), u64(0x02425ba9bce12261)},
	Uint128{u64(0x94cc6bab68bf9628), u64(0x039d5f75fb01d09b)},
	Uint128{u64(0x10a38955ed6611b9), u64(0x02e44c5e6267da16)},
	Uint128{u64(0xda1c6dde5784dafb), u64(0x02503d184eb97b44)},
	Uint128{u64(0xf693e2fd58d49191), u64(0x03b394f3b128c53a)},
	Uint128{u64(0xc5431bfde0aa0e0e), u64(0x02f610c2f4209dc8)},
	Uint128{u64(0x6a9c1664b3bb3e72), u64(0x025e73cf29b3b16d)},
	Uint128{u64(0x10f9bd6dec5eca4f), u64(0x03ca52e50f85e8af)},
	Uint128{u64(0xda616457f04bd50c), u64(0x03084250d937ed58)},
	Uint128{u64(0xe1e783798d09773d), u64(0x026d01da475ff113)},
	Uint128{u64(0x030c058f480f252e), u64(0x03e19c9072331b53)},
	Uint128{u64(0x68d66ad906728425), u64(0x031ae3a6c1c27c42)},
	Uint128{u64(0x8711ef14052869b7), u64(0x027be952349b969b)},
	Uint128{u64(0x0b4fe4ecd50d75f2), u64(0x03f97550542c242c)},
	Uint128{u64(0xa2a650bd773df7f5), u64(0x032df7737689b689)},
	Uint128{u64(0xb551da312c31932a), u64(0x028b2c5c5ed49207)},
	Uint128{u64(0x5ddb14f4235adc22), u64(0x0208f049e576db39)},
	Uint128{u64(0x2fc4ee536bc49369), u64(0x034180763bf15ec2)},
	Uint128{u64(0xbfd0bea92303a921), u64(0x029acd2b63277f01)},
	Uint128{u64(0x9973cbba8269541a), u64(0x021570ef8285ff34)},
	Uint128{u64(0x5bec792a6a42202a), u64(0x0355817f373ccb87)},
	Uint128{u64(0xe3239421ee9b4cef), u64(0x02aacdff5f63d605)},
	Uint128{u64(0xb5b6101b25490a59), u64(0x02223e65e5e97804)},
	Uint128{u64(0x22bce691d541aa27), u64(0x0369fd6fd64259a1)},
	Uint128{u64(0xb563eba7ddce21b9), u64(0x02bb31264501e14d)},
	Uint128{u64(0xf78322ecb171b494), u64(0x022f5a850401810a)},
	Uint128{u64(0x259e9e47824f8753), u64(0x037ef73b399c01ab)},
	Uint128{u64(0x1e187e9f9b72d2a9), u64(0x02cbf8fc2e1667bc)},
	Uint128{u64(0x4b46cbb2e2c24221), u64(0x023cc73024deb963)},
	Uint128{u64(0x120adf849e039d01), u64(0x039471e6a1645bd2)},
	Uint128{u64(0xdb3be603b19c7d9a), u64(0x02dd27ebb4504974)},
	Uint128{u64(0x7c2feb3627b0647c), u64(0x024a865629d9d45d)},
	Uint128{u64(0x2d197856a5e7072c), u64(0x03aa7089dc8fba2f)},
	Uint128{u64(0x8a7ac6abb7ec05bd), u64(0x02eec06e4a0c94f2)},
	Uint128{u64(0xd52f05562cbcd164), u64(0x025899f1d4d6dd8e)},
	Uint128{u64(0x21e4d556adfae8a0), u64(0x03c0f64fbaf1627e)},
	Uint128{u64(0xe7ea444557fbed4d), u64(0x0300c50c958de864)},
	Uint128{u64(0xecbb69d1132ff10a), u64(0x0267040a113e5383)},
	Uint128{u64(0xadf8a94e851981aa), u64(0x03d8067681fd526c)},
	Uint128{u64(0x8b2d543ed0e13488), u64(0x0313385ece6441f0)},
	Uint128{u64(0xd5bddcff0d80f6d3), u64(0x0275c6b23eb69b26)},
	Uint128{u64(0x892fc7fe7c018aeb), u64(0x03efa45064575ea4)},
	Uint128{u64(0x3a8c9ffec99ad589), u64(0x03261d0d1d12b21d)},
	Uint128{u64(0xc8707fff07af113b), u64(0x0284e40a7da88e7d)},
	Uint128{u64(0x39f39998d2f2742f), u64(0x0203e9a1fe2071fe)},
	Uint128{u64(0x8fec28f484b7204b), u64(0x033975cffd00b663)},
	Uint128{u64(0xd989ba5d36f8e6a2), u64(0x02945e3ffd9a2b82)},
	Uint128{u64(0x47a161e42bfa521c), u64(0x02104b66647b5602)},
	Uint128{u64(0x0c35696d132a1cf9), u64(0x034d4570a0c5566a)},
	Uint128{u64(0x09c454574288172d), u64(0x02a4378d4d6aab88)},
	Uint128{u64(0xa169dd129ba0128b), u64(0x021cf93dd7888939)},
	Uint128{u64(0x0242fb50f9001dab), u64(0x03618ec958da7529)},
	Uint128{u64(0x9b68c90d940017bc), u64(0x02b4723aad7b90ed)},
	Uint128{u64(0x4920a0d7a999ac96), u64(0x0229f4fbbdfc73f1)},
	Uint128{u64(0x750101590f5c4757), u64(0x037654c5fcc71fe8)},
	Uint128{u64(0x2a6734473f7d05df), u64(0x02c5109e63d27fed)},
	Uint128{u64(0xeeb8f69f65fd9e4c), u64(0x0237407eb641fff0)},
	Uint128{u64(0xe45b24323cc8fd46), u64(0x038b9a6456cfffe7)},
	Uint128{u64(0xb6af502830a0ca9f), u64(0x02d6151d123fffec)},
	Uint128{u64(0xf88c402026e7087f), u64(0x0244ddb0db666656)},
	Uint128{u64(0x2746cd003e3e73fe), u64(0x03a162b4923d708b)},
	Uint128{u64(0x1f6bd73364fec332), u64(0x02e7822a0e978d3c)},
	Uint128{u64(0xe5efdf5c50cbcf5b), u64(0x0252ce880bac70fc)},
	Uint128{u64(0x3cb2fefa1adfb22b), u64(0x03b7b0d9ac471b2e)},
	Uint128{u64(0x308f3261af195b56), u64(0x02f95a47bd05af58)},
	Uint128{u64(0x5a0c284e25ade2ab), u64(0x0261150630d15913)},
	Uint128{u64(0x29ad0d49d5e30445), u64(0x03ce8809e7b55b52)},
	Uint128{u64(0x548a7107de4f369d), u64(0x030ba007ec9115db)},
	Uint128{u64(0xdd3b8d9fe50c2bb1), u64(0x026fb3398a0dab15)},
	Uint128{u64(0x952c15cca1ad12b5), u64(0x03e5eb8f434911bc)},
	Uint128{u64(0x775677d6e7bda891), u64(0x031e560c35d40e30)},
	Uint128{u64(0xc5dec645863153a7), u64(0x027eab3cf7dcd826)}
]
)
/**********************************************************************
*
* f32/f64 to string utilities
*
* Copyright (c) 2019-2020 Dario Deledda. All rights reserved.
* Use of this source code is governed by an MIT license
* that can be found in the LICENSE file.
*
* This file contains the f32/f64 to string utilities functions
*
* These functions are based on the work of:
* Publication:PLDI 2018: Proceedings of the 39th ACM SIGPLAN
* Conference on Programming Language Design and ImplementationJune 2018
* Pages 270282 https://doi.org/10.1145/3192366.3192369
*
* inspired by the Go version here:
* https://github.com/cespare/ryu/tree/ba56a33f39e3bbbfa409095d0f9ae168a595feea
*
**********************************************************************/
module ftoa
//import math
import math.bits

/******************************************************************************
*
* General Utilities
*
******************************************************************************/
fn assert1(t bool, msg string) {
	if !t {
		panic(msg)
	}
}

[inline]
fn bool_to_int(b bool) int {
	if b {
		return 1
	}
	return 0
}

[inline]
fn bool_to_u32(b bool) u32 {
	if b {
		return u32(1)
	}
	return u32(0)
}

[inline]
fn bool_to_u64(b bool) u64 {
	if b {
		return u64(1)
	}
	return u64(0)
}

fn get_string_special(neg bool, expZero bool, mantZero bool) string {
	if !mantZero {
		return "nan"
	}
	if !expZero {
		if neg {
			return "-inf"
		} else {
			return "+inf"
		}
	}
	if neg {
		return "-0e+00"
	}
	return "0e+00"
}

/******************************************************************************
*
* 32 bit functions
*
******************************************************************************/
fn decimal_len_32(u u32) int {
	// Function precondition: u is not a 10-digit number.
	// (9 digits are sufficient for round-tripping.)
	// This benchmarked faster than the log2 approach used for u64.
	assert1(u < 1000000000, "too big")

	if u >= 100000000     {	return 9 }
	else if u >= 10000000 {	return 8 }
	else if u >= 1000000  {	return 7 }
	else if u >= 100000   {	return 6 }
	else if u >= 10000    {	return 5 }
	else if u >= 1000     { return 4 }
	else if u >= 100      {	return 3 }
	else if u >= 10       {	return 2 }
	return 1
}

fn mul_shift_32(m u32, mul u64, ishift int) u32 {
	// QTODO
	//assert ishift > 32

	hi, lo := bits.mul_64(u64(m), mul)
	shifted_sum := (lo >> u64(ishift)) + (hi << u64(64-ishift))
	assert1(shifted_sum <= 2147483647, "shiftedSum <= math.max_u32")
	return u32(shifted_sum)
}

fn mul_pow5_invdiv_pow2(m u32, q u32, j int) u32 {
	return mul_shift_32(m, pow5_inv_split_32[q], j)
}

fn mul_pow5_div_pow2(m u32, i u32, j int) u32 {
	return mul_shift_32(m, pow5_split_32[i], j)
}

fn pow5_factor_32(i_v u32) u32 {
	mut v := i_v
	for n := u32(0); ; n++ {
		q := v/5
		r := v%5
		if r != 0 {
			return n
		}
		v = q
	}
	return v
}

// multiple_of_power_of_five_32 reports whether v is divisible by 5^p.
fn multiple_of_power_of_five_32(v u32, p u32) bool {
	return pow5_factor_32(v) >= p
}

// multiple_of_power_of_two_32 reports whether v is divisible by 2^p.
fn multiple_of_power_of_two_32(v u32, p u32) bool {
	return u32(bits.trailing_zeros_32(v)) >= p
}

// log10_pow2 returns floor(log_10(2^e)).
fn log10_pow2(e int) u32 {
	// The first value this approximation fails for is 2^1651
	// which is just greater than 10^297.
	assert1(e >= 0, "e >= 0")
	assert1(e <= 1650, "e <= 1650")
	return (u32(e) * 78913) >> 18
}

// log10_pow5 returns floor(log_10(5^e)).
fn log10_pow5(e int) u32 {
	// The first value this approximation fails for is 5^2621
	// which is just greater than 10^1832.
	assert1(e >= 0, "e >= 0")
	assert1(e <= 2620, "e <= 2620")
	return (u32(e) * 732923) >> 20
}

// pow5_bits returns ceil(log_2(5^e)), or else 1 if e==0.
fn pow5_bits(e int) int {
	// This approximation works up to the point that the multiplication
	// overflows at e = 3529. If the multiplication were done in 64 bits,
	// it would fail at 5^4004 which is just greater than 2^9297.
	assert1(e >= 0, "e >= 0")
	assert1(e <= 3528, "e <= 3528")
	return int( ((u32(e)*1217359)>>19) + 1)
}

/******************************************************************************
*
* 64 bit functions
*
******************************************************************************/
fn decimal_len_64(u u64) int {
	// http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
	log2 := 64 - bits.leading_zeros_64(u) - 1
	t := (log2 + 1) * 1233 >> 12
	return t - bool_to_int(u < powers_of_10[t]) + 1
}

fn shift_right_128(v Uint128, shift int) u64 {
	// The shift value is always modulo 64.
	// In the current implementation of the 64-bit version
	// of Ryu, the shift value is always < 64.
	// (It is in the range [2, 59].)
	// Check this here in case a future change requires larger shift
	// values. In this case this function needs to be adjusted.
	assert1(shift < 64, "shift < 64")
	return (v.hi << u64(64 - shift)) | (v.lo >> u32(shift))
}

fn mul_shift_64(m u64, mul Uint128, shift int) u64 {
	hihi, hilo := bits.mul_64(m, mul.hi)
	lohi, _    := bits.mul_64(m, mul.lo)
	mut sum := Uint128{lo: lohi + hilo,hi: hihi}
	if sum.lo < lohi {
		sum.hi++ // overflow
	}
	return shift_right_128(sum, shift-64)
}

fn pow5_factor_64(v_i u64) u32 {
	mut v := v_i
	for n := u32(0); ; n++ {
		q := v/5
		r := v%5
		if r != 0 {
			return n
		}
		v = q
	}
	return u32(0)
}

fn multiple_of_power_of_five_64(v u64, p u32) bool {
	return pow5_factor_64(v) >= p
}

fn multiple_of_power_of_two_64(v u64, p u32) bool {
	return u32(bits.trailing_zeros_64(v)) >= p
}

/******************************************************************************
*
* f64 to string with string format
*
******************************************************************************/

// f32_to_str_l return a string with the f32 converted in a strign in decimal notation
pub fn f32_to_str_l(f f64) string {
	return f64_to_str_l(f32(f))
}

// f64_to_str_l return a string with the f64 converted in a strign in decimal notation
pub fn f64_to_str_l(f f64) string {
	s := f64_to_str(f,18)

	// check for +inf -inf Nan
	if s.len > 2 && (s[0] == `n` || s[1] == `i`) {
		return s
	}

	m_sgn_flag := false
	mut sgn        := 1
	mut b          := [26]byte
	mut d_pos      := 1
	mut i          := 0
	mut i1         := 0
	mut exp        := 0
	mut exp_sgn    := 1

	// get sign and deciaml parts
	for c in s {
		if c == `-` {
			sgn = -1
			i++
		} else if c == `+` {
			sgn = 1
			i++
		}
		else if c >= `0` && c <= `9` {
			b[i1++] = c
			i++
		} else if c == `.` {
			if sgn > 0 {
				d_pos = i
			} else {
				d_pos = i-1
			}
			i++
		} else if c == `e` {
			i++
			break
		} else {
			return "Float conversion error!!"
		}
	}
	b[i1] = 0

	// get exponent
	if s[i] == `-` {
		exp_sgn = -1
		i++
	} else if s[i] == `+` {
		exp_sgn = 1
		i++
	}
	for c in s[i..] {
		exp = exp * 10 + int(c-`0`)
	}

	// allocate exp+32 chars for the return string
	mut res := [`0`].repeat(exp+32) // TODO: Slow!! is there other possibilities to allocate this?
	mut r_i := 0  // result string buffer index

	//println("s:${sgn} b:${b[0]} es:${exp_sgn} exp:${exp}")

	if sgn == 1 {
		if m_sgn_flag {
			res[r_i++] = `+`
		}
	} else {
		res[r_i++] = `-`
	}

	i = 0
	if exp_sgn >= 0 {
		for b[i] != 0 {
			res[r_i++] = b[i]
			i++
			if i >= d_pos && exp >= 0 {
				if exp == 0 {
					res[r_i++] = `.`
				}
				exp--
			}
		}
		for exp >= 0 {
			res[r_i++] = `0`
			exp--
		}
	} else {
		mut dot_p := true
		for exp > 0 {
			res[r_i++] = `0`
			exp--
			if dot_p  {
				res[r_i++] = `.`
				dot_p = false
			}
		}
		for b[i] != 0 {
			res[r_i++] = b[i]
			i++
		}
	}
	res[r_i] = 0
	return tos(&res[0],r_i)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module strings

pub struct Builder {
	// TODO
pub mut:
	buf          []byte
	str_calls    int
	len          int
	initial_size int = 1
}

pub fn new_builder(initial_size int) Builder {
	return Builder{
		//buf: make(0, initial_size)
		buf: []byte{cap: initial_size}
		str_calls: 0
		len: 0
		initial_size: initial_size
	}
}

pub fn (mut b Builder) write_bytes(bytes byteptr, howmany int) {
	b.buf.push_many(bytes, howmany)
	b.len += howmany
}

pub fn (mut b Builder) write_b(data byte) {
	b.buf << data
	b.len++
}

pub fn (mut b Builder) write(s string) {
	if s == '' {
		return
	}
	b.buf.push_many(s.str, s.len)
	// for c in s {
	// b.buf << c
	// }
	// b.buf << []byte(s)  // TODO
	b.len += s.len
}

pub fn (mut b Builder) go_back(n int) {
	b.buf.trim(b.buf.len-n)
	b.len -= n
}

pub fn (mut b Builder) go_back_to(pos int) {
	b.buf.trim(pos)
	b.len = pos
}

pub fn (mut b Builder) writeln(s string) {
	// for c in s {
	// b.buf << c
	// }
	b.buf.push_many(s.str, s.len)
	// b.buf << []byte(s)  // TODO
	b.buf << `\n`
	b.len += s.len + 1
}

// buf == 'hello world'
// last_n(5) returns 'world'
pub fn (b &Builder) last_n(n int) string {
	if n > b.len {
		return ''
	}
	buf := b.buf[b.len-n..]
	return string(buf.clone())
}

// buf == 'hello world'
// after(6) returns 'world'
pub fn (b &Builder) after(n int) string {
	if n >= b.len {
		return ''
	}
	buf := b.buf[n..]
	mut copy := buf.clone()
	copy << `\0`
	return string(copy)
}

// NB: in order to avoid memleaks and additional memory copies, after a call to b.str(),
// the builder b will be empty. The returned string *owns* the accumulated data so far.
pub fn (mut b Builder) str() string {
	b.str_calls++
	if b.str_calls > 1 {
		panic('builder.str() should be called just once.\n' +
			'If you want to reuse a builder, call b.free() first.')
	}
	b.buf << `\0`
	s := string(b.buf,b.len)
	bis := b.initial_size
	b.buf = []byte{cap: bis}
	b.len = 0
	return s
}

pub fn (mut b Builder) free() {
	unsafe{
		free(b.buf.data)
	}
	//b.buf = []byte{cap: b.initial_size}
	b.len = 0
	b.str_calls = 0
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module strings

pub struct Builder {
mut:
	buf []byte
pub mut:
	len int
	initial_size int = 1
}

pub fn new_builder(initial_size int) Builder {
	return Builder {
		buf: make(0, initial_size, sizeof(byte))
		initial_size: initial_size
	}
}

pub fn (mut b Builder) write_b(data byte) {
	b.buf << data
	b.len++
}

pub fn (mut b Builder) write(s string) {
	b.buf.push_many(s.str, s.len)
	//b.buf << []byte(s)  // TODO
	b.len += s.len
}

pub fn (mut b Builder) writeln(s string) {
	b.buf.push_many(s.str, s.len)
	//b.buf << []byte(s)  // TODO
	b.buf << `\n`
	b.len += s.len + 1
}

pub fn (b Builder) str() string {
	return string(b.buf, b.len)
}

pub fn (mut b Builder) cut(n int) {
	b.len -= n
}

pub fn (mut b Builder) free() {
	b.buf = make(0, b.initial_size, 1)
	b.len = 0
}
import strings

fn test_sb() {
	mut sb := strings.Builder{}
	sb.write('hi')
	sb.write('!')
	sb.write('hello')
	assert sb.len == 8
	assert sb.str() == 'hi!hello'
	assert sb.len == 0
	sb = strings.new_builder(10)
	sb.write('a')
	sb.write('b')
	assert sb.len == 2
	assert sb.str() == 'ab'
}

const (
	n = 100000
)

fn test_big_sb() {
	mut sb := strings.new_builder(100)
	mut sb2 := strings.new_builder(10000)
	for i in 0..n {
		sb.writeln(i.str())
		sb2.write('+')
	}
	s := sb.str()
	lines := s.split_into_lines()
	assert lines.len == n
	assert lines[0] == '0'
	assert lines[1] == '1'
	assert lines[777] == '777'
	assert lines[98765] == '98765'
	println(sb2.len)
	assert sb2.len == n

}

fn test_byte_write() {
	mut sb := strings.new_builder(100)
	temp_str := "byte testing"
	mut count := 0
	for word in temp_str {
		sb.write_b(word)
		count++
		assert count == sb.len
	}
	assert sb.str() == temp_str
}
module strings
// #-js
// use levenshtein distance algorithm to calculate
// the distance between between two strings (lower is closer)
pub fn levenshtein_distance(a, b string) int {
	mut f := [0].repeat(b.len + 1)
	for j in 0..f.len {
		f[j] = j
	}
	for ca in a {
		mut j := 1
		mut fj1 := f[0]
		f[0]++
		for cb in b {
			mut mn := if f[j] + 1 <= f[j - 1] + 1 { f[j] + 1 } else { f[j - 1] + 1 }
			if cb != ca {
				mn = if mn <= fj1 + 1 { mn } else { fj1 + 1 }
			}
			else {
				mn = if mn <= fj1 { mn } else { fj1 }
			}
			fj1 = f[j]
			f[j] = mn
			j++
		}
	}
	return f[f.len - 1]
}

// use levenshtein distance algorithm to calculate
// how similar two strings are as a percentage (higher is closer)
pub fn levenshtein_distance_percentage(a, b string) f32 {
	d := levenshtein_distance(a, b)
	l := if a.len >= b.len { a.len } else { b.len }
	return (1.00 - f32(d) / f32(l)) * 100.00
}

// implementation of SrensenDice coefficient.
// find the similarity between two strings.
// returns coefficient between 0.0 (not similar) and 1.0 (exact match).
pub fn dice_coefficient(s1, s2 string) f32 {
	if s1.len == 0 || s2.len == 0 {
		return 0.0
	}
	if s1 == s2 {
		return 1.0
	}
	if s1.len < 2 || s2.len < 2 {
		return 0.0
	}
	a := if s1.len > s2.len { s1 } else { s2 }
	b := if a == s1 { s2 } else { s1 }
	mut first_bigrams := map[string]int
	for i in 0..a.len - 1 {
		bigram := a[i..i + 2]
		q := if bigram in first_bigrams { first_bigrams[bigram] + 1 } else { 1 }
		first_bigrams[bigram] = q
	}
	mut intersection_size := 0
	for i in 0..b.len - 1 {
		bigram := b[i..i + 2]
		count := if bigram in first_bigrams { first_bigrams[bigram] } else { 0 }
		if count > 0 {
			first_bigrams[bigram] = count - 1
			intersection_size++
		}
	}
	return (2.0 * intersection_size) / (f32(a.len) + f32(b.len) - 2)
}

import strings

fn test_levenshtein_distance() {
	assert strings.levenshtein_distance('', '') == 0
	assert strings.levenshtein_distance('one', 'one') == 0
	assert strings.levenshtein_distance('', 'two') == 3
	assert strings.levenshtein_distance('three', '') == 5
	assert strings.levenshtein_distance('bananna', '') == 7
	assert strings.levenshtein_distance('cats', 'hats') == 1
	assert strings.levenshtein_distance('hugs', 'shrugs') == 2
	assert strings.levenshtein_distance('broom', 'shroom') == 2
	assert strings.levenshtein_distance('flomax', 'volmax') == 3
}
module strings

// strings.repeat - fill a string with `n` repetitions of the character `c`
pub fn repeat(c byte, n int) string {
	if n <= 0 {
		return ''
	}
	mut bytes := &byte(0)
	unsafe { bytes = malloc(n + 1) }
	C.memset( bytes, c, n )
	bytes[n] = `0`
	return string( bytes, n )
}

// strings.repeat_string - gives you `n` repetitions of the substring `s`
// NB: strings.repeat, that repeats a single byte, is between 2x
// and 24x faster than strings.repeat_string called for a 1 char string.
pub fn repeat_string(s string, n int) string {
	if n <= 0 || s.len == 0 {
		return ''
	}
	slen := s.len
	blen := slen*n
	mut bytes := &byte(0)
	unsafe { bytes = malloc(blen + 1) }
	for bi in 0..n {
		bislen := bi*slen
		for si in 0..slen {
			bytes[bislen+si] = s[si]
		}
	}
	bytes[blen] = `0`
	return string( bytes, blen )
}
module strings

pub fn repeat(c byte, n int) string {
	if n <= 0 {
		return ''
	}
	mut arr := [c].repeat(n + 1)
	arr[n] = `\0`
	return string(arr,n)
}

pub fn repeat_string(s string, n int) string {
/*
  // TODO: uncomment this. It is commented for now, so that `v doc strings` works
	res := # s.repeat(n)
	return res
*/
}
import strings

fn test_repeat() {
	assert strings.repeat(`x`, 10) == 'xxxxxxxxxx'
	assert strings.repeat(`a`, 1) == 'a'
	assert strings.repeat(`a`, 0) == ''
}

fn test_repeat_string() {
	assert strings.repeat_string('abc', 3) == 'abcabcabc'
	assert strings.repeat_string('abc', 1) == 'abc'
	assert strings.repeat_string('abc', 0) == ''
	assert strings.repeat_string('', 200) == ''
}
module sync
// * Goal: this file provides a convenient way to run identical tasks over a list
// * of items in parallel, without worrying about waitgroups, mutexes and so on.
// *
// * Usage example:
// *   struct SResult{ s string }
// *   fn sprocess(p &sync.PoolProcessor, idx, wid int) voidptr {
// *       item := p.get_item<string>(idx)
// *       println('idx: $idx, wid: $wid, item: ' + item)
// *       return &SResult{ item.reverse() }
// *   }
// *   pool := sync.new_pool_processor({ callback: sprocess })
// *   pool.work_on_items(['a','b','c','d','e','f','g'])
// *   // optionally, you can iterate over the results too:
// *   for x in pool.get_results<SResult>() {
// *       println('result: $x.s')
// *   }
// *
// * See https://github.com/vlang/v/blob/master/vlib/sync/pool_test.v for a
// * more detailed usage example.
// *
// * After all the work is done in parallel by the worker threads in the pool,
// * pool.work_on_items will return, and you can then call
// * pool.get_results<Result>() to retrieve a list of all the results,
// * that the worker callbacks returned for each item that you passed.
// * The parameters of new_pool_processor are:
// *   context.maxjobs: when 0 (the default), the PoolProcessor will use an
// *       optimal for your system number of threads to process your items
// *   context.callback: this should be a callback function, that each worker
// *       thread in the pool will run for each item.
// *       The callback function will receive as parameters:
// *       1) the PoolProcessor instance, so it can call
// *             p.get_item<int>(idx) to get the actual item at index idx
// *             NB: for now, you are better off calling p.get_string_item(idx)
// *                 or p.get_int_item(idx) ; TODO: vfmt and generics
// *       2) idx - the index of the currently processed item
// *       3) task_id - the index of the worker thread in which the callback
// *             function is running.
import runtime

pub const (
	no_result = voidptr(0)
)

pub struct PoolProcessor {
	thread_cb       voidptr
mut:
	njobs           int
	items           []voidptr
	results         []voidptr
	ntask           int // writing to this should be locked by ntask_mtx.
	ntask_mtx       &Mutex
	waitgroup       &WaitGroup
	shared_context  voidptr
	thread_contexts []voidptr
}

pub type ThreadCB fn(p &PoolProcessor, idx int, task_id int)voidptr

pub struct PoolProcessorConfig {
	maxjobs  int
	callback ThreadCB
}

// new_pool_processor returns a new PoolProcessor instance.
pub fn new_pool_processor(context PoolProcessorConfig) &PoolProcessor {
	if isnil(context.callback) {
		panic('You need to pass a valid callback to new_pool_processor.')
	}
	// TODO: remove this call.
	// It prevents a V warning about unused module runtime.
	runtime.nr_jobs()
	pool := &PoolProcessor {
		items: []
		results: []
		shared_context: voidptr(0)
		thread_contexts: []
		njobs: context.maxjobs
		ntask: 0
		ntask_mtx: new_mutex()
		waitgroup: new_waitgroup()
		thread_cb: context.callback
	}
	return pool
}

// set_max_jobs gives you the ability to override the number
// of jobs *after* the PoolProcessor had been created already.
pub fn (mut pool PoolProcessor) set_max_jobs(njobs int) {
	pool.njobs = njobs
}

// work_on_items receives a list of items of type T,
// then starts a work pool of pool.njobs threads, each running
// pool.thread_cb in a loop, untill all items in the list,
// are processed.
// When pool.njobs is 0, the number of jobs is determined
// by the number of available cores on the system.
// work_on_items returns *after* all threads finish.
// You can optionally call get_results after that.
// TODO: uncomment, when generics work again
//pub fn (mut pool PoolProcessor) work_on_items<T>(items []T) {
//	pool.work_on_pointers( items.pointers() )
//}

pub fn (mut pool PoolProcessor) work_on_pointers(items []voidptr) {
	mut njobs := runtime.nr_jobs()
	if pool.njobs > 0 {
		njobs = pool.njobs
	}
	pool.items = []
	pool.results = []
	pool.thread_contexts = []
	pool.items << items
	pool.results = [voidptr(0)].repeat(pool.items.len)
	pool.thread_contexts << [voidptr(0)].repeat(pool.items.len)
	pool.waitgroup.add(njobs)
	for i := 0; i < njobs; i++ {
		go process_in_thread(pool,i)
	}
	pool.waitgroup.wait()
}

// process_in_thread does the actual work of worker thread.
// It is a workaround for the current inability to pass a
// method in a callback.
fn process_in_thread(pool mut PoolProcessor, task_id int) {
	cb := ThreadCB(pool.thread_cb)
	mut idx := 0
	ilen := pool.items.len
	for {
		if pool.ntask >= ilen {
			break
		}
		pool.ntask_mtx.lock()
		idx = pool.ntask
		pool.ntask++
		pool.ntask_mtx.unlock()
		if idx >= ilen {
			break
		}
		pool.results[idx] = cb(pool, idx, task_id)
	}
	pool.waitgroup.done()
}

// get_item - called by the worker callback.
// Retrieves a type safe instance of the currently processed item
// TODO: uncomment, when generics work again
//pub fn (pool &PoolProcessor) get_item<T>(idx int) T {
//	return *(&T(pool.items[idx]))
//}

// get_string_item - called by the worker callback.
// It does not use generics so it does not mess up vfmt.
// TODO: remove the need for this when vfmt becomes smarter.
pub fn (pool &PoolProcessor) get_string_item(idx int) string {
   // return *(&string(pool.items[idx]))
   // TODO: the below is a hack, remove it when v2 casting works again
   return &string( pool.items[idx] )
}

// get_int_item - called by the worker callback.
// It does not use generics so it does not mess up vfmt.
// TODO: remove the need for this when vfmt becomes smarter.
pub fn (pool &PoolProcessor) get_int_item(idx int) int {
	item := pool.items[idx]
	return *(&int(item))
}

// TODO: uncomment, when generics work again
//pub fn (pool &PoolProcessor) get_result<T>(idx int) T {
//	return *(&T(pool.results[idx]))
//}

// TODO: uncomment, when generics work again
// get_results - can be called to get a list of type safe results.
//pub fn (pool &PoolProcessor) get_results<T>() []T {
//	mut res := []T{}
//	for i in 0 .. pool.results.len {
//		res << *(&T(pool.results[i]))
//	}
//	return res
//}

// set_shared_context - can be called during the setup so that you can
// provide a context that is shared between all worker threads, like
// common options/settings.
pub fn (mut pool PoolProcessor) set_shared_context(context voidptr) {
	pool.shared_context = context
}

// get_shared_context - can be called in each worker callback, to get
// the context set by pool.set_shared_context
pub fn (pool &PoolProcessor) get_shared_context() voidptr {
	return pool.shared_context
}

// set_thread_context - can be called during the setup at the start of
// each worker callback, so that the worker callback can have some thread
// local storage area where it can write/read information that is private
// to the given thread, without worrying that it will get overwritten by
// another thread
pub fn (mut pool PoolProcessor) set_thread_context(idx int, context voidptr) {
	pool.thread_contexts[idx] = context
}

// get_thread_context - returns a pointer, that was set with
// pool.set_thread_context . This pointer is private to each thread.
pub fn (pool &PoolProcessor) get_thread_context(idx int) voidptr {
	return pool.thread_contexts[idx]
}

// TODO: remove everything below this line after generics are fixed:
pub struct SResult {
pub:
	s string
}
pub struct IResult {
pub:
	i int
}

//

pub fn (mut pool PoolProcessor) work_on_items_s(items []string) {
	pool.work_on_pointers( items.pointers() )
}

pub fn (mut pool PoolProcessor) work_on_items_i(items []int) {
	pool.work_on_pointers( items.pointers() )
}

pub fn (pool &PoolProcessor) get_results_s() []SResult {
	mut res := []SResult{}
	for i in 0 .. pool.results.len {
		res << *(&SResult(pool.results[i]))
	}
	return res
}
pub fn (pool &PoolProcessor) get_results_i() []IResult {
	mut res := []IResult{}
	for i in 0 .. pool.results.len {
		res << *(&IResult(pool.results[i]))
	}
	return res
}
import sync
import time

fn worker_s(p &sync.PoolProcessor, idx int, worker_id int) voidptr {
	// TODO: this works, but confuses vfmt. It should be used instead of
	// p.get_int_item when vfmt becomes smarter.
	// item := p.get_item<string>(idx)
	item := p.get_string_item(idx)
	println('worker_s worker_id: $worker_id | idx: $idx | item: ${item}')
	time.sleep_ms(3)
	return voidptr( &sync.SResult{ '${item} ${item}' } )
}

fn worker_i(p &sync.PoolProcessor, idx int, worker_id int) voidptr {
	// TODO: this works, but confuses vfmt. See the comment above.
	// item := p.get_item<int>(idx)
	item := p.get_int_item(idx)
	println('worker_i worker_id: $worker_id | idx: $idx | item: ${item}')
	time.sleep_ms(5)
	return voidptr( &sync.IResult{ item * 1000 } )
}

fn test_work_on_strings() {
	mut pool_s := sync.new_pool_processor({
		callback: worker_s
		maxjobs: 8
	})

	// TODO: uncomment this when generics work again
	//pool_s.work_on_items(['a','b','c','d','e','f','g','h','i','j'])
	//for x in pool_s.get_results<SResult>() {
	//	println( x.s )
	//	assert x.s.len > 1
	//}
	   
	pool_s.work_on_items_s(['a','b','c','d','e','f','g','h','i','j'])
	for x in pool_s.get_results_s() {
		println( x.s )
		assert x.s.len > 1
	}
}

fn test_work_on_ints() {
	// NB: since maxjobs is left empty here,
	// the pool processor will use njobs = runtime.nr_jobs so that
	// it will work optimally without overloading the system
	mut pool_i := sync.new_pool_processor({
		callback: worker_i
	})
	   
	// TODO: uncomment this when generics work again
	//pool_i.work_on_items([1,2,3,4,5,6,7,8])
	//for x in pool_i.get_results<IResult>() {
	//	println( x.i )
	//	assert x.i > 100
	//}
	   
	pool_i.work_on_items_i([1,2,3,4,5,6,7,8])
	for x in pool_i.get_results_i() {
		println( x.i )
		assert x.i > 100
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module sync

#flag -lpthread

// [init_with=new_mutex] // TODO: implement support for this struct attribute, and disallow Mutex{} from outside the sync.new_mutex() function.
[ref_only]
pub struct Mutex {
	mutex C.pthread_mutex_t
}

pub fn new_mutex() &Mutex {
	m := &Mutex{}
	C.pthread_mutex_init(&m.mutex, C.NULL)
	return m
}

pub fn (mut m Mutex) lock() {
	C.pthread_mutex_lock(&m.mutex)
}

pub fn (mut m Mutex) unlock() {
	C.pthread_mutex_unlock(&m.mutex)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module sync

// Mutex HANDLE
type MHANDLE voidptr

//[init_with=new_mutex] // TODO: implement support for this struct attribute, and disallow Mutex{} from outside the sync.new_mutex() function.

[ref_only]
pub struct Mutex {
mut:
	mx           MHANDLE    // mutex handle
	state        MutexState // mutex state
	cycle_wait   i64        // waiting cycles (implemented only with atomic)
	cycle_woken  i64        // woken cycles    ^
	reader_sem   u32        // reader semarphone
	writer_sem   u32        // writer semaphones
}

enum MutexState {
	broken
	waiting
	released
	abandoned
	destroyed
}

pub fn new_mutex() &Mutex {
	sm := &Mutex{}
	unsafe {
		mut m := sm
		m.mx = C.CreateMutex(0, false, 0)
		if isnil(m.mx) {
			m.state = .broken // handle broken and mutex state are broken
			return sm
		}
	}
	return sm
}

pub fn (mut m Mutex) lock() {
	// if mutex handle not initalized
	if isnil(m.mx) {
		m.mx = C.CreateMutex(0, false, 0)
		if isnil(m.mx) {
			m.state = .broken // handle broken and mutex state are broken
			return
		}
	}
	state := C.WaitForSingleObject(m.mx, C.INFINITE) // infinite wait
	/* TODO fix match/enum combo
	m.state = match state {
		C.WAIT_ABANDONED { .abandoned }
		C.WAIT_OBJECT_0  { .waiting }
		else           { .broken }
	}
	*/
	if state == C.WAIT_ABANDONED {
		m.state = .abandoned
	// FIXME Use C constant instead
	} else if state == 0 /* C.WAIT_OBJECT_0 */ {
		m.state = .waiting
	} else {
		m.state = .broken
	}
}

pub fn (mut m Mutex) unlock() {
	if m.state == .waiting {
		if C.ReleaseMutex(m.mx) {
			m.state = .broken
			return
		}
	}
	m.state = .released
}

pub fn (mut m Mutex) destroy() {
	if m.state == .waiting {
		m.unlock() // unlock mutex before destroying
	}
	C.CloseHandle(m.mx)  // destroy mutex
	m.state = .destroyed // setting up reference to invalid state
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module sync

// [init_with=new_waitgroup] // TODO: implement support for init_with struct attribute, and disallow WaitGroup{} from outside the sync.new_waitgroup() function.
[ref_only]
pub struct WaitGroup {
mut:
	mu     &Mutex = &Mutex(0)
	active int
}

pub fn new_waitgroup() &WaitGroup {
	return &WaitGroup{mu: sync.new_mutex() }
}

pub fn (mut wg WaitGroup) add(delta int) {
	wg.mu.lock()
	wg.active += delta
	wg.mu.unlock()
	if wg.active < 0 {
		panic('Negative number of jobs in waitgroup')
	}
}

pub fn (mut wg WaitGroup) done() {
	wg.add(-1)
}

pub fn (wg &WaitGroup) wait() {
	for wg.active > 0 {
		// Do not remove this, busy empty loops are optimized
		// with -prod by some compilers, see issue #2874
		$if windows {
			C.Sleep(1)
		} $else {
			C.usleep(1000)
		}
	}
}
module szip

#flag -I @VROOT/thirdparty/zip

#include "zip.c"
#include "zip.h"

type zip      C.zip_t
type zip_ptr &zip

// Ref - miniz.h
const (
    no_compression      = 0
    best_speed          = 1
    best_compression    = 9
    uber_compression    = 10
    default_level       = 6
    default_compression = -1
)

// Ref - zip.h
const (
    default_compression_level = (default_level)
)

const (
    m_write  = 'w'
    m_ronly  = 'r'
    m_append = 'a'
)

/**
 * open opens zip archive with compression level using the given mode.
 *
 * @param zipname zip archive file name.
 * @param level compression level (0-9 are the standard zlib-style levels).
 * @param mode file access mode.
 *        - 'r': opens a file for reading/extracting (the file must exists).
 *        - 'w': creates an empty file for writing.
 *        - 'a': appends to an existing archive.
 *
 * @return the zip archive handler or NULL on error
 */
pub fn open(name string, level int, mode string) ?zip_ptr {
    mut _nlevel := level
    if (_nlevel & 0xF) > uber_compression {
        _nlevel = default_compression_level
    }
    n := name.len
    if n == 0 {
        return error('szip: name of file empty')
    }
    if mode != m_write && mode != m_ronly && mode != m_append {
        return error('szip: invalid provided open mode')
    }
    /* struct zip_t* */_p_zip := zip_ptr(C.zip_open(name.str,
                                 _nlevel, mode.str))
    if _p_zip == zip_ptr(0) {
        return error('szip: cannot open/create/append new zip archive')
    }
    return _p_zip
}

/**
 * close closes the zip archive, releases resources - always finalize.
 *
 * @param zip zip archive handler.
 */
pub fn (mut z zip_ptr) close() {
    C.zip_close(z)
}

/**
 * open_entry opens an entry by name in the zip archive.
 *
 * For zip archive opened in 'w' or 'a' mode the function will append
 * a new entry. In readonly mode the function tries to locate the entry
 * in global dictionary.
 *
 * @param zip zip archive handler.
 * @param entryname an entry name in local dictionary.
 *
 * @return the return code - 0 on success, negative number (< 0) on error.
 */
pub fn (mut zentry zip_ptr) open_entry(name string) /*?*/bool {
    res := C.zip_entry_open(zentry, name.str)
    return res != -1
}

/**
 * close_entry closes a zip entry, flushes buffer and releases resources.
 *
 * @param zip zip archive handler.
 *
 * @return the return code - 0 on success, negative number (< 0) on error.
 */
pub fn (mut zentry zip_ptr) close_entry() {
    C.zip_entry_close(zentry)
}

/**
 * name returns a local name of the current zip entry.
 *
 * The main difference between user's entry name and local entry name
 * is optional relative path.
 * Following .ZIP File Format Specification - the path stored MUST not contain
 * a drive or device letter, or a leading slash.
 * All slashes MUST be forward slashes '/' as opposed to backwards slashes '\'
 * for compatibility with Amiga and UNIX file systems etc.
 *
 * @param zip: zip archive handler.
 *
 * @return the pointer to the current zip entry name, or NULL on error.
 */
pub fn (mut zentry zip_ptr) name() string {
    _name := C.zip_entry_name(zentry)
    if _name == 0 {
        return ''
    }
    return tos_clone(_name)
}

/**
 * index returns an index of the current zip entry.
 *
 * @param zip zip archive handler.
 *
 * @return the index on success, negative number (< 0) on error.
 */
pub fn (mut zentry zip_ptr) index() ?int {
    _index := int(C.zip_entry_index(zentry))
    if _index == -1 {
        return error('szip: cannot get current index of zip entry')
    }
    return _index // must be check for INVALID_VALUE
}

/**
 * isdir determines if the current zip entry is a directory entry.
 *
 * @param zip zip archive handler.
 *
 * @return the return code - 1 (true), 0 (false), negative number (< 0) on
 *         error.
 */
pub fn (mut zentry zip_ptr) isdir() ?bool {
    _isdir := C.zip_entry_isdir(zentry)
    if _isdir == -1 {
        return error('szip: cannot check entry type')
    }
    dir := bool(_isdir) // wtf V , unary lvalue
    return dir
}

/**
 * size returns an uncompressed size of the current zip entry.
 *
 * @param zip zip archive handler.
 *
 * @return the uncompressed size in bytes.
 */
pub fn (mut zentry zip_ptr) size() i64 {
    _size := i64(C.zip_entry_size(zentry))
    return _size
}

/**
 * crc32 returns CRC-32 checksum of the current zip entry.
 *
 * @param zip zip archive handler.
 *
 * @return the CRC-32 checksum.
 */
pub fn (mut zentry zip_ptr) crc32() u32 {
    _checksum := u32(C.zip_entry_crc32(zentry))
    return _checksum // 0
}

/**
 * write_entry compresses an input buffer for the current zip entry.
 *
 * @param zip zip archive handler.
 * @param buf input buffer.
 * @param bufsize input buffer size (in bytes).
 *
 * @return the return code - 0 on success, negative number (< 0) on error.
 */
pub fn (mut zentry zip_ptr) write_entry(data []byte) bool {
    if (data[0] & 0xff) == -1 {
        return false
    }
    buf := data // alias of data
    res := C.zip_entry_write(zentry, buf.data, buf.len)
    return res == 0
}

/**
 * create_entry compresses a file for the current zip entry.
 *
 * @param zip zip archive handler.
 * @param filename input file.
 *
 * @return the return code - 0 on success, negative number (< 0) on error.
 */
pub fn (mut zentry zip_ptr) create_entry(name string) bool {
    res := C.zip_entry_fwrite(zentry, name.str)
    return res == 0
}

/**
 * read_entry extracts the current zip entry into output buffer.
 *
 * The function allocates sufficient memory for an output buffer.
 *
 * @param zip zip archive handler.
 * @param buf output buffer.
 * @param bufsize output buffer size (in bytes).
 *
 * @note remember to release the memory allocated for an output buffer.
 *       for large entries, please take a look at zip_entry_extract function.
 *
 * @return the return code - the number of bytes actually read on success.
 *         Otherwise a -1 on error.
 */
pub fn (mut zentry zip_ptr) read_entry() ?voidptr {
    mut _buf := voidptr(0)
    mut _bsize := i64(0)
    res := C.zip_entry_read(zentry, &_buf, &_bsize)
    if res == -1 {
        return error('szip: cannot read properly data from entry')
    }
    return _buf
}

/**
 * extract_entry extracts the current zip entry into output file.
 *
 * @param zip zip archive handler.
 * @param filename output file.
 *
 * @return the return code - 0 on success, negative number (< 0) on error.
 */
pub fn (mut zentry zip_ptr) extract_entry(path string) /*?*/bool {
    if C.access(path.str, 0) == -1 {
        return false
        //return error('Cannot open file for extracting, file not exists')
    }
    res := C.zip_entry_fread(zentry, path.str)
    return res == 0
}

/**
 * extract extracts the current zip entry using a callback function (on_extract).
 *
 * @param zip zip archive handler.
 * @param on_extract callback function.
 * @param arg opaque pointer (optional argument, which you can pass to the
 *        on_extract callback)
 *
 * @return the return code - 0 on success, negative number (< 0) on error.
 */
/*fn (mut zentry zip_ptr) extract(path string) bool {
    if C.access(path.str, 0) == -1 {
        return false
        //return error('Cannot open directory for extracting, directory not exists')
    }
    res := C.zip_extract(zentry, path.str, 0, 0)
    return res == 0
}*/

/**
 * total returns the number of all entries (files and directories) in the zip archive.
 *
 * @param zip zip archive handler.
 *
 * @return the return code - the number of entries on success, negative number
 *         (< 0) on error.
 */
pub fn (mut zentry zip_ptr) total() ?int {
    _tentry := int(C.zip_total_entries(zentry))
    if _tentry == -1 {
        return error('szip: cannot count total entries')
    }
    return _tentry
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module term

pub fn format(msg, open, close string) string {
	return '\x1b[' + open + 'm' + msg + '\x1b[' + close + 'm'
}

pub fn format_rgb(r, g, b int, msg, open, close string) string {
	return '\x1b[' + open + ';2;' + r.str() + ';' + g.str() + ';' + b.str() + 'm' + msg + '\x1b[' + close + 'm'
}

pub fn rgb(r, g, b int, msg string) string {
	return format_rgb(r, g, b, msg, '38', '39')
}

pub fn bg_rgb(r, g, b int, msg string) string {
	return format_rgb(r, g, b, msg, '48', '49')
}

pub fn hex(hex int, msg string) string {
	return format_rgb(hex>>16, hex>>8 & 0xFF, hex & 0xFF, msg, '38', '39')
}

pub fn bg_hex(hex int, msg string) string {
	return format_rgb(hex>>16, hex>>8 & 0xFF, hex & 0xFF, msg, '48', '49')
}

pub fn bg_black(msg string) string {
	return format(msg, '40', '49')
}

pub fn bright_bg_black(msg string) string {
	return format(msg, '100', '49')
}

pub fn bg_blue(msg string) string {
	return format(msg, '44', '49')
}

pub fn bright_bg_blue(msg string) string {
	return format(msg, '104', '49')
}

pub fn bg_cyan(msg string) string {
	return format(msg, '46', '49')
}

pub fn bright_bg_cyan(msg string) string {
	return format(msg, '106', '49')
}

pub fn bg_green(msg string) string {
	return format(msg, '42', '49')
}

pub fn bright_bg_green(msg string) string {
	return format(msg, '102', '49')
}

pub fn bg_magenta(msg string) string {
	return format(msg, '45', '49')
}

pub fn bright_bg_magenta(msg string) string {
	return format(msg, '105', '49')
}

pub fn bg_red(msg string) string {
	return format(msg, '41', '49')
}

pub fn bright_bg_red(msg string) string {
	return format(msg, '101', '49')
}

pub fn bg_white(msg string) string {
	return format(msg, '47', '49')
}

pub fn bright_bg_white(msg string) string {
	return format(msg, '107', '49')
}

pub fn bg_yellow(msg string) string {
	return format(msg, '43', '49')
}

pub fn bright_bg_yellow(msg string) string {
	return format(msg, '103', '49')
}

pub fn black(msg string) string {
	return format(msg, '30', '39')
}

pub fn bright_black(msg string) string {
	return format(msg, '90', '39')
}

pub fn blue(msg string) string {
	return format(msg, '34', '39')
}

pub fn bright_blue(msg string) string {
	return format(msg, '94', '39')
}

pub fn bold(msg string) string {
	return format(msg, '1', '22')
}

pub fn cyan(msg string) string {
	return format(msg, '36', '39')
}

pub fn bright_cyan(msg string) string {
	return format(msg, '96', '39')
}

pub fn dim(msg string) string {
	return format(msg, '2', '22')
}

pub fn green(msg string) string {
	return format(msg, '32', '39')
}

pub fn bright_green(msg string) string {
	return format(msg, '92', '39')
}

pub fn gray(msg string) string {
	return bright_black(msg)
}

pub fn hidden(msg string) string {
	return format(msg, '8', '28')
}

pub fn italic(msg string) string {
	return format(msg, '3', '23')
}

pub fn inverse(msg string) string {
	return format(msg, '7', '27')
}

pub fn magenta(msg string) string {
	return format(msg, '35', '39')
}

pub fn bright_magenta(msg string) string {
	return format(msg, '95', '39')
}

pub fn reset(msg string) string {
	return format(msg, '0', '0')
}

pub fn red(msg string) string {
	return format(msg, '31', '39')
}

pub fn bright_red(msg string) string {
	return format(msg, '91', '39')
}

pub fn strikethrough(msg string) string {
	return format(msg, '9', '29')
}

pub fn underline(msg string) string {
	return format(msg, '4', '24')
}

pub fn white(msg string) string {
	return format(msg, '37', '39')
}

pub fn bright_white(msg string) string {
	return format(msg, '97', '39')
}

pub fn yellow(msg string) string {
	return format(msg, '33', '39')
}

pub fn bright_yellow(msg string) string {
	return format(msg, '93', '39')
}

// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module term
// Sources for ANSI Control Sequences
// https://github.com/RajeshPatkarInstitute/Panim
// https://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html
// https://en.wikipedia.org/wiki/ANSI_escape_code
// Support for Windows
// https://en.wikipedia.org/wiki/ANSI.SYS
// #include <windows.h>
// C.SetConsoleMode(C.ENABLE_VIRTUAL_TERMINAL_INPUT)
// Setting cursor to the given position
// x is the x coordinate
// y is the y coordinate
pub fn set_cursor_position(x int, y int) {
	print('\x1b[$y;$x' + 'H')
}

// n is number of cells
// direction: A is up / North
// direction: B is down / South
// direction: C is forward / East
// direction: D is backward / West
pub fn move(n int, direction string) {
	print('\x1b[$n$direction')
}

pub fn cursor_up(n int) {
	move(n, 'A')
}

pub fn cursor_down(n int) {
	move(n, 'B')
}

pub fn cursor_forward(n int) {
	move(n, 'C')
}

pub fn cursor_back(n int) {
	move(n, 'D')
}

// type: 0 -> current cursor position to end of the screen
// type: 1 -> current cursor position to beginning of the screen
// type: 2 -> clears entire screen
// type: 3 -> clears entire screen and also delete scrollback buffer
pub fn erase_display(t string) {
	print('\x1b[' + t + 'J')
}

pub fn erase_toend() {
	erase_display('0')
}

pub fn erase_tobeg() {
	erase_display('1')
}

pub fn erase_clear() {
	erase_display('2')
}

pub fn erase_del_clear() {
	erase_display('3')
}

// type: 0 -> current cursor position to end of the line
// type: 1 -> current cursor position to beginning of the line
// type: 2 -> clears entire line
// Note: Cursor position does not change
pub fn erase_line(t string) {
	print('\x1b[' + t + 'K')
}

pub fn erase_line_toend() {
	erase_line('0')
}

pub fn erase_line_tobeg() {
	erase_line('1')
}

pub fn erase_line_clear() {
	erase_line('2')
}

// Will make cursor appear if not visible
pub fn show_cursor() {
	print('\x1b[?25h')
}

// Will make cursor invisible
pub fn hide_cursor() {
	print('\x1b[?25l')
}
module term

// get_terminal_size returns a number of colums and rows of terminal window.
pub fn get_terminal_size() (int, int) {
   // TODO Find a way to get proper width & height of the terminal
   // on a Javascript environment
   return default_columns_size, default_rows_size
}
module term

import os

const (
	default_columns_size = 80
	default_rows_size = 25
)
// can_show_color_on_stdout returns true if colors are allowed in stdout;
// returns false otherwise.
pub fn can_show_color_on_stdout() bool {
	return supports_escape_sequences(1)
}

// can_show_color_on_stderr returns true if colors are allowed in stderr;
// returns false otherwise.
pub fn can_show_color_on_stderr() bool {
	return supports_escape_sequences(2)
}

// ok_message returns a colored string with green color.
// If colors are not allowed, returns a given string.
pub fn ok_message(s string) string {
	return if can_show_color_on_stdout() { green(s) } else { s }
}

// fail_message returns a colored string with red color.
// If colors are not allowed, returns a given string.
pub fn fail_message(s string) string {
	return if can_show_color_on_stdout() { bold(bg_red(white(s))) } else { s }
}

// warn_message returns a colored string with yellow color.
// If colors are not allowed, returns a given string.
pub fn warn_message(s string) string {
	return if can_show_color_on_stdout() { bright_yellow(s) } else { s }
}

// h_divider returns a horizontal divider line with a dynamic width,
// that depends on the current terminal settings.
// If an empty string is passed in, print enough spaces to make a new line
pub fn h_divider(divider string) string {
	cols,_ := get_terminal_size()
	result := if divider.len > 0 { divider.repeat(1 + (cols / divider.len)) } else { " ".repeat(1 + cols) }
	return result[0..cols]
}

// header returns a horizontal divider line with a centered text in the middle.
// e.g: term.header('TEXT', '=')
// =============== TEXT ===============
pub fn header(text, divider string) string {
	if text.len == 0 {
		return h_divider(divider)
	}
	cols,_ := get_terminal_size()
	tlimit := if cols > text.len + 2 + 2 * divider.len { text.len } else { cols - 3 - 2 * divider.len }
	tlimit_alligned := if (tlimit % 2) != (cols % 2) { tlimit + 1 } else { tlimit }
	tstart := (cols - tlimit_alligned) / 2
	ln := if divider.len > 0 { divider.repeat(1 + cols / divider.len)[0..cols] } else { " ".repeat(1 + cols) }
	return ln[0..tstart] + ' ' + text[0..tlimit] + ' ' + ln[tstart + tlimit + 2..cols]
}

fn supports_escape_sequences(fd int) bool {
	vcolors_override := os.getenv('VCOLORS')
	if vcolors_override == 'always' {
		return true
	}
	$if windows {
		return (is_atty(fd) & 0x0004) > 0 && os.getenv('TERM') != 'dumb' // enable_virtual_terminal_processing
	} $else {
		return is_atty(fd) > 0 && os.getenv('TERM') != 'dumb'
	}
}
module term

import os

#include <sys/ioctl.h>

#include <termios.h> // TIOCGWINSZ

pub struct C.winsize {
pub:
	ws_row    u16
	ws_col    u16
	ws_xpixel u16
	ws_ypixel u16
}

fn C.ioctl(fd int, request u64, arg voidptr) int

// get_terminal_size returns a number of colums and rows of terminal window.
pub fn get_terminal_size() (int,int) {
	if is_atty(1) <= 0 || os.getenv('TERM') == 'dumb' {
		return default_columns_size, default_rows_size
	}
	w := C.winsize{}
	C.ioctl(1, C.TIOCGWINSZ, &w)
	return int(w.ws_col),int(w.ws_row)
}
import term

fn test_get_terminal_size() {
	cols,_ := term.get_terminal_size()
	assert cols > 0
}

fn test_h_divider() {
	divider := term.h_divider('-')
	assert divider.len > 0
	assert divider[0] == `-`
	assert divider[divider.len - 1] == `-`
}

fn test_h_divider_multiple_characters() {
	xdivider := term.h_divider('abc')
	assert xdivider.len > 0
	assert xdivider.contains('abcabc')
}

fn test_header() {
	divider := term.h_divider('-')
	term_width := divider.len
	assert term_width > 0
	empty_header := term.header('', '-')
	short_header := term.header('reasonable header', '-')
	very_long_header := term.header(['abc'].repeat(500).join(' '), '-')
	very_long_header_2 := term.header(['abcd'].repeat(500).join(' '), '-')
	/*
	eprintln(divider)
	eprintln(empty_header)
	eprintln(short_header)
	eprintln(term.header('another longer header', '_-/\\'))
	eprintln(term.header('another longer header', '-'))
	eprintln(term.header('short', '-'))
	eprintln(term.header('12345', '-'))
	eprintln(term.header('1234', '-'))
	eprintln(term.header('123', '-'))
	eprintln(term.header('12', '-'))
	eprintln(term.header('1', '-'))
	eprintln(very_long_header)
	eprintln(divider)
	eprintln(very_long_header_2)
	eprintln(term.header(['abcd'].repeat(500).join(' '), '_-/\\'))
	eprintln(term.header(['abcd'].repeat(500).join(' '), '_-//'))
	eprintln(term.header('1', '_-/\\\/'))
	eprintln(term.header('12', '_-/\\\/'))
	eprintln(term.header('123', '_-/\\\/'))
	eprintln(term.header('1234', '_-/\\/\\'))
	eprintln(term.header('', '-'))
    */
	assert term_width == empty_header.len
	assert term_width == short_header.len
	assert term_width == very_long_header.len
	assert term_width == very_long_header_2.len
	assert term_width == term.header('1234', '_-/\\/\\').len
}
module term

import os

struct Coord {
	x i16
	y i16
}

struct SmallRect {
	left   i16
	top    i16
	right  i16
	bottom i16
}

struct ConsoleScreenBufferInfo {
	dw_size                Coord
	dw_cursor_position     Coord
	w_attributes           u16
	sr_window              SmallRect
	dw_maximum_window_size Coord
}

fn C.GetConsoleScreenBufferInfo(handle os.HANDLE, info &ConsoleScreenBufferInfo) bool

// get_terminal_size returns a number of colums and rows of terminal window.
pub fn get_terminal_size() (int, int) {
	if is_atty(1) > 0 && os.getenv('TERM') != 'dumb' {
		info := ConsoleScreenBufferInfo{}
		if C.GetConsoleScreenBufferInfo(C.GetStdHandle(C.STD_OUTPUT_HANDLE), &info) {
			columns := int(info.sr_window.right - info.sr_window.left + 1)
			rows := int(info.sr_window.bottom - info.sr_window.top + 1)
			return columns, rows
		}
	}
	return default_columns_size, default_rows_size
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module time

// format returns a date string in "YYYY-MM-DD HH:MM" format (24h).
pub fn (t Time) format() string {
	return t.get_fmt_str(.hyphen, .hhmm24, .yyyymmdd)
}

// format_ss returns a date string in "YYYY-MM-DD HH:MM:SS" format (24h).
pub fn (t Time) format_ss() string {
	return t.get_fmt_str(.hyphen, .hhmmss24, .yyyymmdd)
}

// hhmm returns a date string in "HH:MM" format (24h).
pub fn (t Time) hhmm() string {
	return t.get_fmt_time_str(.hhmm24)
}

// hhmmss returns a date string in "HH:MM:SS" format (24h).
pub fn (t Time) hhmmss() string {
	return t.get_fmt_time_str(.hhmmss24)
}

// hhmm12 returns a date string in "HH:MM" format (12h).
pub fn (t Time) hhmm12() string {
	return t.get_fmt_time_str(.hhmm12)
}

// ymmdd returns a date string in "YYYY-MM-DD" format.
pub fn (t Time) ymmdd() string {
	return t.get_fmt_date_str(.hyphen, .yyyymmdd)
}

// ddmmy returns a date string in "DD.MM.YYYY" format.
pub fn (t Time) ddmmy() string {
	return t.get_fmt_date_str(.dot, .ddmmyyyy)
}

// md returns a date string in "MMM D" format.
pub fn (t Time) md() string {
	return t.get_fmt_date_str(.space, .mmmd)
}

// clean returns a date string in a following format:
//  - a date string in "HH:MM" format (24h) for current day
//  - a date string in "MMM D HH:MM" format (24h) for date of current year
//  - a date string formatted with format function for other dates
pub fn (t Time) clean() string {
	now := time.now()
	// Today
	if t.month == now.month && t.year == now.year && t.day == now.day {
		return t.get_fmt_time_str(.hhmm24)
	}
	// This year
	if t.year == now.year {
		return t.get_fmt_str(.space, .hhmm24, .mmmd)
	}
	return t.format()
}

// clean12 returns a date string in a following format:
//  - a date string in "HH:MM" format (12h) for current day
//  - a date string in "MMM D HH:MM" format (12h) for date of current year
//  - a date string formatted with format function for other dates
pub fn (t Time) clean12() string {
	now := time.now()
	// Today
	if t.month == now.month && t.year == now.year && t.day == now.day {
		return t.get_fmt_time_str(.hhmm12)
	}
	// This year
	if t.year == now.year {
		return t.get_fmt_str(.space, .hhmm12, .mmmd)
	}
	return t.format()
}

// get_fmt_time_str returns a date string with specified FormatTime type.
pub fn (t Time) get_fmt_time_str(fmt_time FormatTime) string {
	if fmt_time == .no_time {
		return ''
	}
	tp := if t.hour > 11 { 'p.m.' } else { 'a.m.' }
	hour := if t.hour > 12 { t.hour - 12 } else if t.hour == 0 { 12 } else { t.hour }
	return match fmt_time {
		.hhmm12{
			'$hour:${t.minute:02d} $tp'
		}
		.hhmm24{
			'${t.hour:02d}:${t.minute:02d}'
		}
		.hhmmss12{
			'$hour:${t.minute:02d}:${t.second:02d} $tp'
		}
		.hhmmss24{
			'${t.hour:02d}:${t.minute:02d}:${t.second:02d}'
		}
		else {
			'unknown enumeration $fmt_time'}
	}
}

// get_fmt_time_str returns a date string with specified
// FormatDelimiter and FormatDate type.
pub fn (t Time) get_fmt_date_str(fmt_dlmtr FormatDelimiter, fmt_date FormatDate) string {
	if fmt_date == .no_date {
		return ''
	}
	month := '${t.smonth()}'
	year := t.year.str()[2..]
mut 	res := match fmt_date {
		.ddmmyy{
			'${t.day:02d}|${t.month:02d}|$year'
		}
		.ddmmyyyy{
			'${t.day:02d}|${t.month:02d}|${t.year}'
		}
		.mmddyy{
			'${t.month:02d}|${t.day:02d}|$year'
		}
		.mmddyyyy{
			'${t.month:02d}|${t.day:02d}|${t.year}'
		}
		.mmmd{
			'$month|${t.day}'
		}
		.mmmdd{
			'$month|${t.day:02d}'
		}
		.mmmddyyyy{
			'$month|${t.day:02d}|${t.year}'
		}
		.yyyymmdd{
			'${t.year}|${t.month:02d}|${t.day:02d}'
		}
		else {
			'unknown enumeration $fmt_date'}}
	res = res.replace('|', match fmt_dlmtr {
		.dot{
			'.'
		}
		.hyphen{
			'-'
		}
		.slash{
			'/'
		}
		.space{
			' '
		}
		.no_delimiter{
			''
		}
	})
	return res
}

// get_fmt_str returns a date string with specified FormatDelimiter,
// FormatTime type, and FormatDate type.
pub fn (t Time) get_fmt_str(fmt_dlmtr FormatDelimiter, fmt_time FormatTime, fmt_date FormatDate) string {
	if fmt_date == .no_date {
		if fmt_time == .no_time {
			// saving one function call although it's checked in
			// t.get_fmt_time_str(fmt_time) in the beginning
			return ''
		}
		else {
			return t.get_fmt_time_str(fmt_time)
		}
	}
	else {
		if fmt_time != .no_time {
			return t.get_fmt_date_str(fmt_dlmtr, fmt_date) + ' ' + t.get_fmt_time_str(fmt_time)
		}
		else {
			return t.get_fmt_date_str(fmt_dlmtr, fmt_date)
		}
	}
}
import time

const (
	time_to_test = time.Time{
		year: 1980
		month: 7
		day: 11
		hour: 21
		minute: 23
		second: 42
		unix: 332198622
	}
)

fn test_now_format() {
	t := time.now()
	u := t.unix
	assert t.format() == time.unix(u).format()
}

fn test_format() {
	assert '11.07.1980 21:23' == time_to_test.get_fmt_str(.dot, .hhmm24, .ddmmyyyy)
}

fn test_hhmm() {
	assert '21:23' == time_to_test.hhmm()
}

fn test_hhmm12() {
	assert '9:23 p.m.' == time_to_test.hhmm12()
}

fn test_hhmmss() {
	assert '21:23:42' == time_to_test.hhmmss()
}

fn test_ymmdd() {
	assert '1980-07-11' == time_to_test.ymmdd()
}

fn test_ddmmy() {
	assert '11.07.1980' == time_to_test.ddmmy()
}

fn test_md() {
	assert 'Jul 11' == time_to_test.md()
}

fn test_get_fmt_time_str() {
	assert '21:23:42' == time_to_test.get_fmt_time_str(.hhmmss24)
	assert '21:23' == time_to_test.get_fmt_time_str(.hhmm24)
	assert '9:23:42 p.m.' == time_to_test.get_fmt_time_str(.hhmmss12)
	assert '9:23 p.m.' == time_to_test.get_fmt_time_str(.hhmm12)
}

fn test_get_fmt_date_str() {
	assert '11.07.1980' == time_to_test.get_fmt_date_str(.dot, .ddmmyyyy)
	assert '11/07/1980' == time_to_test.get_fmt_date_str(.slash, .ddmmyyyy)
	assert '11-07-1980' == time_to_test.get_fmt_date_str(.hyphen, .ddmmyyyy)
	assert '11 07 1980' == time_to_test.get_fmt_date_str(.space, .ddmmyyyy)
	assert '07.11.1980' == time_to_test.get_fmt_date_str(.dot, .mmddyyyy)
	assert '07/11/1980' == time_to_test.get_fmt_date_str(.slash, .mmddyyyy)
	assert '07-11-1980' == time_to_test.get_fmt_date_str(.hyphen, .mmddyyyy)
	assert '07 11 1980' == time_to_test.get_fmt_date_str(.space, .mmddyyyy)
	assert '11.07.80' == time_to_test.get_fmt_date_str(.dot, .ddmmyy)
	assert '11/07/80' == time_to_test.get_fmt_date_str(.slash, .ddmmyy)
	assert '11-07-80' == time_to_test.get_fmt_date_str(.hyphen, .ddmmyy)
	assert '11 07 80' == time_to_test.get_fmt_date_str(.space, .ddmmyy)
	assert '07.11.80' == time_to_test.get_fmt_date_str(.dot, .mmddyy)
	assert '07/11/80' == time_to_test.get_fmt_date_str(.slash, .mmddyy)
	assert '07-11-80' == time_to_test.get_fmt_date_str(.hyphen, .mmddyy)
	assert '07 11 80' == time_to_test.get_fmt_date_str(.space, .mmddyy)
	assert 'Jul 11' == time_to_test.get_fmt_date_str(.space, .mmmd)
	assert 'Jul 11' == time_to_test.get_fmt_date_str(.space, .mmmdd)
	assert 'Jul 11 1980' == time_to_test.get_fmt_date_str(.space, .mmmddyyyy)
	assert '1980-07-11' == time_to_test.get_fmt_date_str(.hyphen, .yyyymmdd)
}

fn test_get_fmt_str() {
	// Since get_fmt_time_str and get_fmt_date_str do have comprehensive
	// tests I don't want to exaggerate here with all possible
	// combinations.
	assert '11.07.1980 21:23:42' == time_to_test.get_fmt_str(.dot, .hhmmss24, .ddmmyyyy)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module time

// parse returns time from a date string in "YYYY-MM-DD HH:MM:SS" format.
pub fn parse(s string) ?Time {
	pos := s.index(' ') or {
		return error('Invalid time format: $s')
	}
	symd := s[..pos]
	ymd := symd.split('-')
	if ymd.len != 3 {
		return error('Invalid time format: $s')
	}
	shms := s[pos..]
	hms := shms.split(':')
	hour := hms[0][1..]
	minute := hms[1]
	second := hms[2]

	res := new_time(Time{
		year: ymd[0].int()
		month: ymd[1].int()
		day: ymd[2].int()
		hour: hour.int()
		minute: minute.int()
		second: second.int()
	})
	return res
}

// parse_rfc2822 returns time from a date string in RFC 2822 datetime format.
pub fn parse_rfc2822(s string) ?Time {
	fields := s.split(' ')
	if fields.len < 5 {
		return error('Invalid time format: $s')
	}
	pos := months_string.index(fields[2]) or {
		return error('Invalid time format: $s')
	}
	mm := pos / 3 + 1
	mut tmstr := byteptr(0)
	unsafe { tmstr = malloc(s.len * 2) }
	count := C.snprintf(charptr(tmstr), (s.len *  2), '%s-%02d-%s %s', fields[3].str, mm,
		fields[1].str, fields[4].str)

	return parse(tos(tmstr, count))
}
import time

fn test_parse() {
	s := '2018-01-27 12:48:34'
	t := time.parse(s) or {
		assert false
		return
	}
	assert t.year == 2018 && t.month == 1 && t.day == 27 && t.hour == 12 && t.minute == 48 && t.second == 34
	assert t.unix == 1517057314
}

fn test_parse_invalid() {
	s := 'Invalid time string'
	t := time.parse(s) or {
		assert true
		return
	}
	assert false
}

fn test_parse_rfc2822() {
	s1 := 'Thu, 12 Dec 2019 06:07:45 GMT'
	t1 := time.parse_rfc2822(s1) or {
		assert false
		return
	}
	assert t1.year == 2019 && t1.month == 12 && t1.day == 12 && t1.hour == 6 && t1.minute == 7 && t1.second == 45
	assert t1.unix == 1576130865
	s2 := 'Thu 12 Dec 2019 06:07:45 +0800'
	t2 := time.parse_rfc2822(s2) or {
		assert false
		return
	}
	assert t2.year == 2019 && t2.month == 12 && t2.day == 12 && t2.hour == 6 && t2.minute == 7 && t2.second == 45
	assert t2.unix == 1576130865
}

fn test_parse_rfc2822_invalid() {
	s3 := 'Thu 12 Foo 2019 06:07:45 +0800'
	t3 := time.parse_rfc2822(s3) or {
		assert true
		return
	}
	assert false
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module time

pub struct StopWatch {
mut:
	pause_time u64
pub mut:
	start      u64
	end        u64
}

pub fn new_stopwatch() StopWatch {
	return StopWatch{pause_time: 0, start: time.sys_mono_now(), end: 0}
}

// start Starts the timer. If the timer was paused, restarts counting.
pub fn (mut t StopWatch) start() {
	if t.pause_time == 0 {
		t.start = time.sys_mono_now()
	} else {
		t.start += time.sys_mono_now() - t.pause_time
	}
	t.end = 0
	t.pause_time = 0
}

pub fn (mut t StopWatch) restart() {
	t.end = 0
	t.pause_time = 0
	t.start = time.sys_mono_now()
}

pub fn (mut t StopWatch) stop() {
	t.end = time.sys_mono_now()
	t.pause_time = 0
}

pub fn (mut t StopWatch) pause() {
	t.pause_time = time.sys_mono_now()
	t.end = t.pause_time // so elapsed keeps track of actual running time
}

// elapsed returns the Duration since the last start call
pub fn (t StopWatch) elapsed() Duration {
	if t.end == 0 {
		return Duration(time.sys_mono_now() - t.start)
	} else {
		return Duration(t.end - t.start)
	}
}
import time

// NB: on CI jobs, especially msvc ones, sleep_ms may sleep for much more
// time than you have specified. To avoid false positives from CI test
// failures, some of the asserts will be run only if you pass `-d stopwatch`
fn test_stopwatch_works_as_intended() {
	sw := time.new_stopwatch()
	// sample code that you want to measure:
	println('Hello world')
	time.sleep_ms(1)
	//
	println('Greeting the world took: ${sw.elapsed().nanoseconds()}ns')
	assert sw.elapsed().nanoseconds() > 0
}

fn test_stopwatch_time_between_pause_and_start_should_be_skipped_in_elapsed() {
	sw := time.new_stopwatch()
	time.sleep_ms(10) // A
	// eprintln('${sw.elapsed().milliseconds()}ms')
	assert sw.elapsed().milliseconds() >= 10
	sw.pause()
	time.sleep_ms(10)
	// eprintln('${sw.elapsed().milliseconds()}ms')
	assert sw.elapsed().milliseconds() >= 10
	$if stopwatch ? {
		assert sw.elapsed().milliseconds() < 20
	}
	sw.start()
	time.sleep_ms(10) // B
	// Here, sw.elapsed() should be ~10ms (from A) + ~10ms (from B) >= 20ms
	assert sw.elapsed().milliseconds() >= 20
	$if stopwatch ? {
		assert sw.elapsed().milliseconds() < 30
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module time

#include <time.h>

const (
	days_string = 'MonTueWedThuFriSatSun'
	month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
	months_string = 'JanFebMarAprMayJunJulAugSepOctNovDec'
	// The unsigned zero year for internal calculations.
	// Must be 1 mod 400, and times before it will not compute correctly,
	// but otherwise can be changed at will.
	absolute_zero_year = i64(-292277022399 )//as i64
	seconds_per_minute = 60
	seconds_per_hour = 60 * seconds_per_minute
	seconds_per_day = 24 * seconds_per_hour
	seconds_per_week = 7 * seconds_per_day
	days_per_400_years = 365 * 400 + 97
	days_per_100_years = 365 * 100 + 24
	days_per_4_years = 365 * 4 + 1
	days_before = [
		0,
		31,
		31 + 28,
		31 + 28 + 31,
		31 + 28 + 31 + 30,
		31 + 28 + 31 + 30 + 31,
		31 + 28 + 31 + 30 + 31 + 30,
		31 + 28 + 31 + 30 + 31 + 30 + 31,
		31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
		31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
		31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
		31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,
		31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31,
	]
)

pub struct Time {
pub:
	year   int
	month  int
	day    int
	hour   int
	minute int
	second int
	unix   u64
}

pub enum FormatTime {
	hhmm12
	hhmm24
	hhmmss12
	hhmmss24
	no_time
}

pub enum FormatDate {
	ddmmyy
	ddmmyyyy
	mmddyy
	mmddyyyy
	mmmd
	mmmdd
	mmmddyyyy
	no_date
	yyyymmdd
}

pub enum FormatDelimiter {
	dot
	hyphen
	slash
	space
	no_delimiter
}

pub struct C.timeval {
	tv_sec  u64
	tv_usec u64
}

fn C.localtime(t &C.time_t) &C.tm
fn C.time(t &C.time_t) C.time_t

// now returns current local time.
pub fn now() Time {
	t := C.time(0)
	now := C.localtime(&t)
	return convert_ctime(now)
}

// smonth returns month name.
pub fn (t Time) smonth() string {
	i := t.month - 1
	return months_string[i * 3..(i + 1) * 3]
}

// new_time returns a time struct with calculated Unix time.
pub fn new_time(t Time) Time {
	return Time{
		year: t.year
		month: t.month
		day: t.day
		hour: t.hour
		minute: t.minute
		second: t.second
		unix: t.unix_time()
	}
	// TODO Use the syntax below when it works with reserved keywords like `unix`
	// return {
	// 	t |
	// 	unix:t.unix_time()
	// }
}

// unix_time returns Unix time.
pub fn (t Time) unix_time() int {
	if t.unix != 0 {
		return t.unix
	}
	tt := C.tm{
		tm_sec: t.second
		tm_min: t.minute
		tm_hour: t.hour
		tm_mday: t.day
		tm_mon: t.month - 1
		tm_year: t.year - 1900
	}
	return make_unix_time(tt)
}

// add_seconds returns a new time struct with an added number of seconds.
pub fn (t Time) add_seconds(seconds int) Time {
	// TODO Add(d time.Duration)
	return unix(t.unix + seconds)
}

// add_days returns a new time struct with an added number of days.
pub fn (t Time) add_days(days int) Time {
	return unix(t.unix + days * 3600 * 24)
}

// since returns a number of seconds elapsed since a given time.
fn since(t Time) int {
	// TODO Use time.Duration instead of seconds
	return 0
}

// relative returns a string representation of difference between time
// and current time.
pub fn (t Time) relative() string {
	now := time.now()
	secs := now.unix - t.unix
	if secs <= 30 {
		// right now or in the future
		// TODO handle time in the future
		return 'now'
	}
	if secs < 60 {
		return '1m'
	}
	if secs < 3600 {
		return '${secs/60}m'
	}
	if secs < 3600 * 24 {
		return '${secs/3600}h'
	}
	if secs < 3600 * 24 * 5 {
		return '${secs/3600/24}d'
	}
	if secs > 3600 * 24 * 10000 {
		return ''
	}
	return t.md()
}

// day_of_week returns the current day of a given year, month, and day,
// as an integer.
pub fn day_of_week(y, m, d int) int {
	// Sakomotho's algorithm is explained here:
	// https://stackoverflow.com/a/6385934
	t := [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]
	mut sy := y
	if m < 3 {
		sy = sy - 1
	}
	return (sy + sy / 4 - sy / 100 + sy / 400 + t[m - 1] + d - 1) % 7 + 1
}

// day_of_week returns the current day as an integer.
pub fn (t Time) day_of_week() int {
	return day_of_week(t.year, t.month, t.day)
}

// weekday_str returns the current day as a string.
pub fn (t Time) weekday_str() string {
	i := t.day_of_week() - 1
	return days_string[i * 3..(i + 1) * 3]
}

// ticks returns a number of milliseconds elapsed since system start.
pub fn ticks() i64 {
	$if windows {
		return C.GetTickCount()
	} $else {
		ts := C.timeval{}
		C.gettimeofday(&ts, 0)
		return i64(ts.tv_sec * u64(1000) + (ts.tv_usec / u64(1000)))
	}
	// t := i64(C.mach_absolute_time())
	// # Nanoseconds elapsedNano = AbsoluteToNanoseconds( *(AbsoluteTime *) &t );
	// # return (double)(* (uint64_t *) &elapsedNano) / 1000000;
}

// sleep makes the calling thread sleep for a given number of seconds.
pub fn sleep(seconds int) {
	$if windows {
		C.Sleep(seconds * 1000)
	} $else {
		C.sleep(seconds)
	}
}

// sleep_ms makes the calling thread sleep for a given number of milliseconds.
pub fn sleep_ms(milliseconds int) {
	$if windows {
		C.Sleep(milliseconds)
	} $else {
		C.usleep(milliseconds * 1000)
	}
}

// usleep makes the calling thread sleep for a given number of microseconds.
pub fn usleep(microseconds int) {
	$if windows {
		milliseconds := microseconds / 1000
		C.Sleep(milliseconds)
	} $else {
		C.usleep(microseconds)
	}
}

// is_leap_year checks if a given a year is a leap year.
pub fn is_leap_year(year int) bool {
	return (year % 4 == 0) && (year % 100 != 0 || year % 400 == 0)
}

// days_in_month returns a number of days in a given month.
pub fn days_in_month(month, year int) ?int {
	if month > 12 || month < 1 {
		return error('Invalid month: $month')
	}
	extra := if month == 2 && is_leap_year(year) { 1 } else { 0 }
	res := month_days[month - 1] + extra
	return res
}

// str returns time in the same format as `parse` expects ("YYYY-MM-DD HH:MM:SS").
pub fn (t Time) str() string {
	// TODO Define common default format for
	// `str` and `parse` and use it in both ways
	return t.format_ss()
}

fn convert_ctime(t C.tm) Time {
	return Time{
		year: t.tm_year + 1900
		month: t.tm_mon + 1
		day: t.tm_mday
		hour: t.tm_hour
		minute: t.tm_min
		second: t.tm_sec
		unix: make_unix_time(t)
	}
}

// A lot of these are taken from the Go library
pub type Duration i64

pub const(
	nanosecond  = Duration(1)
	microsecond = Duration(1000) * nanosecond
	millisecond = Duration(1000) * microsecond
	second       = Duration(1000) * millisecond
	minute       = Duration(60) * second
	hour         = Duration(60) * minute
)

// nanoseconds returns the duration as an integer number of nanoseconds.
pub fn (d Duration) nanoseconds() i64 { return i64(d) }

// microseconds returns the duration as an integer number of microseconds.
pub fn (d Duration) microseconds() i64 { return i64(d) / 1000 }

// milliseconds returns the duration as an integer number of milliseconds.
pub fn (d Duration) milliseconds() i64 { return i64(d) / 1_000_000 }

// The following functions return floating point numbers because it's common to
// consider all of them in sub-one intervals

// seconds returns the duration as a floating point number of seconds.
pub fn (d Duration) seconds() f64 {
	sec := d / second
	nsec := d % second
	return f64(sec) + f64(nsec)/1e9
}

// minutes returns the duration as a floating point number of minutes.
pub fn (d Duration) minutes() f64 {
	min := d / minute
	nsec := d % minute
	return f64(min) + f64(nsec)/(60*1e9)
}

// hours returns the duration as a floating point number of hours.
pub fn (d Duration) hours() f64 {
	hr := d / hour
	nsec := d % hour
	return f64(hr) + f64(nsec)/(60*60*1e9)
}
module time

#include <mach/mach_time.h>

const (
	// start_time is needed on Darwin and Windows because of potential overflows
	start_time = C.mach_absolute_time()
	time_base = init_time_base()
)

[typedef]
struct C.mach_timebase_info_data_t {
	numer u32
	denom u32
}

fn C.mach_absolute_time() u64
fn C.mach_timebase_info(&C.mach_timebase_info_data_t)
fn C.clock_gettime_nsec_np(int) u64

struct InternalTimeBase {
	numer u32 = 1
	denom u32 = 1
}

fn init_time_base() InternalTimeBase {
	tb := C.mach_timebase_info_data_t{}
	C.mach_timebase_info(&tb)
	return InternalTimeBase{numer:tb.numer, denom:tb.denom}
}

fn sys_mono_now_darwin() u64 {
	tm := C.mach_absolute_time()
	if time_base.denom == 0 {
		C.mach_timebase_info(&time_base)
	}
	return (tm - start_time) * time_base.numer / time_base.denom
}

// NB: vpc_now_darwin is used by `v -profile` .
// It should NOT call *any other v function*, just C functions and casts.
[inline]
fn vpc_now_darwin() u64 {
	tm := C.mach_absolute_time()
	if time_base.denom == 0 {
		C.mach_timebase_info(&time_base)
	}
	return (tm - start_time) * time_base.numer / time_base.denom
}
module time

fn sys_mono_now_darwin() u64 { 
	return 0
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module time

struct C.tm {
	tm_sec  int
	tm_min  int
	tm_hour int
	tm_mday int
	tm_mon  int
	tm_year int
}

fn C.timegm(&tm) time_t

fn make_unix_time(t C.tm) int {
	return int(C.timegm(&t))
}

type time_t voidptr

// in most systems, these are __quad_t, which is an i64
struct C.timespec {
	tv_sec  i64
	tv_nsec i64
}

// the first arg is defined in include/bits/types.h as `__S32_TYPE`, which is `int`
fn C.clock_gettime(int, &C.timespec)

pub fn sys_mono_now() u64 {
	$if macos {
		return sys_mono_now_darwin()
	} $else {
		ts := C.timespec{}
		C.clock_gettime(C.CLOCK_MONOTONIC, &ts)
		return u64(ts.tv_sec) * 1_000_000_000 + u64(ts.tv_nsec)
	}
}

// NB: vpc_now is used by `v -profile` .
// It should NOT call *any other v function*, just C functions and casts.
[inline]
fn vpc_now() u64 {
	ts := C.timespec{}
	C.clock_gettime(C.CLOCK_MONOTONIC, &ts)
	return u64(ts.tv_sec) * 1_000_000_000 + u64(ts.tv_nsec)
}
import time

const (
	time_to_test = time.Time{
		year: 1980
		month: 7
		day: 11
		hour: 21
		minute: 23
		second: 42
		unix: 332198622
	}
)

fn test_is_leap_year() {
	// 1996 % 4 = 0 and 1996 % 100 > 0
	assert time.is_leap_year(1996) == true
	// 2000 % 4 = 0 and 2000 % 400 = 0
	assert time.is_leap_year(2000) == true
	// 1996 % 4 > 0
	assert time.is_leap_year(1997) == false
	// 2000 % 4 = 0 and 2000 % 100 = 0
	assert time.is_leap_year(2100) == false
}

fn check_days_in_month(month, year, expected int) bool {
	res := time.days_in_month(month, year) or {
		return false
	}
	return res == expected
}

fn test_days_in_month() {
	days_in_month := [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
	for i, days in days_in_month {
		month := i + 1
		assert check_days_in_month(month, 2001, days)
	}
}

fn test_unix() {
	t := time.unix(1564366499)
	assert t.year == 2019
	assert t.month == 7
	assert t.day == 29
	assert t.hour == 2
	assert t.minute == 14
	assert t.second == 59
	t2 := time.unix(1078058096)
	assert t2.year == 2004
	assert t2.month == 2
	assert t2.day == 29
	assert t2.hour == 12
	assert t2.minute == 34
	assert t2.second == 56
	t3 := time.unix(1070236799)
	assert t3.year == 2003
	assert t3.month == 11
	assert t3.day == 30
	assert t3.hour == 23
	assert t3.minute == 59
	assert t3.second == 59
	t4 := time.unix(1577783439)
	assert t4.year == 2019
	assert t4.month == 12
	assert t4.day == 31
	assert t4.hour == 9
	assert t4.minute == 10
	assert t4.second == 39
	t5 := time.unix(-1824922433)
	assert t5.year == 1912
	assert t5.month == 3
	assert t5.day == 4
	assert t5.hour == 5
	assert t5.minute == 6
	assert t5.second == 7
	t6 := time.unix(1577858969)
	assert t6.year == 2020
	assert t6.month == 1
	assert t6.day == 1
	assert t6.hour == 6
	assert t6.minute == 9
	assert t6.second == 29
}

fn test_format_ss() {
	assert '11.07.1980 21:23:42' == time_to_test.get_fmt_str(.dot, .hhmmss24, .ddmmyyyy)
}

fn test_smonth() {
	month_names := ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
	'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
	for i, name in month_names {
		month_num := i + 1
		t := time.Time{
			year: 1980
			month: month_num
			day: 1
			hour: 0
			minute: 0
			second: 0
			unix: 0
		}
		assert t.smonth() == name
	}
}

fn test_day_of_week() {
	for i in 0..7 {
		day_of_week := i + 1
		// 2 Dec 2019 is Monday
		t := time.Time{
			year: 2019
			month: 12
			day: 2 + i
			hour: 0
			minute: 0
			second: 0
			unix: 0
		}
		assert day_of_week == t.day_of_week()
	}
}

fn test_weekday_str() {
	day_names := ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
	for i, name in day_names {
		// 2 Dec 2019 is Monday
		t := time.Time{
			year: 2019
			month: 12
			day: 2 + i
			hour: 0
			minute: 0
			second: 0
			unix: 0
		}
		assert t.weekday_str() == name
	}
}

fn test_add_days() {
	num_of_days := 3
	t := time_to_test.add_days(num_of_days)
	assert t.day == time_to_test.day + num_of_days
	assert t.unix == time_to_test.unix + 86400 * u64(num_of_days)
}

fn test_str() {
	assert '1980-07-11 21:23:42' == time_to_test.str()
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module time

struct C.tm {
	tm_year int
	tm_mon  int
	tm_mday int
	tm_hour int
	tm_min  int
	tm_sec  int
}


const (
	// start_time is needed on Darwin and Windows because of potential overflows
	start_time = init_win_time_start()
	freq_time  = init_win_time_freq()
)

fn C._mkgmtime(&C.tm) time_t

fn C.QueryPerformanceCounter(&u64) C.BOOL

fn C.QueryPerformanceFrequency(&u64) C.BOOL

fn make_unix_time(t C.tm) int {
	return int(C._mkgmtime(&t))
}

fn init_win_time_freq() u64 {
	f := u64(0)
	C.QueryPerformanceFrequency(&f)
	return f
}

fn init_win_time_start() u64 {
	s := u64(0)
	C.QueryPerformanceCounter(&s)
	return s
}

pub fn sys_mono_now() u64 {
	tm := u64(0)
	C.QueryPerformanceCounter(&tm) // XP or later never fail
	return (tm - start_time) * 1_000_000_000 / freq_time
}

// NB: vpc_now is used by `v -profile` .
// It should NOT call *any other v function*, just C functions and casts.
[inline]
fn vpc_now() u64 {
	tm := u64(0)
	C.QueryPerformanceCounter(&tm)
	return tm
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module time

// unix returns a time struct from Unix time.
pub fn unix(abs int) Time {
	// Split into day and time
	mut day_offset := abs / seconds_per_day
	if abs % seconds_per_day < 0 {
		// Compensate for round towards zero on integers as we want floored instead
		day_offset--
	}
	year,month,day := calculate_date_from_offset(day_offset)
	hr,min,sec := calculate_time_from_offset(abs % seconds_per_day)
	return Time{
		year: year
		month: month
		day: day
		hour: hr
		minute: min
		second: sec
		unix: abs
	}
}

[inline]
fn calculate_date_from_offset(day_offset_ int) (int,int,int) {
	mut day_offset := day_offset_
	// Move offset to year 2001 as it's the start of a new 400-year cycle
	// Code below this rely on the fact that the day_offset is lined up with the 400-year cycle
	// 1970-2000 (inclusive) has 31 years (8 of which are leap years)
	mut year := 2001
	day_offset -= 31 * 365 + 8
	// Account for 400 year cycle
	year += (day_offset / days_per_400_years) * 400
	day_offset %= days_per_400_years
	// Account for 100 year cycle
	if day_offset == days_per_100_years * 4 {
		year += 300
		day_offset -= days_per_100_years * 3
	}
	else {
		year += (day_offset / days_per_100_years) * 100
		day_offset %= days_per_100_years
	}
	// Account for 4 year cycle
	if day_offset == days_per_4_years * 25 {
		year += 96
		day_offset -= days_per_4_years * 24
	}
	else {
		year += (day_offset / days_per_4_years) * 4
		day_offset %= days_per_4_years
	}
	// Account for every year
	if day_offset == 365 * 4 {
		year += 3
		day_offset -= 365 * 3
	}
	else {
		year += (day_offset / 365)
		day_offset %= 365
	}
	if day_offset < 0 {
		year--
		if is_leap_year(year) {
			day_offset += 366
		}
		else {
			day_offset += 365
		}
	}
	if is_leap_year(year) {
		if day_offset > 31 + 29 - 1 {
			// After leap day; pretend it wasn't there.
			day_offset--
		}
		else if day_offset == 31 + 29 - 1 {
			// Leap day.
			return year,2,29
		}
	}
	mut estimated_month := day_offset / 31
	for day_offset >= days_before[estimated_month + 1] {
		estimated_month++
	}
	for day_offset < days_before[estimated_month] {
		if estimated_month == 0 {
			break
		}
		estimated_month--
	}
	day_offset -= days_before[estimated_month]
	return year,estimated_month + 1,day_offset + 1
}

[inline]
fn calculate_time_from_offset(second_offset_ int) (int,int,int) {
	mut second_offset := second_offset_
	if second_offset < 0 {
		second_offset += seconds_per_day
	}
	hour := second_offset / seconds_per_hour
	second_offset %= seconds_per_hour
	min := second_offset / seconds_per_minute
	second_offset %= seconds_per_minute
	return hour,min,second_offset
}
module misc

import rand
import time

const (
	start_time_unix = time.now().unix
)
// random returns a random time struct in *the past*.
pub fn random() time.Time {
	return time.unix(rand.next(start_time_unix))
}
import time.misc as tmisc
import rand

fn test_random() {
	// guarantee CI test stability, by seeding the random number generator with a known seed
	rand.seed(0)
	t1 := tmisc.random()
	t2 := tmisc.random()
	t3 := tmisc.random()
	t4 := tmisc.random()
	assert t1.unix != t2.unix
	assert t1.unix != t3.unix
	assert t1.unix != t4.unix
	assert t2.unix != t3.unix
	assert t2.unix != t4.unix
	assert t3.unix != t4.unix
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module ast

import v.token
import v.table
import v.errors

pub type TypeDecl = AliasTypeDecl | FnTypeDecl | SumTypeDecl

pub type Expr = AnonFn | ArrayInit | AsCast | AssignExpr | Assoc | BoolLiteral | CallExpr |
	CastExpr | CharLiteral | ConcatExpr | EnumVal | FloatLiteral | Ident | IfExpr | IfGuardExpr |
	IndexExpr | InfixExpr | IntegerLiteral | MapInit | MatchExpr | None | OrExpr | ParExpr | PostfixExpr |
	PrefixExpr | RangeExpr | SelectorExpr | SizeOf | StringInterLiteral | StringLiteral | StructInit |
	Type | TypeOf

pub type Stmt = AssertStmt | AssignStmt | Attr | Block | BranchStmt | Comment | CompIf | ComptimeCall |
	ConstDecl | DeferStmt | EnumDecl | ExprStmt | FnDecl | ForCStmt | ForInStmt | ForStmt | GlobalDecl |
	GoStmt | GotoLabel | GotoStmt | HashStmt | Import | InterfaceDecl | Module | Return | StructDecl |
	TypeDecl | UnsafeStmt

pub type ScopeObject = ConstField | GlobalDecl | Var

// pub type Type = StructType | ArrayType
// pub struct StructType {
// fields []Field
// }
// pub struct ArrayType {}
pub struct Type {
pub:
	typ table.Type
	pos token.Position
}

pub struct Block {
pub:
	stmts []Stmt
}

// | IncDecStmt k
// Stand-alone expression in a statement list.
pub struct ExprStmt {
pub:
	expr Expr
	pos  token.Position
pub mut:
	typ  table.Type
}

pub struct IntegerLiteral {
pub:
	val string
	pos token.Position
}

pub struct FloatLiteral {
pub:
	val string
	pos token.Position
}

pub struct StringLiteral {
pub:
	val      string
	is_raw   bool
	language table.Language
	pos      token.Position
}

// 'name: $name'
pub struct StringInterLiteral {
pub:
	vals       []string
	exprs      []Expr
	expr_fmts  []string
	pos        token.Position
pub mut:
	expr_types []table.Type
}

pub struct CharLiteral {
pub:
	val string
	pos token.Position
}

pub struct BoolLiteral {
pub:
	val bool
	pos token.Position
}

// `foo.bar`
pub struct SelectorExpr {
pub:
	pos        token.Position
	expr       Expr
	field_name string
pub mut:
	expr_type  table.Type
}

// module declaration
pub struct Module {
pub:
	name       string
	path       string
	expr       Expr
	pos        token.Position
	is_skipped bool // module main can be skipped in single file programs
}

pub struct StructField {
pub:
	name             string
	pos              token.Position
	comment          Comment
	default_expr     Expr
	has_default_expr bool
	attrs            []string
	is_public        bool
pub mut:
	typ              table.Type
}

pub struct Field {
pub:
	name string
	pos  token.Position
pub mut:
	typ  table.Type
}

pub struct ConstField {
pub:
	name    string
	expr    Expr
	is_pub  bool
	pos     token.Position
pub mut:
	typ     table.Type
	comment Comment
}

pub struct ConstDecl {
pub:
	is_pub bool
	pos    token.Position
pub mut:
	fields []ConstField
}

pub struct StructDecl {
pub:
	pos         token.Position
	name        string
	fields      []StructField
	is_pub      bool
	mut_pos     int // mut:
	pub_pos     int // pub:
	pub_mut_pos int // pub mut:
	language    table.Language
	is_union    bool
	attr        string
}

pub struct InterfaceDecl {
pub:
	name        string
	field_names []string
	methods     []FnDecl
	pos         token.Position
}

pub struct StructInitField {
pub:
	expr          Expr
	pos           token.Position
pub mut:
	name          string
	typ           table.Type
	expected_type table.Type
}

pub struct StructInit {
pub:
	pos      token.Position
	is_short bool
pub mut:
	typ      table.Type
	fields   []StructInitField
}

// import statement
pub struct Import {
pub:
	pos   token.Position
	mod   string
	alias string
}

pub struct AnonFn {
pub:
	decl FnDecl
pub mut:
	typ  table.Type
}

pub struct FnDecl {
pub:
	name          string
	stmts         []Stmt
	args          []table.Arg
	is_deprecated bool
	is_pub        bool
	is_variadic   bool
	is_anon       bool
	receiver      Field
	receiver_pos  token.Position
	is_method     bool
	rec_mut       bool // is receiver mutable
	language      table.Language
	no_body       bool // just a definition `fn C.malloc()`
	is_builtin    bool // this function is defined in builtin/strconv
	ctdefine      string // has [if myflag] tag
	pos           token.Position
	body_pos      token.Position
	file          string
	is_generic    bool
pub mut:
	return_type   table.Type
}

pub struct BranchStmt {
pub:
	tok token.Token
}

pub struct CallExpr {
pub:
	pos                token.Position
	left               Expr // `user` in `user.register()`
	mod                string
pub mut:
	name               string
	is_method          bool
	args               []CallArg
	expected_arg_types []table.Type
	language           table.Language
	or_block           OrExpr
	left_type          table.Type // type of `user`
	receiver_type      table.Type // User
	return_type        table.Type
	should_be_skipped  bool
	generic_type       table.Type // TODO array, to support multiple types
}

pub struct CallArg {
pub:
	is_mut bool
	expr   Expr
pub mut:
	typ    table.Type
}

pub struct Return {
pub:
	pos   token.Position
	exprs []Expr
pub mut:
	types []table.Type
}

/*
pub enum Expr {
	Binary(InfixExpr)
	If(IfExpr)
	Integer(IntegerExpr)
}
*/
/*
pub struct Stmt {
	pos int
	//end int
}
*/
pub struct Var {
pub:
	name    string
	expr    Expr
	is_mut  bool
	is_arg  bool // fn args should not be autofreed
pub mut:
	typ     table.Type
	pos     token.Position
	is_used bool
}

pub struct GlobalDecl {
pub:
	name     string
	expr     Expr
	has_expr bool
	pos      token.Position
pub mut:
	typ      table.Type
}

pub struct File {
pub:
	path         string
	mod          Module
	stmts        []Stmt
	scope        &Scope
	global_scope &Scope
pub mut:
	imports      []Import
	errors       []errors.Error
	warnings     []errors.Warning
}

pub struct IdentFn {
pub mut:
	typ table.Type
}

pub struct IdentVar {
pub mut:
	typ         table.Type
	is_mut      bool
	is_static   bool
	is_optional bool
}

pub type IdentInfo = IdentFn | IdentVar

pub enum IdentKind {
	unresolved
	blank_ident
	variable
	constant
	global
	function
}

// A single identifier
pub struct Ident {
pub:
	value    string
	language table.Language
	tok_kind token.Kind
	mod      string
	pos      token.Position
pub mut:
	name     string
	kind     IdentKind
	info     IdentInfo
	is_mut   bool
}

pub fn (i &Ident) var_info() IdentVar {
	match i.info {
		IdentVar {
			return it
		}
		else {
			// return IdentVar{}
			panic('Ident.var_info(): info is not IdentVar variant')
		}
	}
}

pub struct InfixExpr {
pub:
	op         token.Kind
	pos        token.Position
	left       Expr
	right      Expr
pub mut:
	left_type  table.Type
	right_type table.Type
}

pub struct PostfixExpr {
pub:
	op   token.Kind
	expr Expr
	pos  token.Position
}

pub struct PrefixExpr {
pub:
	op    token.Kind
	right Expr
	pos   token.Position
}

pub struct IndexExpr {
pub:
	pos       token.Position
	left      Expr
	index     Expr // [0], [start..end] etc
pub mut:
	left_type table.Type // array, map, fixed array
	is_setter bool
}

pub struct IfExpr {
pub:
	tok_kind token.Kind
	branches []IfBranch
	left     Expr // `a` in `a := if ...`
	pos      token.Position
pub mut:
	is_expr  bool
	typ      table.Type
	has_else bool
}

pub struct IfBranch {
pub:
	cond    Expr
	stmts   []Stmt
	pos     token.Position
	comment Comment
}

pub struct MatchExpr {
pub:
	tok_kind      token.Kind
	cond          Expr
	branches      []MatchBranch
	pos           token.Position
	is_mut        bool // `match mut ast_node {`
pub mut:
	is_expr       bool // returns a value
	return_type   table.Type
	cond_type     table.Type // type of `x` in `match x {`
	expected_type table.Type // for debugging only
	is_sum_type   bool
}

pub struct MatchBranch {
pub:
	exprs   []Expr // left side
	stmts   []Stmt // right side
	pos     token.Position
	comment Comment // comment above `xxx {`
	is_else bool
}

/*
CompIf.is_opt:
`$if xyz? {}` => this compile time `if` is optional,
and .is_opt reflects the presence of ? at the end.
When .is_opt is true, the code should compile, even
if `xyz` is NOT defined.
If .is_opt is false, then when `xyz` is not defined,
the compilation will fail.
*/
pub struct CompIf {
pub:
	val        string
	stmts      []Stmt
	is_not     bool
	pos        token.Position
pub mut:
	is_opt     bool
	has_else   bool
	else_stmts []Stmt
}

pub struct ForStmt {
pub:
	cond   Expr
	stmts  []Stmt
	is_inf bool // `for {}`
	pos    token.Position
}

pub struct ForInStmt {
pub:
	key_var   string
	val_var   string
	cond      Expr
	is_range  bool
	high      Expr // `10` in `for i in 0..10 {`
	stmts     []Stmt
	pos       token.Position
pub mut:
	key_type  table.Type
	val_type  table.Type
	cond_type table.Type
	kind      table.Kind // array/map/string
}

pub struct ForCStmt {
pub:
	init     Stmt // i := 0;
	has_init bool
	cond     Expr // i < 10;
	has_cond bool
	inc      Expr // i++;
	has_inc  bool
	stmts    []Stmt
	pos      token.Position
}

/*
pub struct ReturnStmt {
pub:
	tok_kind token.Kind // or pos
	results  []Expr
	pos      token.Position
}
*/
// #include etc
pub struct HashStmt {
pub:
	val string
	mod string
}

// filter(), map()
pub struct Lambda {
pub:
	name string
}

pub struct AssignStmt {
pub:
	right       []Expr
	op          token.Kind
	pos         token.Position
pub mut:
	left        []Ident
	left_types  []table.Type
	right_types []table.Type
	is_static   bool // for translated code only
}

pub struct AsCast {
pub:
	expr      Expr
	typ       table.Type
	pos       token.Position
pub mut:
	expr_type table.Type
}

// e.g. `[unsafe_fn]`
pub struct Attr {
pub:
	name string
}

pub struct EnumVal {
pub:
	enum_name string
	val       string
	mod       string // for full path `mod_Enum_val`
	pos       token.Position
pub mut:
	typ       table.Type
}

pub struct EnumField {
pub:
	name     string
	pos      token.Position
	expr     Expr
	has_expr bool
}

pub struct EnumDecl {
pub:
	name   string
	is_pub bool
	fields []EnumField
	pos    token.Position
}

pub struct AliasTypeDecl {
pub:
	name        string
	is_pub      bool
	parent_type table.Type
	pos         token.Position
}

pub struct SumTypeDecl {
pub:
	name      string
	is_pub    bool
	sub_types []table.Type
	pos       token.Position
}

pub struct FnTypeDecl {
pub:
	name   string
	is_pub bool
	typ    table.Type
	pos    token.Position
}

// TODO: handle this differently
// v1 excludes non current os ifdefs so
// the defer's never get added in the first place
pub struct DeferStmt {
pub:
	stmts []Stmt
pub mut:
	ifdef string
}

pub struct UnsafeStmt {
pub:
	stmts []Stmt
}

// `(3+4)`
pub struct ParExpr {
pub:
	expr Expr
}

pub struct AssignExpr {
pub:
	op         token.Kind
	pos        token.Position
	left       Expr
	val        Expr
pub mut:
	left_type  table.Type
	right_type table.Type
}

pub struct GoStmt {
pub:
	call_expr Expr
}

pub struct GotoLabel {
pub:
	name string
}

pub struct GotoStmt {
pub:
	name string
}

pub struct ArrayInit {
pub:
	pos             token.Position
	exprs           []Expr
	is_fixed        bool
	has_val         bool
	mod             string
	len_expr        Expr
	cap_expr        Expr
	default_expr    Expr
	has_len         bool
	has_cap         bool
	has_default     bool
pub mut:
	is_interface    bool // array of interfaces e.g. `[]Animal` `[Dog{}, Cat{}]`
	interface_types []table.Type // [Dog, Cat]
	interface_type  table.Type // Animal
	elem_type       table.Type
	typ             table.Type
}

pub struct MapInit {
pub:
	pos        token.Position
	keys       []Expr
	vals       []Expr
pub mut:
	typ        table.Type
	key_type   table.Type
	value_type table.Type
}

// s[10..20]
pub struct RangeExpr {
pub:
	low      Expr
	high     Expr
	has_high bool
	has_low  bool
}

pub struct CastExpr {
pub:
	expr      Expr // `buf`
	arg       Expr // `n` in `string(buf, n)`
	typ       table.Type // `string`
	pos       token.Position
pub mut:
	typname   string
	expr_type table.Type // `byteptr`
	has_arg   bool
}

pub struct AssertStmt {
pub:
	expr Expr
	pos  token.Position
}

// `if [x := opt()] {`
pub struct IfGuardExpr {
pub:
	var_name  string
	expr      Expr
pub mut:
	expr_type table.Type
}

pub enum OrKind {
	absent
	block
	propagate
}

// `or { ... }`
pub struct OrExpr {
pub:
	stmts []Stmt
	kind  OrKind
	pos   token.Position
}

pub struct Assoc {
pub:
	var_name string
	fields   []string
	exprs    []Expr
	pos      token.Position
pub mut:
	typ      table.Type
}

pub struct SizeOf {
pub:
	typ       table.Type
	type_name string
}

pub struct TypeOf {
pub:
	expr      Expr
pub mut:
	expr_type table.Type
}

pub struct Comment {
pub:
	text     string
	is_multi bool
	line_nr  int
	pos      token.Position
}

pub struct ConcatExpr {
pub:
	vals        []Expr
pub mut:
	return_type table.Type
}

pub struct ComptimeCall {
	name string
}

pub struct None {
pub:
	foo int // todo
}

[inline]
pub fn expr_is_blank_ident(expr Expr) bool {
	match expr {
		Ident { return it.kind == .blank_ident }
		else { return false }
	}
}

[inline]
pub fn expr_is_call(expr Expr) bool {
	return match expr {
		CallExpr { true }
		else { false }
	}
}

pub fn (expr Expr) position() token.Position {
	// all uncommented have to be implemented
	match mut expr {
		ArrayInit {
			return it.pos
		}
		AsCast {
			return it.pos
		}
		// ast.Ident { }
		AssignExpr {
			return it.pos
		}
		CastExpr {
			return it.pos
		}
		Assoc {
			return it.pos
		}
		BoolLiteral {
			return it.pos
		}
		CallExpr {
			return it.pos
		}
		CharLiteral {
			return it.pos
		}
		EnumVal {
			return it.pos
		}
		FloatLiteral {
			return it.pos
		}
		Ident {
			return it.pos
		}
		IfExpr {
			return it.pos
		}
		// ast.IfGuardExpr { }
		IndexExpr {
			return it.pos
		}
		InfixExpr {
			left_pos := it.left.position()
			right_pos := it.right.position()
			if left_pos.pos == 0 || right_pos.pos == 0 {
				return it.pos
			}
			return token.Position{
				line_nr: it.pos.line_nr
				pos: left_pos.pos
				len: right_pos.pos - left_pos.pos + right_pos.len
			}
		}
		IntegerLiteral {
			return it.pos
		}
		MapInit {
			return it.pos
		}
		MatchExpr {
			return it.pos
		}
		PostfixExpr {
			return it.pos
		}
		// ast.None { }
		PrefixExpr {
			return it.pos
		}
		// ast.ParExpr { }
		SelectorExpr {
			return it.pos
		}
		// ast.SizeOf { }
		StringLiteral {
			return it.pos
		}
		StringInterLiteral {
			return it.pos
		}
		// ast.Type { }
		StructInit {
			return it.pos
		}
		// ast.TypeOf { }
		else {
			return token.Position{}
		}
	}
}

pub fn (stmt Stmt) position() token.Position {
	match stmt {
		AssertStmt { return it.pos }
		AssignStmt { return it.pos }
		/*
		// Attr {
		// }
		// Block {
		// }
		// BranchStmt {
		// }
		*/
		Comment { return it.pos }
		CompIf { return it.pos }
		ConstDecl { return it.pos }
		/*
		// DeferStmt {
		// }
		*/
		EnumDecl { return it.pos }
		ExprStmt { return it.pos }
		FnDecl { return it.pos }
		ForCStmt { return it.pos }
		ForInStmt { return it.pos }
		ForStmt { return it.pos }
		/*
		// GlobalDecl {
		// }
		// GoStmt {
		// }
		// GotoLabel {
		// }
		// GotoStmt {
		// }
		// HashStmt {
		// }
		*/
		Import { return it.pos }
		/*
		// InterfaceDecl {
		// }
		// Module {
		// }
		*/
		Return { return it.pos }
		StructDecl { return it.pos }
		/*
		// TypeDecl {
		// }
		// UnsafeStmt {
		// }
		*/
		else { return token.Position{} }
	}
}

// TODO: remove this fugly hack :-|
// fe2ex/1 and ex2fe/1 are used to convert back and forth from
// table.FExpr to ast.Expr , which in turn is needed to break
// a dependency cycle between v.ast and v.table, for the single
// field table.Field.default_expr, which should be ast.Expr
pub fn fe2ex(x table.FExpr) Expr {
	res := Expr{}
	C.memcpy(&res, &x, sizeof(Expr))
	return res
}

pub fn ex2fe(x Expr) table.FExpr {
	res := table.FExpr{}
	C.memcpy(&res, &x, sizeof(table.FExpr))
	return res
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module ast

import v.table

pub struct Scope {
//mut:
pub mut:
	objects   map[string]ScopeObject
	parent    &Scope
	children  []&Scope
	start_pos int
	end_pos   int
}

pub fn new_scope(parent &Scope, start_pos int) &Scope {
	return &ast.Scope{
		parent: parent
		start_pos: start_pos
	}
}

pub fn (s &Scope) find_with_scope(name string) ?(ScopeObject, &Scope) {
	mut sc := s
	for  {
		if name in sc.objects {
			return sc.objects[name], sc
		}
		if isnil(sc.parent) {
			break
		}
		sc = sc.parent
	}
	return none
}

pub fn (s &Scope) find(name string) ?ScopeObject {
	for sc := s; ; sc = sc.parent {
		if name in sc.objects {
			return sc.objects[name]
		}
		if isnil(sc.parent) {
			break
		}
	}
	return none
}

pub fn (s &Scope) is_known(name string) bool {
	if _ := s.find(name) {
		return true
	}
	//
	else{}
	return false
}

pub fn (s &Scope) find_var(name string) ?&Var {
	if obj := s.find(name) {
		match obj {
			Var {
				return it
			}
			else {}
		}
	}
	return none
}

pub fn (s &Scope) find_const(name string) ?&ConstField {
	if obj := s.find(name) {
		match obj {
			ConstField {
				return it
			}
			else {}
		}
	}
	return none
}

pub fn (s &Scope) known_var(name string) bool {
	if _ := s.find_var(name) {
		return true
	}
	return false
}

pub fn (mut s Scope) update_var_type(name string, typ table.Type) {
	match mut s.objects[name] {
		Var {
			if it.typ == typ {
				return
			}
			it.typ = typ
		}
		else {}
	}
}

pub fn (mut s Scope) register(name string, obj ScopeObject) {
	if name == '_' {
		return
	}
	if name in s.objects {
		// println('existing obect: $name')
		return
	}
	s.objects[name] = obj
}

pub fn (s &Scope) outermost() &Scope {
	mut sc := s
	for !isnil(sc.parent) {
		sc = sc.parent
	}
	return sc
}

// returns the innermost scope containing pos
// pub fn (s &Scope) innermost(pos int) ?&Scope {
pub fn (s &Scope) innermost(pos int) &Scope {
	if s.contains(pos) {
		// binary search
		mut first := 0
		mut last := s.children.len - 1
		mut middle := last / 2
		for first <= last {
			// println('FIRST: $first, LAST: $last, LEN: $s.children.len-1')
			s1 := s.children[middle]
			if s1.end_pos < pos {
				first = middle + 1
			} else if s1.contains(pos) {
				return s1.innermost(pos)
			} else {
				last = middle - 1
			}
			middle = (first + last) / 2
			if first > last {
				break
			}
		}
		return s
	}
	// return none
	return s
}

[inline]
fn (s &Scope) contains(pos int) bool {
	return pos >= s.start_pos && pos <= s.end_pos
}

pub fn (sc &Scope) show(depth, max_depth int) string {
	mut out := ''
	mut indent := ''
	for _ in 0 .. depth * 4 {
		indent += ' '
	}
	out += '$indent# $sc.start_pos - $sc.end_pos\n'
	for _, obj in sc.objects {
		match obj {
			ConstField {
				out += '$indent  * const: $it.name - $it.typ\n'
			}
			Var {
				out += '$indent  * var: $it.name - $it.typ\n'
			}
			else {}
		}
	}
	if max_depth == 0 || depth < max_depth - 1 {
		for i, _ in sc.children {
			out += sc.children[i].show(depth + 1, max_depth)
		}
	}
	return out
}

pub fn (sc &Scope) str() string {
	return sc.show(0, 0)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module ast

// These methods are used only by vfmt, vdoc, and for debugging.
import v.table
import strings

pub fn (node &FnDecl) str(t &table.Table) string {
	mut f := strings.new_builder(30)
	if node.is_pub {
		f.write('pub ')
	}
	mut receiver := ''
	if node.is_method {
		mut styp := t.type_to_str(node.receiver.typ)
		mut m := if node.rec_mut { 'mut ' } else { '' }
		if node.rec_mut {
			styp = styp[1..] // remove &
		}
		receiver = '($m$node.receiver.name $styp) '
		/*
		sym := t.get_type_symbol(node.receiver.typ)
		name := sym.name.after('.')
		mut m := if node.rec_mut { 'mut ' } else { '' }
		if !node.rec_mut && node.receiver.typ.is_ptr() {
			m = '&'
		}
		receiver = '($node.receiver.name $m$name) '
		*/
	}
	mut name := if node.is_anon { '' } else { node.name.after('.') }
	if node.language == .c {
		name = 'C.$name'
	}
	else if node.language == .js {
		name = 'JS.$name'
	}
	f.write('fn ${receiver}${name}')
	if node.is_generic {
		f.write('<T>')
	}
	f.write('(')
	for i, arg in node.args {
		// skip receiver
		// if (node.is_method || node.is_interface) && i == 0 {
		if node.is_method && i == 0 {
			continue
		}
		if arg.is_hidden {
			continue
		}
		is_last_arg := i == node.args.len - 1
		should_add_type := is_last_arg || node.args[i + 1].typ != arg.typ || (node.is_variadic &&
			i == node.args.len - 2)
		if arg.is_mut {
			f.write('mut ')
		}
		f.write(arg.name)
		mut s := t.type_to_str(arg.typ)
		if arg.is_mut {
			// f.write(' mut')
			if s.starts_with('&') {
				s = s[1..]
			}
		}
		if should_add_type {
			if node.is_variadic && is_last_arg {
				f.write(' ...' + s)
			} else {
				f.write(' ' + s)
			}
		}
		if !is_last_arg {
			f.write(', ')
		}
	}
	f.write(')')
	if node.return_type != table.void_type {
		// typ := t.type_to_str(node.typ)
		// if typ.starts_with('
		f.write(' ' + t.type_to_str(node.return_type))
	}
	return f.str()
}

// string representaiton of expr
pub fn (x Expr) str() string {
	match x {
		BoolLiteral {
			return it.val.str()
		}
		CastExpr {
			return '${it.typname}(${it.expr.str()})'
		}
		CallExpr {
			sargs := args2str(it.args)
			if it.is_method {
				return '${it.left.str()}.${it.name}($sargs)'
			}
			return '${it.mod}.${it.name}($sargs)'
		}
		CharLiteral {
			return '`$it.val`'
		}
		EnumVal {
			return '.${it.val}'
		}
		FloatLiteral {
			return it.val
		}
		Ident {
			return it.name
		}
		IndexExpr {
			return '${it.left.str()}[${it.index.str()}]'
		}
		IntegerLiteral {
			return it.val
		}
		InfixExpr {
			return '${it.left.str()} $it.op.str() ${it.right.str()}'
		}
		ParExpr {
			return it.expr.str()
		}
		PrefixExpr {
			return it.op.str() + it.right.str()
		}
		SelectorExpr {
			return '${it.expr.str()}.${it.field_name}'
		}
		StringInterLiteral {
			mut res := []string{}
			res << "'"
			for i, val in it.vals {
				res << val
				if i >= it.exprs.len {
					continue
				}
				res << '$'
				if it.expr_fmts[i].len > 0 {
					res << '{'
					res << it.exprs[i].str()
					res << it.expr_fmts[i]
					res << '}'
				} else {
					res << it.exprs[i].str()
				}
			}
			res << "'"
			return res.join('')
		}
		StringLiteral {
			return '"$it.val"'
		}
		TypeOf {
			return 'typeof(${it.expr.str()})'
		}
		else {
			return '[unhandled expr type ${typeof(x)}]'
		}
	}
}

pub fn (a CallArg) str() string {
	if a.is_mut {
		return 'mut ${a.expr.str()}'
	}
	return '${a.expr.str()}'
}

pub fn args2str(args []CallArg) string {
	mut res := []string{}
	for a in args {
		res << a.str()
	}
	return res.join(', ')
}

pub fn (node Stmt) str() string {
	match node {
		AssignStmt {
			mut out := ''
			for i, ident in it.left {
				var_info := ident.var_info()
				if var_info.is_mut {
					out += 'mut '
				}
				out += ident.name
				if i < it.left.len - 1 {
					out += ','
				}
			}
			out += ' $it.op.str() '
			for i, val in it.right {
				out += val.str()
				if i < it.right.len - 1 {
					out += ','
				}
			}
			return out
		}
		ExprStmt {
			return it.expr.str()
		}
		FnDecl {
			return 'fn ${it.name}() { $it.stmts.len stmts }'
		}
		else {
			return '[unhandled stmt str type: ${typeof(node)} ]'
		}
	}
}
module builder

import os
import v.ast
import v.table
import v.pref
import v.util
import v.vmod
import v.checker
import v.parser
import v.depgraph

pub struct Builder {
pub:
	table               &table.Table
	checker             checker.Checker
	compiled_dir        string // contains os.real_path() of the dir of the final file beeing compiled, or the dir itself when doing `v .`
	module_path         string
mut:
	pref                &pref.Preferences
	parsed_files        []ast.File
	global_scope        &ast.Scope
	out_name_c          string
	out_name_js         string
	max_nr_errors       int = 100
pub mut:
	module_search_paths []string
}

pub fn new_builder(pref &pref.Preferences) Builder {
	rdir := os.real_path(pref.path)
	compiled_dir := if os.is_dir(rdir) { rdir } else { os.dir(rdir) }
	table := table.new_table()
	if pref.use_color == .always {
		util.emanager.set_support_color(true)
	}
	if pref.use_color == .never {
		util.emanager.set_support_color(false)
	}
	return Builder{
		pref: pref
		table: table
		checker: checker.new_checker(table, pref)
		global_scope: &ast.Scope{
			parent: 0
		}
		compiled_dir: compiled_dir
		max_nr_errors: if pref.error_limit > 0 {
			pref.error_limit
		} else {
			100
		}
	}
	// max_nr_errors: pref.error_limit ?? 100 TODO potential syntax?
}

// parse all deps from already parsed files
pub fn (mut b Builder) parse_imports() {
	mut done_imports := []string{}
	// NB: b.parsed_files is appended in the loop,
	// so we can not use the shorter `for in` form.
	for i := 0; i < b.parsed_files.len; i++ {
		ast_file := b.parsed_files[i]
		for _, imp in ast_file.imports {
			mod := imp.mod
			if mod == 'builtin' {
				verror('cannot import module "$mod"')
				break
			}
			if mod in done_imports {
				continue
			}
			import_path := b.find_module_path(mod, ast_file.path) or {
				// v.parsers[i].error_with_token_index('cannot import module "$mod" (not found)', v.parsers[i].import_table.get_import_tok_idx(mod))
				// break
				// println('module_search_paths:')
				// println(b.module_search_paths)
				verror('cannot import module "$mod" (not found)')
				break
			}
			v_files := b.v_files_from_dir(import_path)
			if v_files.len == 0 {
				// v.parsers[i].error_with_token_index('cannot import module "$mod" (no .v files in "$import_path")', v.parsers[i].import_table.get_import_tok_idx(mod))
				verror('cannot import module "$mod" (no .v files in "$import_path")')
			}
			// Add all imports referenced by these libs
			parsed_files := parser.parse_files(v_files, b.table, b.pref, b.global_scope)
			for file in parsed_files {
				if file.mod.name != mod {
					// v.parsers[pidx].error_with_token_index('bad module definition: ${v.parsers[pidx].file_path} imports module "$mod" but $file is defined as module `$p_mod`', 1
					verror('bad module definition: ${ast_file.path} imports module "$mod" but $file.path is defined as module `$file.mod.name`')
				}
			}
			b.parsed_files << parsed_files
			done_imports << mod
		}
	}
	b.resolve_deps()
	//
	if b.pref.print_v_files {
		for p in b.parsed_files {
			println(p.path)
		}
		exit(0)
	}
}

pub fn (mut b Builder) resolve_deps() {
	graph := b.import_graph()
	deps_resolved := graph.resolve()
	cycles := deps_resolved.display_cycles()
	if cycles.len > 1 {
		eprintln('warning: import cycle detected between the following modules: \n' + cycles)
		// TODO: error, when v itself does not have v.table -> v.ast -> v.table cycles anymore
		return
	}
	if b.pref.is_verbose {
		eprintln('------ resolved dependencies graph: ------')
		eprintln(deps_resolved.display())
		eprintln('------------------------------------------')
	}
	mut mods := []string{}
	for node in deps_resolved.nodes {
		mods << node.name
	}
	if b.pref.is_verbose {
		eprintln('------ imported modules: ------')
		eprintln(mods.str())
		eprintln('-------------------------------')
	}
	mut reordered_parsed_files := []ast.File{}
	for m in mods {
		for pf in b.parsed_files {
			if m == pf.mod.name {
				reordered_parsed_files << pf
				// eprintln('pf.mod.name: $pf.mod.name | pf.path: $pf.path')
			}
		}
	}
	b.parsed_files = reordered_parsed_files
}

// graph of all imported modules
pub fn (b &Builder) import_graph() &depgraph.DepGraph {
	mut builtins := util.builtin_module_parts
	builtins << 'builtin'
	mut graph := depgraph.new_dep_graph()
	for p in b.parsed_files {
		mut deps := []string{}
		if p.mod.name !in builtins {
			deps << 'builtin'
		}
		for _, m in p.imports {
			deps << m.mod
		}
		graph.add(p.mod.name, deps)
	}
	return graph
}

pub fn (b Builder) v_files_from_dir(dir string) []string {
	if !os.exists(dir) {
		if dir == 'compiler' && os.is_dir('vlib') {
			println('looks like you are trying to build V with an old command')
			println('use `v -o v cmd/v` instead of `v -o v compiler`')
		}
		verror("$dir doesn't exist")
	} else if !os.is_dir(dir) {
		verror("$dir isn't a directory!")
	}
	mut files := os.ls(dir) or {
		panic(err)
	}
	if b.pref.is_verbose {
		println('v_files_from_dir ("$dir")')
	}
	return b.pref.should_compile_filtered_files(dir, files)
}

pub fn (b Builder) log(s string) {
	if b.pref.is_verbose {
		println(s)
	}
}

pub fn (b Builder) info(s string) {
	if b.pref.is_verbose {
		println(s)
	}
}

[inline]
fn module_path(mod string) string {
	// submodule support
	return mod.replace('.', os.path_separator)
}

pub fn (b Builder) find_module_path(mod, fpath string) ?string {
	// support @VROOT/v.mod relative paths:
	vmod_file_location := vmod.mod_file_cacher.get(fpath)
	mod_path := module_path(mod)
	mut module_lookup_paths := []string{}
	if vmod_file_location.vmod_file.len != 0 && vmod_file_location.vmod_folder !in b.module_search_paths {
		module_lookup_paths << vmod_file_location.vmod_folder
	}
	module_lookup_paths << b.module_search_paths
	for search_path in module_lookup_paths {
		try_path := os.join_path(search_path, mod_path)
		if b.pref.is_verbose {
			println('  >> trying to find $mod in $try_path ..')
		}
		if os.is_dir(try_path) {
			if b.pref.is_verbose {
				println('  << found $try_path .')
			}
			return try_path
		}
	}
	smodule_lookup_paths := module_lookup_paths.join(', ')
	return error('module "$mod" not found in:\n$smodule_lookup_paths')
}

fn (b &Builder) print_warnings_and_errors() {
	if b.pref.output_mode == .silent {
		if b.checker.nr_errors > 0 {
			exit(1)
		}
		return
	}
	if b.pref.is_verbose && b.checker.nr_warnings > 1 {
		println('$b.checker.nr_warnings warnings')
	}
	if b.checker.nr_warnings > 0 && !b.pref.skip_warnings {
		for i, err in b.checker.warnings {
			kind := if b.pref.is_verbose { '$err.reporter warning #$b.checker.nr_warnings:' } else { 'warning:' }
			ferror := util.formatted_error(kind, err.message, err.file_path, err.pos)
			eprintln(ferror)
			// eprintln('')
			if i > b.max_nr_errors {
				return
			}
		}
	}
	//
	if b.pref.is_verbose && b.checker.nr_errors > 1 {
		println('$b.checker.nr_errors errors')
	}
	if b.checker.nr_errors > 0 {
		for i, err in b.checker.errors {
			kind := if b.pref.is_verbose { '$err.reporter error #$b.checker.nr_errors:' } else { 'error:' }
			ferror := util.formatted_error(kind, err.message, err.file_path, err.pos)
			eprintln(ferror)
			// eprintln('')
			if i > b.max_nr_errors {
				return
			}
		}
		exit(1)
	}
	if b.table.redefined_fns.len > 0 {
		for fn_name in b.table.redefined_fns {
			eprintln('redefinition of function `$fn_name`')
			// eprintln('previous declaration at')
			// Find where this function was already declared
			for file in b.parsed_files {
				for stmt in file.stmts {
					if stmt is ast.FnDecl {
						f := stmt as ast.FnDecl
						if f.name == fn_name {
							println(file.path + ':' + f.pos.line_nr.str())
						}
					}
				}
			}
			exit(1)
		}
	}
}

fn verror(s string) {
	util.verror('builder error', s)
}
module builder

import time
import os
import v.parser
import v.pref
import v.gen

pub fn (mut b Builder) gen_c(v_files []string) string {
	t0 := time.ticks()
	b.parsed_files = parser.parse_files(v_files, b.table, b.pref, b.global_scope)
	b.parse_imports()
	t1 := time.ticks()
	parse_time := t1 - t0
	b.info('PARSE: ${parse_time}ms')
	//
	b.checker.check_files(b.parsed_files)
	t2 := time.ticks()
	check_time := t2 - t1
	b.info('CHECK: ${check_time}ms')
	b.print_warnings_and_errors()
	// println('starting cgen...')
	// TODO: move gen.cgen() to c.gen()
	res := gen.cgen(b.parsed_files, b.table, b.pref)
	t3 := time.ticks()
	gen_time := t3 - t2
	b.info('C GEN: ${gen_time}ms')
	// println('cgen done')
	// println(res)
	return res
}

pub fn (mut b Builder) build_c(v_files []string, out_file string) {
	b.out_name_c = out_file
	b.info('build_c($out_file)')
	output2 := b.gen_c(v_files)
	mut f := os.create(out_file) or {
		panic(err)
	}
	f.writeln(output2)
	f.close()
	// os.write_file(out_file, b.gen_c(v_files))
}

pub fn (mut b Builder) compile_c() {
	if os.user_os() != 'windows' && b.pref.ccompiler == 'msvc' {
		verror('Cannot build with msvc on ${os.user_os()}')
	}
	// cgen.genln('// Generated by V')
	// println('compile2()')
	if b.pref.is_verbose {
		println('all .v files before:')
		// println(files)
	}
	// v1 compiler files
	// v.add_v_files_to_compile()
	// v.files << v.dir
	// v2 compiler
	// b.set_module_lookup_paths()
	mut files := b.get_builtin_files()
	files << b.get_user_files()
	b.set_module_lookup_paths()
	if b.pref.is_verbose {
		println('all .v files:')
		println(files)
	}
	mut out_name_c := get_vtmp_filename(b.pref.out_name, '.tmp.c')
	if b.pref.is_shared {
		out_name_c = get_vtmp_filename(b.pref.out_name, '.tmp.so.c')
	}
	b.build_c(files, out_name_c)
	b.cc()
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builder

import os
import time
import v.cflag
import v.pref
import term

const (
c_error_info = '
==================
C error. This should never happen.

If you were not working with C interop, please raise an issue on GitHub:

https://github.com/vlang/v/issues/new/choose

You can also use #help on Discord: https://discord.gg/vlang
')


fn todo() {
}

fn (v &Builder) no_cc_installed() bool {
	$if windows {
		os.exec('$v.pref.ccompiler -v') or {
			if v.pref.is_verbose {
				println('C compiler not found, trying to build with msvc...')
			}
			return true
		}
	}
	return false
}

fn (mut v Builder) cc() {
	if os.executable().contains('vfmt') {
		return
	}
	if v.pref.is_verbose {
		println('builder.cc() pref.out_name="$v.pref.out_name"')
	}
	v.build_thirdparty_obj_files()
	vexe := pref.vexe_path()
	vdir := os.dir(vexe)
	// Just create a C/JavaScript file and exit
	// for example: `v -o v.c compiler`
	ends_with_c := v.pref.out_name.ends_with('.c')
	ends_with_js := v.pref.out_name.ends_with('.js')
	if ends_with_c || ends_with_js {
		v.pref.skip_running = true
		// Translating V code to JS by launching vjs.
		// Using a separate process for V.js is for performance mostly,
		// to avoid constant is_js checks.
		$if !js {
			if ends_with_js {
				vjs_path := vexe + 'js'
				if !os.exists(vjs_path) {
					println('V.js compiler not found, building...')
					// Build V.js. Specifying `-os js` makes V include
					// only _js.v files and ignore _c.v files.
					ret := os.system('$vexe -o $vjs_path -os js $vdir/cmd/v')
					if ret == 0 {
						println('Done.')
					} else {
						println('Failed.')
						exit(1)
					}
				}
				ret := os.system('$vjs_path -o $v.pref.out_name $v.pref.path')
				if ret == 0 {
					println('Done. Run it with `node $v.pref.out_name`')
					println('JS backend is at a very early stage.')
				}
			}
		}
		// v.out_name_c may be on a different partition than v.out_name
		os.mv_by_cp(v.out_name_c, v.pref.out_name) or {
			panic(err)
		}
		return
	}
	// Cross compiling for Windows
	if v.pref.os == .windows {
		$if !windows {
			v.cc_windows_cross()
			return
		}
	}
	$if windows {
		if v.pref.ccompiler == 'msvc' || v.no_cc_installed() {
			v.cc_msvc()
			return
		}
	}
	// arguments for the C compiler
	mut a := [ v.pref.cflags, '-std=gnu11', '-Wall', '-Wextra',
		// TODO : activate -Werror once no warnings remain
		// '-Werror',
		// TODO : try and remove the below workaround options when the corresponding
		// warnings are totally fixed/removed
		'-Wno-unused-variable',
		// '-Wno-unused-but-set-variable',
		'-Wno-unused-parameter', '-Wno-unused-result', '-Wno-unused-function', '-Wno-missing-braces',
			'-Wno-unused-label'
	]
	mut linker_flags := []string{}
	// TCC on Linux by default, unless -cc was provided
	// TODO if -cc = cc, TCC is still used, default compiler should be
	// used instead.
	if v.pref.fast {
		$if linux {
			$if !android {
				tcc_3rd := '$vdir/thirdparty/tcc/bin/tcc'
				// println('tcc third "$tcc_3rd"')
				tcc_path := '/var/tmp/tcc/bin/tcc'
				if os.exists(tcc_3rd) && !os.exists(tcc_path) {
					// println('moving tcc')
					// if there's tcc in thirdparty/, that means this is
					// a prebuilt V_linux.zip.
					// Until the libtcc1.a bug is fixed, we neeed to move
					// it to /var/tmp/
					os.system('mv $vdir/thirdparty/tcc /var/tmp/')
				}
				if v.pref.ccompiler == 'cc' && os.exists(tcc_path) {
					// TODO tcc bug, needs an empty libtcc1.a fila
					// os.mkdir('/var/tmp/tcc/lib/tcc/') or { panic(err) }
					// os.create('/var/tmp/tcc/lib/tcc/libtcc1.a')
					v.pref.ccompiler = tcc_path
					a << '-m64'
				}
			}
		} $else {
			verror('-fast is only supported on Linux right now')
		}
	}
	if !v.pref.is_shared && v.pref.build_mode != .build_module && os.user_os() == 'windows' &&
		!v.pref.out_name.ends_with('.exe') {
		v.pref.out_name += '.exe'
	}
	// linux_host := os.user_os() == 'linux'
	v.log('cc() isprod=$v.pref.is_prod outname=$v.pref.out_name')
	if v.pref.is_shared {
		linker_flags << '-shared'
		a << '-fPIC' // -Wl,-z,defs'
		v.pref.out_name += '.so'
	}
	if v.pref.is_bare {
		a << '-fno-stack-protector'
		a << '-ffreestanding'
		linker_flags << '-static'
		linker_flags << '-nostdlib'
	}
	if v.pref.build_mode == .build_module {
		// Create the modules & out directory if it's not there.
		mut out_dir := if v.pref.path.starts_with('vlib') { '${pref.default_module_path}${os.path_separator}cache${os.path_separator}$v.pref.path' } else { '${pref.default_module_path}${os.path_separator}$v.pref.path' }
		pdir := out_dir.all_before_last(os.path_separator)
		if !os.is_dir(pdir) {
			os.mkdir_all(pdir)
		}
		v.pref.out_name = '${out_dir}.o' // v.out_name
		println('Building ${v.pref.out_name}...')
	}
	debug_mode := v.pref.is_debug
	mut debug_options := '-g'
	mut optimization_options := '-O2'
	mut guessed_compiler := v.pref.ccompiler
	if guessed_compiler == 'cc' && v.pref.is_prod {
		// deliberately guessing only for -prod builds for performance reasons
		if ccversion := os.exec('cc --version') {
			if ccversion.exit_code == 0 {
				if ccversion.output.contains('This is free software;') && ccversion.output.contains('Free Software Foundation, Inc.') {
					guessed_compiler = 'gcc'
				}
				if ccversion.output.contains('clang version ') {
					guessed_compiler = 'clang'
				}
			}
		}
	}
	//
	is_cc_clang := v.pref.ccompiler.contains('clang') || guessed_compiler == 'clang'
	is_cc_tcc := v.pref.ccompiler.contains('tcc') || guessed_compiler == 'tcc'
	is_cc_gcc := v.pref.ccompiler.contains('gcc') || guessed_compiler == 'gcc'
	// is_cc_msvc := v.pref.ccompiler.contains('msvc') || guessed_compiler == 'msvc'
	//
	if is_cc_clang {
		if debug_mode {
			debug_options = '-g -O0 -no-pie'
		}
		optimization_options = '-O3'
		mut have_flto := true
		$if openbsd {
			have_flto = false
		}
		if have_flto {
			optimization_options += ' -flto'
		}
	}
	if is_cc_gcc {
		if debug_mode {
			debug_options = '-g3 -no-pie'
		}
		optimization_options = '-O3 -fno-strict-aliasing -flto'
	}
	if debug_mode {
		a << debug_options
		$if macos {
			a << ' -ferror-limit=5000 '
		}
	}
	if v.pref.is_prod {
		a << optimization_options
	}
	if debug_mode && os.user_os() != 'windows' {
		linker_flags << ' -rdynamic ' // needed for nicer symbolic backtraces
	}
	if v.pref.ccompiler != 'msvc' && v.pref.os != .freebsd {
		a << '-Werror=implicit-function-declaration'
	}
	if v.pref.is_liveshared || v.pref.is_livemain {
		if v.pref.os == .linux || os.user_os() == 'linux' {
			linker_flags << '-rdynamic'
		}
		if v.pref.os == .mac || os.user_os() == 'mac' {
			a << '-flat_namespace'
		}
	}
	mut libs := '' // builtin.o os.o http.o etc
	if v.pref.build_mode == .build_module {
		a << '-c'
	} else if v.pref.use_cache {
		/*
		QTODO
		builtin_o_path := os.join_path(pref.default_module_path, 'cache', 'vlib', 'builtin.o')
		a << builtin_o_path.replace('builtin.o', 'strconv.o') // TODO hack no idea why this is needed
		if os.exists(builtin_o_path) {
			libs = builtin_o_path
		}
		else {
			println('$builtin_o_path not found... building module builtin')
			os.system('$vexe build module vlib${os.path_separator}builtin')
		}
		for imp in v.table.imports {
			if imp.contains('vweb') {
				continue
			} // not working
			if imp == 'webview' {
				continue
			}
			imp_path := imp.replace('.', os.path_separator)
			path := '${pref.default_module_path}${os.path_separator}cache${os.path_separator}vlib${os.path_separator}${imp_path}.o'
			// println('adding ${imp_path}.o')
			if os.exists(path) {
				libs += ' ' + path
			}
			else {
				println('$path not found... building module $imp')
				os.system('$vexe build module vlib${os.path_separator}$imp_path')
			}
			if path.ends_with('vlib/ui.o') {
				a << '-framework Cocoa -framework Carbon'
			}
		}
		*/
	}
	if v.pref.sanitize {
		a << '-fsanitize=leak'
	}
	// Cross compiling linux
	if v.pref.os == .linux {
		$if !linux {
			v.cc_linux_cross()
		}
	}
	// Cross compiling windows
	//
	// Output executable name
	a << '-o "$v.pref.out_name"'
	if os.is_dir(v.pref.out_name) {
		verror("'$v.pref.out_name' is a directory")
	}
	// macOS code can include objective C  TODO remove once objective C is replaced with C
	if v.pref.os == .mac {
		a << '-x objective-c'
	}
	// The C file we are compiling
	a << '"$v.out_name_c"'
	if v.pref.os == .mac {
		a << '-x none'
	}
	// Min macos version is mandatory I think?
	if v.pref.os == .mac {
		a << '-mmacosx-version-min=10.7'
	}
	if v.pref.os == .windows {
		a << '-municode'
	}
	cflags := v.get_os_cflags()
	// add .o files
	a << cflags.c_options_only_object_files()
	// add all flags (-I -l -L etc) not .o files
	a << cflags.c_options_without_object_files()
	a << libs
	// For C++ we must be very tolerant
	if guessed_compiler.contains('++') {
		a << '-fpermissive'
		a << '-w'
	}
	if v.pref.use_cache {
		//vexe := pref.vexe_path()

		cached_modules:= [ 'builtin', 'os', 'math', 'strconv', 'strings']
		for cfile in cached_modules{
			ofile := os.join_path(pref.default_module_path, 'cache', 'vlib', cfile + '.o')
			if !os.exists(ofile) {
				println('${cfile}.o is missing. Building...')
				println('$vexe build-module vlib/$cfile')
				os.system('$vexe build-module vlib/$cfile')
			}
			a << ofile
		}
		if !is_cc_tcc {
			$if linux {
				linker_flags << '-Xlinker -z'
				linker_flags << '-Xlinker muldefs'
			}
		}
	}
	// Without these libs compilation will fail on Linux
	// || os.user_os() == 'linux'
	if !v.pref.is_bare && v.pref.build_mode != .build_module && v.pref.os in [ .linux, .freebsd,
		.openbsd, .netbsd, .dragonfly, .solaris, .haiku] {
		linker_flags << '-lm'
		linker_flags << '-lpthread'
		// -ldl is a Linux only thing. BSDs have it in libc.
		if v.pref.os == .linux {
			linker_flags << '-ldl'
		}
		if v.pref.os == .freebsd {
			// FreeBSD: backtrace needs execinfo library while linking
			linker_flags << '-lexecinfo'
		}
	}
	if !v.pref.is_bare && v.pref.os == .js && os.user_os() == 'linux' {
		linker_flags << '-lm'
	}
	args := a.join(' ') + ' ' + linker_flags.join(' ')
	start:
	todo()
	// TODO remove
	cmd := '${v.pref.ccompiler} $args'
	// Run
	if v.pref.is_verbose || v.pref.show_cc {
		println('\n==========')
		println(cmd)
	}
	ticks := time.ticks()
	res := os.exec(cmd) or {
		// C compilation failed.
		// If we are on Windows, try msvc
		println('C compilation failed.')
		/*
		if os.user_os() == 'windows' && v.pref.ccompiler != 'msvc' {
			println('Trying to build with MSVC')
			v.cc_msvc()
			return
		}
		*/
		verror(err)
		return
	}
	if res.exit_code != 0 {
		// the command could not be found by the system
		if res.exit_code == 127 {
			$if linux {
				// TCC problems on linux? Try GCC.
				if v.pref.ccompiler.contains('tcc') {
					v.pref.ccompiler = 'cc'
					goto start
				}
			}
			verror('C compiler error, while attempting to run: \n' + '-----------------------------------------------------------\n' +
				'$cmd\n' + '-----------------------------------------------------------\n' + 'Probably your C compiler is missing. \n' +
				'Please reinstall it, or make it available in your PATH.\n\n' + missing_compiler_info())
		}
		if v.pref.is_debug {
			eword := 'error:'
			khighlight := if term.can_show_color_on_stdout() { term.red(eword) } else { eword }
			println(res.output.replace(eword, khighlight))
			verror(c_error_info)
		} else {
			if res.output.len < 30 {
				println(res.output)
			} else {
				elines := error_context_lines(res.output, 'error:', 1, 12)
				println('==================')
				for eline in elines {
					println(eline)
				}
				println('...')
				println('==================')
				println('(Use `v -cg` to print the entire error message)\n')
			}
			verror(c_error_info)
		}
	}
	diff := time.ticks() - ticks
	// Print the C command
	if v.pref.is_verbose {
		println('${v.pref.ccompiler} took $diff ms')
		println('=========\n')
	}
	// Link it if we are cross compiling and need an executable
	/*
	if v.os == .linux && !linux_host && v.pref.build_mode != .build {
		v.out_name = v.out_name.replace('.o', '')
		obj_file := v.out_name + '.o'
		println('linux obj_file=$obj_file out_name=$v.out_name')
		ress := os.exec('/usr/local/Cellar/llvm/8.0.0/bin/ld.lld --sysroot=$sysroot ' +
		'-v -o $v.out_name ' +
		'-m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 ' +
		'/usr/lib/x86_64-linux-gnu/crt1.o ' +
		'$sysroot/lib/x86_64-linux-gnu/libm-2.28.a ' +
		'/usr/lib/x86_64-linux-gnu/crti.o ' +
		obj_file +
		' /usr/lib/x86_64-linux-gnu/libc.so ' +
		'/usr/lib/x86_64-linux-gnu/crtn.o') or {
			verror(err)
			return
		}
		println(ress.output)
		println('linux cross compilation done. resulting binary: "$v.out_name"')
	}
	*/
	if !v.pref.keep_c && v.out_name_c != 'v.c' {
		os.rm(v.out_name_c)
	}
	if v.pref.compress {
		$if windows {
			println('-compress does not work on Windows for now')
			return
		}
		ret := os.system('strip $v.pref.out_name')
		if ret != 0 {
			println('strip failed')
			return
		}
		// NB: upx --lzma can sometimes fail with NotCompressibleException
		// See https://github.com/vlang/v/pull/3528
		mut ret2 := os.system('upx --lzma -qqq $v.pref.out_name')
		if ret2 != 0 {
			ret2 = os.system('upx -qqq $v.pref.out_name')
		}
		if ret2 != 0 {
			println('upx failed')
			$if macos {
				println('install upx with `brew install upx`')
			}
			$if linux {
				println('install upx\n' + 'for example, on Debian/Ubuntu run `sudo apt install upx`')
			}
			$if windows {
				// :)
			}
		}
	}
}

fn (mut c Builder) cc_linux_cross() {
	/*
	sysroot := '/tmp/lld/linuxroot/'
		// Build file.o
		a << '-c --sysroot=$sysroot -target x86_64-linux-gnu'
		// Right now `out_name` can be `file`, not `file.o`
		if !v.out_name.ends_with('.o') {
			v.out_name = v.out_name + '.o'
		}
		*/
}

fn (mut c Builder) cc_windows_cross() {
	println('Cross compiling for Windows...')
	if !c.pref.out_name.ends_with('.exe') {
		c.pref.out_name += '.exe'
	}
	mut args := '-o $c.pref.out_name -w -L. '
	cflags := c.get_os_cflags()
	// -I flags
	args += if c.pref.ccompiler == 'msvc' { cflags.c_options_before_target_msvc() } else { cflags.c_options_before_target() }
	mut optimization_options := ''
	mut debug_options := ''
	if c.pref.is_prod {
		optimization_options = if c.pref.ccompiler == 'msvc' { '' } else { ' -O3 -fno-strict-aliasing -flto ' }
	}
	if c.pref.is_debug {
		debug_options =  if c.pref.ccompiler == 'msvc' { '' } else { ' -g3 -no-pie ' }
	}
	mut libs := ''
	if false && c.pref.build_mode == .default_mode {
		libs = '"${pref.default_module_path}/vlib/builtin.o"'
		if !os.exists(libs) {
			println('`$libs` not found')
			exit(1)
		}
		for imp in c.table.imports {
			libs += ' "${pref.default_module_path}/vlib/${imp}.o"'
		}
	}
	args += ' $c.out_name_c '

	args += if c.pref.ccompiler == 'msvc' { cflags.c_options_after_target_msvc() } else { cflags.c_options_after_target() }

	/*
	winroot := '${pref.default_module_path}/winroot'
	if !os.is_dir(winroot) {
		winroot_url := 'https://github.com/vlang/v/releases/download/v0.1.10/winroot.zip'
		println('"$winroot" not found.')
		println('Download it from $winroot_url and save it in ${pref.default_module_path}')
		println('Unzip it afterwards.\n')
		println('winroot.zip contains all library and header files needed ' + 'to cross-compile for Windows.')
		exit(1)
	}
	mut obj_name := c.out_name
	obj_name = obj_name.replace('.exe', '')
	obj_name = obj_name.replace('.o.o', '.o')
	include := '-I $winroot/include '
	*/
	if os.user_os() !in ['mac', 'darwin','linux'] {
		println(os.user_os())
		panic('your platform is not supported yet')
	}
	mut cmd := 'x86_64-w64-mingw32-gcc'
	cmd += ' $optimization_options $debug_options -std=gnu11 $args -municode'
	//cmd := 'clang -o $obj_name -w $include -m32 -c -target x86_64-win32 ${pref.default_module_path}/$c.out_name_c'
	if c.pref.is_verbose || c.pref.show_cc {
		println(cmd)
	}
	if os.system(cmd) != 0 {
		println('Cross compilation for Windows failed. Make sure you have mingw-w64 installed.')
		$if macos {
			println('brew install mingw-w64')
		}
		$if linux {
			println('sudo apt install -y mingw-w64')
		}
		exit(1)
	}
	/*
	if c.pref.build_mode != .build_module {
		link_cmd := 'lld-link $obj_name $winroot/lib/libcmt.lib ' + '$winroot/lib/libucrt.lib $winroot/lib/kernel32.lib $winroot/lib/libvcruntime.lib ' + '$winroot/lib/uuid.lib'
		if c.pref.show_cc {
			println(link_cmd)
		}
		if os.system(link_cmd) != 0 {
			println('Cross compilation for Windows failed. Make sure you have lld linker installed.')
			exit(1)
		}
		// os.rm(obj_name)
	}
	*/
	println(c.pref.out_name + ' has been successfully compiled')
}

fn (c &Builder) build_thirdparty_obj_files() {
	for flag in c.get_os_cflags() {
		if flag.value.ends_with('.o') {
			rest_of_module_flags := c.get_rest_of_module_cflags(flag)
			if c.pref.ccompiler == 'msvc' || c.no_cc_installed() {
				build_thirdparty_obj_file_with_msvc(flag.value, rest_of_module_flags)
			} else {
				c.build_thirdparty_obj_file(flag.value, rest_of_module_flags)
			}
		}
	}
}

fn (v &Builder) build_thirdparty_obj_file(path string, moduleflags []cflag.CFlag) {
	obj_path := os.real_path(path)
	if os.exists(obj_path) {
		return
	}
	println('$obj_path not found, building it...')
	parent := os.dir(obj_path)
	files := os.ls(parent) or {
		panic(err)
	}
	mut cfiles := ''
	for file in files {
		if file.ends_with('.c') {
			cfiles += '"' + os.real_path(parent + os.path_separator + file) + '" '
		}
	}
	btarget := moduleflags.c_options_before_target()
	atarget := moduleflags.c_options_after_target()
	cmd := '$v.pref.ccompiler $v.pref.third_party_option $btarget -c -o "$obj_path" $cfiles $atarget '
	res := os.exec(cmd) or {
		println('failed thirdparty object build cmd: $cmd')
		verror(err)
		return
	}
	if res.exit_code != 0 {
		println('failed thirdparty object build cmd: $cmd')
		verror(res.output)
		return
	}
	println(res.output)
}

fn missing_compiler_info() string {
	$if windows {
		return 'https://github.com/vlang/v/wiki/Installing-a-C-compiler-on-Windows'
	}
	$if linux {
		return 'On Debian/Ubuntu, run `sudo apt install build-essential`'
	}
	$if macos {
		return 'Install command line XCode tools with `xcode-select --install`'
	}
	return ''
}

fn error_context_lines(text, keyword string, before, after int) []string {
	khighlight := if term.can_show_color_on_stdout() { term.red(keyword) } else { keyword }
	mut eline_idx := 0
	mut lines := text.split_into_lines()
	for idx, eline in lines {
		if eline.contains(keyword) {
			lines[idx] = lines[idx].replace(keyword, khighlight)
			if eline_idx == 0 {
				eline_idx = idx
			}
		}
	}
	idx_s := if eline_idx - before >= 0 { eline_idx - before } else { 0 }
	idx_e := if idx_s + after < lines.len { idx_s + after } else { lines.len }
	return lines[idx_s..idx_e]
}
module builder

import v.cflag

// get flags for current os
fn (v &Builder) get_os_cflags() []cflag.CFlag {
	mut flags := []cflag.CFlag{}
	mut ctimedefines := []string{}
	if v.pref.compile_defines.len > 0 {
		ctimedefines << v.pref.compile_defines
	}
	for flag in v.table.cflags {
		if flag.os == '' || (flag.os == 'linux' && v.pref.os == .linux) || (flag.os == 'darwin' &&
			v.pref.os == .mac) || (flag.os == 'freebsd' && v.pref.os == .freebsd) || (flag.os == 'windows' &&
			v.pref.os == .windows) || (flag.os == 'mingw' && v.pref.os == .windows && v.pref.ccompiler !=
			'msvc') || (flag.os == 'solaris' && v.pref.os == .solaris) {
			flags << flag
		}
		if flag.os in ctimedefines {
			flags << flag
		}
	}
	return flags
}

fn (v &Builder) get_rest_of_module_cflags(c &cflag.CFlag) []cflag.CFlag {
	mut flags := []cflag.CFlag{}
	cflags := v.get_os_cflags()
	for flag in cflags {
		if c.mod == flag.mod {
			if c.name == flag.name && c.value == flag.value && c.os == flag.os {
				continue
			}
			flags << flag
		}
	}
	return flags
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module builder

import time
import os
import v.pref

fn get_vtmp_folder() string {
	vtmp := os.join_path(os.temp_dir(), 'v')
	if !os.is_dir(vtmp) {
		os.mkdir(vtmp) or {
			panic(err)
		}
	}
	return vtmp
}

fn get_vtmp_filename(base_file_name, postfix string) string {
	vtmp := get_vtmp_folder()
	return os.real_path(os.join_path(vtmp, os.file_name(os.real_path(base_file_name)) + postfix))
}

pub fn compile(command string, pref &pref.Preferences) {
	// Construct the V object from command line arguments
	mut b := new_builder(pref)
	if pref.is_verbose {
		println('builder.compile() pref:')
		// println(pref)
	}
	mut sw := time.new_stopwatch()
	match pref.backend {
		.c { b.compile_c() }
		.js { b.compile_js() }
		.x64 { b.compile_x64() }
	}
	if pref.is_stats {
		println('compilation took: ${sw.elapsed().milliseconds()} ms')
	}
	// running does not require the parsers anymore
	b.myfree()
	if pref.is_test || pref.is_run {
		b.run_compiled_executable_and_exit()
	}
}

// Temporary, will be done by -autofree
fn (mut b Builder) myfree() {
	// for file in b.parsed_files {
	// }
	b.parsed_files.free()
}

fn (mut b Builder) run_compiled_executable_and_exit() {
	if b.pref.skip_running {
		return
	}
	if b.pref.is_verbose {
		println('============ running $b.pref.out_name ============')
	}
	
	mut cmd := '"${b.pref.out_name}"'
	
	if b.pref.backend == .js {
		cmd = 'node "${b.pref.out_name}.js"'
	}
	for arg in b.pref.run_args {
		// Determine if there are spaces in the parameters
		if arg.index_byte(` `) > 0 {
			cmd += ' "' + arg + '"'
		} else {
			cmd += ' ' + arg
		}
	}
	if b.pref.is_verbose {
		println('command to run executable: $cmd')
	}
	if b.pref.is_test {
		ret := os.system(cmd)
		if ret != 0 {
			exit(1)
		}
	}
	if b.pref.is_run {
		ret := os.system(cmd)
		// TODO: make the runner wrapping as transparent as possible
		// (i.e. use execve when implemented). For now though, the runner
		// just returns the same exit code as the child process.
		exit(ret)
	}
	exit(0)
}

// 'strings' => 'VROOT/vlib/strings'
// 'installed_mod' => '~/.vmodules/installed_mod'
// 'local_mod' => '/path/to/current/dir/local_mod'
fn (mut v Builder) set_module_lookup_paths() {
	// Module search order:
	// 0) V test files are very commonly located right inside the folder of the
	// module, which they test. Adding the parent folder of the module folder
	// with the _test.v files, *guarantees* that the tested module can be found
	// without needing to set custom options/flags.
	// 1) search in the *same* directory, as the compiled final v program source
	// (i.e. the . in `v .` or file.v in `v file.v`)
	// 2) search in the modules/ in the same directory.
	// 3) search in the provided paths
	// By default, these are what (3) contains:
	// 3.1) search in vlib/
	// 3.2) search in ~/.vmodules/ (i.e. modules installed with vpm)
	v.module_search_paths = []
	if v.pref.is_test {
		v.module_search_paths << os.base_dir(v.compiled_dir) // pdir of _test.v
	}
	v.module_search_paths << v.compiled_dir
	x := os.join_path(v.compiled_dir, 'modules')
	if v.pref.is_verbose {
		println('x: "$x"')
	}
	v.module_search_paths << os.join_path(v.compiled_dir, 'modules')
	v.module_search_paths << v.pref.lookup_path
	if v.pref.is_verbose {
		v.log('v.module_search_paths:')
		println(v.module_search_paths)
	}
}

pub fn (v Builder) get_builtin_files() []string {
	if v.pref.build_mode == .build_module && v.pref.path == 'vlib/builtin' { // .contains('builtin/' +  location {
		// We are already building builtin.o, no need to import them again
		if v.pref.is_verbose {
			println('skipping builtin modules for builtin.o')
		}
		return []
	}
	// println('get_builtin_files() lookuppath:')
	// println(v.pref.lookup_path)
	// Lookup for built-in folder in lookup path.
	// Assumption: `builtin/` folder implies usable implementation of builtin
	for location in v.pref.lookup_path {
		if !os.exists(os.join_path(location, 'builtin')) {
			continue
		}
		if v.pref.is_bare {
			return v.v_files_from_dir(os.join_path(location, 'builtin', 'bare'))
		}
		if v.pref.backend == .js {
			return v.v_files_from_dir(os.join_path(location, 'builtin', 'js'))
		}
		return v.v_files_from_dir(os.join_path(location, 'builtin'))
	}
	// Panic. We couldn't find the folder.
	verror('`builtin/` not included on module lookup path.
Did you forget to add vlib to the path? (Use @vlib for default vlib)')
	panic('Unreachable code reached.')
}

pub fn (v Builder) get_user_files() []string {
	mut dir := v.pref.path
	v.log('get_v_files($dir)')
	// Need to store user files separately, because they have to be added after
	// libs, but we dont know	which libs need to be added yet
	mut user_files := []string{}
	// See cmd/tools/preludes/README.md for more info about what preludes are
	vroot := os.dir(pref.vexe_path())
	preludes_path := os.join_path(vroot, 'cmd', 'tools', 'preludes')
	if v.pref.is_livemain || v.pref.is_liveshared {
		user_files << os.join_path(preludes_path, 'live.v')
	}
	if v.pref.is_livemain {
		user_files << os.join_path(preludes_path, 'live_main.v')
	}
	if v.pref.is_liveshared {
		user_files << os.join_path(preludes_path, 'live_shared.v')
	}
	if v.pref.is_test {
		user_files << os.join_path(preludes_path, 'tests_assertions.v')
	}
	if v.pref.is_test && v.pref.is_stats {
		user_files << os.join_path(preludes_path, 'tests_with_stats.v')
	}
	if v.pref.is_prof {
		user_files << os.join_path(preludes_path, 'profiled_program.v')
	}
	is_test := dir.ends_with('_test.v')
	if v.pref.is_run && is_test {
		println('use `v x_test.v` instead of `v run x_test.v`')
		exit(1)
	}
	mut is_internal_module_test := false
	if is_test {
		tcontent := os.read_file(dir) or {
			panic('$dir does not exist')
		}
		slines := tcontent.trim_space().split_into_lines()
		for sline in slines {
			line := sline.trim_space()
			if line.len > 2 {
				if line[0] == `/` && line[1] == `/` {
					continue
				}
				if line.starts_with('module ') && !line.starts_with('module main') {
					is_internal_module_test = true
					break
				}
			}
		}
	}
	if is_internal_module_test {
		// v volt/slack_test.v: compile all .v files to get the environment
		single_test_v_file := os.real_path(dir)
		if v.pref.is_verbose {
			v.log('> Compiling an internal module _test.v file $single_test_v_file .')
			v.log('> That brings in all other ordinary .v files in the same module too .')
		}
		user_files << single_test_v_file
		dir = os.base_dir(single_test_v_file)
	}
	is_real_file := os.exists(dir) && !os.is_dir(dir)
	if is_real_file && (dir.ends_with('.v') || dir.ends_with('.vsh')) {
		single_v_file := dir
		// Just compile one file and get parent dir
		user_files << single_v_file
		if v.pref.is_verbose {
			v.log('> just compile one file: "${single_v_file}"')
		}
	} else {
		if v.pref.is_verbose {
			v.log('> add all .v files from directory "${dir}" ...')
		}
		// Add .v files from the directory being compiled
		user_files << v.v_files_from_dir(dir)
	}
	if user_files.len == 0 {
		println('No input .v files')
		exit(1)
	}
	if v.pref.is_verbose {
		v.log('user_files: $user_files')
	}
	return user_files
}
module builder

import time
import os
import v.parser
import v.pref
import v.gen
import v.gen.js

pub fn (mut b Builder) gen_js(v_files []string) string {
	t0 := time.ticks()
	b.parsed_files = parser.parse_files(v_files, b.table, b.pref, b.global_scope)
	b.parse_imports()
	t1 := time.ticks()
	parse_time := t1 - t0
	b.info('PARSE: ${parse_time}ms')
	b.checker.check_files(b.parsed_files)
	t2 := time.ticks()
	check_time := t2 - t1
	b.info('CHECK: ${check_time}ms')
	b.print_warnings_and_errors()
	res := js.gen(b.parsed_files, b.table, b.pref)
	t3 := time.ticks()
	gen_time := t3 - t2
	b.info('JS GEN: ${gen_time}ms')
	return res
}

pub fn (mut b Builder) build_js(v_files []string, out_file string) {
	b.out_name_js = out_file
	b.info('build_js($out_file)')
	output := b.gen_js(v_files)
	mut f := os.create(out_file) or {
		panic(err)
	}
	f.writeln(output)
	f.close()
}

pub fn (mut b Builder) compile_js() {
	mut files := b.get_user_files()
	files << b.get_builtin_files()
	b.set_module_lookup_paths()
	if b.pref.is_verbose {
		println('all .v files:')
		println(files)
	}
	b.build_js(files, b.pref.out_name + '.js')
}

fn (mut b Builder) run_js() {
	cmd := 'node ' + b.pref.out_name + '.js'
	res := os.exec(cmd) or {
		println('JS compilation failed.')
		verror(err)
		return
	}
	println(res.output)
}module builder

import os
import v.pref
import v.cflag

#flag windows -l shell32
#flag windows -l dbghelp
#flag windows -l advapi32

struct MsvcResult {
	full_cl_exe_path    string
	exe_path            string
	um_lib_path         string
	ucrt_lib_path       string
	vs_lib_path         string
	um_include_path     string
	ucrt_include_path   string
	vs_include_path     string
	shared_include_path string
}

// shell32 for RegOpenKeyExW etc
// Mimics a HKEY
type RegKey voidptr

// Taken from the windows SDK
const (
	hkey_local_machine     = RegKey(0x80000002)
	key_query_value        = (0x0001)
	key_wow64_32key        = (0x0200)
	key_enumerate_sub_keys = (0x0008)
)

// Given a root key look for one of the subkeys in 'versions' and get the path
fn find_windows_kit_internal(key RegKey, versions []string) ?string {
	$if windows {
		unsafe {
			for version in versions {
				required_bytes := 0 // TODO mut
				result := C.RegQueryValueEx(key, version.to_wide(), 0, 0, 0, &required_bytes)
				length := required_bytes / 2
				if result != 0 {
					continue
				}
				alloc_length := (required_bytes + 2)
				mut value := &u16(malloc(alloc_length))
				if isnil(value) {
					continue
				}
				//
				else{}
				result2 := C.RegQueryValueEx(key, version.to_wide(), 0, 0, value, &alloc_length)
				if result2 != 0 {
					continue
				}
				// We might need to manually null terminate this thing
				// So just make sure that we do that
				if value[length - 1] != u16(0) {
					value[length] = u16(0)
				}
				res := string_from_wide(value)
				return res
			}
		}
	}
	return error('windows kit not found')
}

struct WindowsKit {
	um_lib_path         string
	ucrt_lib_path       string
	um_include_path     string
	ucrt_include_path   string
	shared_include_path string
}

// Try and find the root key for installed windows kits
fn find_windows_kit_root(host_arch string) ?WindowsKit {
	$if windows {
		root_key := RegKey(0)
		path := 'SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots'
		rc := C.RegOpenKeyEx(hkey_local_machine, path.to_wide(), 0, key_query_value | key_wow64_32key |
			key_enumerate_sub_keys, &root_key)
		defer {
			C.RegCloseKey(root_key)
		}
		if rc != 0 {
			return error('Unable to open root key')
		}
		// Try and find win10 kit
		kit_root := find_windows_kit_internal(root_key, ['KitsRoot10', 'KitsRoot81']) or {
			return error('Unable to find a windows kit')
		}
		kit_lib := kit_root + 'Lib'
		// println(kit_lib)
		files := os.ls(kit_lib) or {
			panic(err)
		}
		mut highest_path := ''
		mut highest_int := 0
		for f in files {
			no_dot := f.replace('.', '')
			v_int := no_dot.int()
			if v_int > highest_int {
				highest_int = v_int
				highest_path = f
			}
		}
		kit_lib_highest := kit_lib + '\\$highest_path'
		kit_include_highest := kit_lib_highest.replace('Lib', 'Include')
		// println('$kit_lib_highest $kit_include_highest')
		return WindowsKit{
			um_lib_path: kit_lib_highest + '\\um\\$host_arch'
			ucrt_lib_path: kit_lib_highest + '\\ucrt\\$host_arch'
			um_include_path: kit_include_highest + '\\um'
			ucrt_include_path: kit_include_highest + '\\ucrt'
			shared_include_path: kit_include_highest + '\\shared'
		}
	}
	return error('Host OS does not support funding a windows kit')
}

struct VsInstallation {
	include_path string
	lib_path     string
	exe_path     string
}

fn find_vs(vswhere_dir, host_arch string) ?VsInstallation {
	$if !windows {
		return error('Host OS does not support finding a Vs installation')
	}
	// Emily:
	// VSWhere is guaranteed to be installed at this location now
	// If its not there then end user needs to update their visual studio
	// installation!
	res := os.exec('"$vswhere_dir\\Microsoft Visual Studio\\Installer\\vswhere.exe" -latest -prerelease -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath') or {
		return error(err)
	}
	// println('res: "$res"')
	version := os.read_file('$res.output\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt') or {
		println('Unable to find msvc version')
		return error('Unable to find vs installation')
	}
	version2 := version // TODO remove. cgen option bug if expr
	// println('version: $version')
	v := if version.ends_with('\n') { version2[..version.len - 2] } else { version2 }
	lib_path := '$res.output\\VC\\Tools\\MSVC\\$v\\lib\\$host_arch'
	include_path := '$res.output\\VC\\Tools\\MSVC\\$v\\include'
	if os.exists('$lib_path\\vcruntime.lib') {
		p := '$res.output\\VC\\Tools\\MSVC\\$v\\bin\\Host$host_arch\\$host_arch'
		// println('$lib_path $include_path')
		return VsInstallation{
			exe_path: p
			lib_path: lib_path
			include_path: include_path
		}
	}
	println('Unable to find vs installation (attempted to use lib path "$lib_path")')
	return error('Unable to find vs exe folder')
}

fn find_msvc() ?MsvcResult {
	$if windows {
		processor_architecture := os.getenv('PROCESSOR_ARCHITECTURE')
		vswhere_dir := if processor_architecture == 'x86' { '%ProgramFiles%' } else { '%ProgramFiles(x86)%' }
		host_arch := if processor_architecture == 'x86' { 'X86' } else { 'X64' }
		wk := find_windows_kit_root(host_arch) or {
			return error('Unable to find windows sdk')
		}
		vs := find_vs(vswhere_dir, host_arch) or {
			return error('Unable to find visual studio')
		}
		return MsvcResult{
			full_cl_exe_path: os.real_path(vs.exe_path + os.path_separator + 'cl.exe')
			exe_path: vs.exe_path
			um_lib_path: wk.um_lib_path
			ucrt_lib_path: wk.ucrt_lib_path
			vs_lib_path: vs.lib_path
			um_include_path: wk.um_include_path
			ucrt_include_path: wk.ucrt_include_path
			vs_include_path: vs.include_path
			shared_include_path: wk.shared_include_path
		}
	} $else {
		verror('Cannot find msvc on this OS')
		return error('msvc not found')
	}
}

pub fn (mut v Builder) cc_msvc() {
	r := find_msvc() or {
		// TODO: code reuse
		if !v.pref.keep_c && v.out_name_c != 'v.c' && v.out_name_c != 'v_macos.c' {
			os.rm(v.out_name_c)
		}
		verror('Cannot find MSVC on this OS')
		return
	}
	out_name_obj := os.real_path(v.out_name_c + '.obj')
	// Default arguments
	// volatile:ms enables atomic volatile (gcc _Atomic)
	// -w: no warnings
	// 2 unicode defines
	// /Fo sets the object file name - needed so we can clean up after ourselves properly
	mut a := ['-w', '/we4013', '/volatile:ms', '/Fo"$out_name_obj"']
	if v.pref.is_prod {
		a << '/O2'
		a << '/MD'
		a << '/Zi'
		a << '/DNDEBUG'
	} else {
		a << '/Zi'
		a << '/MDd'
	}
	if v.pref.is_shared {
		if !v.pref.out_name.ends_with('.dll') {
			v.pref.out_name += '.dll'
		}
		// Build dll
		a << '/LD'
	} else if !v.pref.out_name.ends_with('.exe') {
		v.pref.out_name += '.exe'
	}
	v.pref.out_name = os.real_path(v.pref.out_name)
	// alibs := []string{} // builtin.o os.o http.o etc
	if v.pref.build_mode == .build_module {
		// Compile only
		a << '/c'
	} else if v.pref.build_mode == .default_mode {
		/*
		b := os.real_path( '${pref.default_module_path}/vlib/builtin.obj' )
		alibs << '"$b"'
		if !os.exists(b) {
			println('`builtin.obj` not found')
			exit(1)
		}
		for imp in v.table.imports {
			if imp == 'webview' {
				continue
			}
			alibs << '"' + os.real_path( '${pref.default_module_path}/vlib/${imp}.obj' ) + '"'
		}
		*/
	}
	if v.pref.sanitize {
		println('Sanitize not supported on msvc.')
	}
	// The C file we are compiling
	// a << '"$TmpPath/$v.out_name_c"'
	a << '"' + os.real_path(v.out_name_c) + '"'
	// Emily:
	// Not all of these are needed (but the compiler should discard them if they are not used)
	// these are the defaults used by msbuild and visual studio
	mut real_libs := ['kernel32.lib', 'user32.lib', 'advapi32.lib']
	sflags := v.get_os_cflags().msvc_string_flags()
	real_libs << sflags.real_libs
	inc_paths := sflags.inc_paths
	lib_paths := sflags.lib_paths
	other_flags := sflags.other_flags
	// Include the base paths
	a << '-I "$r.ucrt_include_path"'
	a << '-I "$r.vs_include_path"'
	a << '-I "$r.um_include_path"'
	a << '-I "$r.shared_include_path"'
	a << inc_paths
	a << other_flags
	// Libs are passed to cl.exe which passes them to the linker
	a << real_libs.join(' ')
	a << '/link'
	a << '/NOLOGO'
	a << '/OUT:"$v.pref.out_name"'
	a << '/LIBPATH:"$r.ucrt_lib_path"'
	a << '/LIBPATH:"$r.um_lib_path"'
	a << '/LIBPATH:"$r.vs_lib_path"'
	a << '/DEBUG:FULL' // required for prod builds to generate PDB
	if v.pref.is_prod {
		a << '/INCREMENTAL:NO' // Disable incremental linking
		a << '/OPT:REF'
		a << '/OPT:ICF'
	}
	a << lib_paths
	args := a.join(' ')
	cmd := '"$r.full_cl_exe_path" $args'
	// It is hard to see it at first, but the quotes above ARE balanced :-| ...
	// Also the double quotes at the start ARE needed.
	if v.pref.is_verbose {
		println('\n========== cl cmd line:')
		println(cmd)
		println('==========\n')
	}
	// println('$cmd')
	res := os.exec(cmd) or {
		println(err)
		verror('msvc error')
		return
	}
	if res.exit_code != 0 {
		verror(res.output)
	}
	// println(res)
	// println('C OUTPUT:')
	if !v.pref.keep_c && v.out_name_c != 'v.c' && v.out_name_c != 'v_macos.c' {
		os.rm(v.out_name_c)
	}
	// Always remove the object file - it is completely unnecessary
	os.rm(out_name_obj)
}

fn build_thirdparty_obj_file_with_msvc(path string, moduleflags []cflag.CFlag) {
	msvc := find_msvc() or {
		println('Could not find visual studio')
		return
	}
	// msvc expects .obj not .o
	mut obj_path := '${path}bj'
	obj_path = os.real_path(obj_path)
	if os.exists(obj_path) {
		println('$obj_path already built.')
		return
	}
	println('$obj_path not found, building it (with msvc)...')
	parent := os.dir(obj_path)
	files := os.ls(parent) or {
		panic(err)
	}
	mut cfiles := ''
	for file in files {
		if file.ends_with('.c') {
			cfiles += '"' + os.real_path(parent + os.path_separator + file) + '" '
		}
	}
	include_string := '-I "$msvc.ucrt_include_path" -I "$msvc.vs_include_path" -I "$msvc.um_include_path" -I "$msvc.shared_include_path"'
	// println('cfiles: $cfiles')
	btarget := moduleflags.c_options_before_target_msvc()
	atarget := moduleflags.c_options_after_target_msvc()
	cmd := '"$msvc.full_cl_exe_path" /volatile:ms /Zi /DNDEBUG $include_string /c $btarget $cfiles $atarget /Fo"$obj_path"'
	// NB: the quotes above ARE balanced.
	println('thirdparty cmd line: $cmd')
	res := os.exec(cmd) or {
		println('msvc: failed thirdparty object build cmd: $cmd')
		verror(err)
		return
	}
	if res.exit_code != 0 {
		println('msvc: failed thirdparty object build cmd: $cmd')
		verror(res.output)
		return
	}
	println(res.output)
}

struct MsvcStringFlags {
mut:
	real_libs   []string
	inc_paths   []string
	lib_paths   []string
	other_flags []string
}

fn (cflags []cflag.CFlag) msvc_string_flags() MsvcStringFlags {
	mut real_libs := []string{}
	mut inc_paths := []string{}
	mut lib_paths := []string{}
	mut other_flags := []string{}
	for flag in cflags {
		// println('fl: $flag.name | flag arg: $flag.value')
		// We need to see if the flag contains -l
		// -l isnt recognised and these libs will be passed straight to the linker
		// by the compiler
		if flag.name == '-l' {
			if flag.value.ends_with('.dll') {
				verror('MSVC cannot link against a dll (`#flag -l $flag.value`)')
			}
			// MSVC has no method of linking against a .dll
			// TODO: we should look for .defs aswell
			lib_lib := flag.value + '.lib'
			real_libs << lib_lib
		} else if flag.name == '-I' {
			inc_paths << flag.format()
		} else if flag.name == '-L' {
			lib_paths << flag.value
			lib_paths << flag.value + os.path_separator + 'msvc'
			// The above allows putting msvc specific .lib files in a subfolder msvc/ ,
			// where gcc will NOT find them, but cl will do...
			// NB: gcc is smart enough to not need .lib files at all in most cases, the .dll is enough.
			// When both a msvc .lib file and .dll file are present in the same folder,
			// as for example for glfw3, compilation with gcc would fail.
		} else if flag.value.ends_with('.o') {
			// msvc expects .obj not .o
			other_flags << '"${flag.value}bj"'
		} else {
			other_flags << flag.value
		}
	}
	mut lpaths := []string{}
	for l in lib_paths {
		lpaths << '/LIBPATH:"' + os.real_path(l) + '"'
	}
	return MsvcStringFlags{
		real_libs: real_libs
		inc_paths: inc_paths
		lib_paths: lpaths
		other_flags: other_flags
	}
}
module builder

import time
import v.parser
import v.pref
import v.gen
import v.gen.x64

pub fn (mut b Builder) build_x64(v_files []string, out_file string) {
	$if !linux {
		println('v -x64 can only generate Linux binaries for now')
		println('You are not on a Linux system, so you will not ' + 'be able to run the resulting executable')
	}
	t0 := time.ticks()
	b.parsed_files = parser.parse_files(v_files, b.table, b.pref, b.global_scope)
	b.parse_imports()
	t1 := time.ticks()
	parse_time := t1 - t0
	b.info('PARSE: ${parse_time}ms')
	b.checker.check_files(b.parsed_files)
	t2 := time.ticks()
	check_time := t2 - t1
	b.info('CHECK: ${check_time}ms')
	x64.gen(b.parsed_files, out_file, b.pref)
	t3 := time.ticks()
	gen_time := t3 - t2
	b.info('x64 GEN: ${gen_time}ms')
}

pub fn (mut b Builder) compile_x64() {
	// v.files << v.v_files_from_dir(os.join_path(v.pref.vlib_path,'builtin','bare'))
	files := [b.pref.path]
	b.set_module_lookup_paths()
	b.build_x64(files, b.pref.out_name)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module cflag

import os

// parsed cflag
pub struct CFlag {
pub:
	mod   string // the module in which the flag was given
	os    string // eg. windows | darwin | linux
	name  string // eg. -I
	value string // eg. /path/to/include
}

pub fn (c &CFlag) str() string {
	return 'CFlag{ name: "$c.name" value: "$c.value" mod: "$c.mod" os: "$c.os" }'
}

// format flag
pub fn (cf &CFlag) format() string {
	mut value := cf.value
	if cf.name in ['-l', '-Wa', '-Wl', '-Wp'] && value.len > 0 {
		return '${cf.name}${value}'.trim_space()
	}
	// convert to absolute path
	if cf.name == '-I' || cf.name == '-L' || value.ends_with('.o') {
		value = '"' + os.real_path(value) + '"'
	}
	return '$cf.name $value'.trim_space()
}

// TODO: implement msvc specific c_options_before_target and c_options_after_target ...
fn (cflags []CFlag) c_options_before_target_msvc() string {
	return ''
}

fn (cflags []CFlag) c_options_after_target_msvc() string {
	return ''
}

fn (cflags []CFlag) c_options_before_target() string {
	// -I flags, optimization flags and so on
	mut args := []string{}
	for flag in cflags {
		if flag.name != '-l' {
			args << flag.format()
		}
	}
	return args.join(' ')
}

fn (cflags []CFlag) c_options_after_target() string {
	// -l flags (libs)
	mut args := []string{}
	for flag in cflags {
		if flag.name == '-l' {
			args << flag.format()
		}
	}
	return args.join(' ')
}

fn (cflags []CFlag) c_options_without_object_files() string {
	mut args := []string{}
	for flag in cflags {
		if flag.value.ends_with('.o') || flag.value.ends_with('.obj') {
			continue
		}
		args << flag.format()
	}
	return args.join(' ')
}

fn (cflags []CFlag) c_options_only_object_files() string {
	mut args := []string{}
	for flag in cflags {
		if flag.value.ends_with('.o') || flag.value.ends_with('.obj') {
			args << flag.format()
		}
	}
	return args.join(' ')
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module checker

import v.ast
import v.table
import v.token
import v.pref
import v.util
import v.errors

const (
	max_nr_errors = 300
)

pub struct Checker {
	table            &table.Table
pub mut:
	file             ast.File
	nr_errors        int
	nr_warnings      int
	errors           []errors.Error
	warnings         []errors.Warning
	error_lines      []int // to avoid printing multiple errors for the same line
	expected_type    table.Type
	cur_fn           &ast.FnDecl // current function
	const_decl       string
	const_deps       []string
	const_names      []string
	pref             &pref.Preferences // Preferences shared from V struct
	in_for_count     int // if checker is currently in an for loop
	// checked_ident  string // to avoid infinit checker loops
	returns          bool
	scope_returns    bool
	mod              string // current module name
	is_builtin_mod   bool // are we in `builtin`?
	inside_unsafe    bool
	cur_generic_type table.Type
}

pub fn new_checker(table &table.Table, pref &pref.Preferences) Checker {
	return Checker{
		table: table
		pref: pref
		cur_fn: 0
	}
}

pub fn (mut c Checker) check(ast_file ast.File) {
	c.file = ast_file
	for i, ast_import in ast_file.imports {
		for j in 0 .. i {
			if ast_import.mod == ast_file.imports[j].mod {
				c.error('module name `$ast_import.mod` duplicate', ast_import.pos)
			}
		}
	}
	for stmt in ast_file.stmts {
		c.stmt(stmt)
	}
}

pub fn (mut c Checker) check2(ast_file ast.File) []errors.Error {
	c.file = ast_file
	for stmt in ast_file.stmts {
		c.stmt(stmt)
	}
	return c.errors
}

pub fn (mut c Checker) check_files(ast_files []ast.File) {
	mut has_main_mod_file := false
	mut has_main_fn := false
	for file in ast_files {
		c.check(file)
		if file.mod.name == 'main' {
			has_main_mod_file = true
			if c.check_file_in_main(file) {
				has_main_fn = true
			}
		}
	}
	// Make sure fn main is defined in non lib builds
	if c.pref.build_mode == .build_module || c.pref.is_test {
		return
	}
	if c.pref.is_shared {
		// shared libs do not need to have a main
		return
	}
	if !has_main_mod_file {
		c.error('project must include a `main` module or be a shared library (compile with `v -shared`)',
			token.Position{})
	} else if !has_main_fn {
		c.error('function `main` must be declared in the main module', token.Position{})
	}
}

const (
	no_pub_in_main_warning = 'in module main cannot be declared public'
)

// do checks specific to files in main module
// returns `true` if a main function is in the file
fn (mut c Checker) check_file_in_main(file ast.File) bool {
	mut has_main_fn := false
	for stmt in file.stmts {
		match stmt {
			ast.ConstDecl {
				if it.is_pub {
					c.warn('const $no_pub_in_main_warning', it.pos)
				}
			}
			ast.ConstField {
				if it.is_pub {
					c.warn('const field `$it.name` $no_pub_in_main_warning', it.pos)
				}
			}
			ast.EnumDecl {
				if it.is_pub {
					c.warn('enum `$it.name` $no_pub_in_main_warning', it.pos)
				}
			}
			ast.FnDecl {
				if it.name == 'main' {
					has_main_fn = true
					if it.is_pub {
						c.error('function `main` cannot be declared public', it.pos)
					}
					if it.args.len > 0 {
						c.error('function `main` cannot have arguments', it.pos)
					}
					if it.return_type != table.void_type {
						c.error('function `main` cannot return values', it.pos)
					}
				} else {
					if it.is_pub {
						c.warn('function `$it.name` $no_pub_in_main_warning', it.pos)
					}
				}
				if it.ctdefine.len > 0 {
					if it.return_type != table.void_type {
						c.error('only functions that do NOT return values can have `[if ${it.ctdefine}]` tags',
							it.pos)
					}
				}
			}
			ast.StructDecl {
				if it.is_pub {
					c.warn('struct `$it.name` $no_pub_in_main_warning', it.pos)
				}
			}
			ast.TypeDecl {
				type_decl := stmt as ast.TypeDecl
				if type_decl is ast.AliasTypeDecl {
					alias_decl := type_decl as ast.AliasTypeDecl
					if alias_decl.is_pub {
						c.warn('type alias `$alias_decl.name` $no_pub_in_main_warning', alias_decl.pos)
					}
				} else if type_decl is ast.SumTypeDecl {
					sum_decl := type_decl as ast.SumTypeDecl
					if sum_decl.is_pub {
						c.warn('sum type `$sum_decl.name` $no_pub_in_main_warning', sum_decl.pos)
					}
				} else if type_decl is ast.FnTypeDecl {
					fn_decl := type_decl as ast.FnTypeDecl
					if fn_decl.is_pub {
						c.warn('type alias `$fn_decl.name` $no_pub_in_main_warning', fn_decl.pos)
					}
				}
			}
			else {}
		}
	}
	return has_main_fn
}

fn (mut c Checker) check_valid_snake_case(name, identifier string, pos token.Position) {
	if name[0] == `_` {
		c.error('$identifier `$name` cannot start with `_`', pos)
	}
	if util.contains_capital(name) {
		c.error('$identifier `$name` cannot contain uppercase letters, use snake_case instead',
			pos)
	}
}

fn stripped_name(name string) string {
	idx := name.last_index('.') or {
		-1
	}
	return name[(idx + 1)..]
}

fn (mut c Checker) check_valid_pascal_case(name, identifier string, pos token.Position) {
	stripped_name := stripped_name(name)
	if !stripped_name[0].is_capital() {
		c.error('$identifier `$name` must begin with capital letter', pos)
	}
}

pub fn (mut c Checker) type_decl(node ast.TypeDecl) {
	match node {
		ast.AliasTypeDecl {
			// TODO Replace `c.file.mod.name != 'time'` by `it.language != .v` once available
			if c.file.mod.name != 'time' {
				c.check_valid_pascal_case(it.name, 'type alias', it.pos)
			}
			typ_sym := c.table.get_type_symbol(it.parent_type)
			if typ_sym.kind == .placeholder {
				c.error("type `$typ_sym.name` doesn't exist", it.pos)
			}
		}
		ast.FnTypeDecl {
			c.check_valid_pascal_case(it.name, 'fn type', it.pos)
			typ_sym := c.table.get_type_symbol(it.typ)
			fn_typ_info := typ_sym.info as table.FnType
			fn_info := fn_typ_info.func
			ret_sym := c.table.get_type_symbol(fn_info.return_type)
			if ret_sym.kind == .placeholder {
				c.error("type `$ret_sym.name` doesn't exist", it.pos)
			}
			for arg in fn_info.args {
				arg_sym := c.table.get_type_symbol(arg.typ)
				if arg_sym.kind == .placeholder {
					c.error("type `$arg_sym.name` doesn't exist", it.pos)
				}
			}
		}
		ast.SumTypeDecl {
			c.check_valid_pascal_case(it.name, 'sum type', it.pos)
			for typ in it.sub_types {
				typ_sym := c.table.get_type_symbol(typ)
				if typ_sym.kind == .placeholder {
					c.error("type `$typ_sym.name` doesn't exist", it.pos)
				}
			}
		}
	}
}

pub fn (mut c Checker) interface_decl(decl ast.InterfaceDecl) {
	c.check_valid_pascal_case(decl.name, 'interface name', decl.pos)
	for method in decl.methods {
		c.check_valid_snake_case(method.name, 'method name', method.pos)
	}
}

pub fn (mut c Checker) struct_decl(decl ast.StructDecl) {
	if decl.language == .v && !c.is_builtin_mod {
		c.check_valid_pascal_case(decl.name, 'struct name', decl.pos)
	}
	for i, field in decl.fields {
		if decl.language == .v {
			c.check_valid_snake_case(field.name, 'field name', field.pos)
		}
		for j in 0 .. i {
			if field.name == decl.fields[j].name {
				c.error('field name `$field.name` duplicate', field.pos)
			}
		}
		sym := c.table.get_type_symbol(field.typ)
		if sym.kind == .placeholder && decl.language != .c && !sym.name.starts_with('C.') {
			c.error('unknown type `$sym.name`', field.pos)
		}
		if sym.kind == .struct_ {
			info := sym.info as table.Struct
			if info.is_ref_only && !field.typ.is_ptr() {
				c.error('`$sym.name` type can only be used as a reference: `&$sym.name`', field.pos)
			}
		}
		if field.has_default_expr {
			c.expected_type = field.typ
			field_expr_type := c.expr(field.default_expr)
			if !c.check_types(field_expr_type, field.typ) {
				field_expr_type_sym := c.table.get_type_symbol(field_expr_type)
				field_type_sym := c.table.get_type_symbol(field.typ)
				c.error('default expression for field `${field.name}` ' + 'has type `${field_expr_type_sym.name}`, but should be `${field_type_sym.name}`',
					field.default_expr.position())
			}
		}
	}
}

pub fn (mut c Checker) struct_init(mut struct_init ast.StructInit) table.Type {
	// typ := c.table.find_type(struct_init.typ.typ.name) or {
	// c.error('unknown struct: $struct_init.typ.typ.name', struct_init.pos)
	// panic('')
	// }
	if struct_init.typ == table.void_type {
		// Short syntax `({foo: bar})`
		if c.expected_type == table.void_type {
			c.error('unexpected short struct syntax', struct_init.pos)
			return table.void_type
		}
		struct_init.typ = c.expected_type
	}
	type_sym := c.table.get_type_symbol(struct_init.typ)
	if type_sym.kind == .interface_ {
		c.error('cannot instantiate interface `$type_sym.name`', struct_init.pos)
	}
	if !type_sym.is_public && type_sym.kind != .placeholder && type_sym.mod != c.mod {
		c.error('type `$type_sym.name` is private', struct_init.pos)
	}
	// println('check struct $typ_sym.name')
	match type_sym.kind {
		.placeholder {
			c.error('unknown struct: $type_sym.name', struct_init.pos)
		}
		// string & array are also structs but .kind of string/array
		.struct_, .string, .array, .alias {
			mut info := table.Struct{}
			if type_sym.kind == .alias {
				info_t := type_sym.info as table.Alias
				sym := c.table.get_type_symbol(info_t.parent_typ)
				if sym.kind != .struct_ {
					c.error('alias type name: $sym.name is not struct type', struct_init.pos)
				}
				info = sym.info as table.Struct
			} else {
				info = type_sym.info as table.Struct
			}
			if struct_init.is_short && struct_init.fields.len > info.fields.len {
				c.error('too many fields', struct_init.pos)
			}
			mut inited_fields := []string{}
			for i, field in struct_init.fields {
				mut info_field := table.Field{}
				mut field_name := ''
				if struct_init.is_short {
					if i >= info.fields.len {
						// It doesn't make sense to check for fields that don't exist.
						// We should just stop here.
						break
					}
					info_field = info.fields[i]
					field_name = info_field.name
					struct_init.fields[i].name = field_name
				} else {
					field_name = field.name
					mut exists := false
					for f in info.fields {
						if f.name == field_name {
							info_field = f
							exists = true
							break
						}
					}
					if !exists {
						c.error('unknown field `$field.name` in struct literal of type `$type_sym.name`',
							field.pos)
						continue
					}
					if field_name in inited_fields {
						c.error('duplicate field name in struct literal: `$field_name`', field.pos)
						continue
					}
				}
				inited_fields << field_name
				c.expected_type = info_field.typ
				expr_type := c.expr(field.expr)
				expr_type_sym := c.table.get_type_symbol(expr_type)
				field_type_sym := c.table.get_type_symbol(info_field.typ)
				if !c.check_types(expr_type, info_field.typ) {
					c.error('cannot assign `$expr_type_sym.name` as `$field_type_sym.name` for field `$info_field.name`',
						field.pos)
				}
				if info_field.typ.is_ptr() && !expr_type.is_ptr() && !expr_type.is_number() {
					c.error('ref', field.pos)
				}
				struct_init.fields[i].typ = expr_type
				struct_init.fields[i].expected_type = info_field.typ
			}
			// Check uninitialized refs
			for field in info.fields {
				if field.has_default_expr || field.name in inited_fields {
					continue
				}
				if field.typ.is_ptr() {
					c.warn('reference field `${type_sym.name}.${field.name}` must be initialized',
						struct_init.pos)
				}
			}
		}
		else {}
	}
	return struct_init.typ
}

pub fn (mut c Checker) infix_expr(mut infix_expr ast.InfixExpr) table.Type {
	// println('checker: infix expr(op $infix_expr.op.str())')
	former_expected_type := c.expected_type
	defer {
		c.expected_type = former_expected_type
	}
	c.expected_type = table.void_type
	mut left_type := c.expr(infix_expr.left)
	if false && left_type == table.t_type {
		left_type = c.cur_generic_type
	}
	infix_expr.left_type = left_type
	c.expected_type = left_type
	mut right_type := c.expr(infix_expr.right)
	if false && right_type == table.t_type {
		right_type = c.cur_generic_type
	}
	infix_expr.right_type = right_type
	right := c.table.get_type_symbol(right_type)
	left := c.table.get_type_symbol(left_type)
	// Single side check
	// Place these branches according to ops' usage frequency to accelerate.
	// TODO: First branch includes ops where single side check is not needed, or needed but hasn't been implemented.
	// TODO: Some of the checks are not single side. Should find a better way to organize them.
	match infix_expr.op {
		// .eq, .ne, .gt, .lt, .ge, .le, .and, .logical_or, .dot, .key_as, .right_shift {}
		.key_in, .not_in {
			match right.kind {
				.array {
					right_sym := c.table.get_type_symbol(right.array_info().elem_type)
					if left.kind != right_sym.kind {
						c.error('the data type on the left of `$infix_expr.op.str()` does not match the array item type',
							infix_expr.pos)
					}
				}
				.map {
					key_sym := c.table.get_type_symbol(right.map_info().key_type)
					if left.kind != key_sym.kind {
						c.error('the data type on the left of `$infix_expr.op.str()` does not match the map key type',
							infix_expr.pos)
					}
				}
				.string {
					if left.kind != .string {
						c.error('the data type on the left of `$infix_expr.op.str()` must be a string',
							infix_expr.pos)
					}
				}
				else {
					c.error('`$infix_expr.op.str()` can only be used with an array/map/string',
						infix_expr.pos)
				}
			}
			return table.bool_type
		}
		.plus, .minus, .mul, .div {
			if infix_expr.op == .div && (infix_expr.right is ast.IntegerLiteral && infix_expr.right.str() ==
				'0' || infix_expr.right is ast.FloatLiteral && infix_expr.right.str().f64() == 0.0) {
				c.error('division by zero', infix_expr.right.position())
			}
			if left.kind in [.array, .array_fixed, .map, .struct_] && !left.has_method(infix_expr.op.str()) {
				c.error('mismatched types `$left.name` and `$right.name`', infix_expr.left.position())
			} else if right.kind in [.array, .array_fixed, .map, .struct_] && !right.has_method(infix_expr.op.str()) {
				c.error('mismatched types `$left.name` and `$right.name`', infix_expr.right.position())
			}
		}
		.left_shift {
			if left.kind == .array {
				// `array << elm`
				c.fail_if_immutable(infix_expr.left)
				left_value_type := c.table.value_type(left_type)
				left_value_sym := c.table.get_type_symbol(left_value_type)
				if left_value_sym.kind == .interface_ {
					if right.kind != .array {
						// []Animal << Cat
						c.type_implements(right_type, left_value_type, infix_expr.right.position())
					} else {
						// []Animal << Cat
						c.type_implements(c.table.value_type(right_type), left_value_type,
							infix_expr.right.position())
					}
					return table.void_type
				}
				// the expressions have different types (array_x and x)
				if c.check_types(right_type, left_value_type) { // , right_type) {
					// []T << T
					return table.void_type
				}
				if right.kind == .array && c.check_types(left_value_type, c.table.value_type(right_type)) {
					// []T << []T
					return table.void_type
				}
				s := left.name.replace('array_', '[]')
				c.error('cannot append `$right.name` to `$s`', infix_expr.right.position())
				return table.void_type
			} else if !left.is_int() {
				c.error('cannot shift type $right.name into non-integer type $left.name', infix_expr.left.position())
				return table.void_type
			} else if !right.is_int() {
				c.error('cannot shift non-integer type $right.name into type $left.name', infix_expr.right.position())
				return table.void_type
			}
		}
		.key_is {
			type_expr := infix_expr.right as ast.Type
			typ_sym := c.table.get_type_symbol(type_expr.typ)
			if typ_sym.kind == .placeholder {
				c.error('is: type `${typ_sym.name}` does not exist', type_expr.pos)
			}
			return table.bool_type
		}
		.amp, .pipe, .xor {
			if !left.is_int() {
				c.error('left type of `${infix_expr.op.str()}` cannot be non-integer type $left.name',
					infix_expr.left.position())
			} else if !right.is_int() {
				c.error('right type of `${infix_expr.op.str()}` cannot be non-integer type $right.name',
					infix_expr.right.position())
			}
		}
		.mod {
			if left.is_int() && !right.is_int() {
				c.error('mismatched types `$left.name` and `$right.name`', infix_expr.right.position())
			} else if !left.is_int() && right.is_int() {
				c.error('mismatched types `$left.name` and `$right.name`', infix_expr.left.position())
			} else if left.kind == .f32 && right.kind == .f32 || left.kind == .f64 && right.kind ==
				.f64 {
				c.error('float modulo not allowed, use math.fmod() instead', infix_expr.left.position())
			} else if left.kind in [.f32, .f64, .string, .array, .array_fixed, .map, .struct_] &&
				!left.has_method(infix_expr.op.str()) {
				c.error('mismatched types `$left.name` and `$right.name`', infix_expr.left.position())
			} else if right.kind in [.f32, .f64, .string, .array, .array_fixed, .map, .struct_] &&
				!right.has_method(infix_expr.op.str()) {
				c.error('mismatched types `$left.name` and `$right.name`', infix_expr.right.position())
			} else if infix_expr.right is ast.IntegerLiteral && infix_expr.right.str() == '0' {
				c.error('modulo by zero', infix_expr.right.position())
			}
		}
		else {}
	}
	// TODO: Absorb this block into the above single side check block to accelerate.
	if left_type == table.bool_type && infix_expr.op !in [.eq, .ne, .logical_or, .and] {
		c.error('bool types only have the following operators defined: `==`, `!=`, `||`, and `&&`',
			infix_expr.pos)
	} else if left_type == table.string_type && infix_expr.op !in [.plus, .eq, .ne, .lt, .gt,
		.le, .ge] {
		// TODO broken !in
		c.error('string types only have the following operators defined: `==`, `!=`, `<`, `>`, `<=`, `>=`, and `&&`',
			infix_expr.pos)
	}
	// Dual sides check (compatibility check)
	if !c.check_types(right_type, left_type) {
		// for type-unresolved consts
		if left_type == table.void_type || right_type == table.void_type {
			return table.void_type
		}
		c.error('infix expr: cannot use `$right.name` (right expression) as `$left.name`',
			infix_expr.pos)
	}
	return if infix_expr.op.is_relational() {
		table.bool_type
	} else {
		left_type
	}
}

fn (mut c Checker) fail_if_immutable(expr ast.Expr) {
	match expr {
		ast.Ident {
			scope := c.file.scope.innermost(it.pos.pos)
			if v := scope.find_var(it.name) {
				if !v.is_mut && !v.typ.is_ptr() {
					c.error('`$it.name` is immutable, declare it with `mut` to make it mutable',
						it.pos)
				}
			} else if it.name in c.const_names {
				c.error('cannot assign to constant `$it.name`', it.pos)
			}
		}
		ast.IndexExpr {
			c.fail_if_immutable(it.left)
		}
		ast.ParExpr {
			c.fail_if_immutable(it.expr)
		}
		ast.PrefixExpr {
			c.fail_if_immutable(it.right)
		}
		ast.SelectorExpr {
			// retrieve table.Field
			if it.expr_type == 0 {
				c.error('0 type in SelectorExpr', it.pos)
				return
			}
			typ_sym := c.table.get_type_symbol(it.expr_type)
			match typ_sym.kind {
				.struct_ {
					struct_info := typ_sym.info as table.Struct
					field_info := struct_info.find_field(it.field_name) or {
						type_str := c.table.type_to_str(it.expr_type)
						c.error('unknown field `${type_str}.$it.field_name`', it.pos)
						return
					}
					if !field_info.is_mut {
						type_str := c.table.type_to_str(it.expr_type)
						c.error('field `$it.field_name` of struct `${type_str}` is immutable',
							it.pos)
					}
					c.fail_if_immutable(it.expr)
				}
				.array, .string {
					// This should only happen in `builtin`
					// TODO Remove `crypto.rand` when possible (see vlib/crypto/rand/rand.v,
					// if `c_array_to_bytes_tmp` doesn't exist, then it's safe to remove it)
					if c.file.mod.name !in ['builtin', 'crypto.rand'] {
						c.error('`$typ_sym.kind` can not be modified', it.pos)
					}
				}
				else {
					c.error('unexpected symbol `${typ_sym.kind}`', it.pos)
				}
			}
		}
		else {
			c.error('unexpected expression `${typeof(expr)}`', expr.position())
		}
	}
}

fn (mut c Checker) assign_expr(mut assign_expr ast.AssignExpr) {
	c.expected_type = table.void_type
	left_type := c.unwrap_generic(c.expr(assign_expr.left))
	c.expected_type = left_type
	assign_expr.left_type = left_type
	// println('setting exp type to $c.expected_type $t.name')
	right_type := c.check_expr_opt_call(assign_expr.val, c.unwrap_generic(c.expr(assign_expr.val)))
	assign_expr.right_type = right_type
	right := c.table.get_type_symbol(right_type)
	left := c.table.get_type_symbol(left_type)
	if ast.expr_is_blank_ident(assign_expr.left) {
		return
	}
	// Make sure the variable is mutable
	c.fail_if_immutable(assign_expr.left)
	// Do now allow `*x = y` outside `unsafe`
	if assign_expr.left is ast.PrefixExpr {
		p := assign_expr.left as ast.PrefixExpr
		if p.op == .mul && !c.inside_unsafe {
			c.error('modifying variables via deferencing can only be done in `unsafe` blocks',
				assign_expr.pos)
		}
	}
	// Single side check
	match assign_expr.op {
		.assign {} // No need to do single side check for =. But here put it first for speed.
		.plus_assign {
			if !left.is_number() && left_type != table.string_type && !left.is_pointer() {
				c.error('operator += not defined on left operand type `$left.name`', assign_expr.left.position())
			} else if !right.is_number() && right_type != table.string_type && !right.is_pointer() {
				c.error('operator += not defined on right operand type `$right.name`', assign_expr.val.position())
			}
		}
		.minus_assign {
			if !left.is_number() && !left.is_pointer() {
				c.error('operator -= not defined on left operand type `$left.name`', assign_expr.left.position())
			} else if !right.is_number() && !right.is_pointer() {
				c.error('operator -= not defined on right operand type `$right.name`', assign_expr.val.position())
			}
		}
		.mult_assign, .div_assign {
			if !left.is_number() {
				c.error('operator ${assign_expr.op.str()} not defined on left operand type `$left.name`',
					assign_expr.left.position())
			} else if !right.is_number() {
				c.error('operator ${assign_expr.op.str()} not defined on right operand type `$right.name`',
					assign_expr.val.position())
			}
		}
		.and_assign, .or_assign, .xor_assign, .mod_assign, .left_shift_assign, .right_shift_assign {
			if !left.is_int() {
				c.error('operator ${assign_expr.op.str()} not defined on left operand type `$left.name`',
					assign_expr.left.position())
			} else if !right.is_int() {
				c.error('operator ${assign_expr.op.str()} not defined on right operand type `$right.name`',
					assign_expr.val.position())
			}
		}
		else {}
	}
	// Dual sides check (compatibility check)
	if !c.check_types(right_type, left_type) {
		left_type_sym := c.table.get_type_symbol(left_type)
		right_type_sym := c.table.get_type_symbol(right_type)
		c.error('cannot assign `$right_type_sym.name` to variable `${assign_expr.left.str()}` of type `$left_type_sym.name`',
			assign_expr.val.position())
	}
}

pub fn (mut c Checker) call_expr(mut call_expr ast.CallExpr) table.Type {
	c.stmts(call_expr.or_block.stmts)
	if call_expr.is_method {
		return c.call_method(call_expr)
	}
	return c.call_fn(call_expr)
}

pub fn (mut c Checker) call_method(mut call_expr ast.CallExpr) table.Type {
	left_type := c.expr(call_expr.left)
	call_expr.left_type = left_type
	left_type_sym := c.table.get_type_symbol(left_type)
	method_name := call_expr.name
	// TODO: remove this for actual methods, use only for compiler magic
	// FIXME: Argument count != 1 will break these
	if left_type_sym.kind == .array && method_name in ['filter', 'clone', 'repeat', 'reverse',
		'map', 'slice'] {
		if method_name in ['filter', 'map'] {
			array_info := left_type_sym.info as table.Array
			mut scope := c.file.scope.innermost(call_expr.pos.pos)
			scope.update_var_type('it', array_info.elem_type)
		}
		// map/filter are supposed to have 1 arg only
		mut arg_type := left_type
		for arg in call_expr.args {
			arg_type = c.expr(arg.expr)
		}
		call_expr.return_type = left_type
		call_expr.receiver_type = left_type
		if method_name == 'map' {
			arg_sym := c.table.get_type_symbol(arg_type)
			// FIXME: match expr failed for now
			mut ret_type := 0
			match arg_sym.info {
				table.FnType { ret_type = it.func.return_type }
				else { ret_type = arg_type }
			}
			call_expr.return_type = c.table.find_or_register_array(ret_type, 1)
		} else if method_name == 'clone' {
			// need to return `array_xxx` instead of `array`
			// in ['clone', 'str'] {
			call_expr.receiver_type = left_type.to_ptr()
			// call_expr.return_type = call_expr.receiver_type
		}
		return call_expr.return_type
	} else if left_type_sym.kind == .array && method_name in ['first', 'last'] {
		info := left_type_sym.info as table.Array
		call_expr.return_type = info.elem_type
		call_expr.receiver_type = left_type
		return call_expr.return_type
	}
	if method := c.table.type_find_method(left_type_sym, method_name) {
		if !method.is_pub && !c.is_builtin_mod && !c.pref.is_test && left_type_sym.mod != c.mod &&
			left_type_sym.mod != '' { // method.mod != c.mod {
			// If a private method is called outside of the module
			// its receiver type is defined in, show an error.
			// println('warn $method_name lef.mod=$left_type_sym.mod c.mod=$c.mod')
			c.error('method `${left_type_sym.name}.$method_name` is private', call_expr.pos)
		}
		if method.return_type == table.void_type && method.ctdefine.len > 0 && method.ctdefine !in
			c.pref.compile_defines {
			call_expr.should_be_skipped = true
		}
		nr_args := if method.args.len == 0 { 0 } else { method.args.len - 1 }
		min_required_args := method.args.len - if method.is_variadic && method.args.len > 1 { 2 } else { 1 }
		if call_expr.args.len < min_required_args {
			c.error('too few arguments in call to `${left_type_sym.name}.$method_name` ($call_expr.args.len instead of $min_required_args)',
				call_expr.pos)
		} else if !method.is_variadic && call_expr.args.len > nr_args {
			c.error('!too many arguments in call to `${left_type_sym.name}.$method_name` ($call_expr.args.len instead of $nr_args)',
				call_expr.pos)
			return method.return_type
		}
		// if method_name == 'clone' {
		// println('CLONE nr args=$method.args.len')
		// }
		// call_expr.args << method.args[0].typ
		// call_expr.exp_arg_types << method.args[0].typ
		for i, arg in call_expr.args {
			exp_arg_typ := if method.is_variadic && i >= method.args.len - 1 { method.args[method.args.len -
					1].typ } else { method.args[i + 1].typ }
			exp_arg_sym := c.table.get_type_symbol(exp_arg_typ)
			c.expected_type = exp_arg_typ
			got_arg_typ := c.expr(arg.expr)
			call_expr.args[i].typ = got_arg_typ
			if method.is_variadic && got_arg_typ.flag_is(.variadic) && call_expr.args.len -
				1 > i {
				c.error('when forwarding a varg variable, it must be the final argument', call_expr.pos)
			}
			if exp_arg_sym.kind == .interface_ {
				c.type_implements(got_arg_typ, exp_arg_typ, arg.expr.position())
				continue
			}
			if !c.check_types(got_arg_typ, exp_arg_typ) {
				got_arg_sym := c.table.get_type_symbol(got_arg_typ)
				// str method, allow type with str method if fn arg is string
				if exp_arg_sym.kind == .string && got_arg_sym.has_method('str') {
					continue
				}
				c.error('cannot use type `$got_arg_sym.str()` as type `$exp_arg_sym.str()` in argument ${i+1} to `${left_type_sym.name}.$method_name`',
					call_expr.pos)
			}
		}
		// TODO: typ optimize.. this node can get processed more than once
		if call_expr.expected_arg_types.len == 0 {
			for i in 1 .. method.args.len {
				call_expr.expected_arg_types << method.args[i].typ
			}
		}
		call_expr.receiver_type = method.args[0].typ
		call_expr.return_type = method.return_type
		return method.return_type
	}
	// TODO: str methods
	if method_name == 'str' {
		call_expr.receiver_type = left_type
		call_expr.return_type = table.string_type
		return table.string_type
	}
	// call struct field fn type
	// TODO: can we use SelectorExpr for all? this dosent really belong here
	if field := c.table.struct_find_field(left_type_sym, method_name) {
		field_type_sym := c.table.get_type_symbol(field.typ)
		if field_type_sym.kind == .function {
			call_expr.is_method = false
			info := field_type_sym.info as table.FnType
			call_expr.return_type = info.func.return_type
			// TODO: check args (do it once for all of the above)
			for arg in call_expr.args {
				c.expr(arg.expr)
			}
			return info.func.return_type
		}
	}
	c.error('unknown method: `${left_type_sym.name}.$method_name`', call_expr.pos)
	return table.void_type
}

pub fn (mut c Checker) call_fn(mut call_expr ast.CallExpr) table.Type {
	if call_expr.name == 'panic' {
		c.returns = true
	}
	fn_name := call_expr.name
	if fn_name == 'main' {
		c.error('the `main` function cannot be called in the program', call_expr.pos)
	}
	if fn_name == 'typeof' {
		// TODO: impl typeof properly (probably not going to be a fn call)
		return table.string_type
	}
	// if c.fileis('json_test.v') {
	// println(fn_name)
	// }
	if fn_name == 'json.encode' {
	} else if fn_name == 'json.decode' {
		expr := call_expr.args[0].expr
		if !(expr is ast.Type) {
			typ := typeof(expr)
			c.error('json.decode: first argument needs to be a type, got `$typ`', call_expr.pos)
			return table.void_type
		}
		c.expected_type = table.string_type
		call_expr.args[1].typ = c.expr(call_expr.args[1].expr)
		if call_expr.args[1].typ != table.string_type {
			c.error('json.decode: second argument needs to be a string', call_expr.pos)
		}
		typ := expr as ast.Type
		ret_type := typ.typ.set_flag(.optional)
		call_expr.return_type = ret_type
		return ret_type
	}
	// look for function in format `mod.fn` or `fn` (main/builtin)
	mut f := table.Fn{}
	mut found := false
	mut found_in_args := false
	// try prefix with current module as it would have never gotten prefixed
	if !fn_name.contains('.') && call_expr.mod !in ['builtin', 'main'] {
		name_prefixed := '${call_expr.mod}.$fn_name'
		if f1 := c.table.find_fn(name_prefixed) {
			call_expr.name = name_prefixed
			found = true
			f = f1
		}
	}
	// already prefixed (mod.fn) or C/builtin/main
	if !found {
		if f1 := c.table.find_fn(fn_name) {
			found = true
			f = f1
		}
	}
	// check for arg (var) of fn type
	if !found {
		scope := c.file.scope.innermost(call_expr.pos.pos)
		if v := scope.find_var(fn_name) {
			if v.typ != 0 {
				vts := c.table.get_type_symbol(v.typ)
				if vts.kind == .function {
					info := vts.info as table.FnType
					f = info.func
					found = true
					found_in_args = true
				}
			}
		}
	}
	if !found {
		c.error('unknown function: $fn_name', call_expr.pos)
		return table.void_type
	}
	if !found_in_args && call_expr.mod in ['builtin', 'main'] {
		scope := c.file.scope.innermost(call_expr.pos.pos)
		if _ := scope.find_var(fn_name) {
			c.error('ambiguous call to: `$fn_name`, may refer to fn `$fn_name` or variable `$fn_name`',
				call_expr.pos)
		}
	}
	if !f.is_pub && f.language == .v && !c.is_builtin_mod && !c.pref.is_test && f.mod != c.mod &&
		f.name != '' && f.mod != '' {
		c.warn('function `$f.name` is private. curmod=$c.mod fmod=$f.mod', call_expr.pos)
	}
	call_expr.return_type = f.return_type
	if f.return_type == table.void_type && f.ctdefine.len > 0 && f.ctdefine !in c.pref.compile_defines {
		call_expr.should_be_skipped = true
	}
	if f.language != .v || call_expr.language != .v {
		for arg in call_expr.args {
			c.expr(arg.expr)
		}
		return f.return_type
	}
	min_required_args := if f.is_variadic { f.args.len - 1 } else { f.args.len }
	if call_expr.args.len < min_required_args {
		c.error('too few arguments in call to `$fn_name` ($call_expr.args.len instead of $min_required_args)',
			call_expr.pos)
	} else if !f.is_variadic && call_expr.args.len > f.args.len {
		c.error('too many arguments in call to `$fn_name` ($call_expr.args.len instead of $f.args.len)',
			call_expr.pos)
		return f.return_type
	}
	// println can print anything
	if (fn_name == 'println' || fn_name == 'print') && call_expr.args.len > 0 {
		c.expected_type = table.string_type
		call_expr.args[0].typ = c.expr(call_expr.args[0].expr)
		/*
		// TODO: optimize `struct T{} fn (t &T) str() string {return 'abc'} mut a := []&T{} a << &T{} println(a[0])`
		// It currently generates:
		// `println(T_str_no_ptr(*(*(T**)array_get(a, 0))));`
		// ... which works, but could be just:
		// `println(T_str(*(T**)array_get(a, 0)));`
		prexpr := call_expr.args[0].expr
		prtyp := call_expr.args[0].typ
		prtyp_sym := c.table.get_type_symbol(prtyp)
		prtyp_is_ptr := prtyp.is_ptr()
		prhas_str, prexpects_ptr, prnr_args := prtyp_sym.str_method_info()
		eprintln('>>> println hack typ: ${prtyp} | sym.name: ${prtyp_sym.name} | is_ptr: $prtyp_is_ptr | has_str: $prhas_str | expects_ptr: $prexpects_ptr | nr_args: $prnr_args | expr: ${prexpr.str()} ')
		*/
		return f.return_type
	}
	// TODO: typ optimize.. this node can get processed more than once
	if call_expr.expected_arg_types.len == 0 {
		for arg in f.args {
			call_expr.expected_arg_types << arg.typ
		}
	}
	for i, call_arg in call_expr.args {
		arg := if f.is_variadic && i >= f.args.len - 1 { f.args[f.args.len - 1] } else { f.args[i] }
		c.expected_type = arg.typ
		typ := c.expr(call_arg.expr)
		call_expr.args[i].typ = typ
		typ_sym := c.table.get_type_symbol(typ)
		arg_typ_sym := c.table.get_type_symbol(arg.typ)
		if f.is_variadic && typ.flag_is(.variadic) && call_expr.args.len - 1 > i {
			c.error('when forwarding a varg variable, it must be the final argument', call_expr.pos)
		}
		// Handle expected interface
		if arg_typ_sym.kind == .interface_ {
			c.type_implements(typ, arg.typ, call_arg.expr.position())
			continue
		}
		// Handle expected interface array
		/*
		if exp_type_sym.kind == .array && t.get_type_symbol(t.value_type(exp_idx)).kind == .interface_ {
			return true
		}
		*/
		if !c.check_types(typ, arg.typ) {
			// str method, allow type with str method if fn arg is string
			if arg_typ_sym.kind == .string && typ_sym.has_method('str') {
				continue
			}
			if typ_sym.kind == .void && arg_typ_sym.kind == .string {
				continue
			}
			if f.is_generic {
				continue
			}
			if typ_sym.kind == .array_fixed {
			}
			c.error('cannot use type `$typ_sym.str()` as type `$arg_typ_sym.str()` in argument ${i+1} to `$fn_name`',
				call_expr.pos)
		}
	}
	if call_expr.generic_type != table.void_type && f.return_type != 0 { // table.t_type {
		// Handle `foo<T>() T` => `foo<int>() int` => return int
		sym := c.table.get_type_symbol(f.return_type)
		if sym.name == 'T' {
			return call_expr.generic_type
		}
	}
	return f.return_type
}

fn (mut c Checker) type_implements(typ, inter_typ table.Type, pos token.Position) {
	typ_sym := c.table.get_type_symbol(typ)
	inter_sym := c.table.get_type_symbol(inter_typ)
	styp := c.table.type_to_str(typ)
	for imethod in inter_sym.methods {
		if method := typ_sym.find_method(imethod.name) {
			if !imethod.is_same_method_as(method) {
				c.error('`$styp` incorrectly implements method `$imethod.name` of interface `$inter_sym.name`, expected `${c.table.fn_to_str(imethod)}`',
					pos)
			}
			continue
		}
		c.error("`$styp` doesn't implement method `$imethod.name`", pos)
	}
	mut inter_info := inter_sym.info as table.Interface
	if typ !in inter_info.types && typ_sym.kind != .interface_ {
		inter_info.types << typ
	}
}

// return the actual type of the expression, once the optional is handled
pub fn (mut c Checker) check_expr_opt_call(expr ast.Expr, ret_type table.Type) table.Type {
	if expr is ast.CallExpr {
		call_expr := expr as ast.CallExpr
		if call_expr.return_type.flag_is(.optional) {
			if call_expr.or_block.kind == .absent {
				if ret_type != table.void_type {
					c.error('${call_expr.name}() returns an option, but you missed to add an `or {}` block to it',
						call_expr.pos)
				}
			} else {
				c.check_or_expr(call_expr.or_block, ret_type)
			}
			// remove optional flag
			return ret_type.set_flag(.unset)
		} else if call_expr.or_block.kind == .block {
			c.error('unexpected `or` block, the function `$call_expr.name` does not return an optional',
				call_expr.pos)
		} else if call_expr.or_block.kind == .propagate {
			c.error('unexpected `?`, the function `$call_expr.name`, does not return an optional',
				call_expr.pos)
		}
	}
	return ret_type
}

pub fn (mut c Checker) check_or_expr(mut or_expr ast.OrExpr, ret_type table.Type) {
	if or_expr.kind == .propagate {
		if !c.cur_fn.return_type.flag_is(.optional) && c.cur_fn.name != 'main' {
			c.error('to propagate the optional call, `${c.cur_fn.name}` must itself return an optional',
				or_expr.pos)
		}
		return
	}
	stmts_len := or_expr.stmts.len
	if stmts_len == 0 {
		if ret_type != table.void_type {
			// x := f() or {}
			c.error('assignment requires a non empty `or {}` block', or_expr.pos)
			return
		}
		// allow `f() or {}`
		return
	}
	last_stmt := or_expr.stmts[stmts_len - 1]
	if ret_type != table.void_type {
		if !(last_stmt is ast.Return || last_stmt is ast.BranchStmt || last_stmt is ast.ExprStmt) {
			expected_type_name := c.table.get_type_symbol(ret_type).name
			c.error('last statement in the `or {}` block should return `$expected_type_name`',
				or_expr.pos)
			return
		}
		match last_stmt {
			ast.ExprStmt {
				it.typ = c.expr(it.expr)
				type_fits := c.check_types(it.typ, ret_type)
				is_panic_or_exit := is_expr_panic_or_exit(it.expr)
				if type_fits || is_panic_or_exit {
					return
				}
				type_name := c.table.get_type_symbol(it.typ).name
				expected_type_name := c.table.get_type_symbol(ret_type).name
				c.error('wrong return type `$type_name` in the `or {}` block, expected `$expected_type_name`',
					it.pos)
				return
			}
			ast.BranchStmt {
				if it.tok.kind !in [.key_continue, .key_break] {
					c.error('only break/continue is allowed as a branch statement in the end of an `or {}` block',
						it.tok.position())
					return
				}
			}
			else {}
		}
		return
	}
}

fn is_expr_panic_or_exit(expr ast.Expr) bool {
	match expr {
		ast.CallExpr { return it.name in ['panic', 'exit'] }
		else { return false }
	}
}

pub fn (mut c Checker) selector_expr(mut selector_expr ast.SelectorExpr) table.Type {
	typ := c.expr(selector_expr.expr)
	if typ == table.void_type_idx {
		c.error('unknown selector expression', selector_expr.pos)
		return table.void_type
	}
	selector_expr.expr_type = typ
	// println('sel expr line_nr=$selector_expr.pos.line_nr typ=$selector_expr.expr_type')
	typ_sym := c.table.get_type_symbol(typ)
	field_name := selector_expr.field_name
	// variadic
	if typ.flag_is(.variadic) {
		if field_name == 'len' {
			return table.int_type
		}
	}
	if field := c.table.struct_find_field(typ_sym, field_name) {
		if typ_sym.mod != c.mod && !field.is_pub {
			c.error('field `${typ_sym.name}.$field_name` is not public', selector_expr.pos)
		}
		return field.typ
	}
	if typ_sym.kind != .struct_ {
		c.error('`$typ_sym.name` is not a struct', selector_expr.pos)
	} else {
		c.error('unknown field `${typ_sym.name}.$field_name`', selector_expr.pos)
	}
	return table.void_type
}

// TODO: non deferred
pub fn (mut c Checker) return_stmt(mut return_stmt ast.Return) {
	c.expected_type = c.cur_fn.return_type
	if return_stmt.exprs.len > 0 && c.expected_type == table.void_type {
		c.error('too many arguments to return, current function does not return anything',
			return_stmt.pos)
		return
	} else if return_stmt.exprs.len == 0 && c.expected_type != table.void_type {
		c.error('too few arguments to return', return_stmt.pos)
		return
	}
	if return_stmt.exprs.len == 0 {
		return
	}
	expected_type := c.expected_type
	expected_type_sym := c.table.get_type_symbol(expected_type)
	exp_is_optional := expected_type.flag_is(.optional)
	mut expected_types := [expected_type]
	if expected_type_sym.kind == .multi_return {
		mr_info := expected_type_sym.info as table.MultiReturn
		expected_types = mr_info.types
	}
	mut got_types := []table.Type{}
	for expr in return_stmt.exprs {
		typ := c.expr(expr)
		got_types << typ
	}
	return_stmt.types = got_types
	// allow `none` & `error (Option)` return types for function that returns optional
	if exp_is_optional && got_types[0].idx() in [table.none_type_idx, c.table.type_idxs['Option']] {
		return
	}
	if expected_types.len > 0 && expected_types.len != got_types.len {
		// c.error('wrong number of return arguments:\n\texpected: $expected_table.str()\n\tgot: $got_types.str()', return_stmt.pos)
		c.error('wrong number of return arguments', return_stmt.pos)
	}
	for i, exp_type in expected_types {
		got_typ := got_types[i]
		is_generic := exp_type == table.t_type
		ok := if is_generic { c.check_types(got_typ, c.cur_generic_type) || got_typ == exp_type } else { c.check_types(got_typ,
				exp_type) }
		// ok := c.check_types(got_typ, exp_type)
		if !ok { // !c.table.check(got_typ, exp_typ) {
			got_typ_sym := c.table.get_type_symbol(got_typ)
			mut exp_typ_sym := c.table.get_type_symbol(exp_type)
			pos := return_stmt.exprs[i].position()
			if is_generic {
				exp_typ_sym = c.table.get_type_symbol(c.cur_generic_type)
			}
			c.error('cannot use `$got_typ_sym.name` as type `$exp_typ_sym.name` in return argument',
				pos)
		}
	}
}

pub fn (mut c Checker) enum_decl(decl ast.EnumDecl) {
	c.check_valid_pascal_case(decl.name, 'enum name', decl.pos)
	for i, field in decl.fields {
		if util.contains_capital(field.name) {
			c.error('field name `$field.name` cannot contain uppercase letters, use snake_case instead',
				field.pos)
		}
		for j in 0 .. i {
			if field.name == decl.fields[j].name {
				c.error('field name `$field.name` duplicate', field.pos)
			}
		}
		if field.has_expr {
			match field.expr {
				ast.IntegerLiteral {}
				ast.PrefixExpr {}
				else {
					if field.expr is ast.Ident {
						expr := field.expr as ast.Ident
						if expr.language == .c {
							continue
						}
					}
					mut pos := field.expr.position()
					if pos.pos == 0 {
						pos = field.pos
					}
					c.error('default value for enum has to be an integer', pos)
				}
			}
		}
	}
}

pub fn (mut c Checker) assign_stmt(mut assign_stmt ast.AssignStmt) {
	c.expected_type = table.none_type // TODO a hack to make `x := if ... work`
	right_first := assign_stmt.right[0]
	mut right_len := assign_stmt.right.len
	if right_first is ast.CallExpr || right_first is ast.IfExpr || right_first is ast.MatchExpr {
		right_type0 := c.expr(assign_stmt.right[0])
		assign_stmt.right_types = [right_type0]
		right_type_sym0 := c.table.get_type_symbol(right_type0)
		if right_type0 == table.void_type {
			right_len = 0
		} else if right_type_sym0.kind == .multi_return {
			assign_stmt.right_types = right_type_sym0.mr_info().types
			right_len = assign_stmt.right_types.len
		}
		if assign_stmt.left.len != right_len {
			if right_first is ast.CallExpr {
				call_expr := assign_stmt.right[0] as ast.CallExpr
				c.error('assignment mismatch: $assign_stmt.left.len variable(s) but `${call_expr.name}()` returns $right_len value(s)',
					assign_stmt.pos)
				return
			} else {
				c.error('assignment mismatch: $assign_stmt.left.len variable(s) $right_len value(s)',
					assign_stmt.pos)
				return
			}
		}
	} else if assign_stmt.left.len != right_len {
		c.error('assignment mismatch: $assign_stmt.left.len variable(s) $assign_stmt.right.len value(s)',
			assign_stmt.pos)
		return
	}
	mut scope := c.file.scope.innermost(assign_stmt.pos.pos)
	for i, _ in assign_stmt.left {
		mut ident := assign_stmt.left[i]
		if assign_stmt.right_types.len < right_len {
			right_type := c.expr(assign_stmt.right[i])
			assign_stmt.right_types << c.check_expr_opt_call(assign_stmt.right[i], right_type)
		} else if i < assign_stmt.right.len { // only once for multi return
			c.check_expr_opt_call(assign_stmt.right[i], assign_stmt.right_types[i])
		}
		val_type := assign_stmt.right_types[i]
		// check variable name for beginning with capital letter 'Abc'
		is_decl := assign_stmt.op == .decl_assign
		if is_decl && ident.name != '_' {
			c.check_valid_snake_case(ident.name, 'variable name', ident.pos)
		}
		mut ident_var_info := ident.var_info()
		if assign_stmt.op == .assign {
			c.fail_if_immutable(ident)
			var_type := c.expr(ident)
			assign_stmt.left_types << var_type
			if !c.check_types(val_type, var_type) {
				val_type_sym := c.table.get_type_symbol(val_type)
				var_type_sym := c.table.get_type_symbol(var_type)
				c.error('assign stmt: cannot use `$val_type_sym.name` as `$var_type_sym.name`',
					assign_stmt.pos)
			}
		}
		ident_var_info.typ = val_type
		ident.info = ident_var_info
		assign_stmt.left[i] = ident
		scope.update_var_type(ident.name, val_type)
	}
	c.expected_type = table.void_type
}

pub fn (mut c Checker) array_init(mut array_init ast.ArrayInit) table.Type {
	// println('checker: array init $array_init.pos.line_nr $c.file.path')
	mut elem_type := table.void_type
	// []string - was set in parser
	if array_init.typ != table.void_type {
		if array_init.exprs.len == 0 {
			if array_init.has_cap {
				if c.expr(array_init.cap_expr) != table.int_type {
					c.error('array cap needs to be an int', array_init.pos)
				}
			}
			if array_init.has_len {
				if c.expr(array_init.len_expr) != table.int_type {
					c.error('array len needs to be an int', array_init.pos)
				}
			}
		}
		return array_init.typ
	}
	// a = []
	if array_init.exprs.len == 0 {
		if array_init.has_cap {
			if c.expr(array_init.cap_expr) != table.int_type {
				c.error('array cap needs to be an int', array_init.pos)
			}
		}
		if array_init.has_len {
			if c.expr(array_init.len_expr) != table.int_type {
				c.error('array len needs to be an int', array_init.pos)
			}
		}
		type_sym := c.table.get_type_symbol(c.expected_type)
		if type_sym.kind != .array {
			c.error('array_init: no type specified (maybe: `[]Type{}` instead of `[]`)', array_init.pos)
			return table.void_type
		}
		// TODO: seperate errors once bug is fixed with `x := if expr { ... } else { ... }`
		// if c.expected_type == table.void_type {
		// c.error('array_init: use `[]Type{}` instead of `[]`', array_init.pos)
		// return table.void_type
		// }
		array_info := type_sym.array_info()
		array_init.elem_type = array_info.elem_type
		return c.expected_type
	}
	// [1,2,3]
	if array_init.exprs.len > 0 && array_init.elem_type == table.void_type {
		mut expected_value_type := table.void_type
		mut expecting_interface_array := false
		cap := array_init.exprs.len
		mut interface_types := []table.Type{cap: cap}
		if c.expected_type != 0 {
			expected_value_type = c.table.value_type(c.expected_type)
			if c.table.get_type_symbol(expected_value_type).kind == .interface_ {
				// Array of interfaces? (`[dog, cat]`) Save the interface type (`Animal`)
				expecting_interface_array = true
				array_init.interface_type = expected_value_type
				array_init.is_interface = true
			}
		}
		// expecting_interface_array := c.expected_type != 0 &&
		// c.table.get_type_symbol(c.table.value_type(c.expected_type)).kind ==			.interface_
		//
		// if expecting_interface_array {
		// println('ex $c.expected_type')
		// }
		for i, expr in array_init.exprs {
			typ := c.expr(expr)
			if expecting_interface_array {
				if i == 0 {
					elem_type = expected_value_type
					c.expected_type = elem_type
				}
				interface_types << typ
				continue
			}
			// The first element's type
			if i == 0 {
				elem_type = typ
				c.expected_type = typ
				continue
			}
			if !c.check_types(elem_type, typ) {
				elem_type_sym := c.table.get_type_symbol(elem_type)
				c.error('expected array element with type `$elem_type_sym.name`', array_init.pos)
			}
		}
		if expecting_interface_array {
			array_init.interface_types = interface_types
		}
		if array_init.is_fixed {
			idx := c.table.find_or_register_array_fixed(elem_type, array_init.exprs.len, 1)
			array_init.typ = table.new_type(idx)
		} else {
			idx := c.table.find_or_register_array(elem_type, 1)
			array_init.typ = table.new_type(idx)
		}
		array_init.elem_type = elem_type
	} else if array_init.is_fixed && array_init.exprs.len == 1 && array_init.elem_type != table.void_type {
		// [50]byte
		mut fixed_size := 1
		match array_init.exprs[0] {
			ast.IntegerLiteral {
				fixed_size = it.val.int()
			}
			ast.Ident {
				// if obj := c.file.global_scope.find_const(it.name) {
				// if  obj := scope.find(it.name) {
				// scope := c.file.scope.innermost(array_init.pos.pos)
				// eprintln('scope: ${scope.str()}')
				// scope.find(it.name) or {
				// c.error('undefined: `$it.name`', array_init.pos)
				// }
				mut full_const_name := if it.mod == 'main' { it.name } else { it.mod + '.' +
						it.name }
				if obj := c.file.global_scope.find_const(full_const_name) {
					if cint := const_int_value(obj) {
						fixed_size = cint
					}
				} else {
					c.error('non existant integer const $full_const_name while initializing the size of a static array',
						array_init.pos)
				}
			}
			else {
				c.error('expecting `int` for fixed size', array_init.pos)
			}
		}
		idx := c.table.find_or_register_array_fixed(array_init.elem_type, fixed_size, 1)
		array_type := table.new_type(idx)
		array_init.typ = array_type
	}
	return array_init.typ
}

fn const_int_value(cfield ast.ConstField) ?int {
	if cint := is_const_integer(cfield) {
		return cint.val.int()
	}
	return none
}

fn is_const_integer(cfield ast.ConstField) ?ast.IntegerLiteral {
	match cfield.expr {
		ast.IntegerLiteral { return it }
		else {}
	}
	return none
}

fn (mut c Checker) stmt(node ast.Stmt) {
	// c.expected_type = table.void_type
	match mut node {
		ast.AssertStmt {
			assert_type := c.expr(it.expr)
			if assert_type != table.bool_type_idx {
				atype_name := c.table.get_type_symbol(assert_type).name
				c.error('assert can be used only with `bool` expressions, but found `${atype_name}` instead',
					it.pos)
			}
		}
		// ast.Attr {}
		ast.AssignStmt {
			c.assign_stmt(mut it)
		}
		ast.Block {
			c.stmts(it.stmts)
		}
		ast.BranchStmt {
			if c.in_for_count == 0 {
				c.error('$it.tok.lit statement not within a loop', it.tok.position())
			}
		}
		ast.CompIf {
			// c.expr(it.cond)
			c.stmts(it.stmts)
			if it.has_else {
				c.stmts(it.else_stmts)
			}
		}
		ast.ConstDecl {
			mut field_names := []string{}
			mut field_order := []int{}
			for i, field in it.fields {
				// TODO Check const name once the syntax is decided
				if field.name in c.const_names {
					c.error('field name `$field.name` duplicate', field.pos)
				}
				c.const_names << field.name
				field_names << field.name
				field_order << i
			}
			mut needs_order := false
			mut done_fields := []int{}
			for i, field in it.fields {
				c.const_decl = field.name
				c.const_deps << field.name
				typ := c.expr(field.expr)
				it.fields[i].typ = typ
				for cd in c.const_deps {
					for j, f in it.fields {
						if j != i && cd in field_names && cd == f.name && j !in done_fields {
							needs_order = true
							x := field_order[j]
							field_order[j] = field_order[i]
							field_order[i] = x
							break
						}
					}
				}
				done_fields << i
				c.const_deps = []
			}
			if needs_order {
				mut ordered_fields := []ast.ConstField{}
				for order in field_order {
					ordered_fields << it.fields[order]
				}
				it.fields = ordered_fields
			}
		}
		ast.DeferStmt {
			c.stmts(it.stmts)
		}
		ast.EnumDecl {
			c.enum_decl(it)
		}
		ast.ExprStmt {
			it.typ = c.expr(it.expr)
			c.expected_type = table.void_type
			c.check_expr_opt_call(it.expr, table.void_type)
			// TODO This should work, even if it's prolly useless .-.
			// it.typ = c.check_expr_opt_call(it.expr, table.void_type)
		}
		ast.FnDecl {
			c.fn_decl(it)
		}
		ast.ForCStmt {
			c.in_for_count++
			c.stmt(it.init)
			c.expr(it.cond)
			// c.stmt(it.inc)
			c.expr(it.inc)
			c.stmts(it.stmts)
			c.in_for_count--
		}
		ast.ForInStmt {
			c.in_for_count++
			typ := c.expr(it.cond)
			typ_idx := typ.idx()
			if it.is_range {
				high_type_idx := c.expr(it.high).idx()
				if typ_idx in table.integer_type_idxs && high_type_idx !in table.integer_type_idxs {
					c.error('range types do not match', it.cond.position())
				} else if typ_idx in table.float_type_idxs || high_type_idx in table.float_type_idxs {
					c.error('range type can not be float', it.cond.position())
				} else if typ_idx == table.bool_type_idx || high_type_idx == table.bool_type_idx {
					c.error('range type can not be bool', it.cond.position())
				} else if typ_idx == table.string_type_idx || high_type_idx == table.string_type_idx {
					c.error('range type can not be string', it.cond.position())
				}
				c.expr(it.high)
			} else {
				mut scope := c.file.scope.innermost(it.pos.pos)
				sym := c.table.get_type_symbol(typ)
				if sym.kind == .map && !(it.key_var.len > 0 && it.val_var.len > 0) {
					c.error('declare a key and a value variable when ranging a map: `for key, val in map {`\n' +
						'use `_` if you do not need the variable', it.pos)
				}
				if it.key_var.len > 0 {
					key_type := match sym.kind {
						.map { sym.map_info().key_type }
						else { table.int_type }
					}
					it.key_type = key_type
					scope.update_var_type(it.key_var, key_type)
				}
				value_type := c.table.value_type(typ)
				if value_type == table.void_type {
					typ_sym := c.table.get_type_symbol(typ)
					c.error('for in: cannot index `$typ_sym.name`', it.cond.position())
				}
				it.cond_type = typ
				it.kind = sym.kind
				it.val_type = value_type
				scope.update_var_type(it.val_var, value_type)
			}
			c.stmts(it.stmts)
			c.in_for_count--
		}
		ast.ForStmt {
			c.in_for_count++
			typ := c.expr(it.cond)
			if !it.is_inf && typ.idx() != table.bool_type_idx {
				c.error('non-bool used as for condition', it.pos)
			}
			// TODO: update loop var type
			// how does this work currenly?
			c.stmts(it.stmts)
			c.in_for_count--
		}
		ast.GlobalDecl {
			c.check_valid_snake_case(it.name, 'global name', it.pos)
		}
		ast.GoStmt {
			if !(it.call_expr is ast.CallExpr) {
				c.error('expression in `go` must be a function call', it.call_expr.position())
			}
			c.expr(it.call_expr)
		}
		// ast.HashStmt {}
		ast.Import {}
		ast.InterfaceDecl {
			c.interface_decl(it)
		}
		ast.Module {
			c.mod = it.name
			c.is_builtin_mod = it.name == 'builtin'
			c.check_valid_snake_case(it.name, 'module name', it.pos)
		}
		ast.Return {
			c.returns = true
			c.return_stmt(mut it)
			c.scope_returns = true
		}
		ast.StructDecl {
			c.struct_decl(it)
		}
		ast.TypeDecl {
			c.type_decl(it)
		}
		ast.UnsafeStmt {
			c.inside_unsafe = true
			c.stmts(it.stmts)
			c.inside_unsafe = false
		}
		else {
			// println('checker.stmt(): unhandled node')
			// println('checker.stmt(): unhandled node (${typeof(node)})')
		}
	}
}

fn (mut c Checker) stmts(stmts []ast.Stmt) {
	mut unreachable := token.Position{
		line_nr: -1
	}
	c.expected_type = table.void_type
	for stmt in stmts {
		if c.scope_returns {
			if unreachable.line_nr == -1 {
				unreachable = stmt.position()
			}
		}
		c.stmt(stmt)
	}
	if unreachable.line_nr >= 0 {
		c.warn('unreachable code', unreachable)
	}
	c.scope_returns = false
	c.expected_type = table.void_type
}

pub fn (mut c Checker) unwrap_generic(typ table.Type) table.Type {
	if typ == table.t_type {
		return c.cur_generic_type
	}
	return typ
}

// TODO node must be mut
pub fn (mut c Checker) expr(node ast.Expr) table.Type {
	match mut node {
		ast.AnonFn {
			keep_fn := c.cur_fn
			c.cur_fn = &it.decl
			c.stmts(it.decl.stmts)
			c.cur_fn = keep_fn
			return it.typ
		}
		ast.ArrayInit {
			return c.array_init(mut it)
		}
		ast.AsCast {
			it.expr_type = c.expr(it.expr)
			expr_type_sym := c.table.get_type_symbol(it.expr_type)
			type_sym := c.table.get_type_symbol(it.typ)
			if expr_type_sym.kind == .sum_type {
				info := expr_type_sym.info as table.SumType
				if it.typ !in info.variants {
					c.error('cannot cast `$expr_type_sym.name` to `$type_sym.name`', it.pos)
					// c.error('only $info.variants can be casted to `$typ`', it.pos)
				}
			} else {
				//
				c.error('cannot cast non sum type `$type_sym.name` using `as`', it.pos)
			}
			return it.typ.to_ptr()
			// return it.typ
		}
		ast.AssignExpr {
			c.assign_expr(mut it)
		}
		ast.Assoc {
			scope := c.file.scope.innermost(it.pos.pos)
			v := scope.find_var(it.var_name) or {
				panic(err)
			}
			for i, _ in it.fields {
				c.expr(it.exprs[i])
			}
			it.typ = v.typ
			return v.typ
		}
		ast.BoolLiteral {
			return table.bool_type
		}
		ast.CastExpr {
			it.expr_type = c.expr(it.expr)
			sym := c.table.get_type_symbol(it.expr_type)
			if it.typ == table.string_type && !(sym.kind in [.byte, .byteptr] || sym.kind ==
				.array && sym.name == 'array_byte') {
				type_name := c.table.type_to_str(it.expr_type)
				c.error('cannot cast type `$type_name` to string, use `x.str()` instead', it.pos)
			}
			if it.expr_type == table.string_type {
				mut error_msg := 'cannot cast a string'
				if it.expr is ast.StringLiteral {
					str_lit := it.expr as ast.StringLiteral
					if str_lit.val.len == 1 {
						error_msg += ", for denoting characters use `$str_lit.val` instead of '$str_lit.val'"
					}
				}
				c.error(error_msg, it.pos)
			}
			if it.has_arg {
				c.expr(it.arg)
			}
			it.typname = c.table.get_type_symbol(it.typ).name
			return it.typ
		}
		ast.CallExpr {
			return c.call_expr(mut it)
		}
		ast.CharLiteral {
			return table.byte_type
		}
		ast.ConcatExpr {
			return c.concat_expr(mut it)
		}
		ast.EnumVal {
			return c.enum_val(mut it)
		}
		ast.FloatLiteral {
			return table.f64_type
		}
		ast.Ident {
			// c.checked_ident = it.name
			res := c.ident(mut it)
			// c.checked_ident = ''
			return res
		}
		ast.IfExpr {
			return c.if_expr(mut it)
		}
		ast.IfGuardExpr {
			it.expr_type = c.expr(it.expr)
			return table.bool_type
		}
		ast.IndexExpr {
			return c.index_expr(mut it)
		}
		ast.InfixExpr {
			return c.infix_expr(mut it)
		}
		ast.IntegerLiteral {
			return table.int_type
		}
		ast.MapInit {
			return c.map_init(mut it)
		}
		ast.MatchExpr {
			return c.match_expr(mut it)
		}
		ast.PostfixExpr {
			return c.postfix_expr(it)
		}
		ast.PrefixExpr {
			right_type := c.expr(it.right)
			// TODO: testing ref/deref strategy
			if it.op == .amp && !right_type.is_ptr() {
				return right_type.to_ptr()
			}
			if it.op == .mul && right_type.is_ptr() {
				return right_type.deref()
			}
			if it.op == .not && right_type != table.bool_type_idx {
				c.error('! operator can only be used with bool types', it.pos)
			}
			return right_type
		}
		ast.None {
			return table.none_type
		}
		ast.ParExpr {
			return c.expr(it.expr)
		}
		ast.SelectorExpr {
			return c.selector_expr(mut it)
		}
		ast.SizeOf {
			return table.int_type
		}
		ast.StringLiteral {
			if it.language == .c {
				return table.byteptr_type
			}
			return table.string_type
		}
		ast.StringInterLiteral {
			for expr in it.exprs {
				it.expr_types << c.expr(expr)
			}
			return table.string_type
		}
		ast.StructInit {
			return c.struct_init(mut it)
		}
		ast.Type {
			return it.typ
		}
		ast.TypeOf {
			it.expr_type = c.expr(it.expr)
			return table.string_type
		}
		else {
			tnode := typeof(node)
			if tnode != 'unknown v.ast.Expr' {
				println('checker.expr(): unhandled node with typeof(`${tnode}`)')
			}
		}
	}
	return table.void_type
}

pub fn (mut c Checker) ident(mut ident ast.Ident) table.Type {
	// TODO: move this
	if c.const_deps.len > 0 {
		mut name := ident.name
		if !name.contains('.') && ident.mod !in ['builtin', 'main'] {
			name = '${ident.mod}.$ident.name'
		}
		if name == c.const_decl {
			c.error('cycle in constant `$c.const_decl`', ident.pos)
			return table.void_type
		}
		c.const_deps << name
	}
	if ident.kind == .blank_ident {
		return table.void_type
	}
	// second use
	if ident.kind == .variable {
		info := ident.info as ast.IdentVar
		if info.typ == table.t_type {
			// Got a var with type T, return current generic type
			// return c.cur_generic_type
		}
		return info.typ
	} else if ident.kind == .constant {
		info := ident.info as ast.IdentVar
		return info.typ
	} else if ident.kind == .function {
		info := ident.info as ast.IdentFn
		return info.typ
	} else if ident.kind == .unresolved {
		// first use
		start_scope := c.file.scope.innermost(ident.pos.pos)
		if obj := start_scope.find(ident.name) {
			match obj {
				ast.Var {
					mut typ := it.typ
					if typ == 0 {
						if it.expr is ast.Ident {
							inner_ident := it.expr as ast.Ident
							if inner_ident.kind == .unresolved {
								c.error('unresolved variable: `$ident.name`', ident.pos)
								return table.void_type
							}
						}
						typ = c.expr(it.expr)
					}
					is_optional := typ.flag_is(.optional)
					ident.kind = .variable
					ident.info = ast.IdentVar{
						typ: typ
						is_optional: is_optional
					}
					// if typ == table.t_type {
					// sym := c.table.get_type_symbol(c.cur_generic_type)
					// println('IDENT T unresolved $ident.name typ=$sym.name')
					// Got a var with type T, return current generic type
					// typ = c.cur_generic_type
					// }
					// } else {
					it.typ = typ
					// unwrap optional (`println(x)`)
					if is_optional {
						return typ.set_flag(.unset)
					}
					return typ
				}
				else {}
			}
		}
		// prepend mod to look for fn call or const
		mut name := ident.name
		if !name.contains('.') && ident.mod !in ['builtin', 'main'] {
			name = '${ident.mod}.$ident.name'
		}
		if obj := c.file.global_scope.find(name) {
			match obj {
				ast.GlobalDecl {
					ident.kind = .global
					ident.info = ast.IdentVar{
						typ: it.typ
					}
					return it.typ
				}
				ast.ConstField {
					mut typ := it.typ
					if typ == 0 {
						typ = c.expr(it.expr)
					}
					ident.name = name
					ident.kind = .constant
					ident.info = ast.IdentVar{
						typ: typ
					}
					it.typ = typ
					return typ
				}
				else {}
			}
		}
		// Non-anon-function object (not a call), e.g. `onclick(my_click)`
		if func := c.table.find_fn(name) {
			fn_type := table.new_type(c.table.find_or_register_fn_type(ident.mod, func, false,
				true))
			ident.name = name
			ident.kind = .function
			ident.info = ast.IdentFn{
				typ: fn_type
			}
			return fn_type
		}
	}
	if ident.language == .c {
		return table.int_type
	}
	if ident.name != '_' {
		c.error('undefined: `$ident.name`', ident.pos)
	}
	if c.table.known_type(ident.name) {
		// e.g. `User`  in `json.decode(User, '...')`
		return table.void_type
	}
	return table.void_type
}

pub fn (mut c Checker) concat_expr(mut concat_expr ast.ConcatExpr) table.Type {
	mut mr_types := []table.Type{}
	for expr in concat_expr.vals {
		mr_types << c.expr(expr)
	}
	if concat_expr.vals.len == 1 {
		typ := mr_types[0]
		concat_expr.return_type = typ
		return typ
	} else {
		typ := c.table.find_or_register_multi_return(mr_types)
		table.new_type(typ)
		concat_expr.return_type = typ
		return typ
	}
}

pub fn (mut c Checker) match_expr(mut node ast.MatchExpr) table.Type {
	node.is_expr = c.expected_type != table.void_type
	node.expected_type = c.expected_type
	cond_type := c.expr(node.cond)
	if cond_type == 0 {
		c.error('match 0 cond type', node.pos)
	}
	type_sym := c.table.get_type_symbol(cond_type)
	if type_sym.kind != .sum_type {
		node.is_sum_type = false
	}
	c.match_exprs(mut node, type_sym)
	c.expected_type = cond_type
	mut ret_type := table.void_type
	for branch in node.branches {
		for expr in branch.exprs {
			c.expected_type = cond_type
			typ := c.expr(expr)
			typ_sym := c.table.get_type_symbol(typ)
			if !node.is_sum_type && !c.check_types(typ, cond_type) {
				exp_sym := c.table.get_type_symbol(cond_type)
				c.error('cannot use `$typ_sym.name` as `$exp_sym.name` in `match`', node.pos)
			}
			// TODO:
			if typ_sym.kind == .sum_type {
			}
		}
		c.stmts(branch.stmts)
		// If the last statement is an expression, return its type
		if branch.stmts.len > 0 {
			match branch.stmts[branch.stmts.len - 1] {
				ast.ExprStmt {
					ret_type = c.expr(it.expr)
					it.typ = ret_type
				}
				else {
					// TODO: ask alex about this
					// typ := c.expr(it.expr)
					// type_sym := c.table.get_type_symbol(typ)
					// p.warn('match expr ret $type_sym.name')
					// node.typ = typ
					// return typ
				}
			}
		}
	}
	// if ret_type != table.void_type {
	// node.is_expr = c.expected_type != table.void_type
	// node.expected_type = c.expected_type
	// }
	node.return_type = ret_type
	node.cond_type = cond_type
	// println('!m $expr_type')
	return ret_type
}

fn (mut c Checker) match_exprs(mut node ast.MatchExpr, type_sym table.TypeSymbol) {
	// branch_exprs is a histogram of how many times
	// an expr was used in the match
	mut branch_exprs := map[string]int{}
	for branch in node.branches {
		for expr in branch.exprs {
			mut key := ''
			match expr {
				ast.Type { key = c.table.type_to_str(it.typ) }
				ast.EnumVal { key = it.val }
				else { key = expr.str() }
			}
			val := if key in branch_exprs { branch_exprs[key] } else { 0 }
			if val == 1 {
				c.error('match case `$key` is handled more than once', branch.pos)
			}
			branch_exprs[key] = val + 1
		}
	}
	// check that expressions are exhaustive
	// this is achieved either by putting an else
	// or, when the match is on a sum type or an enum
	// by listing all variants or values
	mut is_exhaustive := true
	mut unhandled := []string{}
	match type_sym.info {
		table.SumType { for v in it.variants {
				v_str := c.table.type_to_str(v)
				if v_str !in branch_exprs {
					is_exhaustive = false
					unhandled << '`$v_str`'
				}
			} }
		table.Enum { for v in it.vals {
				if v !in branch_exprs {
					is_exhaustive = false
					unhandled << '`.$v`'
				}
			} }
		else { is_exhaustive = false }
	}
	mut else_branch := node.branches[node.branches.len - 1]
	mut has_else := else_branch.is_else
	if !has_else {
		for i, branch in node.branches {
			if branch.is_else && i != node.branches.len - 1 {
				c.error('`else` must be the last branch of `match`', branch.pos)
				else_branch = branch
				has_else = true
			}
		}
	}
	if is_exhaustive {
		if has_else {
			c.error('match expression is exhaustive, `else` is unnecessary', else_branch.pos)
		}
		return
	}
	if has_else {
		return
	}
	mut err_details := 'match must be exhaustive'
	if unhandled.len > 0 {
		err_details += ' (add match branches for: ' + unhandled.join(', ') + ' or `else {}` at the end)'
	} else {
		err_details += ' (add `else {}` at the end)'
	}
	c.error(err_details, node.pos)
}

pub fn (mut c Checker) if_expr(mut node ast.IfExpr) table.Type {
	mut expr_required := false
	if c.expected_type != table.void_type {
		// sym := c.table.get_type_symbol(c.expected_type)
		// println('$c.file.path  $node.pos.line_nr IF is expr: checker exp type = ' + sym.name)
		expr_required = true
	}
	former_expected_type := c.expected_type
	node.typ = table.void_type
	for i, branch in node.branches {
		if branch.cond is ast.ParExpr {
			c.error('unnecessary `()` in an if condition. use `if expr {` instead of `if (expr) {`.',
				branch.pos)
		}
		if !node.has_else || i < node.branches.len - 1 {
			// check condition type is boolean
			cond_typ := c.expr(branch.cond)
			if cond_typ.idx() != table.bool_type_idx {
				typ_sym := c.table.get_type_symbol(cond_typ)
				c.error('non-bool type `$typ_sym.name` used as if condition', branch.pos)
			}
		}
		c.stmts(branch.stmts)
		if expr_required {
			if branch.stmts.len > 0 && branch.stmts[branch.stmts.len - 1] is ast.ExprStmt {
				last_expr := branch.stmts[branch.stmts.len - 1] as ast.ExprStmt
				c.expected_type = former_expected_type
				last_expr.typ = c.expr(last_expr.expr)
				if last_expr.typ != node.typ {
					if node.typ == table.void_type {
						// first branch of if expression
						node.is_expr = true
						node.typ = last_expr.typ
					} else {
						c.error('mismatched types `${c.table.type_to_str(node.typ)}` and `${c.table.type_to_str(last_expr.typ)}`',
							node.pos)
					}
				}
			} else {
				c.error('`if` expression requires an expression as the last statement of every branch',
					branch.pos)
			}
		}
	}
	if expr_required {
		if !node.has_else {
			c.error('`if` expression needs `else` clause', node.pos)
		}
		return node.typ
	}
	return table.bool_type
}

pub fn (mut c Checker) postfix_expr(node ast.PostfixExpr) table.Type {
	typ := c.expr(node.expr)
	typ_sym := c.table.get_type_symbol(typ)
	// if !typ.is_number() {
	if !typ_sym.is_number() {
		println(typ_sym.kind.str())
		c.error('invalid operation: $node.op.str() (non-numeric type `$typ_sym.name`)', node.pos)
	} else {
		c.fail_if_immutable(node.expr)
	}
	return typ
}

pub fn (mut c Checker) index_expr(mut node ast.IndexExpr) table.Type {
	typ := c.expr(node.left)
	node.left_type = typ
	mut is_range := false // TODO is_range := node.index is ast.RangeExpr
	match node.index {
		ast.RangeExpr {
			is_range = true
			if it.has_low {
				c.expr(it.low)
			}
			if it.has_high {
				c.expr(it.high)
			}
		}
		else {}
	}
	typ_sym := c.table.get_type_symbol(typ)
	if !is_range {
		index_type := c.expr(node.index)
		index_type_sym := c.table.get_type_symbol(index_type)
		// println('index expr left=$typ_sym.name $node.pos.line_nr')
		// if typ_sym.kind == .array && (!(table.type_idx(index_type) in table.number_type_idxs) &&
		// index_type_sym.kind != .enum_) {
		if typ_sym.kind in [.array, .array_fixed] && !(index_type.is_number() || index_type_sym.kind ==
			.enum_) {
			c.error('non-integer index `$index_type_sym.name` (array type `$typ_sym.name`)',
				node.pos)
		} else if typ_sym.kind == .map && index_type.idx() != table.string_type_idx {
			c.error('non-string map index (map type `$typ_sym.name`)', node.pos)
		}
		value_type := c.table.value_type(typ)
		if value_type != table.void_type {
			return value_type
		}
	} else if is_range {
		// array[1..2] => array
		// fixed_array[1..2] => array
		if typ_sym.kind == .array_fixed {
			elem_type := c.table.value_type(typ)
			idx := c.table.find_or_register_array(elem_type, 1)
			return table.new_type(idx)
		}
	}
	return typ
}

// `.green` or `Color.green`
// If a short form is used, `expected_type` needs to be an enum
// with this value.
pub fn (mut c Checker) enum_val(mut node ast.EnumVal) table.Type {
	typ_idx := if node.enum_name == '' {
		c.expected_type.idx()
	} else { //
		c.table.find_type_idx(node.enum_name)
	}
	// println('checker: enum_val: $node.enum_name typeidx=$typ_idx')
	if typ_idx == 0 {
		c.error('not an enum (name=$node.enum_name) (type_idx=0)', node.pos)
		return table.void_type
	}
	typ := table.new_type(typ_idx)
	if typ == table.void_type {
		c.error('not an enum', node.pos)
		return table.void_type
	}
	typ_sym := c.table.get_type_symbol(typ)
	// println('tname=$typ_sym.name $node.pos.line_nr $c.file.path')
	if typ_sym.kind != .enum_ {
		c.error('not an enum', node.pos)
		return table.void_type
	}
	if !(typ_sym.info is table.Enum) {
		c.error('not an enum', node.pos)
		return table.void_type
	}
	// info := typ_sym.info as table.Enum
	info := typ_sym.enum_info()
	// rintln('checker: x = $info.x enum val $c.expected_type $typ_sym.name')
	// println(info.vals)
	if node.val !in info.vals {
		c.error('enum `$typ_sym.name` does not have a value `$node.val`', node.pos)
	}
	node.typ = typ
	return typ
}

pub fn (mut c Checker) map_init(mut node ast.MapInit) table.Type {
	// `x ;= map[string]string` - set in parser
	if node.typ != 0 {
		info := c.table.get_type_symbol(node.typ).map_info()
		node.key_type = info.key_type
		node.value_type = info.value_type
		return node.typ
	}
	// `{'age': 20}`
	key0_type := c.expr(node.keys[0])
	val0_type := c.expr(node.vals[0])
	for i, key in node.keys {
		key_i := key as ast.StringLiteral
		for j in 0 .. i {
			key_j := node.keys[j] as ast.StringLiteral
			if key_i.val == key_j.val {
				c.error('duplicate key "$key_i.val" in map literal', key.position())
			}
		}
		if i == 0 {
			continue
		}
		val := node.vals[i]
		key_type := c.expr(key)
		val_type := c.expr(val)
		if !c.check_types(key_type, key0_type) {
			key0_type_sym := c.table.get_type_symbol(key0_type)
			key_type_sym := c.table.get_type_symbol(key_type)
			c.error('map init: cannot use `$key_type_sym.name` as `$key0_type_sym.name` for map key',
				node.pos)
		}
		if !c.check_types(val_type, val0_type) {
			val0_type_sym := c.table.get_type_symbol(val0_type)
			val_type_sym := c.table.get_type_symbol(val_type)
			c.error('map init: cannot use `$val_type_sym.name` as `$val0_type_sym.name` for map value',
				node.pos)
		}
	}
	map_type := table.new_type(c.table.find_or_register_map(key0_type, val0_type))
	node.typ = map_type
	node.key_type = key0_type
	node.value_type = val0_type
	return map_type
}

pub fn (mut c Checker) warn(s string, pos token.Position) {
	allow_warnings := !c.pref.is_prod // allow warnings only in dev builds
	c.warn_or_error(s, pos, allow_warnings) // allow warnings only in dev builds
}

pub fn (mut c Checker) error(message string, pos token.Position) {
	if c.pref.is_verbose {
		print_backtrace()
	}
	c.warn_or_error(message, pos, false)
}

fn (mut c Checker) warn_or_error(message string, pos token.Position, warn bool) {
	// add backtrace to issue struct, how?
	// if c.pref.is_verbose {
	// print_backtrace()
	// }
	if warn && !c.pref.skip_warnings {
		c.nr_warnings++
		wrn := errors.Warning{
			reporter: errors.Reporter.checker
			pos: pos
			file_path: c.file.path
			message: message
		}
		c.file.warnings << wrn
		c.warnings << wrn
		return
	}
	if !warn {
		c.nr_errors++
		if pos.line_nr !in c.error_lines {
			err := errors.Error{
				reporter: errors.Reporter.checker
				pos: pos
				file_path: c.file.path
				message: message
			}
			c.file.errors << err
			c.errors << err
			c.error_lines << pos.line_nr
		}
	}
}

// for debugging only
fn (c &Checker) fileis(s string) bool {
	return c.file.path.contains(s)
}

fn (mut c Checker) fn_decl(it ast.FnDecl) {
	if it.is_generic && c.cur_generic_type == 0 { // need the cur_generic_type check to avoid inf. recursion
		// loop thru each generic type and generate a function
		for gen_type in c.table.fn_gen_types[it.name] {
			c.cur_generic_type = gen_type
			// println('\ncalling check for $it.name for type ' + gen_type.str())
			c.fn_decl(it)
		}
		c.cur_generic_type = 0
		return
	}
	if it.language == .v && !c.is_builtin_mod {
		c.check_valid_snake_case(it.name, 'function name', it.pos)
	}
	if it.is_method {
		sym := c.table.get_type_symbol(it.receiver.typ)
		if sym.kind == .interface_ {
			c.error('interfaces cannot be used as method receiver', it.receiver_pos)
		}
		// if sym.has_method(it.name) {
		// c.warn('duplicate method `$it.name`', it.pos)
		// }
	}
	if it.language == .v {
		// Make sure all types are valid
		for arg in it.args {
			sym := c.table.get_type_symbol(arg.typ)
			if sym.kind == .placeholder {
				c.error('unknown type `$sym.name`', it.pos)
			}
		}
	}
	c.expected_type = table.void_type
	c.cur_fn = &it
	c.stmts(it.stmts)
	if it.language == .v && !it.no_body && it.return_type != table.void_type && !c.returns &&
		it.name !in ['panic', 'exit'] {
		c.error('missing return at end of function `$it.name`', it.pos)
	}
	c.returns = false
}
import os
import term

fn test_all() {
	mut total_errors := 0
	vexe := os.getenv('VEXE')
	vroot := os.dir(vexe)
	os.chdir(vroot)
	classic_dir := 'vlib/v/checker/tests'
	classic_tests := get_tests_in_dir(classic_dir)
	global_dir := '$classic_dir/globals'
	global_tests := get_tests_in_dir(global_dir)
	run_dir := '$classic_dir/run'
	run_tests := get_tests_in_dir(run_dir)	
	// -prod so that warns are errors
	total_errors += check_path(vexe, classic_dir, '-prod', '.out', classic_tests)
	total_errors += check_path(vexe, global_dir, '--enable-globals', '.out', global_tests)
	total_errors += check_path(vexe, classic_dir, '--enable-globals run', '.run.out', ['globals_error.vv'])
	total_errors += check_path(vexe, run_dir,   'run', '.run.out', run_tests)
	assert total_errors == 0
}

fn get_tests_in_dir(dir string) []string {
	files := os.ls(dir) or {
		panic(err)
	}
	mut tests := files.filter(it.ends_with('.vv'))
	tests.sort()
	return tests
}

fn check_path(vexe, dir, voptions, result_extension string, tests []string) int {
	mut nb_fail := 0
	for test in tests {
		path := os.join_path(dir, test).replace('\\', '/')
		program := path.replace('.vv', '.v')
		print(path + ' ')
		os.cp(path, program) or {
			panic(err)
		}
		res := os.exec('$vexe $voptions $program') or {
			panic(err)
		}
		mut expected := os.read_file(program.replace('.v', '') + result_extension) or {
			panic(err)
		}
		expected = clean_line_endings(expected)
		found := clean_line_endings(res.output)
		if expected != found {
			println(term.red('FAIL'))
			println('============')
			println('expected:')
			println(expected)
			println('============')
			println('found:')
			println(found)
			println('============\n')
			nb_fail += 1
		} else {
			println(term.green('OK'))
			os.rm(program)
		}
	}
	return nb_fail
}

fn clean_line_endings(s string) string {
	return s.trim_space().replace(' \n', '\n').replace(' \r\n', '\n').replace('\r\n', '\n').trim('\n')
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module checker

import v.table

pub fn (c &Checker) check_types(got, expected table.Type) bool {
	t := c.table
	got_idx := got.idx()
	exp_idx := expected.idx()
	// got_is_ptr := got.is_ptr()
	exp_is_ptr := expected.is_ptr()
	// println('check: $got_type_sym.name, $exp_type_sym.name')
	// # NOTE: use idxs here, and symbols below for perf
	if got_idx == exp_idx {
		// this is returning true even if one type is a ptr
		// and the other is not, is this correct behaviour?
		return true
	}
	if got_idx == table.none_type_idx && expected.flag_is(.optional) {
		return true
	}
	// allow pointers to be initialized with 0. TODO: use none instead
	if exp_is_ptr && got_idx == table.int_type_idx {
		return true
	}
	if exp_idx == table.voidptr_type_idx || got_idx == table.voidptr_type_idx {
		return true
	}
	if exp_idx == table.any_type_idx || got_idx == table.any_type_idx {
		return true
	}
	// TODO i64 as int etc
	if (exp_idx in table.pointer_type_idxs || exp_idx in table.number_type_idxs) && (got_idx in
		table.pointer_type_idxs || got_idx in table.number_type_idxs) {
		return true
	}
	// if exp_idx in pointer_type_idxs && got_idx in pointer_type_idxs {
	// return true
	// }
	// see hack in checker IndexExpr line #691
	if (got_idx == table.byte_type_idx && exp_idx == table.byteptr_type_idx) || (exp_idx ==
		table.byte_type_idx && got_idx == table.byteptr_type_idx) {
		return true
	}
	if (got_idx == table.char_type_idx && exp_idx == table.charptr_type_idx) || (exp_idx ==
		table.char_type_idx && got_idx == table.charptr_type_idx) {
		return true
	}
	if expected == table.t_type && got == table.t_type {
		return true
	}
	// # NOTE: use symbols from this point on for perf
	got_type_sym := t.get_type_symbol(got)
	exp_type_sym := t.get_type_symbol(expected)
	//
	if exp_type_sym.kind == .function && got_type_sym.kind == .int {
		// TODO temporary
		// fn == 0
		return true
	}
	// allow enum value to be used as int
	if (got_type_sym.is_int() && exp_type_sym.kind == .enum_) || (exp_type_sym.is_int() &&
		got_type_sym.kind == .enum_) {
		return true
	}
	// TODO
	// if got_type_sym.kind == .array && exp_type_sym.kind == .array {
	// return true
	// }
	if got_type_sym.kind == .array_fixed && exp_type_sym.kind == .byteptr {
		info := got_type_sym.info as table.ArrayFixed
		if info.elem_type.idx() == table.byte_type_idx {
			return true
		}
	}
	// TODO
	if exp_type_sym.name == 'array' || got_type_sym.name == 'array' {
		return true
	}
	// TODO
	// accept [] when an expected type is an array
	if got_type_sym.kind == .array && got_type_sym.name == 'array_void' && exp_type_sym.kind ==
		.array {
		return true
	}
	// type alias
	if (got_type_sym.kind == .alias && got_type_sym.parent_idx == exp_idx) || (exp_type_sym.kind ==
		.alias && exp_type_sym.parent_idx == got_idx) {
		return true
	}
	// sum type
	if got_type_sym.kind == .sum_type {
		sum_info := got_type_sym.info as table.SumType
		// TODO: handle `match SumType { &PtrVariant {} }` currently just checking base
		if expected.set_nr_muls(0) in sum_info.variants {
			return true
		}
	}
	if exp_type_sym.kind == .sum_type {
		sum_info := exp_type_sym.info as table.SumType
		// TODO: handle `match SumType { &PtrVariant {} }` currently just checking base
		if got.set_nr_muls(0) in sum_info.variants {
			return true
		}
	}
	// fn type
	if got_type_sym.kind == .function && exp_type_sym.kind == .function {
		got_info := got_type_sym.info as table.FnType
		exp_info := exp_type_sym.info as table.FnType
		got_fn := got_info.func
		exp_fn := exp_info.func
		// we are using check() to compare return type & args as they might include
		// functions themselves. TODO: optimize, only use check() when needed
		if got_fn.args.len == exp_fn.args.len && c.check_types(got_fn.return_type, exp_fn.return_type) {
			for i, got_arg in got_fn.args {
				exp_arg := exp_fn.args[i]
				if !c.check_types(got_arg.typ, exp_arg.typ) {
					return false
				}
			}
			return true
		}
	}
	return false
}
*.v
*.c
!*_test.vvlib/v/checker/tests/add_op_wrong_left_type_err_a.v:3:5: error: mismatched types `A` and `int`
    1 | struct A{}
    2 | fn main() {
    3 |     A{} + 10
      |     ~~~
    4 | }
struct A{}
fn main() {
    A{} + 10
}
vlib/v/checker/tests/add_op_wrong_left_type_err_b.v:2:5: error: mismatched types `array_int` and `int`
    1 | fn main() {
    2 |     [1,2,3] + 10
      |     ~~~~~~~
    3 | }
fn main() {
    [1,2,3] + 10
}
vlib/v/checker/tests/add_op_wrong_left_type_err_c.v:3:5: error: mismatched types `map_string_int` and `int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     a + 10
      |     ^
    4 | }
fn main() {
	a := map[string]int
    a + 10
}
vlib/v/checker/tests/add_op_wrong_right_type_err_a.v:3:10: error: mismatched types `int` and `A`
    1 | struct A{}
    2 | fn main() {
    3 |     10 + A{}
      |          ~~~
    4 | }
struct A{}
fn main() {
    10 + A{}
}
vlib/v/checker/tests/add_op_wrong_right_type_err_b.v:2:10: error: mismatched types `int` and `array_int`
    1 | fn main() {
    2 |     10 + [1,2,3]
      |          ~~~~~~~
    3 | }
fn main() {
    10 + [1,2,3]
}
vlib/v/checker/tests/add_op_wrong_right_type_err_c.v:3:10: error: mismatched types `int` and `map_string_int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     10 + a
      |          ^
    4 | }
fn main() {
	a := map[string]int
    10 + a
}
vlib/v/checker/tests/alias_type_exists.v:1:1: error: type `Bird` doesn't exist
    1 | type Pigeon Bird
      | ~~~~~~~~~~~
    2 |
    3 | fn main() {
type Pigeon Bird

fn main() {

}
vlib/v/checker/tests/ambiguous_function_call_a.v:2:2: error: ambiguous call to: `foo`, may refer to fn `foo` or variable `foo` 
    1 | fn foo(foo int) {
    2 |     foo(foo + 1)
      |     ~~~~~~~~~~~~
    3 | }
    4 |
fn foo(foo int) {
	foo(foo + 1)
}

fn main() {
	foo(5)
}
vlib/v/checker/tests/ambiguous_function_call_b.v:3:2: error: ambiguous call to: `foo`, may refer to fn `foo` or variable `foo` 
    1 | fn foo() {
    2 |     foo := 1
    3 |     foo(foo)
      |     ~~~~~~~~
    4 | }
    5 |
fn foo() {
	foo := 1
	foo(foo)
}

fn main() {
	foo()
}
vlib/v/checker/tests/assign_expr_type_err_a.v:3:2: error: operator <<= not defined on left operand type `f64`
    1 | fn main() {
    2 |     mut foo := 0.5
    3 |     foo <<= 1
      |     ~~~
    4 | }
fn main() {
	mut foo := 0.5
	foo <<= 1
}vlib/v/checker/tests/assign_expr_type_err_b.v:3:9: error: operator %= not defined on right operand type `string`
    1 | fn main() {
    2 |     mut foo := 10
    3 |     foo %= 'hello'
      |            ~~~~~~~
    4 | }
fn main() {
	mut foo := 10
	foo %= 'hello'
}vlib/v/checker/tests/assign_expr_type_err_c.v:3:2: error: operator *= not defined on left operand type `string`
    1 | fn main() {
    2 |     mut foo := 'hello'
    3 |     foo *= 10
      |     ~~~
    4 | }
fn main() {
	mut foo := 'hello'
	foo *= 10
}vlib/v/checker/tests/assign_expr_type_err_d.v:3:9: error: operator /= not defined on right operand type `bool`
    1 | fn main() {
    2 |     mut foo := 1.5
    3 |     foo /= true
      |            ~~~~
    4 | }
fn main() {
	mut foo := 1.5
	foo /= true
}vlib/v/checker/tests/assign_expr_type_err_e.v:3:2: error: operator -= not defined on left operand type `string`
    1 | fn main() {
    2 |     mut foo := 'hello'
    3 |     foo -= `a`
      |     ~~~
    4 | }
fn main() {
	mut foo := 'hello'
	foo -= `a`
}vlib/v/checker/tests/assign_expr_type_err_f.v:3:9: error: operator -= not defined on right operand type `bool`
    1 | fn main() {
    2 |     mut foo := 10
    3 |     foo -= false
      |            ~~~~~
    4 | }
fn main() {
	mut foo := 10
	foo -= false
}vlib/v/checker/tests/assign_expr_type_err_g.v:3:2: error: operator += not defined on left operand type `bool`
    1 | fn main() {
    2 |     mut foo := true
    3 |     foo += false
      |     ~~~
    4 | }
fn main() {
	mut foo := true
	foo += false
}vlib/v/checker/tests/assign_expr_type_err_h.v:3:9: error: operator += not defined on right operand type `bool`
    1 | fn main() {
    2 |     mut foo := 'hello'
    3 |     foo += false
      |            ~~~~~
    4 | }
fn main() {
	mut foo := 'hello'
	foo += false
}vlib/v/checker/tests/assign_expr_type_err_i.v:3:9: error: cannot assign `string` to variable `foo` of type `f64`
    1 | fn main() {
    2 |     mut foo := 1.5
    3 |     foo += 'hello'
      |            ~~~~~~~
    4 | }
fn main() {
	mut foo := 1.5
	foo += 'hello' 
}vlib/v/checker/tests/assign_expr_undefined_err_a.v:2:7: error: undefined: `a`
    1 | fn main() {
    2 |     a := a
      |          ^
    3 |     println(a)
    4 | }
fn main() {
	a := a
	println(a)
}
vlib/v/checker/tests/assign_expr_undefined_err_b.v:2:10: error: undefined: `a`
    1 | fn main() {
    2 |     a, b := a, b
      |             ^
    3 |     println('$a, $b')
    4 | }
fn main() {
	a, b := a, b
	println('$a, $b')
}
vlib/v/checker/tests/assign_expr_undefined_err_c.v:2:10: error: undefined: `a`
    1 | fn main() {
    2 |     a, b := a + 1, b * 3
      |             ^
    3 |     println('$a, $b')
    4 | }
fn main() {
	a, b := a + 1, b * 3
	println('$a, $b')
}
vlib/v/checker/tests/assign_expr_undefined_err_d.v:2:9: error: undefined: `s`
    1 | fn main() {
    2 |     s := '$s'
      |            ^
    3 |     println(s)
    4 | }
fn main() {
	s := '$s'
	println(s)
}
vlib/v/checker/tests/assign_multi_immutable_err.v:4:2: error: `a` is immutable, declare it with `mut` to make it mutable
    2 |     a := 10
    3 |     b := 20
    4 |     a, b = 1, 2
      |     ^
    5 |
    6 |     println('$a, $b')fn main() {
	a := 10
	b := 20
	a, b = 1, 2

	println('$a, $b')
}vlib/v/checker/tests/bin_lit_without_digit_err.v:2:14: error: number part of this binary is not provided
    1 | fn main() {
    2 |     println(0b**)
      |              ^
    3 | }
fn main() {
    println(0b**)
}
vlib/v/checker/tests/bin_lit_wrong_digit_err.v:2:18: error: this binary number has unsuitable digit `2`
    1 | fn main() {
    2 |     println(0b1112)
      |                  ^
    3 | }
fn main() {
    println(0b1112)
}
vlib/v/checker/tests/bit_op_wrong_left_type_err.v:2:2: error: left type of `&` cannot be non-integer type f64
    1 | fn main() {
    2 |     0.5 & 1
      |     ~~~
    3 | }
fn main() {
	0.5 & 1
}vlib/v/checker/tests/bit_op_wrong_right_type_err.v:2:6: error: right type of `|` cannot be non-integer type f64
    1 | fn main() {
    2 |     1 | 0.5
      |         ~~~
    3 | }
fn main() {
	1 | 0.5
}vlib/v/checker/tests/cannot_assign_array.v:9:11: error: cannot assign `array_fixed_f64_8` to variable `ctx.vb` of type `string`
    7 |     mut ctx := Context{}
    8 |     x := 2.32
    9 |     ctx.vb = [1.1, x, 3.3, 4.4, 5.0, 6.0, 7.0, 8.9]!!
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   10 | }
struct Context {
	pub mut:
	vb string
}

fn main() {
	mut ctx := Context{}
	x := 2.32
	ctx.vb = [1.1, x, 3.3, 4.4, 5.0, 6.0, 7.0, 8.9]!!
}
vlib/v/checker/tests/cast_string_err.v:2:14: error: cannot cast type `int` to string, use `x.str()` instead
    1 | fn main() {
    2 |     a := string(1)
      |                 ^
    3 |     println(a)
    4 | }
fn main() {
	a := string(1)
	println(a)
}vlib/v/checker/tests/const_define_in_function_err.v:2:2: error: const can only be defined at the top level (outside of functions)
    1 | fn main() {
    2 |     const (a = 1)
      |     ~~~~~
    3 |     println(a)
    4 | }
fn main() {
	const (a = 1)
	println(a)
}
vlib/v/checker/tests/const_field_add_err.v:6:2: error: cannot assign to constant `a` 
    4 | 
    5 | fn main() {
    6 |     a += 1
      |     ^
    7 | }
const (
	a = 1
)

fn main() {
	a += 1
}
vlib/v/checker/tests/const_field_dec_err.v:6:2: error: cannot assign to constant `a` 
    4 | 
    5 | fn main() {
    6 |     a--
      |     ^
    7 | }
const (
	a = 1
)

fn main() {
	a--
}
vlib/v/checker/tests/const_field_inc_err.v:6:2: error: cannot assign to constant `a` 
    4 | 
    5 | fn main() {
    6 |     a++
      |     ^
    7 | }
const (
	a = 1
)

fn main() {
	a++
}
vlib/v/checker/tests/const_field_name_duplicate_err.v:3:2: error: field name `aaa` duplicate
    1 | const (
    2 |     aaa = 1
    3 |     aaa = 2
      |     ~~~
    4 | )
    5 | fn main() {
const (
	aaa = 1
	aaa = 2
)
fn main() {
	println(aaa)
}
vlib/v/checker/tests/const_field_name_snake_case.v:2:2: warning: const names cannot contain uppercase letters, use snake_case instead
    1 | const (
    2 |     Red = 1
      |     ~~~
    3 | )
    4 | fn main() { println(Red) }
const (
	Red = 1
)
fn main() { println(Red) }
vlib/v/checker/tests/const_field_sub_err.v:6:2: error: cannot assign to constant `a` 
    4 | 
    5 | fn main() {
    6 |     a -= 1
      |     ^
    7 | }
const (
	a = 1
)

fn main() {
	a -= 1
}
vlib/v/checker/tests/dec_lit_wrong_digit_err.v:2:18: error: this number has unsuitable digit `q`
    1 | fn main() {
    2 |     println(12345qrst+10)
      |                  ^
    3 | }
fn main() {
    println(12345qrst+10)
}
vlib/v/checker/tests/division_by_zero_float_err.v:2:14: error: division by zero
    1 | fn main() {
    2 |     println(1.0/0.0)
      |                 ~~~
    3 | }
fn main() {
	println(1.0/0.0)
}
vlib/v/checker/tests/division_by_zero_int_err.v:2:12: error: division by zero
    1 | fn main() {
    2 |     println(1/0)
      |               ^
    3 | }
fn main() {
	println(1/0)
}
vlib/v/checker/tests/div_op_wrong_left_type_err_a.v:3:5: error: mismatched types `A` and `int`
    1 | struct A{}
    2 | fn main() {
    3 |     A{} / 10
      |     ~~~
    4 | }
struct A{}
fn main() {
    A{} / 10
}
vlib/v/checker/tests/div_op_wrong_left_type_err_b.v:2:5: error: mismatched types `array_int` and `int`
    1 | fn main() {
    2 |     [1,2,3] / 10
      |     ~~~~~~~
    3 | }
fn main() {
    [1,2,3] / 10
}
vlib/v/checker/tests/div_op_wrong_left_type_err_c.v:3:5: error: mismatched types `map_string_int` and `int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     a / 10
      |     ^
    4 | }
fn main() {
	a := map[string]int
    a / 10
}
vlib/v/checker/tests/div_op_wrong_right_type_err_a.v:3:10: error: mismatched types `int` and `A`
    1 | struct A{}
    2 | fn main() {
    3 |     10 / A{}
      |          ~~~
    4 | }
struct A{}
fn main() {
    10 / A{}
}
vlib/v/checker/tests/div_op_wrong_right_type_err_b.v:2:10: error: mismatched types `int` and `array_int`
    1 | fn main() {
    2 |     10 / [1,2,3]
      |          ~~~~~~~
    3 | }
fn main() {
    10 / [1,2,3]
}
vlib/v/checker/tests/div_op_wrong_right_type_err_c.v:3:10: error: mismatched types `int` and `map_string_int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     10 / a
      |          ^
    4 | }
fn main() {
	a := map[string]int
    10 / a
}
vlib/v/checker/tests/enum_err.v:4:13: error: default value for enum has to be an integer
    2 |
    3 | enum Color {
    4 |     green = 'green'
      |             ~~~~~~~
    5 |     yellow = 1+1
    6 |     blue
vlib/v/checker/tests/enum_err.v:5:14: error: default value for enum has to be an integer
    3 | enum Color {
    4 |     green = 'green'
    5 |     yellow = 1+1
      |              ~~~
    6 |     blue
    7 | }
module main

enum Color {
    green = 'green'
    yellow = 1+1
    blue
}

fn main(){
	println('hello')
}
vlib/v/checker/tests/enum_field_name_duplicate_err.v:5:2: error: field name `green` duplicate
    3 |     yellow
    4 |     blue
    5 |     green
      |     ~~~~~
    6 | }
    7 |
enum Color {
    green
    yellow
    blue
	green
}

fn main(){
	println('hello')
}
vlib/v/checker/tests/float_lit_exp_not_integer_err.v:2:17: error: exponential part should be integer
    1 | fn main() {
    2 |     println(45e2.5)
      |                 ^
    3 | }
fn main() {
    println(45e2.5)
}
vlib/v/checker/tests/float_lit_exp_without_digit_err.v:2:14: error: exponent has no digits
    1 | fn main() {
    2 |     println(2E)
      |              ^
    3 | }
fn main() {
    println(2E)
}
vlib/v/checker/tests/float_lit_too_many_points_err.v:2:19: error: too many decimal points in number
    1 | fn main() {
    2 |     println(123.45.67)
      |                   ^
    3 | }
fn main() {
    println(123.45.67)
}
vlib/v/checker/tests/float_modulo_err.v:2:13: error: float modulo not allowed, use math.fmod() instead 
    1 | fn main() {
    2 |     println(3.0 % 2.0)
      |             ~~~
    3 |     println(f32(3.0) % f32(2.0))
    4 | }
vlib/v/checker/tests/float_modulo_err.v:3:17: error: float modulo not allowed, use math.fmod() instead
    1 | fn main() {
    2 |     println(3.0 % 2.0)
    3 |     println(f32(3.0) % f32(2.0))
      |                 ~~~
    4 | }
fn main() {
    println(3.0 % 2.0)
    println(f32(3.0) % f32(2.0))
}
vlib/v/checker/tests/fn_type_exists.v:1:1: error: type `Pants` doesn't exist
    1 | type PantsCreator = fn (a Shirt) Pants
      | ~~~~~~~~~~~~~~~~~
    2 |
    3 | type PantsConsumer = fn (p Pants)
vlib/v/checker/tests/fn_type_exists.v:3:1: error: type `Pants` doesn't exist
    1 | type PantsCreator = fn (a Shirt) Pants
    2 |
    3 | type PantsConsumer = fn (p Pants)
      | ~~~~~~~~~~~~~~~~~~
    4 |
    5 | fn main() {
type PantsCreator = fn (a Shirt) Pants

type PantsConsumer = fn (p Pants)

fn main() {

}
vlib/v/checker/tests/for-in-index-type.v:2:11: error: for in: cannot index `int`
    1 | fn main() {
    2 |     for a in 52 {
      |              ~~
    3 |         println(a)
    4 |     }
fn main() {
	for a in 52 {
		println(a)
	}
}vlib/v/checker/tests/for_in_map_one_variable_err.v:3:6: error: declare a key and a value variable when ranging a map: `for key, val in map {`
use `_` if you do not need the variable
    1 | fn main() {
    2 |     kvs := {'foo':'bar'}
    3 |     for k in kvs {
      |         ^
    4 |         println('$k')
    5 |     }
fn main() {
	kvs := {'foo':'bar'}
	for k in kvs {
		println('$k')
	}
}
vlib/v/checker/tests/for_in_range_not_match_type.v:2:11: error: range types do not match
    1 | fn main() {
    2 |     for i in 10..10.5 {
      |              ~~
    3 |         println(i)
    4 |     }
fn main() {
	for i in 10..10.5 {
		println(i)
	}
}
vlib/v/checker/tests/for_in_range_string_type.v:2:11: error: range type can not be string
    1 | fn main() {
    2 |     for i in 'a'..'b' {
      |              ~~~
    3 |         println(i)
    4 |     }
fn main() {
	for i in 'a'..'b' {
		println(i)
	}
}
vlib/v/checker/tests/globals_error.v:2:1: error: use `v --enable-globals ...` to enable globals
    1 |
    2 | __global rfcnt int
      | ~~~~~~~~
    3 |
    4 | fn abc(){
rfcnt: 2

__global rfcnt int

fn abc(){
	rfcnt = 2
}

fn main(){
	rfcnt = 1
	abc()
	println('rfcnt: $rfcnt')
}
vlib/v/checker/tests/go_expr.v:2:5: error: expression in `go` must be a function call
    1 | fn main() {
    2 |     go 1
      |        ^
    3 | }
fn main() {
	go 1
}
vlib/v/checker/tests/hex_lit_without_digit_err.v:2:14: error: number part of this hexadecimal is not provided
    1 | fn main() {
    2 |     println(0x)
      |              ^
    3 | }
fn main() {
    println(0x)
}
vlib/v/checker/tests/hex_lit_wrong_digit_err.v:2:18: error: this hexadecimal number has unsuitable digit `g`
    1 | fn main() {
    2 |     println(0x111ghi)
      |                  ^
    3 | }
fn main() {
    println(0x111ghi)
}
vlib/v/checker/tests/if_expr_last_stmt.v:4:7: error: `if` expression requires an expression as the last statement of every branch
    2 |     _ := if true {
    3 |         1
    4 |     } else if false {
      |       ~~~~~~~~~~~~~
    5 |     } else {
    6 |     }
vlib/v/checker/tests/if_expr_last_stmt.v:5:7: error: `if` expression requires an expression as the last statement of every branch
    3 |         1
    4 |     } else if false {
    5 |     } else {
      |       ~~~~
    6 |     }
    7 | }
fn main() {
    _ := if true {
        1
    } else if false {
    } else {
    }
}
vlib/v/checker/tests/if_expr_mismatch.v:2:7: error: mismatched types `string` and `int`
    1 | fn main() {
    2 |     s := if true { '12' } else { 12 }
      |          ~~
    3 |     println(s)
    4 | }
fn main() {
	s := if true { '12' } else { 12 }
	println(s)
}
vlib/v/checker/tests/if_expr_no_else.v:2:10: error: `if` expression needs `else` clause
    1 | fn main() {
    2 |     _ := if true { 1 }
      |          ~~
    3 | }
fn main() {
    _ := if true { 1 }
}
vlib/v/checker/tests/immutable_array_field_assign.v:9:4: error: field `i` of struct `A` is immutable
    7 |         i: [0]
    8 |     }
    9 |     a.i[0] = 3
      |       ^
   10 | }
struct A {
	i []int
}

fn main() {
	mut a := A{
		i: [0]
	}
	a.i[0] = 3
}
vlib/v/checker/tests/immutable_array_field_shift.v:14:4: error: field `a` of struct `B` is immutable
   12 |         a: A{}
   13 |     }
   14 |     b.a.i << 3
      |       ^
   15 | }
struct A {
mut:
	i []int
}

struct B {
	a A
}

fn main() {
	mut b := B{
		a: A{}
	}
	b.a.i << 3
}
vlib/v/checker/tests/immutable_array_struct_assign.v:8:2: error: `a` is immutable, declare it with `mut` to make it mutable
    6 | fn main() {
    7 |     a := A{}
    8 |     a.i[0] += 3
      |     ^
    9 | }
struct A {
pub mut:
	i []int
}

fn main() {
	a := A{}
	a.i[0] += 3
}
vlib/v/checker/tests/immutable_array_struct_shift.v:8:2: error: `a` is immutable, declare it with `mut` to make it mutable
    6 | fn main() {
    7 |     a := []A{}
    8 |     a[0].i << 3
      |     ^
    9 | }
struct A {
pub mut:
	i []int
}

fn main() {
	a := []A{}
	a[0].i << 3
}
vlib/v/checker/tests/immutable_array_var.v:3:2: error: `a` is immutable, declare it with `mut` to make it mutable
    1 | fn main() {
    2 |     a := [1, 2]
    3 |     a << 3
      |     ^
    4 | }
fn main() {
	a := [1, 2]
	a << 3
}
vlib/v/checker/tests/immutable_field.v:8:4: error: field `i1` of struct `A` is immutable
    6 | fn main() {
    7 |     a := A{1}
    8 |     a.i1 = 2
      |       ~~
    9 | }
struct A {
pub:
	i1 int
}

fn main() {
	a := A{1}
	a.i1 = 2
}
vlib/v/checker/tests/immutable_field_postfix.v:7:4: error: field `i` of struct `A` is immutable
    5 | fn main() {
    6 |     mut a := A{}
    7 |     a.i++
      |       ^
    8 |     a.i--
    9 | }
vlib/v/checker/tests/immutable_field_postfix.v:8:4: error: field `i` of struct `A` is immutable
    6 |     mut a := A{}
    7 |     a.i++
    8 |     a.i--
      |       ^
    9 | }
struct A {
	i int
}

fn main() {
	mut a := A{}
	a.i++
	a.i--
}
vlib/v/checker/tests/immutable_map_postfix.v:3:2: error: `m` is immutable, declare it with `mut` to make it mutable
    1 | fn main() {
    2 |     m := map[string]int
    3 |     m['test']++
      |     ^
    4 |     m['test']--
    5 | }
vlib/v/checker/tests/immutable_map_postfix.v:4:2: error: `m` is immutable, declare it with `mut` to make it mutable
    2 |     m := map[string]int
    3 |     m['test']++
    4 |     m['test']--
      |     ^
    5 | }
fn main() {
	m := map[string]int
	m['test']++
	m['test']--
}
vlib/v/checker/tests/immutable_struct_postfix.v:8:2: error: `a` is immutable, declare it with `mut` to make it mutable
    6 | fn main() {
    7 |     a := A{}
    8 |     a.i++
      |     ^
    9 |     a.i--
   10 | }
vlib/v/checker/tests/immutable_struct_postfix.v:9:2: error: `a` is immutable, declare it with `mut` to make it mutable
    7 |     a := A{}
    8 |     a.i++
    9 |     a.i--
      |     ^
   10 | }
struct A {
mut:
	i int
}

fn main() {
	a := A{}
	a.i++
	a.i--
}
vlib/v/checker/tests/immutable_var.v:3:2: error: `a` is immutable, declare it with `mut` to make it mutable
    1 | fn main() {
    2 |     a := 1
    3 |     a = 2
      |     ^
    4 | }
fn main() {
	a := 1
	a = 2
}
vlib/v/checker/tests/immutable_var_postfix.v:3:2: error: `a` is immutable, declare it with `mut` to make it mutable
    1 | fn main() {
    2 |     a := 1
    3 |     a++
      |     ^
    4 |     a--
    5 | }
vlib/v/checker/tests/immutable_var_postfix.v:4:2: error: `a` is immutable, declare it with `mut` to make it mutable
    2 |     a := 1
    3 |     a++
    4 |     a--
      |     ^
    5 | }
fn main() {
	a := 1
	a++
	a--
}
vlib/v/checker/tests/import_duplicate_err.v:2:8: error: module name `time` duplicate
    1 | import time
    2 | import time
      |        ~~~~
    3 | fn main() {
    4 |     println(time.now().unix_time())
import time
import time
fn main() {
	println(time.now().unix_time())
}
vlib/v/checker/tests/import_middle_err.v:5:1: error: `import x` can only be declared at the beginning of the file
    3 |     println('hello, world')
    4 | }
    5 | import os
      | ~~~~~~
    6 | fn main() {
    7 |     println(time.now())
import time
fn show() {
	println('hello, world')
}
import os
fn main() {
	println(time.now())
}
vlib/v/checker/tests/import_multiple_modules_err.v:1:13: error: cannot import multiple modules at a time
    1 | import time math
      |             ~~~~
    2 | fn main() {
    3 |     println(time.now().unix_time())
import time math
fn main() {
	println(time.now().unix_time())
}
builder error: cannot import module "notexist" (not found)
import notexist
fn main() {
	println(notexist.name)
}
vlib/v/checker/tests/import_not_same_line_err.v:2:2: error: `import` and `module` must be at same line
    1 | import
    2 |  time
      |  ~~~~
    3 | fn main() {
    4 |     println(time.now())
import
 time
fn main() {
	println(time.now())
}
vlib/v/checker/tests/import_syntax_err.v:1:12: error: module syntax error, please use `x.y.z`
    1 | import time, os
      |            ^
    2 | fn main() {
    3 |     println(time.now())
import time, os
fn main() {
	println(time.now())
}
vlib/v/checker/tests/import_unused_warning.v:1:8: warning: module 'time' is imported but never used 
    1 | import time
      |        ~~~~
    2 | fn main() {
    3 |     println('hello, world')
import time
fn main() {
	println('hello, world')
}
vlib/v/checker/tests/incorrect_name_alias_type.v:1:1: error: type alias `integer` must begin with capital letter
    1 | type integer = int
      | ~~~~~~~~~~~~type integer = int
const (
	_my_const = 0
)
vlib/v/checker/tests/incorrect_name_enum.v:1:1: error: enum name `color` must begin with capital letter
    1 | enum color {
      | ~~~~~~~~~~
    2 |     green
    3 |     yellowenum color {
    green
    yellow
}
vlib/v/checker/tests/incorrect_name_enum_field.v:2:5: error: field name `Green` cannot contain uppercase letters, use snake_case instead
    1 | enum Color {
    2 |     Green
      |     ~~~~~
    3 |     red
    4 |     blueenum Color {
    Green
    red
    blue
}
vlib/v/checker/tests/incorrect_name_fn_type.v:1:1: error: fn type `callback` must begin with capital letter
    1 | type callback = fn ()
      | ~~~~~~~~~~~~~
type callback = fn ()
vlib/v/checker/tests/incorrect_name_function.v:1:1: error: function name `_my_fn` cannot start with `_`
    1 | fn _my_fn() {}
      | ~~~~~~~~~~~fn _my_fn() {}
vlib/v/checker/tests/incorrect_name_interface.v:1:1: error: interface name `_MyInterface` must begin with capital letter
    1 | interface _MyInterface {}
      | ~~~~~~~~~interface _MyInterface {}
vlib/v/checker/tests/incorrect_name_interface_method.v:2:5: error: method name `_speak` cannot start with `_`
    1 | interface MyInterface {
    2 |     _speak()
      |     ~~~~~~~~
    3 | }interface MyInterface {
    _speak()
}
vlib/v/checker/tests/incorrect_name_module.v:1:1: error: module name `_A` cannot start with `_`
    1 | module _A
      | ~~~~~~~~~module _A
vlib/v/checker/tests/incorrect_name_struct.v:1:8: error: struct name `abc` must begin with capital letter
    1 | struct abc {}
      |        ~~~struct abc {}
vlib/v/checker/tests/incorrect_name_struct_field.v:2:5: error: field name `_a` cannot start with `_`
    1 | struct Abc {
    2 |     _a int
      |     ~~~~~~
    3 | }struct Abc {
    _a int
}
vlib/v/checker/tests/incorrect_name_sum_type.v:1:1: error: sum type `integer` must begin with capital letter
    1 | type integer = i8 | i16 | int | i64
      | ~~~~~~~~~~~~type integer = i8 | i16 | int | i64
vlib/v/checker/tests/incorrect_name_variable.v:2:2: error: variable name `_abc` cannot start with `_`
    1 | fn main() {
    2 |     _abc := 1
      |     ~~~~
    3 |     _ := _abc
    4 | }fn main() {
	_abc := 1
	_ := _abc
}
vlib/v/checker/tests/int_modulo_by_zero_err.v:2:17: error: modulo by zero 
    1 | fn main() {
    2 |     println(3 % 0)
      |                 ^
    3 | }
fn main() {
    println(3 % 0)
}
vlib/v/checker/tests/in_mismatch_type.v:10:7: error: the data type on the left of `in` does not match the array item type 
    8 |     }
    9 |     s := 'abcd'
   10 |     if 1 in a_s {
      |          ~~
   11 |         println('ok')
   12 |     }
vlib/v/checker/tests/in_mismatch_type.v:13:7: error: the data type on the left of `in` does not match the map key type
   11 |         println('ok')
   12 |     }
   13 |     if 2 in m {
      |          ~~
   14 |         println('yeah')
   15 |     }
vlib/v/checker/tests/in_mismatch_type.v:16:7: error: the data type on the left of `in` must be a string
   14 |         println('yeah')
   15 |     }
   16 |     if 3 in s {
      |          ~~
   17 |         println('dope')
   18 |     }
vlib/v/checker/tests/in_mismatch_type.v:19:9: error: the data type on the left of `in` must be a string 
   17 |         println('dope')
   18 |     }
   19 |     if `a` in s {
      |            ~~
   20 |         println("oh no :'(")
   21 |     }
vlib/v/checker/tests/in_mismatch_type.v:22:7: error: `in` can only be used with an array/map/string
   20 |         println("oh no :'(")
   21 |     }
   22 |     if 1 in 12 {
      |          ~~
   23 |         println('right')
   24 |     }
vlib/v/checker/tests/in_mismatch_type.v:25:12: error: the data type on the left of `in` does not match the map key type
   23 |         println('right')
   24 |     }
   25 |     if Int(2) in m {
      |               ~~
   26 |         println('yeah')
   27 |     }
vlib/v/checker/tests/in_mismatch_type.v:28:9: error: the data type on the left of `in` does not match the array item type
   26 |         println('yeah')
   27 |     }
   28 |     if '3' in a_i {
      |            ~~
   29 |         println('sure')
   30 |     }
vlib/v/checker/tests/in_mismatch_type.v:31:9: error: the data type on the left of `in` does not match the array item type
   29 |         println('sure')
   30 |     }
   31 |     if '2' in a_i {
      |            ~~
   32 |         println('all right')
   33 |     }
vlib/v/checker/tests/in_mismatch_type.v:34:7: error: the data type on the left of `!in` does not match the array item type
   32 |         println('all right')
   33 |     }
   34 |     if 1 !in a_s {
      |          ~~~
   35 |         println('ok')
   36 |     }
vlib/v/checker/tests/in_mismatch_type.v:37:9: error: the data type on the left of `!in` does not match the array item type 
   35 |         println('ok')
   36 |     }
   37 |     if '1' !in a_i {
      |            ~~~
   38 |         println('good')
   39 |     }
vlib/v/checker/tests/in_mismatch_type.v:41:7: error: the data type on the left of `!in` does not match the map key type
   39 |     }
   40 |
   41 |     if 5 !in m {
      |          ~~~
   42 |         println('yay')
   43 |     }
type Int = int

fn main() {
	a_i := [1, 2, 3]
	a_s := ['1', '2', '3']
	m := {
		'test': 1
	}
	s := 'abcd'
	if 1 in a_s {
		println('ok')
	}
	if 2 in m {
		println('yeah')
	}
	if 3 in s {
		println('dope')
	}
	if `a` in s {
		println("oh no :'(")
	}
	if 1 in 12 {
		println('right')
	}
	if Int(2) in m {
		println('yeah')
	}
	if '3' in a_i {
		println('sure')
	}
	if '2' in a_i {
		println('all right')
	}
	if 1 !in a_s {
		println('ok')
	}
	if '1' !in a_i {
		println('good')
	}

	if 5 !in m {
		println('yay')
	}
}
vlib/v/checker/tests/is_type_not_exist.v:8:10: error: is: type `SomethingThatDontExist` does not exist
    6 |
    7 | fn fn_with_sum_type_param(i Integer) {
    8 |     if i is SomethingThatDontExist {
      |             ~~~~~~~~~~~~~~~~~~~~~~
    9 |         println('It should fail !')
   10 |     }
type Integer = i8 | i16 | int | i64

fn main() {
	fn_with_sum_type_param(1)
}

fn fn_with_sum_type_param(i Integer) {
	if i is SomethingThatDontExist {
		println('It should fail !')
	}
}
vlib/v/checker/tests/left_shift_err.v:3:7: error: cannot append `string` to `[]int`
    1 | fn main() {
    2 |     mut l := []int{}
    3 |     l << 'test'
      |          ~~~~~~
    4 | }
fn main() {
	mut l := []int{}
	l << 'test'
}
vlib/v/checker/tests/main_args_err.v:1:1: error: function `main` cannot have arguments
    1 | fn main(a string) {
      | ~~~~~~~~~~~~~~~~~
    2 |     println(a)
    3 | }
fn main(a string) {
	println(a)
}
vlib/v/checker/tests/main_called_err.v:2:2: error: the `main` function cannot be called in the program
    1 | fn main() {
    2 |     main()
      |     ~~~~~~
    3 | }
fn main() {
	main()
}
vlib/v/checker/tests/main_return_err.v:1:1: error: function `main` cannot return values
    1 | fn main() f64 {
      | ~~~~~~~~~~~~~
    2 |     return 1.23
    3 | }
fn main() f64 {
	return 1.23
}
vlib/v/checker/tests/map_init_key_duplicate_err.v:5:3: error: duplicate key "foo" in map literal
    3 |         'foo': 'bar'
    4 |         'abc': 'abc'
    5 |         'foo': 'bar'
      |         ~~~~~
    6 |     }
    7 |     println(a)
fn main() {
	a := {
		'foo': 'bar'
		'abc': 'abc'
		'foo': 'bar'
	}
	println(a)
}
vlib/v/checker/tests/match_duplicate_branch.v:15:3: error: match case `St1` is handled more than once
   13 |     match i {
   14 |         St1 { println('St1') }
   15 |         St1 { println('St1') }
      |         ~~~~~
   16 |         St2 { println('St2') }
   17 |     }
vlib/v/checker/tests/match_duplicate_branch.v:20:3: error: match case `St1` is handled more than once
   18 |     match i {
   19 |         St1 { println('St1') }
   20 |         St1 { println('St1') }
      |         ~~~~~
   21 |         else { println('else') }
   22 |     }
vlib/v/checker/tests/match_duplicate_branch.v:29:3: error: match case `green` is handled more than once
   27 |         .red { println('red') }
   28 |         .green { println('green') }
   29 |         .green { println('green') }
      |         ~~~~~~~~
   30 |         .blue { println('blue') }
   31 |     }
vlib/v/checker/tests/match_duplicate_branch.v:34:3: error: match case `green` is handled more than once
   32 |     match c {
   33 |         .red, .green { println('red green') }
   34 |         .green { println('green') }
      |         ~~~~~~~~
   35 |         else { println('else') }
   36 |     }
vlib/v/checker/tests/match_duplicate_branch.v:43:3: error: match case `2` is handled more than once
   41 |         1 { println('1') }
   42 |         2 { println('2') }
   43 |         2 { println('3') }
      |         ~~~
   44 |         else { println('else') }
   45 |     }
enum Color {
	red
	green
	blue
}

struct St1 {}
struct St2 {}

type St = St1 | St2

fn test_sum_type(i St) {
	match i {
		St1 { println('St1') }
		St1 { println('St1') }
		St2 { println('St2') }
	}
	match i {
		St1 { println('St1') }
		St1 { println('St1') }
		else { println('else') }
	}
}

fn test_enum(c Color) {
	match c {
		.red { println('red') }
		.green { println('green') }
		.green { println('green') }
		.blue { println('blue') }
	}
	match c {
		.red, .green { println('red green') }
		.green { println('green') }
		else { println('else') }
	}
}

fn test_int(i int) {
	match i {
		1 { println('1') }
		2 { println('2') }
		2 { println('3') }
		else { println('else') }
	}
}

fn main() {
	test_sum_type(St1{})
	test_enum(.red)
	test_int(2)
}
vlib/v/checker/tests/match_else_last_expr.v:4:3: error: `else` must be the last branch of `match`
    2 |     match 1 {
    3 |         1 { println('1') }
    4 |         else { println('else') }
      |         ~~~~~~
    5 |         4 { println('4') }
    6 |     }
fn main() {
	match 1 {
		1 { println('1') }
		else { println('else') }
		4 { println('4') }
	}
}
vlib/v/checker/tests/match_expr_else.v:4:9: error: cannot cast a string
    2 |
    3 | fn main() {
    4 |     x := A('test')
      |            ~~~~~~
    5 |     _ = match x {
    6 |         int {
vlib/v/checker/tests/match_expr_else.v:5:6: error: match must be exhaustive (add match branches for: `f64` or `else {}` at the end)
    3 | fn main() {
    4 |     x := A('test')
    5 |     _ = match x {
      |         ~~~~~~~~~
    6 |         int {
    7 |             'int'
vlib/v/checker/tests/match_expr_else.v:23:3: error: match expression is exhaustive, `else` is unnecessary
   21 |             'f64'
   22 |         }
   23 |         else {
      |         ~~~~~~
   24 |             'else'
   25 |         }
vlib/v/checker/tests/match_expr_else.v:34:3: error: `else` must be the last branch of `match`
   32 |             'string'
   33 |         }
   34 |         else {
      |         ~~~~~~
   35 |             'else'
   36 |         }
type A = int | string | f64

fn main() {
	x := A('test')
	_ = match x {
		int {
			'int'
		}
		string {
			'string'
		}
	}
	_ := match x {
		int {
			'int'
		}
		string {
			'string'
		}
		f64 {
			'f64'
		}
		else {
			'else'
		}
	}
	_ := match x {
		int {
			'int'
		}
		string {
			'string'
		}
		else {
			'else'
		}
		f64 {
			'f64'
		}
	}
}
vlib/v/checker/tests/match_undefined_cond.v:4:15: error: undefined: `Asd`
    2 |
    3 | fn main() {
    4 |     res := match Asd {
      |                  ~~~
    5 |         1 { 'foo' }
    6 |         2 { 'test' }
type Asd = int

fn main() {
	res := match Asd {
		1 { 'foo' }
		2 { 'test' }
		else { '' }
	}
	_ = res
}
vlib/v/checker/tests/minus_op_wrong_left_type_err_a.v:3:5: error: mismatched types `A` and `int`
    1 | struct A{}
    2 | fn main() {
    3 |     A{} - 10
      |     ~~~
    4 | }
struct A{}
fn main() {
    A{} - 10
}
vlib/v/checker/tests/minus_op_wrong_left_type_err_b.v:2:5: error: mismatched types `array_int` and `int`
    1 | fn main() {
    2 |     [1,2,3] - 10
      |     ~~~~~~~
    3 | }
fn main() {
    [1,2,3] - 10
}
vlib/v/checker/tests/minus_op_wrong_left_type_err_c.v:3:5: error: mismatched types `map_string_int` and `int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     a - 10
      |     ^
    4 | }
fn main() {
	a := map[string]int
    a - 10
}
vlib/v/checker/tests/minus_op_wrong_right_type_err_a.v:3:10: error: mismatched types `int` and `A`
    1 | struct A{}
    2 | fn main() {
    3 |     10 - A{}
      |          ~~~
    4 | }
struct A{}
fn main() {
    10 - A{}
}
vlib/v/checker/tests/minus_op_wrong_right_type_err_b.v:2:10: error: mismatched types `int` and `array_int`
    1 | fn main() {
    2 |     10 - [1,2,3]
      |          ~~~~~~~
    3 | }
fn main() {
    10 - [1,2,3]
}
vlib/v/checker/tests/minus_op_wrong_right_type_err_c.v:3:10: error: mismatched types `int` and `map_string_int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     10 - a
      |          ^
    4 | }
fn main() {
	a := map[string]int
    10 - a
}
vlib/v/checker/tests/module_multiple_names_err.v:1:13: error: `module x` can only declare one module
    1 | module main os
      |             ~~
    2 | fn main() {
    3 |     println('hello, world')
module main os
fn main() {
	println('hello, world')
}
vlib/v/checker/tests/module_not_at_same_line_err.v:2:1: error: `module` and `main` must be at same line
    1 | module
    2 | main
      | ~~~~
    3 | fn main() {
    4 |     println('hello, world')
module
main
fn main() {
	println('hello, world')
}
vlib/v/checker/tests/module_syntax_err.v:1:12: error: `module x` syntax error
    1 | module main.os
      |            ^
    2 | fn main() {
    3 |     println('hello, world')
module main.os
fn main() {
	println('hello, world')
}
vlib/v/checker/tests/mod_op_wrong_left_type_err_a.v:2:2: error: mismatched types `f64` and `int`
    1 | fn main() {
    2 |     0.5 % 1
      |     ~~~
    3 | }
fn main() {
	0.5 % 1
}
vlib/v/checker/tests/mod_op_wrong_left_type_err_b.v:2:2: error: mismatched types `array_int` and `int`
    1 | fn main() {
    2 |     [1,2,3] % 1
      |     ~~~~~~~
    3 | }
fn main() {
	[1,2,3] % 1
}
vlib/v/checker/tests/mod_op_wrong_left_type_err_c.v:4:2: error: mismatched types `A` and `int`
    2 | fn main() {
    3 |     a := A{}
    4 |     a % 1
      |     ^
    5 | }
struct A{}
fn main() {
	a := A{}
	a % 1
}
vlib/v/checker/tests/mod_op_wrong_left_type_err_d.v:3:2: error: mismatched types `map_string_int` and `int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     a % 1
      |     ^
    4 | }
fn main() {
	a := map[string]int
	a % 1
}
vlib/v/checker/tests/mod_op_wrong_right_type_err_a.v:2:6: error: mismatched types `int` and `f64`
    1 | fn main() {
    2 |     1 % 0.5
      |         ~~~
    3 | }
fn main() {
	1 % 0.5
}
vlib/v/checker/tests/mod_op_wrong_right_type_err_b.v:2:6: error: mismatched types `int` and `array_int`
    1 | fn main() {
    2 |     1 % [1,2,3]
      |         ~~~~~~~
    3 | }
fn main() {
	1 % [1,2,3]
}
vlib/v/checker/tests/mod_op_wrong_right_type_err_c.v:4:6: error: mismatched types `int` and `A`
    2 | fn main() {
    3 |     a := A{}
    4 |     1 % a
      |         ^
    5 | }
struct A{}
fn main() {
	a := A{}
	1 % a
}
vlib/v/checker/tests/mod_op_wrong_right_type_err_d.v:3:6: error: mismatched types `int` and `map_string_int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     1 % a
      |         ^
    4 | }
fn main() {
	a := map[string]int
	1 % a
}
vlib/v/checker/tests/multiple_fn_attributes.v:2:1: error: multiple attributes detected 
    1 | [inline;deprecated]
    2 | fn foo(name string) string {}
      | ~~[inline;deprecated]
fn foo(name string) string {}vlib/v/checker/tests/multi_const_field_name_duplicate_err.v:2:8: error: field name `aaa` duplicate
    1 | const (aaa = 1)
    2 | const (aaa = 2)
      |        ~~~
    3 | fn main() {
    4 |     println(aaa)
const (aaa = 1)
const (aaa = 2)
fn main() {
	println(aaa)
}
vlib/v/checker/tests/multi_names_err.v:2:4: error: unexpected name `a`
    1 | fn main() {
    2 |     a a a a := 1
      |       ^
    3 | }
fn main() {
	a a a a := 1
}
vlib/v/checker/tests/mul_op_wrong_left_type_err_a.v:3:5: error: mismatched types `A` and `int`
    1 | struct A{}
    2 | fn main() {
    3 |     A{} * 10
      |     ~~~
    4 | }
struct A{}
fn main() {
    A{} * 10
}
vlib/v/checker/tests/mul_op_wrong_left_type_err_b.v:2:5: error: mismatched types `array_int` and `int`
    1 | fn main() {
    2 |     [1,2,3] * 10
      |     ~~~~~~~
    3 | }
fn main() {
    [1,2,3] * 10
}
vlib/v/checker/tests/mul_op_wrong_left_type_err_c.v:3:5: error: mismatched types `map_string_int` and `int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     a * 10
      |     ^
    4 | }
fn main() {
	a := map[string]int
    a * 10
}
vlib/v/checker/tests/mul_op_wrong_right_type_err_a.v:3:10: error: mismatched types `int` and `A`
    1 | struct A{}
    2 | fn main() {
    3 |     10 * A{}
      |          ~~~
    4 | }
struct A{}
fn main() {
    10 * A{}
}
vlib/v/checker/tests/mul_op_wrong_right_type_err_b.v:2:10: error: mismatched types `int` and `array_int`
    1 | fn main() {
    2 |     10 * [1,2,3]
      |          ~~~~~~~
    3 | }
fn main() {
    10 * [1,2,3]
}
vlib/v/checker/tests/mul_op_wrong_right_type_err_c.v:3:10: error: mismatched types `int` and `map_string_int`
    1 | fn main() {
    2 |     a := map[string]int
    3 |     10 * a
      |          ^
    4 | }
fn main() {
	a := map[string]int
    10 * a
}
vlib/v/checker/tests/mut_receiver_warning.v:5:7: warning: use `(mut f Foo)` instead of `(f mut Foo)`
    3 |     name string
    4 | }
    5 | fn (f mut Foo) info() {
      |       ~~~
    6 |     f.name = 'foo'
    7 | }struct Foo{
mut:
	name string
}
fn (f mut Foo) info() {
	f.name = 'foo'
}
fn main() {
	println('hello, world')
}
vlib/v/checker/tests/no_interface_instantiation_a.v:4:10: error: cannot instantiate interface `Speaker`
    2 |
    3 | fn main() {
    4 |     _ := Speaker{}
      |          ~~~~~~~~~
    5 | }interface Speaker {}

fn main() {
    _ := Speaker{}
}
vlib/v/checker/tests/no_interface_instantiation_b.v:6:12: error: cannot instantiate interface `Speaker`
    4 |
    5 | fn main() {
    6 |     my_fn({})
      |            ^
    7 | }interface Speaker {}

fn my_fn(s Speaker) {}

fn main() {
    my_fn({})
}
vlib/v/checker/tests/no_interface_instantiation_c.v:9:9: error: cannot instantiate interface `Speaker`
    7 | fn main() {
    8 |     my_fn(
    9 |         speak: 1
      |         ~~~~~~~~
   10 |     )
   11 | }interface Speaker {
    speak()
}

fn my_fn(s Speaker) {}

fn main() {
    my_fn(
        speak: 1
    )
}
vlib/v/checker/tests/no_interface_receiver.v:5:5: error: interfaces cannot be used as method receiver
    3 | }
    4 |
    5 | fn (a Animal) str() {}
      |     ~~~~~~~~

interface Animal {
	speak()
}

fn (a Animal) str() {}
vlib/v/checker/tests/no_main_mod.v:1:1: error: project must include a `main` module or be a shared library (compile with `v -shared`)
    1 | module a
      | ^
module a
vlib/v/checker/tests/no_main_println_err.v:1:5: error: too few arguments in call to `println` (0 instead of 1)
    1 |     println()
      |     ~~~~~~~~~
    println()
vlib/v/checker/tests/no_pub_in_main.v:3:1: error: type alias `Integer` in module main cannot be declared public
    1 | module main
    2 |
    3 | pub type Integer = int
      | ~~~~~~~~~~~~~~~~
    4 |
    5 | pub type Float = f32 | f64
vlib/v/checker/tests/no_pub_in_main.v:5:1: error: sum type `Float` in module main cannot be declared public
    3 | pub type Integer = int
    4 |
    5 | pub type Float = f32 | f64
      | ~~~~~~~~~~~~~~
    6 |
    7 | // Buggy ATM
vlib/v/checker/tests/no_pub_in_main.v:10:1: error: enum `Color` in module main cannot be declared public
    8 | // pub type Fn = fn () int
    9 |
   10 | pub enum Color {
      | ~~~~~~~~~~~~~~
   11 |     red
   12 |     green
vlib/v/checker/tests/no_pub_in_main.v:16:1: error: const in module main cannot be declared public
   14 | }
   15 |
   16 | pub const (
      | ~~~~~~~~~
   17 |     w = 'world'
   18 | )
vlib/v/checker/tests/no_pub_in_main.v:20:1: error: function `my_fn` in module main cannot be declared public
   18 | )
   19 |
   20 | pub fn my_fn() int {
      | ~~~~~~~~~~~~~~~~~~
   21 |     return 1
   22 | }
vlib/v/checker/tests/no_pub_in_main.v:24:1: error: function `main` cannot be declared public
   22 | }
   23 |
   24 | pub fn main() {
      | ~~~~~~~~~~~~~
   25 |     println('main')
   26 | }
vlib/v/checker/tests/no_pub_in_main.v:28:1: error: struct `MyStruct` in module main cannot be declared public
   26 | }
   27 |
   28 | pub struct MyStruct {
      | ~~~~~~~~~~~~~~~~~~~
   29 |     field int
   30 | }
module main

pub type Integer = int

pub type Float = f32 | f64

// Buggy ATM
// pub type Fn = fn () int

pub enum Color {
	red
	green
	blue
}

pub const (
	w = 'world'
)

pub fn my_fn() int {
	return 1
}

pub fn main() {
	println('main')
}

pub struct MyStruct {
	field int
}
vlib/v/checker/tests/oct_lit_without_digit_err.v:2:14: error: number part of this octal is not provided
    1 | fn main() {
    2 |     println(0o)
      |              ^
    3 | }
fn main() {
    println(0o)
}
vlib/v/checker/tests/oct_lit_wrong_digit_err.v:2:18: error: this octal number has unsuitable digit `8`
    1 | fn main() {
    2 |     println(0o1118)
      |                  ^
    3 | }
fn main() {
    println(0o1118)
}
vlib/v/checker/tests/reference_field_must_be_initialized.v:8:7: error: reference field `Node.next` must be initialized
    6 |
    7 | fn main(){
    8 |     n := Node{ data: 123 }
      |          ~~~~~~~~~~~~~~~~~
    9 |     eprintln('n.data: $n.data')
   10 | }
module main
struct Node {
    data int
	next &Node
}

fn main(){
	n := Node{ data: 123 }
    eprintln('n.data: $n.data')
}
vlib/v/checker/tests/return_type.v:2:9: error: cannot use `int` as type `bool` in return argument
    1 | fn test() bool {
    2 |     return 100
      |            ~~~
    3 | }
    4 |
fn test() bool {
	return 100
}

fn main() {}
vlib/v/checker/tests/shift_op_wrong_left_type_err.v:2:2: error: cannot shift type int into non-integer type f64
    1 | fn main() {
    2 |     0.5 << 1
      |     ~~~
    3 | }
fn main() {
	0.5 << 1
}vlib/v/checker/tests/shift_op_wrong_right_type_err.v:2:7: error: cannot shift non-integer type f64 into type int
    1 | fn main() {
    2 |     1 << 0.5
      |          ~~~
    3 | }
fn main() {
	1 << 0.5
}vlib/v/checker/tests/short_struct_too_many.v:6:7: error: too many fields
    4 |
    5 | fn main() {
    6 |     t := Test{true, false}
      |          ~~~~~~~~~~~~~~~~~
    7 |     _ = t
    8 | }
struct Test {
	foo bool
}

fn main() {
	t := Test{true, false}
	_ = t
}
vlib/v/checker/tests/struct_field_name_duplicate_err.v:3:2: error: field name `a` duplicate
    1 | struct A {
    2 |     a int
    3 |     a string
      |     ~~~~~~~~
    4 | }struct A {
	a int
	a string
}
vlib/v/checker/tests/struct_pub_field.v:9:4: error: field `i` of struct `A` is immutable
    7 |         i: 1
    8 |     }
    9 |     a.i = 2
      |       ^
   10 | }
struct A {
	i int
}

fn main() {
	a := A{
		i: 1
	}
	a.i = 2
}
vlib/v/checker/tests/struct_unknown_field.v:8:9: error: unknown field `bar` in struct literal of type `Test`
    6 |     t := Test{
    7 |         foo: true
    8 |         bar: false
      |         ~~~~~~~~~~
    9 |     }
   10 |      _ = t
struct Test {
	foo bool
}

fn main() {
	t := Test{
        foo: true
        bar: false
    }
	 _ = t
}
vlib/v/checker/tests/sum_type_exists.v:1:1: error: type `Nope` doesn't exist
    1 | type Miscellaneous = Nope | Inexistant | int
      | ~~~~~~~~~~~~~~~~~~
    2 |
    3 | fn main() {
type Miscellaneous = Nope | Inexistant | int

fn main() {

}
vlib/v/checker/tests/trailing_comma_struct_attr.v:3:31: error: unexpected `]`, expecting `name` 
    1 | struct User {
    2 |     name string
    3 |     jobs []string [json:jobss;]
      |                               ^
    4 | }struct User {
    name string
    jobs []string [json:jobss;]
}vlib/v/checker/tests/unexpected_or.v:6:7: error: unexpected `or` block, the function `ret_zero` does not return an optional
    4 |
    5 | fn main() {
    6 |     _ := ret_zero() or { 1 }
      |          ~~~~~~~~~~
    7 | }
fn ret_zero() int {
	return 0
}

fn main() {
	_ := ret_zero() or { 1 }
}
vlib/v/checker/tests/unexpected_or_propagate.v:6:7: error: unexpected `?`, the function `ret_zero`, does not return an optional
    4 |
    5 | fn opt_fn() ?int {
    6 |     a := ret_zero()?
      |          ~~~~~~~~~~
    7 |     return a
    8 | }
fn ret_zero() int {
	return 0
}

fn opt_fn() ?int {
	a := ret_zero()?
	return a
}

fn main() {
	opt_fn() or {}
}
vlib/v/checker/tests/unimplemented_interface_a.v:10:6: error: `Cat` doesn't implement method `name`
    8 |
    9 | fn main() {
   10 |     foo(Cat{})
      |         ~~~~~
   11 | }
interface Animal {
	name() string
}

struct Cat {}

fn foo(a Animal) {}

fn main() {
	foo(Cat{})
}
vlib/v/checker/tests/unimplemented_interface_b.v:13:6: error: `Cat` incorrectly implements method `name` of interface `Animal`, expected `name() string`
   11 | fn main() {
   12 |     c := Cat{}
   13 |     foo(c)
      |         ^
   14 | }
interface Animal {
	name() string
}

struct Cat {}

fn (c Cat) name() {}

fn foo(a Animal) {}

fn main() {
	c := Cat{}
	foo(c)
}
vlib/v/checker/tests/unimplemented_interface_c.v:12:6: error: `Cat` incorrectly implements method `name` of interface `Animal`, expected `name()`
   10 |
   11 | fn main() {
   12 |     foo(Cat{})
      |         ~~~~~
   13 | }
interface Animal {
	name()
}

struct Cat {}

fn (c Cat) name(s string) {}

fn foo(a Animal) {}

fn main() {
	foo(Cat{})
}
vlib/v/checker/tests/unimplemented_interface_d.v:12:6: error: `Cat` incorrectly implements method `speak` of interface `Animal`, expected `speak(s string)`
   10 |
   11 | fn main() {
   12 |     foo(Cat{})
      |         ~~~~~
   13 | }
interface Animal {
	speak(s string)
}

struct Cat {}

fn (c Cat) speak() {}

fn foo(a Animal) {}

fn main() {
	foo(Cat{})
}
vlib/v/checker/tests/unimplemented_interface_e.v:12:6: error: `Cat` incorrectly implements method `speak` of interface `Animal`, expected `speak(s string)`
   10 |
   11 | fn main() {
   12 |     foo(Cat{})
      |         ~~~~~
   13 | }
interface Animal {
	speak(s string)
}

struct Cat {}

fn (c Cat) speak(s &string) {}

fn foo(a Animal) {}

fn main() {
	foo(Cat{})
}
vlib/v/checker/tests/unimplemented_interface_f.v:11:13: error: `Cat` incorrectly implements method `speak` of interface `Animal`, expected `speak(s string)`
    9 | fn main() {
   10 |     mut animals := []Animal{}
   11 |     animals << Cat{}
      |                ~~~~~
   12 | }
interface Animal {
	speak(s string)
}

struct Cat {}

fn (c Cat) speak() {}

fn main() {
	mut animals := []Animal{}
	animals << Cat{}
}
vlib/v/checker/tests/unimplemented_interface_g.v:12:13: error: `Cat` incorrectly implements method `speak` of interface `Animal`, expected `speak(s string)`
   10 |     mut animals := []Animal{}
   11 |     mut cats := []Cat{}
   12 |     animals << cats
      |                ~~~~
   13 | }
   14 |
interface Animal {
	speak(s string)
}

struct Cat {}

fn (c Cat) speak() {}

fn main() {
	mut animals := []Animal{}
	mut cats := []Cat{}
	animals << cats
}

vlib/v/checker/tests/unknown_field.v:7:12: error: unknown field `Test.sdd`
    5 | fn main() {
    6 |     t := Test{}
    7 |     println(t.sdd)
      |               ~~~
    8 | }
module main

struct Test {}

fn main() {
	t := Test{}
	println(t.sdd)
}
vlib/v/checker/tests/unknown_method.v:7:12: error: unknown method: `Test.sdd`
    5 | fn main() {
    6 |     t := Test{}
    7 |     println(t.sdd())
      |               ~~~~~
    8 | }
module main

struct Test {}

fn main() {
	t := Test{}
	println(t.sdd())
}
vlib/v/checker/tests/unnecessary_parenthesis.v:2:2: error: unnecessary `()` in an if condition. use `if expr {` instead of `if (expr) {`.
    1 | fn main() {
    2 |     if (1 == 1) {
      |     ~~~~~~~~~~~
    3 |         println('yeay')
    4 |     } else if (1 == 2) {
vlib/v/checker/tests/unnecessary_parenthesis.v:4:4: error: unnecessary `()` in an if condition. use `if expr {` instead of `if (expr) {`.
    2 |     if (1 == 1) {
    3 |         println('yeay')
    4 |     } else if (1 == 2) {
      |       ~~~~~~~~~~~~~~~~
    5 |         println("oh no :'(")
    6 |     } else if (1 == 3) {
vlib/v/checker/tests/unnecessary_parenthesis.v:6:4: error: unnecessary `()` in an if condition. use `if expr {` instead of `if (expr) {`.
    4 |     } else if (1 == 2) {
    5 |         println("oh no :'(")
    6 |     } else if (1 == 3) {
      |       ~~~~~~~~~~~~~~~~
    7 |         println("what's wrong with physics ????")
    8 |     }
fn main() {
	if (1 == 1) {
		println('yeay')
	} else if (1 == 2) {
		println("oh no :'(")
	} else if (1 == 3) {
		println("what's wrong with physics ????")
	}
}
vlib/v/checker/tests/unreachable_code.v:3:7: error: unreachable code 
    1 | fn foo() int {
    2 |     return if 1 == 1 { 1 } else { 2 }
    3 |     a := 1
      |          ^
    4 |     println(a)
    5 | }
fn foo() int {
	return if 1 == 1 { 1 } else { 2 }
	a := 1
	println(a)
}
fn main() {
	foo()
}
vlib/v/checker/tests/var_eval_not_used.v:6:2: error: `c` evaluated but not used 
    4 | 
    5 | fn main() {
    6 |     c
      |     ^
    7 | }
const (
	c = 1
)

fn main() {
	c
}
vlib/v/checker/tests/var_eval_not_used_scope.v:7:3: error: `c` evaluated but not used 
    5 | fn main() {
    6 |     {
    7 |         c
      |         ^
    8 |     }
    9 | }
const (
	c = 1
)

fn main() {
	{
		c
	}
}
vlib/v/checker/tests/void_fn_as_value.v:5:8: error: unknown function: x
    3 | fn main() {
    4 |   mut a := 'aa'
    5 |   a += x('a','b')
      |        ~~~~~~~~~~
    6 |   mut b := 'abcdef'
    7 |   _ = b
module main

fn main() {
  mut a := 'aa'
  a += x('a','b')
  mut b := 'abcdef'
  _ = b
}
vlib/v/checker/tests/void_function_assign_to_string.v:6:6: error: cannot assign `void` to variable `a` of type `string`
    4 | fn main(){
    5 |     mut a := ''
    6 |     a = x(1,2) // hello
      |         ~~~~~~
    7 |     eprintln('a: $a')
    8 | }
fn x(x,y int) {

}
fn main(){
	mut a := ''
	a = x(1,2) // hello
	eprintln('a: $a')
}
vlib/v/checker/tests/wrong_propagate_ret_type.v:6:7: error: to propagate the optional call, `opt_call` must itself return an optional
    4 |
    5 | fn opt_call() int {
    6 |     a := ret_none()?
      |          ~~~~~~~~~~
    7 |     return a
    8 | }
fn ret_none() ?int {
	return none
}

fn opt_call() int {
	a := ret_none()?
	return a
}
vlib/v/checker/tests/globals/incorrect_name_global.v:1:1: error: global name `A` cannot contain uppercase letters, use snake_case instead
    1 | __global A := 1
      | ~~~~~~~~~~__global A := 1
vlib/v/checker/tests/run/assign_expr_unresolved_variables_err_chain.v:3:2: warning: unused variable: `b`
    1 | fn main() {
    2 |     a := b
    3 |     b := c
      |     ^
    4 |     c := a
    5 | }
vlib/v/checker/tests/run/assign_expr_unresolved_variables_err_chain.v:4:2: warning: unused variable: `c`
    2 |     a := b
    3 |     b := c
    4 |     c := a
      |     ^
    5 | }
vlib/v/checker/tests/run/assign_expr_unresolved_variables_err_chain.v:2:7: error: unresolved variable: `b`
    1 | fn main() {
    2 |     a := b
      |          ^
    3 |     b := c
    4 |     c := a
vlib/v/checker/tests/run/assign_expr_unresolved_variables_err_chain.v:3:7: error: unresolved variable: `c`
    1 | fn main() {
    2 |     a := b
    3 |     b := c
      |          ^
    4 |     c := a
    5 | }

fn main() {
	a := b
	b := c
	c := a
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
// Directed acyclic graph
// this implementation is specifically suited to ordering dependencies
module depgraph

struct DepGraphNode {
pub mut:
	name string
	deps []string
}

struct DepGraph {
pub mut:
	acyclic bool
	nodes   []DepGraphNode
}

struct OrderedDepMap {
mut:
	keys []string
	data map[string][]string
}

pub fn (mut o OrderedDepMap) set(name string, deps []string) {
	if name !in o.data {
		o.keys << name
	}
	o.data[name] = deps
}

pub fn (mut o OrderedDepMap) add(name string, deps []string) {
	mut d := o.data[name]
	for dep in deps {
		if dep !in d {
			d << dep
		}
		//
		else{}
	}
	o.set(name, d)
}

pub fn (o &OrderedDepMap) get(name string) []string {
	return o.data[name]
}

pub fn (mut o OrderedDepMap) delete(name string) {
	if name !in o.data {
		panic('delete: no such key: $name')
	}
	for i, _ in o.keys {
		if o.keys[i] == name {
			o.keys.delete(i)
			break
		}
	}
	o.data.delete(name)
}

pub fn (mut o OrderedDepMap) apply_diff(name string, deps []string) {
	mut diff := []string{}
	for dep in o.data[name] {
		if dep !in deps {
			diff << dep
		}
	}
	o.set(name, diff)
}

pub fn (o &OrderedDepMap) size() int {
	return o.data.size
}

pub fn new_dep_graph() &DepGraph {
	return &DepGraph{
		acyclic: true
	}
}

pub fn (mut graph DepGraph) add(mod string, deps []string) {
	graph.nodes << DepGraphNode{
		name: mod
		deps: deps.clone()
	}
}

pub fn (graph &DepGraph) resolve() &DepGraph {
	mut node_names := OrderedDepMap{}
	mut node_deps := OrderedDepMap{}
	for node in graph.nodes {
		node_names.add(node.name, node.deps)
		node_deps.add(node.name, node.deps)
	}
	mut resolved := new_dep_graph()
	for node_deps.size() != 0 {
		mut ready_set := []string{}
		for name in node_deps.keys {
			deps := node_deps.data[name]
			if deps.len == 0 {
				ready_set << name
			}
		}
		if ready_set.len == 0 {
			mut g := new_dep_graph()
			g.acyclic = false
			for name in node_deps.keys {
				g.add(name, node_names.data[name])
			}
			return g
		}
		for name in ready_set {
			node_deps.delete(name)
			resolved.add(name, node_names.data[name])
		}
		for name in node_deps.keys {
			node_deps.apply_diff(name, ready_set)
		}
	}
	return resolved
}

pub fn (graph &DepGraph) last_node() DepGraphNode {
	return graph.nodes[graph.nodes.len - 1]
}

pub fn (graph &DepGraph) display() string {
	mut out := '\n'
	for node in graph.nodes {
		for dep in node.deps {
			out += ' * $node.name -> $dep\n'
		}
	}
	return out
}

pub fn (graph &DepGraph) display_cycles() string {
	mut node_names := map[string]DepGraphNode
	for node in graph.nodes {
		node_names[node.name] = node
	}
	mut out := '\n'
	for node in graph.nodes {
		for dep in node.deps {
			if dep !in node_names {
				continue
			}
			dn := node_names[dep]
			if node.name in dn.deps {
				out += ' * $node.name -> $dep\n'
			}
		}
	}
	return out
}
module doc

import strings
import v.pref
import v.table
import v.parser
import v.ast
import os

struct Doc {
	out   strings.Builder
	table &table.Table
	mod   string
mut:
	stmts []ast.Stmt // all module statements from all files
}

type FilterFn = fn (node ast.FnDecl) bool

pub fn doc(mod string, table &table.Table, prefs &pref.Preferences) string {
	mut d := Doc{
		out: strings.new_builder(1000)
		table: table
		mod: mod
	}
	vlib_path := os.dir(pref.vexe_path()) + '/vlib'
	mod_path := mod.replace('.', os.path_separator)
	path := os.join_path(vlib_path, mod_path)
	if mod == '' || !os.exists(path) {
		if mod != '' {
			println('module "$mod" not found')
		}
		println('\navailable modules:')
		mut files := os.ls(vlib_path) or {
			return ''
		}
		files.sort()
		for file in files {
			println(file)
		}
		// println(path)
		return ''
	}
	// vfiles := os.walk_ext(path, '.v')
	files := os.ls(path) or {
		panic(err)
	}
	filtered_files := prefs.should_compile_filtered_files(path, files)
	for file in filtered_files {
		fscope := &ast.Scope{
			parent: 0
		}
		file_ast := parser.parse_file(file, table, .skip_comments, prefs, fscope)
		d.stmts << file_ast.stmts
	}
	if d.stmts.len == 0 {
		println('nothing here')
		exit(1)
	}
	d.print_structs()
	d.print_enums()
	d.print_fns()
	d.out.writeln('')
	d.print_methods()
	/*
	for stmt in file_ast.stmts {
		d.stmt(stmt)
	}
	println(path)
	*/
	return d.out.str().trim_space()
}

fn (d &Doc) get_fn_node(f ast.FnDecl) string {
	return f.str(d.table).replace_each([d.mod + '.', '', 'pub ', ''])
}

fn (mut d Doc) print_fns() {
	fn_signatures := d.get_fn_signatures(is_pub_function)
	d.write_fn_signatures(fn_signatures)
}

fn (mut d Doc) print_methods() {
	fn_signatures := d.get_fn_signatures(is_pub_method)
	d.write_fn_signatures(fn_signatures)
}

[inline]
fn (mut d Doc) write_fn_signatures(fn_signatures []string) {
	for s in fn_signatures {
		d.out.writeln(s)
	}
}

fn (d Doc) get_fn_signatures(filter_fn FilterFn) []string {
	mut fn_signatures := []string{}
	for stmt in d.stmts {
		match stmt {
			ast.FnDecl {
				if filter_fn(it) {
					fn_signatures << d.get_fn_node(it)
				}
			}
			else {}
		}
	}
	fn_signatures.sort()
	return fn_signatures
}

fn is_pub_method(node ast.FnDecl) bool {
	return node.is_pub && node.is_method && !node.is_deprecated
}

fn is_pub_function(node ast.FnDecl) bool {
	return node.is_pub && !node.is_method && !node.is_deprecated
}

// TODO it's probably better to keep using AST, not `table`
fn (mut d Doc) print_enums() {
	for typ in d.table.types {
		if typ.kind != .enum_ {
			continue
		}
		d.out.writeln('enum $typ.name {')
		info := typ.info as table.Enum
		for val in info.vals {
			d.out.writeln('\t$val')
		}
		d.out.writeln('}')
	}
}

fn (mut d Doc) print_structs() {
	for typ in d.table.types {
		if typ.kind != .struct_ || !typ.name.starts_with(d.mod + '.') {
			// !typ.name[0].is_capital() || typ.name.starts_with('C.') {
			continue
		}
		name := typ.name.after('.')
		d.out.writeln('struct $name {')
		info := typ.info as table.Struct
		for field in info.fields {
			sym := d.table.get_type_symbol(field.typ)
			d.out.writeln('\t$field.name $sym.name')
		}
		d.out.writeln('}\n')
	}
}
import v.table
import v.doc
import v.pref

fn test_vdoc() {
	mut prefs := &pref.Preferences{}
	prefs.fill_with_defaults()
	table := table.new_table()
	println(doc.doc('net', table, prefs))
}
module errors

import v.token

pub enum Reporter {
	scanner
	parser
	checker
	gen
}

pub struct Error {
pub:
	message   string
	file_path string
	pos       token.Position
	backtrace string
	reporter  Reporter
}

pub struct Warning {
pub:
	message   string
	file_path string
	pos       token.Position
	reporter  Reporter
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module eval

import v.ast
import v.checker
import v.table
import v.pref

pub type Object = int | string

pub struct Eval {
mut:
	checker checker.Checker
	vars    map[string]Var
	table   &table.Table
}

pub struct Var {
	value Object
}

pub fn (mut e Eval) eval(file ast.File, table &table.Table) string {
	vpref := &pref.Preferences{}
	e.table = table
	mut res := ''
	e.checker = checker.new_checker(table, vpref)
	for stmt in file.stmts {
		res += e.stmt(stmt) + '\n'
	}
	return res.trim_space()
}

fn print_object(o Object) {
	match o {
		int { println(it) }
		else { println('unknown object') }
	}
}

pub fn (o Object) str() string {
	match o {
		int { return it.str() }
		else { println('unknown object') }
	}
	return ''
}

fn (mut e Eval) stmt(node ast.Stmt) string {
	match node {
		ast.AssignStmt {
			// TODO; replaced VarDecl
		}
		ast.ExprStmt {
			o := e.expr(it.expr)
			print('out: ')
			print_object(o)
			return o.str()
		}
		// ast.StructDecl {
		//	println('s decl')
		// }
		// ast.VarDecl {
		//	e.vars[it.name] = Var{
		//		value: e.expr(it.expr)
		//	}
		// }
		else {}
	}
	return '>>'
}

fn (mut e Eval) expr(node ast.Expr) Object {
	match node {
		ast.IntegerLiteral {
			return it.val
		}
		ast.Ident {
			print_object(it.value)
			// Find the variable
			v := e.vars[it.name]
			return v.value
		}
		ast.InfixExpr {
			e.checker.infix_expr(mut it)
			// println('bin $it.op')
			left := e.expr(it.left) as int
			right := e.expr(it.right) as int
			match it.op {
				.plus { return left + right }
				.mul { return left * right }
				else {}
			}
		}
		else {}
	}
	return 0
	// return Object{}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module fmt

import v.ast
import v.table
import strings

const (
	tabs    = ['', '\t', '\t\t', '\t\t\t', '\t\t\t\t', '\t\t\t\t\t', '\t\t\t\t\t\t', '\t\t\t\t\t\t\t']
	max_len = 90
)

pub struct Fmt {
pub:
	out               strings.Builder
	out_imports       strings.Builder
	table             &table.Table
pub mut:
	indent            int
	empty_line        bool
	line_len          int
	single_line_if    bool
	cur_mod           string
	file              ast.File
	did_imports       bool
	is_assign         bool
	auto_imports      []string // automatically inserted imports that the user forgot to specify
	import_pos        int // position of the imports in the resulting string for later autoimports insertion
	used_imports      []string // to remove unused imports
	is_debug          bool
	mod2alias         map[string]string // for `import time as t`, will contain: 'time'=>'t'
	use_short_fn_args bool
}

pub fn fmt(file ast.File, table &table.Table, is_debug bool) string {
	mut f := Fmt{
		out: strings.new_builder(1000)
		out_imports: strings.new_builder(200)
		table: table
		indent: 0
		file: file
		is_debug: is_debug
	}
	for imp in file.imports {
		f.mod2alias[imp.mod.all_after_last('.')] = imp.alias
	}
	f.cur_mod = 'main'
	for stmt in file.stmts {
		if stmt is ast.Import {
			// Just remember the position of the imports for now
			f.import_pos = f.out.len
			// f.imports(f.file.imports)
		}
		f.stmt(stmt)
	}
	// for comment in file.comments { println('$comment.line_nr $comment.text')	}
	f.imports(f.file.imports) // now that we have all autoimports, handle them
	res := f.out.str().trim_space() + '\n'
	return res[..f.import_pos] + f.out_imports.str() + res[f.import_pos..] // + '\n'
}

/*
fn (f mut Fmt) find_comment(line_nr int) {
	for comment in f.file.comments {
		if comment.line_nr == line_nr {
			f.writeln('// FFF $comment.line_nr $comment.text')
			return
		}
	}
}
*/
pub fn (mut f Fmt) write(s string) {
	if f.indent > 0 && f.empty_line {
		if f.indent < tabs.len {
			f.out.write(tabs[f.indent])
		} else {
			// too many indents, do it the slow way:
			for _ in 0 .. f.indent {
				f.out.write('\t')
			}
		}
		f.line_len += f.indent * 4
	}
	f.out.write(s)
	f.line_len += s.len
	f.empty_line = false
}

pub fn (mut f Fmt) writeln(s string) {
	if f.indent > 0 && f.empty_line {
		// println(f.indent.str() + s)
		f.out.write(tabs[f.indent])
	}
	f.out.writeln(s)
	f.empty_line = true
	f.line_len = 0
}

pub fn (mut f Fmt) mod(mod ast.Module) {
	f.cur_mod = mod.name
	if mod.is_skipped {
		return
	}
	f.writeln('module $mod.name\n')
}

pub fn (mut f Fmt) imports(imports []ast.Import) {
	if f.did_imports || imports.len == 0 {
		return
	}
	// f.import_pos = f.out.len
	f.did_imports = true
	/*
	if imports.len == 1 {
		imp_stmt_str := f.imp_stmt_str(imports[0])
		f.out_imports.writeln('import ${imp_stmt_str}\n')
	} else if imports.len > 1 {
	*/
	// f.out_imports.writeln('import (')
	for imp in imports {
		if imp.mod !in f.used_imports {
			// TODO bring back once only unused imports are removed
			// continue
		}
		// f.out_imports.write('\t')
		// f.out_imports.writeln(f.imp_stmt_str(imp))
		f.out_imports.write('import ')
		f.out_imports.writeln(f.imp_stmt_str(imp))
	}
	f.out_imports.writeln('')
	// f.out_imports.writeln(')\n')
	// }
}

pub fn (f Fmt) imp_stmt_str(imp ast.Import) string {
	is_diff := imp.alias != imp.mod && !imp.mod.ends_with('.' + imp.alias)
	imp_alias_suffix := if is_diff { ' as ${imp.alias}' } else { '' }
	return '${imp.mod}${imp_alias_suffix}'
}

pub fn (mut f Fmt) stmts(stmts []ast.Stmt) {
	f.indent++
	for stmt in stmts {
		f.stmt(stmt)
	}
	f.indent--
}

pub fn (mut f Fmt) stmt(node ast.Stmt) {
	if f.is_debug {
		eprintln('stmt: ${node.position():-42} | node: ${typeof(node):-20}')
	}
	match node {
		ast.AssignStmt {
			for i, ident in it.left {
				var_info := ident.var_info()
				if var_info.is_mut {
					f.write('mut ')
				}
				f.expr(ident)
				if i < it.left.len - 1 {
					f.write(', ')
				}
			}
			f.is_assign = true
			f.write(' $it.op.str() ')
			for i, val in it.right {
				f.expr(val)
				if i < it.right.len - 1 {
					f.write(', ')
				}
			}
			if !f.single_line_if {
				f.writeln('')
			}
			f.is_assign = false
		}
		ast.AssertStmt {
			f.write('assert ')
			f.expr(it.expr)
			f.writeln('')
		}
		ast.Attr {
			f.writeln('[$it.name]')
		}
		ast.Block {
			f.writeln('{')
			f.stmts(it.stmts)
			f.writeln('}')
		}
		ast.BranchStmt {
			match it.tok.kind {
				.key_break { f.writeln('break') }
				.key_continue { f.writeln('continue') }
				else {}
			}
		}
		ast.Comment {
			f.comment(it)
		}
		ast.CompIf {
			inversion := if it.is_not { '!' } else { '' }
			is_opt := if it.is_opt { ' ?' } else { '' }
			f.writeln('\$if ${inversion}${it.val}${is_opt} {')
			f.stmts(it.stmts)
			if it.has_else {
				f.writeln('} \$else {')
				f.stmts(it.else_stmts)
			}
			f.writeln('}')
		}
		ast.ConstDecl {
			f.const_decl(it)
		}
		ast.DeferStmt {
			f.writeln('defer {')
			f.stmts(it.stmts)
			f.writeln('}')
		}
		ast.EnumDecl {
			if it.is_pub {
				f.write('pub ')
			}
			name := it.name.after('.')
			f.writeln('enum $name {')
			for field in it.fields {
				f.write('\t$field.name')
				if field.has_expr {
					f.write(' = ')
					f.expr(field.expr)
				}
				f.writeln('')
			}
			f.writeln('}\n')
		}
		ast.ExprStmt {
			f.expr(it.expr)
			if !f.single_line_if {
				f.writeln('')
			}
		}
		ast.FnDecl {
			f.fn_decl(it)
		}
		ast.ForCStmt {
			f.write('for ')
			if it.has_init {
				f.single_line_if = true // to keep all for ;; exprs on the same line
				f.stmt(it.init)
				f.single_line_if = false
			}
			f.write('; ')
			f.expr(it.cond)
			f.write('; ')
			f.expr(it.inc)
			f.writeln(' {')
			f.stmts(it.stmts)
			f.writeln('}')
		}
		ast.ForInStmt {
			f.write('for ')
			if it.key_var != '' {
				f.write(it.key_var)
			}
			if it.val_var != '' {
				if it.key_var != '' {
					f.write(', ')
				}
				f.write(it.val_var)
			}
			f.write(' in ')
			f.expr(it.cond)
			if it.is_range {
				f.write(' .. ')
				f.expr(it.high)
			}
			f.writeln(' {')
			f.stmts(it.stmts)
			f.writeln('}')
		}
		ast.ForStmt {
			f.write('for ')
			f.expr(it.cond)
			if it.is_inf {
				f.writeln('{')
			} else {
				f.writeln(' {')
			}
			f.stmts(it.stmts)
			f.writeln('}')
		}
		ast.GlobalDecl {
			f.write('__global $it.name ')
			f.write(f.type_to_str(it.typ))
			if it.has_expr {
				f.write(' = ')
				f.expr(it.expr)
			}
			f.writeln('')
		}
		ast.GoStmt {
			f.write('go ')
			f.expr(it.call_expr)
			f.writeln('')
		}
		ast.GotoLabel {
			f.writeln('$it.name:')
		}
		ast.GotoStmt {
			f.writeln('goto $it.name')
		}
		ast.HashStmt {
			f.writeln('#$it.val')
		}
		ast.Import {
			// Imports are handled after the file is formatted, to automatically add necessary modules
			// f.imports(f.file.imports)
		}
		ast.InterfaceDecl {
			f.writeln('interface $it.name {')
			for method in it.methods {
				f.write('\t')
				f.writeln(method.str(f.table).after('fn '))
			}
			f.writeln('}\n')
		}
		ast.Module {
			f.mod(it)
		}
		ast.Return {
			f.write('return')
			if it.exprs.len > 1 {
				// multiple returns
				f.write(' ')
				for i, expr in it.exprs {
					f.expr(expr)
					if i < it.exprs.len - 1 {
						f.write(', ')
					}
				}
			} else if it.exprs.len == 1 {
				// normal return
				f.write(' ')
				f.expr(it.exprs[0])
			}
			f.writeln('')
		}
		ast.StructDecl {
			f.struct_decl(it)
		}
		ast.TypeDecl {
			// already handled in f.imports
			f.type_decl(it)
		}
		ast.UnsafeStmt {
			f.writeln('unsafe {')
			f.stmts(it.stmts)
			f.writeln('}')
		}
		ast.ComptimeCall {}
	}
}

pub fn (mut f Fmt) type_decl(node ast.TypeDecl) {
	match node {
		ast.AliasTypeDecl {
			if it.is_pub {
				f.write('pub ')
			}
			ptype := f.type_to_str(it.parent_type)
			f.write('type $it.name $ptype')
		}
		ast.FnTypeDecl {
			if it.is_pub {
				f.write('pub ')
			}
			typ_sym := f.table.get_type_symbol(it.typ)
			fn_typ_info := typ_sym.info as table.FnType
			fn_info := fn_typ_info.func
			fn_name := it.name.replace(f.cur_mod + '.', '')
			f.write('type $fn_name = fn (')
			for i, arg in fn_info.args {
				f.write(arg.name)
				mut s := f.table.type_to_str(arg.typ)
				if arg.is_mut {
					f.write('mut ')
					if s.starts_with('&') {
						s = s[1..]
					}
				}
				is_last_arg := i == fn_info.args.len - 1
				should_add_type := is_last_arg || fn_info.args[i + 1].typ != arg.typ || (fn_info.is_variadic &&
					i == fn_info.args.len - 2)
				if should_add_type {
					if fn_info.is_variadic && is_last_arg {
						f.write(' ...' + s)
					} else {
						f.write(' ' + s)
					}
				}
				if !is_last_arg {
					f.write(', ')
				}
			}
			f.write(')')
			if fn_info.return_type.idx() != table.void_type_idx {
				ret_str := f.table.type_to_str(fn_info.return_type)
				f.write(' ' + ret_str)
			}
		}
		ast.SumTypeDecl {
			if it.is_pub {
				f.write('pub ')
			}
			f.write('type $it.name = ')
			mut sum_type_names := []string{}
			for t in it.sub_types {
				sum_type_names << f.type_to_str(t)
			}
			sum_type_names.sort()
			for i, name in sum_type_names {
				f.write(name)
				if i < sum_type_names.len - 1 {
					f.write(' | ')
				}
				f.wrap_long_line()
			}
			// f.write(sum_type_names.join(' | '))
		}
	}
	f.writeln('\n')
}

pub fn (mut f Fmt) struct_decl(node ast.StructDecl) {
	if node.is_pub {
		f.write('pub ')
	}
	name := node.name.after('.')
	f.writeln('struct $name {')
	mut max := 0
	for field in node.fields {
		if field.name.len > max {
			max = field.name.len
		}
	}
	for i, field in node.fields {
		if i == node.mut_pos {
			f.writeln('mut:')
		} else if i == node.pub_pos {
			f.writeln('pub:')
		} else if i == node.pub_mut_pos {
			f.writeln('pub mut:')
		}
		if field.comment.text != '' && field.comment.pos.line_nr < field.pos.line_nr {
			// Comment on the previous line
			f.write('\t')
			f.comment(field.comment)
		}
		f.write('\t$field.name ')
		f.write(strings.repeat(` `, max - field.name.len))
		f.write(f.type_to_str(field.typ))
		if field.has_default_expr {
			f.write(' = ')
			f.expr(field.default_expr)
		}
		// f.write('// $field.pos.line_nr')
		if field.comment.text != '' && field.comment.pos.line_nr == field.pos.line_nr {
			// Same line comment
			f.write('  ')
			f.comment(field.comment)
		} else {
			// if field.comment.text != '' {
			// f.write (' // com linenr=$field.comment.pos.line_nr')
			// }
			f.writeln('')
		}
	}
	f.writeln('}\n')
}

fn (f &Fmt) type_to_str(t table.Type) string {
	mut res := f.table.type_to_str(t)
	if res.ends_with('_ptr') {
		// type_ptr => &type
		res = res[0..res.len - 4]
		start_pos := 2 * res.count('[]')
		res = res[0..start_pos] + '&' + res[start_pos..res.len]
	}
	return res.replace(f.cur_mod + '.', '')
}

pub fn (mut f Fmt) expr(node ast.Expr) {
	if f.is_debug {
		eprintln('expr: ${node.position():-42} | node: ${typeof(node):-20} | ${node.str()}')
	}
	match node {
		ast.AnonFn {
			f.fn_decl(it.decl)
		}
		ast.ArrayInit {
			f.array_init(it)
		}
		ast.AsCast {
			type_str := f.type_to_str(it.typ)
			f.expr(it.expr)
			f.write(' as $type_str')
		}
		ast.AssignExpr {
			f.expr(it.left)
			f.write(' $it.op.str() ')
			f.expr(it.val)
		}
		ast.Assoc {
			f.writeln('{')
			// f.indent++
			f.writeln('\t$it.var_name |')
			// TODO StructInit copy pasta
			for i, field in it.fields {
				f.write('\t$field: ')
				f.expr(it.exprs[i])
				f.writeln('')
			}
			// f.indent--
			f.write('}')
		}
		ast.BoolLiteral {
			f.write(it.val.str())
		}
		ast.CastExpr {
			f.write(f.type_to_str(it.typ) + '(')
			f.expr(it.expr)
			f.write(')')
		}
		ast.CallExpr {
			f.call_expr(it)
		}
		ast.CharLiteral {
			f.write('`$it.val`')
		}
		ast.ConcatExpr {
			for i, val in it.vals {
				if i != 0 {
					f.write(' + ')
				}
				f.expr(val)
			}
		}
		ast.EnumVal {
			name := f.short_module(it.enum_name)
			f.write(name + '.' + it.val)
		}
		ast.FloatLiteral {
			f.write(it.val)
		}
		ast.IfExpr {
			f.if_expr(it)
		}
		ast.Ident {
			if it.kind == .blank_ident {
				f.write('_')
			} else {
				name := f.short_module(it.name)
				// f.write('<$it.name => $name>')
				f.write(name)
				if name.contains('.') {
					f.mark_module_as_used(name)
				}
			}
		}
		ast.IfGuardExpr {
			f.write(it.var_name + ' := ')
			f.expr(it.expr)
		}
		ast.InfixExpr {
			f.expr(it.left)
			f.write(' $it.op.str() ')
			f.wrap_long_line()
			f.expr(it.right)
		}
		ast.IndexExpr {
			f.expr(it.left)
			f.write('[')
			f.expr(it.index)
			f.write(']')
		}
		ast.IntegerLiteral {
			f.write(it.val)
		}
		ast.MapInit {
			if it.keys.len == 0 {
				if it.value_type == 0 {
					typ_sym := f.table.get_type_symbol(it.typ)
					minfo := typ_sym.info as table.Map
					mk := f.table.get_type_symbol(minfo.key_type).name
					mv := f.table.get_type_symbol(minfo.value_type).name
					f.write('map[${mk}]${mv}{}')
					return
				}
				f.write('map[')
				f.write(f.type_to_str(it.key_type))
				f.write(']')
				f.write(f.type_to_str(it.value_type))
				return
			}
			f.writeln('{')
			f.indent++
			for i, key in it.keys {
				f.expr(key)
				// f.write(strings.repeat(` `, max - field.name.len))
				f.write(': ')
				f.expr(it.vals[i])
				f.writeln('')
			}
			f.indent--
			f.write('}')
		}
		ast.MatchExpr {
			f.match_expr(it)
		}
		ast.None {
			f.write('none')
		}
		ast.OrExpr {
			// shouldn't happen, an or expression
			// is always linked to a call expr
			panic('fmt: OrExpr should to linked to CallExpr')
		}
		ast.ParExpr {
			f.write('(')
			f.expr(it.expr)
			f.write(')')
		}
		ast.PostfixExpr {
			f.expr(it.expr)
			f.write(it.op.str())
		}
		ast.PrefixExpr {
			f.write(it.op.str())
			f.expr(it.right)
		}
		ast.RangeExpr {
			f.expr(it.low)
			f.write('..')
			f.expr(it.high)
		}
		ast.SelectorExpr {
			f.expr(it.expr)
			f.write('.')
			f.write(it.field_name)
		}
		ast.SizeOf {
			f.write('sizeof(')
			if it.type_name != '' {
				f.write(it.type_name)
			} else {
				f.write(f.type_to_str(it.typ))
			}
			f.write(')')
		}
		ast.StringLiteral {
			if it.val.contains("'") && !it.val.contains('"') {
				f.write('"$it.val"')
			} else {
				f.write("'$it.val'")
			}
		}
		ast.StringInterLiteral {
			f.write("'")
			for i, val in it.vals {
				f.write(val)
				if i >= it.exprs.len {
					continue
				}
				f.write('$')
				if it.expr_fmts[i].len > 0 {
					f.write('{')
					f.expr(it.exprs[i])
					f.write(it.expr_fmts[i])
					f.write('}')
				} else {
					f.expr(it.exprs[i])
				}
			}
			f.write("'")
		}
		ast.StructInit {
			f.struct_init(it)
		}
		ast.Type {
			f.write(f.type_to_str(it.typ))
		}
		ast.TypeOf {
			f.write('typeof(')
			f.expr(it.expr)
			f.write(')')
		}
	}
}

pub fn (mut f Fmt) wrap_long_line() bool {
	if f.line_len <= max_len {
		return false
	}
	if f.out.buf[f.out.buf.len - 1] == ` ` {
		f.out.go_back(1)
	}
	f.write('\n' + tabs[f.indent + 1])
	f.line_len = 0
	return true
}

pub fn (mut f Fmt) call_args(args []ast.CallArg) {
	for i, arg in args {
		if arg.is_mut {
			f.write('mut ')
		}
		if i > 0 {
			f.wrap_long_line()
		}
		f.expr(arg.expr)
		if i < args.len - 1 {
			f.write(', ')
		}
	}
}

pub fn (mut f Fmt) or_expr(or_block ast.OrExpr) {
	match or_block.kind {
		.absent {}
		.block {
			f.writeln(' or {')
			f.stmts(or_block.stmts)
			f.write('}')
		}
		.propagate {
			f.write('?')
		}
	}
}

pub fn (mut f Fmt) comment(node ast.Comment) {
	if !node.text.contains('\n') {
		is_separate_line := node.text.starts_with('|')
		mut s := if is_separate_line { node.text[1..] } else { node.text }
		if s == '' {
			s = '//'
		} else {
			s = '// ' + s
		}
		if !is_separate_line {
			f.remove_new_line() // delete the generated \n
			f.write(' ')
		}
		f.writeln(s)
		return
	}
	lines := node.text.split_into_lines()
	f.writeln('/*')
	for line in lines {
		f.writeln(line)
		f.empty_line = false
	}
	f.empty_line = true
	f.writeln('*/')
}

pub fn (mut f Fmt) fn_decl(node ast.FnDecl) {
	// println('$it.name find_comment($it.pos.line_nr)')
	// f.find_comment(it.pos.line_nr)
	s := node.str(f.table)
	f.write(s.replace(f.cur_mod + '.', '')) // `Expr` instead of `ast.Expr` in mod ast
	if node.language == .v {
		f.writeln(' {')
		f.stmts(node.stmts)
		f.write('}')
		if !node.is_anon {
			f.writeln('\n')
		}
	} else {
		f.writeln('\n')
	}
	// Mark all function's used type so that they are not removed from imports
	for arg in node.args {
		f.mark_types_module_as_used(arg.typ)
	}
	f.mark_types_module_as_used(node.return_type)
}

// foo.bar.fn() => bar.fn()
pub fn (mut f Fmt) short_module(name string) string {
	if !name.contains('.') {
		return name
	}
	vals := name.split('.')
	if vals.len < 2 {
		return name
	}
	mname := vals[vals.len - 2]
	symname := vals[vals.len - 1]
	aname := f.mod2alias[mname]
	if aname == '' {
		return symname
	}
	return '${aname}.${symname}'
}

pub fn (mut f Fmt) if_expr(it ast.IfExpr) {
	single_line := it.branches.len == 2 && it.has_else && it.branches[0].stmts.len == 1 &&
		it.branches[1].stmts.len == 1 && (it.is_expr || f.is_assign)
	f.single_line_if = single_line
	for i, branch in it.branches {
		if branch.comment.text != '' {
			f.comment(branch.comment)
		}
		if i == 0 {
			f.write('if ')
			f.expr(branch.cond)
			f.write(' {')
		} else if i < it.branches.len - 1 || !it.has_else {
			f.write('} else if ')
			f.expr(branch.cond)
			f.write(' {')
		} else if i == it.branches.len - 1 && it.has_else {
			f.write('} else {')
		}
		if single_line {
			f.write(' ')
		} else {
			f.writeln('')
		}
		f.stmts(branch.stmts)
		if single_line {
			f.write(' ')
		}
	}
	f.write('}')
	f.single_line_if = false
}

pub fn (mut f Fmt) call_expr(node ast.CallExpr) {
	/*
	if node.args.len == 1 && node.expected_arg_types.len == 1 && node.args[0].expr is ast.StructInit &&
		node.args[0].typ == node.expected_arg_types[0] {
		// struct_init := node.args[0].expr as ast.StructInit
		// if struct_init.typ == node.args[0].typ {
		f.use_short_fn_args = true
		// }
	}
	*/
	if node.is_method {
		if node.left is ast.Ident {
			it := node.left as ast.Ident
			// `time.now()` without `time imported` is processed as a method call with `time` being
			// a `node.left` expression. Import `time` automatically.
			// TODO fetch all available modules
			if it.name in ['time', 'os', 'strings', 'math', 'json', 'base64'] {
				if it.name !in f.auto_imports {
					f.auto_imports << it.name
					f.file.imports << ast.Import{
						mod: it.name
						alias: it.name
					}
				}
				// for imp in f.file.imports {
				// println(imp.mod)
				// }
			}
		}
		f.expr(node.left)
		f.write('.' + node.name + '(')
		f.call_args(node.args)
		f.write(')')
		f.or_expr(node.or_block)
	} else {
		if node.language == .c {
			f.write('C.')
		}
		name := f.short_module(node.name)
		f.mark_module_as_used(name)
		f.write('${name}')
		if node.generic_type != 0 && node.generic_type != table.void_type {
			f.write('<')
			f.write(f.type_to_str(node.generic_type))
			f.write('>')
		}
		f.write('(')
		f.call_args(node.args)
		f.write(')')
		f.or_expr(node.or_block)
	}
	f.use_short_fn_args = false
}

pub fn (mut f Fmt) match_expr(it ast.MatchExpr) {
	f.write('match ')
	if it.is_mut {
		f.write('mut ')
	}
	f.expr(it.cond)
	f.writeln(' {')
	f.indent++
	mut single_line := true
	for branch in it.branches {
		if branch.stmts.len > 1 {
			single_line = false
			break
		}
		if branch.stmts.len == 0 {
			continue
		}
		stmt := branch.stmts[0]
		if stmt is ast.ExprStmt {
			// If expressions inside match branches can't be one a single line
			expr_stmt := stmt as ast.ExprStmt
			if !expr_is_single_line(expr_stmt.expr) {
				single_line = false
				break
			}
		} else if stmt is ast.Comment {
			single_line = false
			break
		}
	}
	for branch in it.branches {
		if branch.comment.text != '' {
			f.comment(branch.comment)
		}
		if !branch.is_else {
			// normal branch
			for j, expr in branch.exprs {
				f.expr(expr)
				if j < branch.exprs.len - 1 {
					f.write(', ')
				}
			}
		} else {
			// else branch
			f.write('else')
		}
		if branch.stmts.len == 0 {
			f.writeln(' {}')
		} else {
			if single_line {
				f.write(' { ')
			} else {
				f.writeln(' {')
			}
			f.stmts(branch.stmts)
			if single_line {
				f.remove_new_line()
				f.writeln(' }')
			} else {
				f.writeln('}')
			}
		}
	}
	f.indent--
	f.write('}')
}

pub fn (mut f Fmt) remove_new_line() {
	mut i := 0
	for i = f.out.len - 1; i >= 0; i-- {
		if !f.out.buf[i].is_space() { // != `\n` {
			break
		}
	}
	f.out.go_back(f.out.len - i - 1)
	f.empty_line = false
	// f.writeln('sdf')
}

pub fn (mut f Fmt) mark_types_module_as_used(typ table.Type) {
	sym := f.table.get_type_symbol(typ)
	f.mark_module_as_used(sym.name)
}

// `name` is a function (`foo.bar()`) or type (`foo.Bar{}`)
pub fn (mut f Fmt) mark_module_as_used(name string) {
	if !name.contains('.') {
		return
	}
	pos := name.last_index('.') or {
		0
	}
	mod := name[..pos]
	if mod in f.used_imports {
		return
	}
	f.used_imports << mod
	// println('marking module $mod as used')
}

fn expr_is_single_line(expr ast.Expr) bool {
	match expr {
		ast.IfExpr { return false }
		else {}
	}
	return true
}

pub fn (mut f Fmt) array_init(it ast.ArrayInit) {
	if it.exprs.len == 0 && it.typ != 0 && it.typ != table.void_type {
		// `x := []string`
		typ_sym := f.table.get_type_symbol(it.typ)
		if typ_sym.kind == .array && typ_sym.name.starts_with('array_map') {
			ainfo := typ_sym.info as table.Array
			map_typ_sym := f.table.get_type_symbol(ainfo.elem_type)
			minfo := map_typ_sym.info as table.Map
			mk := f.table.get_type_symbol(minfo.key_type).name
			mv := f.table.get_type_symbol(minfo.value_type).name
			for _ in 0 .. ainfo.nr_dims {
				f.write('[]')
			}
			f.write('map[${mk}]${mv}')
			f.write('{')
			if it.has_len {
				f.write('len: ')
				f.expr(it.len_expr)
			}
			if it.has_cap {
				f.write('cap: ')
				f.expr(it.cap_expr)
			}
			if it.has_default {
				f.write('init: ')
				f.expr(it.default_expr)
			}
			f.write('}')
			return
		}
		f.write(f.type_to_str(it.typ))
		f.write('{')
		// TODO copypasta
		if it.has_len {
			f.write('len: ')
			f.expr(it.len_expr)
			if it.has_cap || it.has_default {
				f.write(', ')
			}
		}
		if it.has_cap {
			f.write('cap: ')
			f.expr(it.cap_expr)
			if it.has_default {
				f.write(', ')
			}
		}
		if it.has_default {
			f.write('init: ')
			f.expr(it.default_expr)
		}
		f.write('}')
		return
	}
	// `[1,2,3]`
	// type_sym := f.table.get_type_symbol(it.typ)
	f.write('[')
	mut inc_indent := false
	mut last_line_nr := it.pos.line_nr // to have the same newlines between array elements
	for i, expr in it.exprs {
		line_nr := expr.position().line_nr
		if last_line_nr < line_nr {
			if !inc_indent {
				f.indent++
				inc_indent = true
			}
			f.writeln('')
		}
		is_new_line := last_line_nr < line_nr || f.wrap_long_line()
		if !is_new_line && i > 0 {
			f.write(' ')
		}
		f.expr(expr)
		if i == it.exprs.len - 1 {
			if is_new_line {
				f.writeln('')
			}
		} else {
			f.write(',')
		}
		last_line_nr = line_nr
	}
	if inc_indent {
		f.indent--
	}
	f.write(']')
	// `[100]byte`
	if it.is_fixed {
		f.write(f.type_to_str(it.elem_type))
	}
}

pub fn (mut f Fmt) struct_init(it ast.StructInit) {
	type_sym := f.table.get_type_symbol(it.typ)
	// f.write('<old name: $type_sym.name>')
	mut name := f.short_module(type_sym.name).replace(f.cur_mod + '.', '') // TODO f.type_to_str?
	if name == 'void' {
		name = ''
	}
	if it.fields.len == 0 {
		// `Foo{}` on one line if there are no fields
		f.write('$name{}')
	} else if it.is_short {
		// `Foo{1,2,3}` (short syntax )
		// if name != '' {
		f.write('$name{')
		// }
		for i, field in it.fields {
			f.expr(field.expr)
			if i < it.fields.len - 1 {
				f.write(', ')
			}
		}
		f.write('}')
	} else {
		if f.use_short_fn_args {
			f.writeln('')
		} else {
			f.writeln('$name{')
		}
		f.indent++
		for field in it.fields {
			f.write('$field.name: ')
			f.expr(field.expr)
			f.writeln('')
		}
		f.indent--
		if !f.use_short_fn_args {
			f.write('}')
		}
	}
}

pub fn (mut f Fmt) const_decl(it ast.ConstDecl) {
	if it.is_pub {
		f.write('pub ')
	}
	f.writeln('const (')
	mut max := 0
	for field in it.fields {
		if field.name.len > max {
			max = field.name.len
		}
	}
	f.indent++
	for field in it.fields {
		if field.comment.text != '' {
			f.comment(field.comment)
			// f.writeln('// ' + field.comment.text)
		}
		name := field.name.after('.')
		f.write('$name ')
		f.write(strings.repeat(` `, max - field.name.len))
		f.write('= ')
		f.expr(field.expr)
		f.writeln('')
	}
	f.indent--
	f.writeln(')\n')
}
import os
import term
import benchmark
import v.ast
import v.fmt
import v.parser
import v.table
import v.pref
import v.util

const (
	error_missing_vexe = 1
	error_failed_tests = 2
)

fn test_fmt() {
	fmt_message := 'checking that v fmt keeps already formatted files *unchanged*'
	eprintln(term.header(fmt_message, '-'))
	vexe := os.getenv('VEXE')
	if vexe.len == 0 || !os.exists(vexe) {
		eprintln('VEXE must be set')
		exit(error_missing_vexe)
	}
	vroot := os.dir(vexe)
	tmpfolder := os.temp_dir()
	diff_cmd := util.find_working_diff_command() or {
		''
	}
	mut fmt_bench := benchmark.new_benchmark()
	keep_input_files := os.walk_ext('$vroot/vlib/v/fmt/tests', '_keep.vv')
	expected_input_files := os.walk_ext('$vroot/vlib/v/fmt/tests', '_expected.vv')
	mut input_files := []string{}
	input_files << keep_input_files
	input_files << expected_input_files
	fmt_bench.set_total_expected_steps(input_files.len)
	for istep, ipath in input_files {
		fmt_bench.cstep = istep
		fmt_bench.step()
		ifilename := os.file_name(ipath)
		opath := ipath
		expected_ocontent := os.read_file(opath) or {
			fmt_bench.fail()
			eprintln(fmt_bench.step_message_fail('cannot read from ${opath}'))
			continue
		}
		table := table.new_table()
		file_ast := parser.parse_file(ipath, table, .parse_comments, &pref.Preferences{}, &ast.Scope{
			parent: 0
		})
		result_ocontent := fmt.fmt(file_ast, table, false)
		if expected_ocontent != result_ocontent {
			fmt_bench.fail()
			eprintln(fmt_bench.step_message_fail('file ${ipath} after formatting, does not look as expected.'))
			if diff_cmd == '' {
				eprintln('>> sorry, but no working "diff" CLI command can be found')
				continue
			}
			vfmt_result_file := os.join_path(tmpfolder, 'vfmt_run_over_${ifilename}')
			os.write_file(vfmt_result_file, result_ocontent)
			eprintln(util.color_compare_files(diff_cmd, opath, vfmt_result_file))
			continue
		}
		fmt_bench.ok()
		eprintln(fmt_bench.step_message_ok('${ipath}'))
	}
	fmt_bench.stop()
	eprintln(term.h_divider('-'))
	eprintln(fmt_bench.total_message(fmt_message))
	if fmt_bench.nfail > 0 {
		exit(error_failed_tests)
	}
}
import os
import term
import benchmark
import v.ast
import v.fmt
import v.parser
import v.table
import v.pref
import v.util

const (
	error_missing_vexe = 1
	error_failed_tests = 2
)

fn test_fmt() {
	fmt_message := 'vfmt tests'
	eprintln(term.header(fmt_message, '-'))
	vexe := os.getenv('VEXE')
	if vexe.len == 0 || !os.exists(vexe) {
		eprintln('VEXE must be set')
		exit(error_missing_vexe)
	}
	vroot := os.dir(vexe)
	tmpfolder := os.temp_dir()
	diff_cmd := util.find_working_diff_command() or { '' }
	mut fmt_bench := benchmark.new_benchmark()
	// Lookup the existing test _input.vv files:
	input_files := os.walk_ext('$vroot/vlib/v/fmt/tests', '_input.vv')
	fmt_bench.set_total_expected_steps(input_files.len)
	for istep, ipath in input_files {
		fmt_bench.cstep = istep
		fmt_bench.step()
		ifilename := os.file_name(ipath)
		opath := ipath.replace('_input.vv', '_expected.vv')
		if !os.exists(opath) {
			fmt_bench.fail()
			eprintln(fmt_bench.step_message_fail('missing file ${opath}'))
			continue
		}
		expected_ocontent := os.read_file(opath) or {
			fmt_bench.fail()
			eprintln(fmt_bench.step_message_fail('cannot read from ${opath}'))
			continue
		}
		table := table.new_table()
		file_ast := parser.parse_file(ipath, table, .parse_comments, &pref.Preferences{}, &ast.Scope{
			parent: 0
		})
		result_ocontent := fmt.fmt(file_ast, table, false)
		if expected_ocontent != result_ocontent {
			fmt_bench.fail()
			eprintln(fmt_bench.step_message_fail('file ${ipath} after formatting, does not look as expected.'))
			if diff_cmd == '' {
				eprintln('>> sorry, but no working "diff" CLI command can be found')
				continue
			}
			vfmt_result_file := os.join_path(tmpfolder, 'vfmt_run_over_${ifilename}')
			os.write_file(vfmt_result_file, result_ocontent)
            eprintln(util.color_compare_files(diff_cmd, opath, vfmt_result_file))
			continue
		}
		fmt_bench.ok()
		eprintln(fmt_bench.step_message_ok('${ipath}'))
	}
	fmt_bench.stop()
	eprintln(term.h_divider('-'))
	eprintln(fmt_bench.total_message(fmt_message))
	if fmt_bench.nfail > 0 {
		exit(error_failed_tests)
	}
}
import os
import term
import benchmark
import v.ast
import v.fmt
import v.parser
import v.table
import v.pref
import v.util

const (
	error_missing_vexe = 1
	error_failed_tests = 2
)

fn test_vlib_fmt() {
	$if !freebsd {
		return
	}
	fmt_message := "checking that all V source files are vfmt'ed"
	eprintln(term.header(fmt_message, '-'))
	vexe := os.getenv('VEXE')
	if vexe.len == 0 || !os.exists(vexe) {
		eprintln('VEXE must be set')
		exit(error_missing_vexe)
	}
	vroot := os.dir(vexe)
	tmpfolder := os.temp_dir()
	diff_cmd := util.find_working_diff_command() or {
		''
	}
	mut fmt_bench := benchmark.new_benchmark()
	input_files := os.walk_ext('$vroot/vlib/v/', '.v')
	fmt_bench.set_total_expected_steps(input_files.len)
	for istep, ipath in input_files {
		fmt_bench.cstep = istep
		fmt_bench.step()
		ifilename := os.file_name(ipath)
		opath := ipath
		expected_ocontent := os.read_file(opath) or {
			fmt_bench.fail()
			eprintln(fmt_bench.step_message_fail('cannot read from ${opath}'))
			continue
		}
		table := table.new_table()
		file_ast := parser.parse_file(ipath, table, .parse_comments, &pref.Preferences{}, &ast.Scope{
			parent: 0
		})
		result_ocontent := fmt.fmt(file_ast, table, false)
		if expected_ocontent != result_ocontent {
			fmt_bench.fail()
			eprintln(fmt_bench.step_message_fail('file ${ipath} after formatting, does not look as expected.'))
			if diff_cmd == '' {
				eprintln('>> sorry, but no working "diff" CLI command can be found')
				continue
			}
			vfmt_result_file := os.join_path(tmpfolder, 'vfmt_run_over_${ifilename}')
			os.write_file(vfmt_result_file, result_ocontent)
			eprintln(util.color_compare_files(diff_cmd, opath, vfmt_result_file))
			continue
		}
		fmt_bench.ok()
		eprintln(fmt_bench.step_message_ok('${ipath}'))
	}
	fmt_bench.stop()
	eprintln(term.h_divider('-'))
	eprintln(fmt_bench.total_message(fmt_message))
	if fmt_bench.nfail > 0 {
		exit(error_failed_tests)
	}
}
fn has_anon_fn() {
	an_fn := fn () {
		println('Hello there !')
	}
	an_fn_w_param := fn (s string) {
		println('I received $s')
	}
	an_fn_w_multi_params := fn (s1, s2, s3 string) {
		println('I received $s1, $s2, $s3')
	}
	an_fn_w_multi_params2 := fn (s string, i int) {
		println('I received $s, $i')
	}
	fn_w_var_args := fn (ss ...string) {
		for s in ss {
			println('yo $s')
		}
	}
	an_fn()
	an_fn_w_param('a gift')
	an_fn_w_multi_params('one', 'two', 'three')
	an_fn_w_multi_params2('one', 1)
	fn_w_var_args('one arg', 'two args', 'three args')
}
fn has_anon_fn() {
	an_fn := fn() {
		println('Hello there !')
	}
  an_fn_w_param := fn   ( s string )
  {
		println('I received $s')
	}
	  an_fn_w_multi_params := fn (s1, s2, s3 string) {
			println('I received $s1, $s2, $s3')
	}
	an_fn_w_multi_params2 :=fn	(s string, i int)    {
	    println('I received $s, $i')
	}
	fn_w_var_args := fn (ss ...string) {
		for s in ss {
			println('yo $s')
		}
	}  an_fn()
	  an_fn_w_param('a gift') an_fn_w_multi_params('one', 'two', 'three')
   an_fn_w_multi_params2(  'one',   1)
        fn_w_var_args('one arg', 'two args', 'three args')
}
fn make_flag(a, b, c string) string {
	return ''
}

fn main() {
	// Set up flags
	expected_flags := [
		make_flag('solaris', '-L', '/opt/local/lib'),
		make_flag('darwin', '-framework', 'Cocoa'),
		make_flag('windows', '-l', 'gdi32')
	]
	x := []int{len: 10, cap: 100, init: 1}
	_ := expected_flags
	buf := [100]byte
	println(x)
	println(buf)
}
fn fn_contains_index_expr() {
	arr := [1, 2, 3, 4, 5]
	a := 1 in arr[0..]
	_ := a
	_ := 1 in arr[..2]
	_ := 1 in arr[1..3]
	d := arr[2]
	_ := d
	_ := arr[2..]
	_ := arr[..2]
	_ := arr[1..3]
}


fn    fn_contains_index_expr()  {
 arr := [1, 2, 3, 4,   5]
    a := 1 in arr[ 0.. ]
_ := a
  _  := 1  in arr[ ..2  ]
      _ := 1 in arr[1..3]
   d :=  arr[2]
     _ := d
     _ := arr[2 ..]
 _ := arr[.. 2 ]
   _ := arr[ 1 .. 3]
}
fn test_abc() {
	assert 2 < 3
	assert 2 == 2
	assert 'abc' == 'abc'
	assert 'abc'.len == 3
}
fn unsafe_fn() {
	unsafe {
		malloc(2)
	}
}

fn fn_with_defer() {
	defer {
		voidfn()
	}
}
fn unsafe_fn() {
unsafe { malloc(2) }
}

fn fn_with_defer() {
defer {	voidfn() }
}
fn test_as() {
	a := sum_expr() as Bar
	_ := a
}

fn test_cast() {
	_ := f32(0)
}
fn test_as() {
	a := sum_expr()     as Bar
	_ := a
}

fn test_cast() {
	_ := f32(0)
}
fn char_backtick() {
	`\``
}
fn concatenation_of_strings() {
	_ := 'Simple' + 'Concat'
	_ := 'Hello' + ' ' + 'World' + '!'
	_ := 'There' + ' ' + 'so' + ' ' + 'many' + ' ' + 'words' + ' ' + 'they' + ' ' + "don't" +
		' ' + 'fit' + ' ' + 'in' + ' ' + 'one' + ' ' + 'line'
}
fn concatenation_of_strings() {
_ := 'Simple'   +    'Concat'
	_ := 'Hello'
		+ ' ' +
		'World' + '!'
		_ := 'There' + ' ' + 'so' + ' ' + 'many' + ' ' + 'words' + ' ' + 'they' + ' ' + "don't" + ' ' + 'fit' + ' ' + 'in' + ' ' + 'one' + ' ' + 'line'
}
// __global g_my_global_variable int
fn main() {
	$if tinyc {
		println('This will be compiled only when the compiler is tcc')
	}
	$if !windows {
		println('This will get compiled on non-windows platforms.')
	}
	//
	$if !linux {
		println('Only non linux platforms will get this')
	} $else {
		println('This part is for linux only.')
	}
	//
	$if network ? {
		println('This will be run, only when the program is compiled with `-d network`')
	}
}
fn fn_with_if_else() {
	if true {
		a = 10
		a++
	} else {
		println('false')
	}
}

fn fn_with_if_else_oneline() {
	_ := if true { 1 } else { 2 }
}
fn fn_with_if_else() {
	if true {
		a = 10
		a++
	} else { println('false') }
}

fn fn_with_if_else_oneline() {
_ := if true { 1 } else { 2 }
}
const (
	// pi
	pi                  = 3.14
	phi                 = 1.618
	// Euler's constant
	eulers              = 2.7182
	supported_platforms = ['windows', 'mac', 'macos', 'darwin', 'linux', 'freebsd', 'openbsd',
		'netbsd', 'dragonfly', 'android', 'js', 'solaris', 'haiku', 'linux_or_macos']
	one_line_supported  = ['windows', 'mac', 'macos', 'darwin', 'linux', 'freebsd', 'openbsd',
		'netbsd', 'dragonfly', 'android', 'js', 'solaris', 'haiku', 'linux_or_macos']
	another_const       = [
		'a', 'b',
		'c', 'd', 'e',
		'f'
	]
)

const (
	i_am_a_very_long_constant_name_so_i_stand_alone_and_my_length_is_over_90_characters = [
		'testforit'
	]
)

pub const (
	i_am_pub_const = true
)
const (
// pi
pi=3.14
phi=1.618
	//Euler's constant
eulers=2.7182
supported_platforms = ['windows', 'mac', 'macos', 'darwin', 'linux', 'freebsd', 'openbsd',
		'netbsd', 'dragonfly', 'android', 'js', 'solaris', 'haiku', 'linux_or_macos']
one_line_supported    = ['windows', 'mac', 'macos', 'darwin', 'linux', 'freebsd', 'openbsd', 'netbsd', 'dragonfly', 'android', 'js', 'solaris', 'haiku', 'linux_or_macos']
another_const = [
	'a', 'b'
		'c', 'd', 'e'
		'f'
		]
)

const (
	i_am_a_very_long_constant_name_so_i_stand_alone_and_my_length_is_over_90_characters = ['testforit']
)

pub const (
i_am_pub_const=true
)


pub enum PubEnum {
	foo
	bar
}

enum PrivateEnum {
	foo
	bar
}
pub enum PubEnum{
	foo
    bar
}
enum PrivateEnum { foo bar }
fn C.func(arg int) int

fn fn_variadic(arg int, args ...string) {
	println('Do nothing')
}

fn fn_with_assign_stmts() {
	_, _ := fn_with_multi_return()
}

fn fn_with_multi_return() (int, string) {
	return 0, 'test'
}

fn voidfn() {
	println('this is a function that does not return anything')
}

fn fn_with_1_arg(arg int) int {
	return 0
}

fn fn_with_2a_args(arg1, arg2 int) int {
	return 0
}

fn fn_with_2_args_to_be_shorten(arg1, arg2 int) int {
	return 0
}

fn fn_with_2b_args(arg1 string, arg2 int) int {
	return 0
}

fn fn_with_3_args(arg1 string, arg2 int, arg3 User) int {
	return 0
}

fn (this User) fn_with_receiver() {
	println('')
}

fn fn_with_optional() ?int {
	if true {
		return error('true')
	}
	return 30
}

fn (f Foo) fn_with_optional() ?int {
	if true {
		return error('true')
	}
	return 40
}

fn mut_array(mut a []int) {
	println(1)
}

fn fn_with_ref_return() &Foo {
	return &Foo{}
}

[inline]
fn fn_with_flag() {
	println('flag')
}
fn C.func(arg int) int

fn fn_variadic(arg int, args... string) {
	println('Do nothing')
}

fn fn_with_assign_stmts() {
	_,_ := fn_with_multi_return()
}

fn fn_with_multi_return() (int,string) {
	return 0,'test'
}

fn   voidfn(){
 println('this is a function that does not return anything')
   }

fn fn_with_1_arg(arg int) int {
return 0
}

fn fn_with_2a_args(arg1, arg2 int) int {
return 0
}

fn fn_with_2_args_to_be_shorten(arg1 int, arg2 int) int {
return 0
}

fn fn_with_2b_args(arg1 string, arg2 int) int {
return 0
}

fn fn_with_3_args(arg1 string, arg2 int, arg3 User) int {
return 0
}

fn    (this User) fn_with_receiver() {
println('')
}

fn fn_with_optional() ?int {
	if true { return error('true') }
	return 30
}

fn (f Foo) fn_with_optional() ?int {
	if true { return error('true') }
	return 40
}

fn mut_array(a mut []int) {
	println(1)
}

fn fn_with_ref_return() &Foo {
	return &Foo{}
}

[inline] fn fn_with_flag() {
println('flag')
}
fn test_goto() {
	goto label
	label:
}
fn test_goto() {
	goto label
label:
}
fn my_thread() {
	println('yo')
}

fn my_thread_with_params(s string) {
	println(s)
}

fn my_fn_calling_threads() {
	go my_thread()
	go my_thread_with_params('yay')
	go my_thread_with_params('nono')
}
fn my_thread() {
	   println('yo')
}

fn my_thread_with_params(s string)
{
 println(s)
}

fn my_fn_calling_threads ()  {
go my_thread()
  go    my_thread_with_params('yay')

  go
  	my_thread_with_params('nono')
}
import math
import os

const (
	mypi = math.pi
)

fn main() {
	println(os.path_separator)
}
import math
import os

const (
	mypi = math.pi
)

fn main() {
	println(os.path_separator)
}
import os
import math

fn main() {
	// println(m.pi)
	println(os.path_separator)
	println(math.pi)
	// math as m
	// import math.complex as c
	// num := c.Complex{} TODO
}
import os
import math

fn main() {
	// println(m.pi)
	println(os.path_separator)
	println(math.pi)
	// math as m
	// import math.complex as c
	// num := c.Complex{} TODO
}
import os

fn main() {
	os.system('echo hi')
}
import os

fn main() {
	os.system('echo hi')
}
import os
import time as t

fn main() {
	println('start')
	t.sleep_ms(500)
	println('end')
	os.system('date')
}
struct IfExpr {
}

struct MatchExpr {
}

type Expr = IfExpr | MatchExpr

fn sum_types(a []Expr) {
}

fn main() {
	x := 0xdeadbeef
	u := 9978654321
	o := 0o664
	eprintln('  hex constant in decimal: $x')
	eprintln('    u constant in decimal: $u')
	eprintln('octal constant in decimal: $o')
}
fn for_in_loop() {
	for item in arr {
		println(item)
	}
}

fn for_in_loop_with_counter() {
	for i, item in arr {
		println(i)
		println(item)
	}
}

fn for_in_loop_with_index_expr() {
	for i in 0 .. 10 {
		println(i)
	}
}
fn for_in_loop() {
	for item in arr {
		println(item)
	}
}

fn for_in_loop_with_counter() {
	for i, item in arr {
		println(i)
		println(item)
	}
}

fn for_in_loop_with_index_expr() {
	for i in 0..10 {
		println(i)
	}
}
const (
	reserved_types = {
		'i8': true
		'i16': true
		'int': true
		'i64': true
		'i128': true
	}
)
const (
reserved_types = {
         'i8': true
     'i16': true
         'int': true
         'i64': true
         'i128': true
}
)
fn workaround() {
	a := map[string]string{}
	println(a)
}

fn main() {
	mut ams := []map[string]string{}
	ams << {
		'a': 'b'
		'c': 'd'
	}
	ams << {
		'e': 'f'
		'g': 'h'
	}
	println(ams)
}
fn match_expr() {
	a := 10
	match a {
		10 { println('10') }
		20 { println('20') }
		else {}
	}
}

fn match_expr_assignment() {
	a := 20
	_ := match a {
		10 { 10 }
		5 { 5 }
		else { 2 }
	}
}

fn match_branch_comment() {
	a := 1
	match a {
		1 {
			println('1')
		}
		2 {
			println('2')
		}
		else {
			// do nothing
		}
	}
}
fn match_expr() {
	a := 10
	match a {
		10 {
			println('10')
		}
		20 {
			println('20')
		}
		else {}
	}
}

fn match_expr_assignment() {
    a := 20
	_ := match a {
		10 { 10	}
		5 {	5 }
		else { 2 }
	}
}

fn match_branch_comment() {
 a := 1
     	match a {
	  1 { println('1') }
	     2 {
	println('2')
	 }
	 else {


// do nothing
 }
  }
}
import time

fn main() {
	println(time.now())
}
fn main() {
	println(time.now())
}
module module_fmt

pub struct MyStruct {
mut:
	value int
}

pub fn (m MyStruct) foo() bool {
	return true
}
/*
this is a very long comment
that is on multiple lines
   and has some formatting in it
 that should be
   preserved.
*/
fn main() {
	println('hello')
	/*
	this comment also
	has mutliple lines
	but it's difference
	is that it is indented !
	*/
	if true {
		/*
		this one is even more
		indented !
		*/
	}
}
pub fn test() ?&SomeType {
}

struct SomeType {
}
fn opt_propagate() ?int {
	eventual_wrong_int()?
}
fn fn_with_or() int {
	fn_with_optional() or {
		return 10
	}
	return 20
}

fn (f Foo) method_with_or() int {
	f.fn_with_optional() or {
		return 10
	}
	return 20
}
fn fn_with_or() int {
	fn_with_optional() or {	return 10 }
	return 20
}

fn (f Foo) method_with_or() int {
	f.fn_with_optional() or { return 10 }
	return 20
}
import os

fn main() {
	println('Hello world, args: $os.args')
	i := 123
	a := 'abc'
	b := 'xyz'
	e := 'a: $a b: $b i: $i'
	d := 'a: ${a:5s} b: ${b:-5s} i: ${i:20d}'
	println('a: $a $b xxx')
	eprintln('e: $e')
	println(d)
}
fn main() {
	'Hello world !'
	'This is correct !'
	"It's okay"
	'This is "too"'
	// TODO
	// 'I\'m not correctly formatted' => "I'm not correctly formatted"
	// "\"Everything on the internet is true\" - Albert Einstein, 1965" => '"Everything on the internet is true" - Albert Einstein, 1965'
	'I\'m out of idea "_"'
	// "Definitely out \":'(\"" => 'Definitely out ":\'("'
}
fn main() {
	"Hello world !"
	'This is correct !'
	"It's okay"
	'This is "too"'
	// TODO
	// 'I\'m not correctly formatted' => "I'm not correctly formatted"
	// "\"Everything on the internet is true\" - Albert Einstein, 1965" => '"Everything on the internet is true" - Albert Einstein, 1965'
	'I\'m out of idea "_"'
	// "Definitely out \":'(\"" => 'Definitely out ":\'("'
}
struct User {
	name            string
	very_long_field bool
	age             int
}

struct Foo {
	field1        int
	field2        string
pub:
	public_field1 int
	public_field2 f64
mut:
	mut_field     string
pub mut:
	pub_mut_field string
}

fn new_user() User {
	return User{
		name: 'Serious Sam'
		age: 19
	}
}
struct User {
	name string
	very_long_field bool
	age int
}

struct Foo {
	field1 int
	field2 string
	pub:
	public_field1 int
	public_field2 f64
	mut:
	mut_field string
	pub mut:
	pub_mut_field string
}

fn new_user()
User
{
  return User{
    name: 'Serious Sam'
          age: 19
           }
}
struct User {
	age  int
	name string
}

fn main() {
	u := User{
		age: 54
	}
	println(u)
}
import os

fn foo(a []os.File) {
}

struct User {
	age  int
	name string
}

fn handle_users(users []User) {
	println(users.len)
}

fn (u &User) foo(u2 &User) {
}

type Expr = IfExpr | IntegerLiteral

fn exprs(e []Expr) {
	println(e.len)
}
fn test_typeof() {
	println(typeof(x))
}
// Sumtype
type FooBar = Bar | Foo

pub type PublicBar = Bar | Foo | FooBar

type Uint = byte | u16 | u32 | u64

type Float = f32 | f64

// Alias type
type MyInt int

pub type Abc f32

// Fn type decl
type EmptyFn = fn ()

type OneArgFn = fn (i int)

type TwoDiffArgs = fn (i int, s string) bool

type TwoSameArgs = fn (i, j int) string

type VarArgs = fn (s ...string) int

type NOVarArgs = fn (i int, s ...string) f64


  // Sumtype
   type    FooBar=   Foo |     Bar
   pub type   PublicBar = Foo | Bar | FooBar

type   Uint =   u16 | u64
	| u32
	    | byte
type
Float =
	f32 |
	f64

 // Alias type
     type  MyInt    int

 pub type Abc f32


// Fn type decl

 type EmptyFn	= fn()
type OneArgFn =
	fn (i    int)
type TwoDiffArgs
= fn (i    int, s string) bool


	type TwoSameArgs = fn(i int, j int) string

type VarArgs = fn
(s ...string) int

type NOVarArgs = fn(i int, s ...string) f64
const (
	x = &Test{}
	y = []&Test{}
	z = &[]&Test{}
)

fn test_type_ptr() {
	_ := &Test{}
	_ := []&Test{}
	_ := &[]&Test{}
}

struct Test {
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module gen

import strings
import strconv
import v.ast
import v.table
import v.pref
import v.token
import v.util
import v.depgraph
import term

// NB: keywords after 'new' are reserved in C++
const (
	c_reserved = ['delete', 'exit', 'unix', 'error', 'calloc', 'malloc', 'free', 'panic', 'auto',
		'char',
		'default',
		'do',
		'double',
		'extern',
		'float',
		'inline',
		'int',
		'long',
		'register',
		'restrict',
		'short',
		'signed',
		'sizeof',
		'static',
		'switch',
		'typedef',
		'union',
		'unsigned',
		'void',
		'volatile',
		'while',
		'new',
		'namespace',
		'class',
		'typename'
	]
)

struct Gen {
	out                  strings.Builder
	cheaders             strings.Builder
	includes             strings.Builder // all C #includes required by V modules
	typedefs             strings.Builder
	typedefs2            strings.Builder
	definitions          strings.Builder // typedefs, defines etc (everything that goes to the top of the file)
	inits                strings.Builder // contents of `void _vinit(){}`
	cleanups             strings.Builder // contents of `void _vcleanup(){}`
	gowrappers           strings.Builder // all go callsite wrappers
	stringliterals       strings.Builder // all string literals (they depend on tos3() beeing defined
	auto_str_funcs       strings.Builder // function bodies of all auto generated _str funcs
	comptime_defines     strings.Builder // custom defines, given by -d/-define flags on the CLI
	pcs_declarations     strings.Builder // -prof profile counter declarations for each function
	hotcode_definitions  strings.Builder // -live declarations & functions
	table                &table.Table
	pref                 &pref.Preferences
	module_built         string
mut:
	file                 ast.File
	fn_decl              &ast.FnDecl // pointer to the FnDecl we are currently inside otherwise 0
	last_fn_c_name       string
	tmp_count            int
	variadic_args        map[string]int
	is_c_call            bool // e.g. `C.printf("v")`
	is_assign_lhs        bool // inside left part of assign expr (for array_set(), etc)
	is_assign_rhs        bool // inside right part of assign after `=` (val expr)
	is_array_set         bool
	is_amp               bool // for `&Foo{}` to merge PrefixExpr `&` and StructInit `Foo{}`; also for `&byte(0)` etc
	optionals            []string // to avoid duplicates TODO perf, use map
	inside_ternary       int // ?: comma separated statements on a single line
	ternary_names        map[string]string
	ternary_level_names  map[string][]string
	stmt_path_pos        []int
	right_is_opt         bool
	autofree             bool
	indent               int
	empty_line           bool
	is_test              bool
	assign_op            token.Kind // *=, =, etc (for array_set)
	defer_stmts          []ast.DeferStmt
	defer_ifdef          string
	defer_profile_code   string
	str_types            []string // types that need automatic str() generation
	threaded_fns         []string // for generating unique wrapper types and fns for `go xxx()`
	array_fn_definitions []string // array equality functions that have been defined
	is_json_fn           bool // inside json.encode()
	json_types           []string // to avoid json gen duplicates
	pcs                  []ProfileCounterMeta // -prof profile counter fn_names => fn counter name
	attr                 string
	is_builtin_mod       bool
	hotcode_fn_names     []string
	fn_main              &ast.FnDecl // the FnDecl of the main function. Needed in order to generate the main function code *last*
	cur_fn               &ast.FnDecl
	cur_generic_type     table.Type // `int`, `string`, etc in `foo<T>()`
}

const (
	tabs = ['', '\t', '\t\t', '\t\t\t', '\t\t\t\t', '\t\t\t\t\t', '\t\t\t\t\t\t', '\t\t\t\t\t\t\t',
		'\t\t\t\t\t\t\t\t'
	]
)

pub fn cgen(files []ast.File, table &table.Table, pref &pref.Preferences) string {
	// println('start cgen2')
	mut g := Gen{
		out: strings.new_builder(1000)
		cheaders: strings.new_builder(8192)
		includes: strings.new_builder(100)
		typedefs: strings.new_builder(100)
		typedefs2: strings.new_builder(100)
		definitions: strings.new_builder(100)
		gowrappers: strings.new_builder(100)
		stringliterals: strings.new_builder(100)
		auto_str_funcs: strings.new_builder(100)
		comptime_defines: strings.new_builder(100)
		inits: strings.new_builder(100)
		cleanups: strings.new_builder(100)
		pcs_declarations: strings.new_builder(100)
		hotcode_definitions: strings.new_builder(100)
		table: table
		pref: pref
		fn_decl: 0
		fn_main: 0
		cur_fn: 0
		autofree: true
		indent: -1
		module_built: pref.path.after('vlib/')
	}
	g.init()
	//
	mut tests_inited := false
	mut autofree_used := false
	for file in files {
		g.file = file
		// println('\ncgen "$g.file.path" nr_stmts=$file.stmts.len')
		// building_v := true && (g.file.path.contains('/vlib/') || g.file.path.contains('cmd/v'))
		is_test := g.file.path.ends_with('.vv') || g.file.path.ends_with('_test.v')
		if g.file.path.ends_with('_test.v') {
			g.is_test = is_test
		}
		if g.file.path == '' || is_test || !g.pref.autofree {
			// cgen test or building V
			// println('autofree=false')
			g.autofree = false
		} else {
			g.autofree = true
			autofree_used = true
		}
		// anon fn may include assert and thus this needs
		// to be included before any test contents are written
		if g.is_test && !tests_inited {
			g.write_tests_main()
			tests_inited = true
		}
		g.stmts(file.stmts)
	}
	if autofree_used {
		g.autofree = true // so that void _vcleanup is generated
	}
	g.write_variadic_types()
	// g.write_str_definitions()
	if g.pref.build_mode != .build_module {
		// no init in builtin.o
		g.write_init_function()
	}
	//
	g.finish()
	//
	b := strings.new_builder(250000)
	b.writeln(g.hashes())
	b.writeln(g.comptime_defines.str())
	b.writeln('\n// V typedefs:')
	b.writeln(g.typedefs.str())
	b.writeln('\n// V typedefs2:')
	b.writeln(g.typedefs2.str())
	b.writeln('\n// V cheaders:')
	b.writeln(g.cheaders.str())
	b.writeln('\n// V includes:')
	b.writeln(g.includes.str())
	b.writeln('\n// V definitions:')
	b.writeln(g.definitions.str())
	b.writeln('\n// V profile counters:')
	b.writeln(g.pcs_declarations.str())
	b.writeln('\n// V interface table:')
	b.writeln(g.interface_table())
	b.writeln('\n// V gowrappers:')
	b.writeln(g.gowrappers.str())
	b.writeln('\n// V hotcode definitions:')
	b.writeln(g.hotcode_definitions.str())
	b.writeln('\n// V stringliterals:')
	b.writeln(g.stringliterals.str())
	b.writeln('\n// V auto str functions:')
	b.writeln(g.auto_str_funcs.str())
	b.writeln('\n// V out')
	b.writeln(g.out.str())
	b.writeln('\n// THE END.')
	return b.str()
}

pub fn (g Gen) hashes() string {
	mut res := c_commit_hash_default.replace('@@@', util.vhash())
	res += c_current_commit_hash_default.replace('@@@', util.githash(g.pref.building_v))
	return res
}

pub fn (mut g Gen) init() {
	g.cheaders.writeln('// Generated by the V compiler')
	g.cheaders.writeln('#include <inttypes.h>') // int64_t etc
	g.cheaders.writeln(c_builtin_types)
	g.cheaders.writeln(c_headers)
	g.definitions.writeln('\nvoid _STR_PRINT_ARG(const char*, char**, int*, int*, int, ...);\n')
	g.definitions.writeln('\nstring _STR(const char*, int, ...);\n')
	g.definitions.writeln('\nstring _STR_TMP(const char*, ...);\n')
	g.write_builtin_types()
	g.write_typedef_types()
	g.write_typeof_functions()
	if g.pref.build_mode != .build_module {
		// _STR functions should not be defined in builtin.o
		g.write_str_fn_definitions()
	}
	g.write_sorted_types()
	g.write_multi_return_types()
	g.definitions.writeln('// end of definitions #endif')
	//
	g.stringliterals.writeln('')
	g.stringliterals.writeln('// >> string literal consts')
	if g.pref.build_mode != .build_module {
		g.stringliterals.writeln('void vinit_string_literals(){')
	}
	if g.pref.compile_defines_all.len > 0 {
		g.comptime_defines.writeln('// V compile time defines by -d or -define flags:')
		g.comptime_defines.writeln('//     All custom defines      : ' + g.pref.compile_defines_all.join(','))
		g.comptime_defines.writeln('//     Turned ON custom defines: ' + g.pref.compile_defines.join(','))
		for cdefine in g.pref.compile_defines {
			g.comptime_defines.writeln('#define CUSTOM_DEFINE_${cdefine}')
		}
		g.comptime_defines.writeln('')
	}
	if g.pref.is_debug || 'debug' in g.pref.compile_defines {
		g.comptime_defines.writeln('#define _VDEBUG (1)')
	}
	if g.pref.is_livemain || g.pref.is_liveshared {
		g.generate_hotcode_reloading_declarations()
	}
}

pub fn (mut g Gen) finish() {
	if g.pref.build_mode != .build_module {
		g.stringliterals.writeln('}')
	}
	g.stringliterals.writeln('// << string literal consts')
	g.stringliterals.writeln('')
	if g.pref.is_prof {
		g.gen_vprint_profile_stats()
	}
	if g.pref.is_livemain || g.pref.is_liveshared {
		g.generate_hotcode_reloader_code()
	}
	if g.fn_main != 0 {
		g.out.writeln('')
		g.fn_decl = g.fn_main
		g.gen_fn_decl(g.fn_main)
	}
}

pub fn (mut g Gen) write_typeof_functions() {
	g.writeln('')
	g.writeln('// >> typeof() support for sum types')
	for typ in g.table.types {
		if typ.kind == .sum_type {
			sum_info := typ.info as table.SumType
			tidx := g.table.find_type_idx(typ.name)
			g.writeln('char * v_typeof_sumtype_${tidx}(int sidx) { /* ${typ.name} */ ')
			g.writeln('	switch(sidx) {')
			g.writeln('		case $tidx: return "$typ.name";')
			for v in sum_info.variants {
				subtype := g.table.get_type_symbol(v)
				g.writeln('		case $v: return "$subtype.name";')
			}
			g.writeln('		default: return "unknown ${typ.name}";')
			g.writeln('	}')
			g.writeln('}')
		}
	}
	g.writeln('// << typeof() support for sum types')
	g.writeln('')
}

// V type to C type
fn (mut g Gen) typ(t table.Type) string {
	mut styp := g.base_type(t)
	if styp.len == 1 && t == table.t_type && g.cur_generic_type != 0 {
		// T => int etc
		return g.typ(g.cur_generic_type)
	}
	base := styp
	if t.flag_is(.optional) {
		if t.is_ptr() {
			styp = styp.replace('*', '_ptr')
		}
		styp = 'Option_' + styp
		// Register an optional if it's not registered yet
		if styp !in g.optionals {
			g.register_optional(t, base)
			// println(styp)
			x := styp // .replace('*', '_ptr')			// handle option ptrs
			g.typedefs2.writeln('typedef Option $x;')
			g.optionals << styp
		}
	}
	/*
	if styp.starts_with('C__') {
		return styp[3..]
	}
	*/
	return styp
}

fn (g &Gen) base_type(t table.Type) string {
	mut styp := g.cc_type(t)
	nr_muls := t.nr_muls()
	if nr_muls > 0 {
		styp += strings.repeat(`*`, nr_muls)
	}
	return styp
}

fn (mut g Gen) register_optional(t table.Type, styp string) {
	// g.typedefs2.writeln('typedef Option $x;')
	no_ptr := styp.replace('*', '_ptr')
	typ := if styp == 'void' { 'void*' } else { styp }
	g.hotcode_definitions.writeln('typedef struct {
		$typ  data;
		string error;
		int    ecode;
		bool   ok;
		bool   is_none;
	} Option2_$no_ptr;')
}

// cc_type returns the Cleaned Concrete Type name, *without ptr*,
// i.e. it's always just Cat, not Cat_ptr:
fn (g &Gen) cc_type(t table.Type) string {
	sym := g.table.get_type_symbol(t)
	mut styp := sym.name.replace('.', '__')
	if styp.starts_with('C__') {
		styp = styp[3..]
		if sym.kind == .struct_ {
			info := sym.info as table.Struct
			if !info.is_typedef {
				styp = 'struct $styp'
			}
		}
	}
	return styp
}

//
pub fn (mut g Gen) write_typedef_types() {
	g.typedefs.writeln('
typedef struct {
	void* _object;
	int _interface_idx;
} _Interface;
')
	for typ in g.table.types {
		match typ.kind {
			.alias {
				parent := &g.table.types[typ.parent_idx]
				styp := typ.name.replace('.', '__')
				is_c_parent := parent.name.len > 2 && parent.name[0] == `C` && parent.name[1] ==
					`.`
				parent_styp := if is_c_parent { 'struct ' + parent.name[2..].replace('.', '__') } else { parent.name.replace('.',
						'__') }
				g.definitions.writeln('typedef $parent_styp $styp;')
			}
			.array {
				styp := typ.name.replace('.', '__')
				g.definitions.writeln('typedef array $styp;')
			}
			.interface_ {
				g.definitions.writeln('typedef _Interface ${c_name(typ.name)};')
			}
			.map {
				styp := typ.name.replace('.', '__')
				g.definitions.writeln('typedef map $styp;')
			}
			.function {
				info := typ.info as table.FnType
				func := info.func
				sym := g.table.get_type_symbol(func.return_type)
				is_multi := sym.kind == .multi_return
				is_fn_sig := func.name == ''
				not_anon := !info.is_anon
				if !info.has_decl && !is_multi && (not_anon || is_fn_sig) {
					fn_name := if func.language == .c {
						func.name.replace('.', '__')
					} else if info.is_anon {
						typ.name
					} else {
						c_name(func.name)
					}
					g.definitions.write('typedef ${g.typ(func.return_type)} (*$fn_name)(')
					for i, arg in func.args {
						g.definitions.write(g.typ(arg.typ))
						if i < func.args.len - 1 {
							g.definitions.write(',')
						}
					}
					g.definitions.writeln(');')
				}
			}
			else {
				continue
			}
		}
	}
}

pub fn (mut g Gen) write_multi_return_types() {
	g.definitions.writeln('// multi return structs')
	for typ in g.table.types {
		// sym := g.table.get_type_symbol(typ)
		if typ.kind != .multi_return {
			continue
		}
		name := typ.name.replace('.', '__')
		info := typ.info as table.MultiReturn
		g.definitions.writeln('typedef struct {')
		// TODO copy pasta StructDecl
		// for field in struct_info.fields {
		for i, mr_typ in info.types {
			type_name := g.typ(mr_typ)
			g.definitions.writeln('\t$type_name arg${i};')
		}
		g.definitions.writeln('} $name;\n')
		// g.typedefs.writeln('typedef struct $name $name;')
	}
}

pub fn (mut g Gen) write_variadic_types() {
	if g.variadic_args.size > 0 {
		g.definitions.writeln('// variadic structs')
	}
	for type_str, arg_len in g.variadic_args {
		typ := table.Type(type_str.int())
		type_name := g.typ(typ)
		struct_name := 'varg_' + type_name.replace('*', '_ptr')
		g.definitions.writeln('struct $struct_name {')
		g.definitions.writeln('\tint len;')
		g.definitions.writeln('\t$type_name args[$arg_len];')
		g.definitions.writeln('};\n')
		g.typedefs.writeln('typedef struct $struct_name $struct_name;')
	}
}

pub fn (g Gen) save() {
}

pub fn (mut g Gen) write(s string) {
	if g.indent > 0 && g.empty_line {
		g.out.write(tabs[g.indent])
		// g.line_len += g.indent * 4
	}
	g.out.write(s)
	g.empty_line = false
}

pub fn (mut g Gen) writeln(s string) {
	if g.indent > 0 && g.empty_line {
		g.out.write(tabs[g.indent])
	}
	g.out.writeln(s)
	g.empty_line = true
}

pub fn (mut g Gen) new_tmp_var() string {
	g.tmp_count++
	return '_t$g.tmp_count'
}

pub fn (mut g Gen) reset_tmp_count() {
	g.tmp_count = 0
}

fn (mut g Gen) decrement_inside_ternary() {
	key := g.inside_ternary.str()
	for name in g.ternary_level_names[key] {
		g.ternary_names.delete(name)
	}
	g.ternary_level_names.delete(key)
	g.inside_ternary--
}

fn (mut g Gen) stmts(stmts []ast.Stmt) {
	g.indent++
	if g.inside_ternary > 0 {
		g.writeln('(')
	}
	for i, stmt in stmts {
		g.stmt(stmt)
		if g.inside_ternary > 0 && i < stmts.len - 1 {
			g.writeln(',')
		}
	}
	g.indent--
	if g.inside_ternary > 0 {
		g.writeln('')
		g.write(')')
	}
}

fn (mut g Gen) stmt(node ast.Stmt) {
	g.stmt_path_pos << g.out.len
	// println('cgen.stmt()')
	// g.writeln('//// stmt start')
	match node {
		ast.AssertStmt {
			g.gen_assert_stmt(it)
		}
		ast.AssignStmt {
			g.gen_assign_stmt(it)
		}
		ast.Attr {
			g.attr = it.name
			g.writeln('// Attr: [$it.name]')
		}
		ast.Block {
			g.writeln('{')
			g.stmts(it.stmts)
			g.writeln('}')
		}
		ast.BranchStmt {
			// continue or break
			g.write(it.tok.kind.str())
			g.writeln(';')
		}
		ast.ConstDecl {
			// if g.pref.build_mode != .build_module {
			g.const_decl(it)
			// }
		}
		ast.CompIf {
			g.comp_if(it)
		}
		ast.DeferStmt {
			mut defer_stmt := *it
			defer_stmt.ifdef = g.defer_ifdef
			g.defer_stmts << defer_stmt
		}
		ast.EnumDecl {
			enum_name := it.name.replace('.', '__')
			g.typedefs.writeln('typedef enum {')
			mut cur_enum_expr := ''
			mut cur_enum_offset := 0
			for field in it.fields {
				g.typedefs.write('\t${enum_name}_${field.name}')
				if field.has_expr {
					g.typedefs.write(' = ')
					pos := g.out.len
					g.expr(field.expr)
					expr_str := g.out.after(pos)
					g.out.go_back(expr_str.len)
					g.typedefs.write(expr_str)
					cur_enum_expr = expr_str
					cur_enum_offset = 0
				}
				cur_value := if cur_enum_offset > 0 { '${cur_enum_expr}+${cur_enum_offset}' } else { cur_enum_expr }
				g.typedefs.writeln(', // ${cur_value}')
				cur_enum_offset++
			}
			g.typedefs.writeln('} ${enum_name};\n')
		}
		ast.ExprStmt {
			g.expr(it.expr)
			if g.inside_ternary == 0 && !(it.expr is ast.IfExpr) {
				g.writeln(';')
			}
		}
		ast.FnDecl {
			mut skip := false
			pos := g.out.buf.len
			if g.pref.build_mode == .build_module {
				if !it.name.starts_with(g.module_built + '.') {
					// Skip functions that don't have to be generated
					// for this module.
					skip = true
				}
				if g.is_builtin_mod && g.module_built == 'builtin' {
					skip = false
				}
				if !skip {
					println('build module `$g.module_built` fn `$it.name`')
				}
			}
			keep_fn_decl := g.fn_decl
			g.fn_decl = it // &it
			if it.name == 'main' {
				// just remember `it`; main code will be generated in finish()
				g.fn_main = it
			} else {
				if it.name == 'backtrace' || it.name == 'backtrace_symbols' || it.name == 'backtrace_symbols_fd' {
					g.write('\n#ifndef __cplusplus\n')
				}
				g.gen_fn_decl(it)
				if it.name == 'backtrace' || it.name == 'backtrace_symbols' || it.name == 'backtrace_symbols_fd' {
					g.write('\n#endif\n')
				}
			}
			g.fn_decl = keep_fn_decl
			if skip {
				g.out.go_back_to(pos)
			}
			g.writeln('')
			// g.attr has to be reset after each function
			g.attr = ''
		}
		ast.ForCStmt {
			g.write('for (')
			if !it.has_init {
				g.write('; ')
			} else {
				g.stmt(it.init)
			}
			if it.has_cond {
				g.expr(it.cond)
			}
			g.write('; ')
			if it.has_inc {
				g.expr(it.inc)
			}
			g.writeln(') {')
			g.stmts(it.stmts)
			g.writeln('}')
		}
		ast.ForInStmt {
			g.for_in(it)
		}
		ast.ForStmt {
			g.write('while (')
			if it.is_inf {
				g.write('1')
			} else {
				g.expr(it.cond)
			}
			g.writeln(') {')
			g.stmts(it.stmts)
			g.writeln('}')
		}
		ast.GlobalDecl {
			styp := g.typ(it.typ)
			g.definitions.writeln('$styp $it.name; // global')
		}
		ast.GoStmt {
			g.go_stmt(it)
		}
		ast.GotoLabel {
			g.writeln('$it.name: {}')
		}
		ast.GotoStmt {
			g.writeln('goto $it.name;')
		}
		ast.HashStmt {
			// #include etc
			typ := it.val.all_before(' ')
			if typ == 'include' {
				g.includes.writeln('// added by module `$it.mod`:')
				g.includes.writeln('#$it.val')
			}
			if typ == 'define' {
				g.includes.writeln('#$it.val')
			}
		}
		ast.Import {}
		ast.InterfaceDecl {
			// definitions are sorted and added in write_types
		}
		ast.Module {
			g.is_builtin_mod = it.name == 'builtin'
		}
		ast.Return {
			g.write_defer_stmts_when_needed()
			g.write_autofree_stmts_when_needed(it)
			g.return_statement(it)
		}
		ast.StructDecl {
			name := if it.language == .c { it.name.replace('.', '__') } else { c_name(it.name) }
			// g.writeln('typedef struct {')
			// for field in it.fields {
			// field_type_sym := g.table.get_type_symbol(field.typ)
			// g.writeln('\t$field_type_sym.name $field.name;')
			// }
			// g.writeln('} $name;')
			if it.language == .c {
				return
			}
			if it.is_union {
				g.typedefs.writeln('typedef union $name $name;')
			} else {
				g.typedefs.writeln('typedef struct $name $name;')
			}
		}
		ast.TypeDecl {
			g.writeln('// TypeDecl')
		}
		ast.UnsafeStmt {
			g.stmts(it.stmts)
		}
		else {
			verror('cgen.stmt(): unhandled node ' + typeof(node))
		}
	}
	g.stmt_path_pos.delete(g.stmt_path_pos.len - 1)
}

fn (mut g Gen) write_defer_stmts() {
	for defer_stmt in g.defer_stmts {
		g.writeln('// defer')
		if defer_stmt.ifdef.len > 0 {
			g.writeln(defer_stmt.ifdef)
			g.stmts(defer_stmt.stmts)
			g.writeln('')
			g.writeln('#endif')
		} else {
			g.stmts(defer_stmt.stmts)
		}
	}
}

fn (mut g Gen) for_in(it ast.ForInStmt) {
	if it.is_range {
		// `for x in 1..10 {`
		i := if it.val_var == '_' { g.new_tmp_var() } else { c_name(it.val_var) }
		g.write('for (int $i = ')
		g.expr(it.cond)
		g.write('; $i < ')
		g.expr(it.high)
		g.writeln('; $i++) {')
		g.stmts(it.stmts)
		g.writeln('}')
	} else if it.kind == .array {
		// `for num in nums {`
		g.writeln('// FOR IN array')
		styp := g.typ(it.val_type)
		cond_type_is_ptr := it.cond_type.is_ptr()
		atmp := g.new_tmp_var()
		atmp_type := if cond_type_is_ptr { 'array *' } else { 'array' }
		g.write('${atmp_type} ${atmp} = ')
		g.expr(it.cond)
		g.writeln(';')
		i := if it.key_var in ['', '_'] { g.new_tmp_var() } else { it.key_var }
		op_field := if cond_type_is_ptr { '->' } else { '.' }
		g.writeln('for (int $i = 0; $i < ${atmp}${op_field}len; $i++) {')
		if it.val_var != '_' {
			g.writeln('\t$styp ${c_name(it.val_var)} = (($styp*)${atmp}${op_field}data)[$i];')
		}
		g.stmts(it.stmts)
		g.writeln('}')
	} else if it.kind == .map {
		// `for key, val in map {`
		g.writeln('// FOR IN map')
		key_styp := g.typ(it.key_type)
		val_styp := g.typ(it.val_type)
		keys_tmp := 'keys_' + g.new_tmp_var()
		idx := g.new_tmp_var()
		key := if it.key_var in ['', '_'] { g.new_tmp_var() } else { it.key_var }
		zero := g.type_default(it.val_type)
		g.write('array_$key_styp $keys_tmp = map_keys(&')
		g.expr(it.cond)
		g.writeln(');')
		g.writeln('for (int $idx = 0; $idx < ${keys_tmp}.len; $idx++) {')
		g.writeln('\t$key_styp $key = (($key_styp*)${keys_tmp}.data)[$idx];')
		if it.val_var != '_' {
			g.write('\t$val_styp ${c_name(it.val_var)} = (*($val_styp*)map_get3(')
			g.expr(it.cond)
			g.writeln(', $key, &($val_styp[]){ $zero }));')
		}
		g.stmts(it.stmts)
		g.writeln('}')
	} else if it.cond_type.flag_is(.variadic) {
		g.writeln('// FOR IN cond_type/variadic')
		i := if it.key_var in ['', '_'] { g.new_tmp_var() } else { it.key_var }
		styp := g.typ(it.cond_type)
		g.write('for (int $i = 0; $i < ')
		g.expr(it.cond)
		g.writeln('.len; $i++) {')
		g.write('$styp ${c_name(it.val_var)} = ')
		g.expr(it.cond)
		g.writeln('.args[$i];')
		g.stmts(it.stmts)
		g.writeln('}')
	} else if it.kind == .string {
		i := if it.key_var in ['', '_'] { g.new_tmp_var() } else { it.key_var }
		g.write('for (int $i = 0; $i < ')
		g.expr(it.cond)
		g.writeln('.len; $i++) {')
		if it.val_var != '_' {
			g.write('byte ${c_name(it.val_var)} = ')
			g.expr(it.cond)
			g.writeln('.str[$i];')
		}
		g.stmts(it.stmts)
		g.writeln('}')
	}
}

// use instead of expr() when you need to cast to sum type (can add other casts also)
fn (mut g Gen) expr_with_cast(expr ast.Expr, got_type, expected_type table.Type) {
	// cast to sum type
	if expected_type != table.void_type {
		exp_sym := g.table.get_type_symbol(expected_type)
		if exp_sym.kind == .sum_type {
			sum_info := exp_sym.info as table.SumType
			if got_type in sum_info.variants {
				got_sym := g.table.get_type_symbol(got_type)
				got_styp := g.typ(got_type)
				exp_styp := g.typ(expected_type)
				got_idx := got_type.idx()
				g.write('/* sum type cast */ ($exp_styp) {.obj = memdup(&(${got_styp}[]) {')
				g.expr(expr)
				g.write('}, sizeof($got_styp)), .typ = $got_idx /* $got_sym.name */}')
				return
			}
		}
	}
	// Generic dereferencing logic
	expected_sym := g.table.get_type_symbol(expected_type)
	got_is_ptr := got_type.is_ptr()
	expected_is_ptr := expected_type.is_ptr()
	neither_void := table.voidptr_type !in [got_type, expected_type]
	if got_is_ptr && !expected_is_ptr && neither_void && expected_sym.kind !in [.interface_,
		.placeholder
	] {
		got_deref_type := got_type.deref()
		deref_sym := g.table.get_type_symbol(got_deref_type)
		deref_will_match := expected_type in [got_type, got_deref_type, deref_sym.parent_idx]
		got_is_opt := got_type.flag_is(.optional)
		if deref_will_match || got_is_opt {
			g.write('*')
		}
	}
	// no cast
	g.expr(expr)
}

fn (mut g Gen) gen_assert_stmt(a ast.AssertStmt) {
	g.writeln('// assert')
	g.inside_ternary++
	g.write('if (')
	g.expr(a.expr)
	g.write(')')
	g.decrement_inside_ternary()
	s_assertion := a.expr.str().replace('"', "\'")
	mut mod_path := g.file.path
	$if windows {
		mod_path = g.file.path.replace('\\', '\\\\')
	}
	if g.is_test {
		g.writeln('{')
		g.writeln('	g_test_oks++;')
		g.writeln('	cb_assertion_ok( tos_lit("${mod_path}"), ${a.pos.line_nr+1}, tos_lit("assert ${s_assertion}"), tos_lit("${g.fn_decl.name}()") );')
		g.writeln('}else{')
		g.writeln('	g_test_fails++;')
		g.writeln('	cb_assertion_failed( tos_lit("${mod_path}"), ${a.pos.line_nr+1}, tos_lit("assert ${s_assertion}"), tos_lit("${g.fn_decl.name}()") );')
		g.writeln('	exit(1);')
		g.writeln('	// TODO')
		g.writeln('	// Maybe print all vars in a test function if it fails?')
		g.writeln('}')
		return
	}
	g.writeln('{}else{')
	g.writeln('	eprintln( tos_lit("${mod_path}:${a.pos.line_nr+1}: FAIL: fn ${g.fn_decl.name}(): assert $s_assertion"));')
	g.writeln('	exit(1);')
	g.writeln('}')
}

fn (mut g Gen) gen_assign_stmt(assign_stmt ast.AssignStmt) {
	if assign_stmt.is_static {
		g.write('static ')
	}
	mut return_type := table.void_type
	match assign_stmt.right[0] {
		ast.CallExpr { return_type = it.return_type }
		ast.IfExpr { return_type = it.typ }
		ast.MatchExpr { return_type = it.return_type }
		else {}
	}
	// json_test failed w/o this check
	if return_type != table.void_type && return_type != 0 {
		sym := g.table.get_type_symbol(return_type)
		// the left vs. right is ugly and should be removed
		if sym.kind == .multi_return || assign_stmt.left.len > assign_stmt.right.len || assign_stmt.left.len >
			1 {
			// multi return
			// TODO Handle in if_expr
			is_optional := return_type.flag_is(.optional)
			mr_var_name := 'mr_$assign_stmt.pos.pos'
			mr_styp := g.typ(return_type)
			g.write('$mr_styp $mr_var_name = ')
			g.is_assign_rhs = true
			g.expr(assign_stmt.right[0])
			g.is_assign_rhs = false
			if is_optional && assign_stmt.right[0] is ast.CallExpr {
				val := assign_stmt.right[0] as ast.CallExpr
				return_type = val.return_type
				g.or_block(mr_var_name, val.or_block, return_type)
			}
			g.writeln(';')
			for i, ident in assign_stmt.left {
				if ident.kind == .blank_ident {
					continue
				}
				ident_var_info := ident.var_info()
				styp := g.typ(ident_var_info.typ)
				if assign_stmt.op == .decl_assign {
					g.write('$styp ')
				}
				g.expr(ident)
				if is_optional {
					mr_base_styp := g.base_type(return_type)
					g.writeln(' = (*(${mr_base_styp}*)${mr_var_name}.data).arg$i;')
				} else {
					g.writeln(' = ${mr_var_name}.arg$i;')
				}
			}
			return
		}
	}
	// `a := 1` | `a,b := 1,2`
	for i, ident in assign_stmt.left {
		val := assign_stmt.right[i]
		ident_var_info := ident.var_info()
		styp := g.typ(ident_var_info.typ)
		mut is_call := false
		blank_assign := ident.kind == .blank_ident
		match val {
			ast.CallExpr {
				is_call = true
				return_type = it.return_type
			}
			// TODO: no buffer fiddling
			ast.AnonFn {
				if blank_assign {
					g.write('{')
				}
				ret_styp := g.typ(it.decl.return_type)
				g.write('$ret_styp (*$ident.name) (')
				def_pos := g.definitions.len
				g.fn_args(it.decl.args, it.decl.is_variadic)
				g.definitions.go_back(g.definitions.len - def_pos)
				g.write(') = ')
				g.expr(*it)
				g.writeln(';')
				if blank_assign {
					g.write('}')
				}
				continue
			}
			else {}
		}
		g.is_assign_rhs = true
		if blank_assign {
			if is_call {
				g.expr(val)
			} else {
				g.gen_default_init_value(val)
				g.write('{$styp _ = ')
				g.expr(val)
				g.writeln(';}')
			}
		} else {
			right_sym := g.table.get_type_symbol(assign_stmt.right_types[i])
			mut is_fixed_array_init := false
			mut has_val := false
			is_fixed_array_init, has_val = g.gen_default_init_value(val)
			is_inside_ternary := g.inside_ternary != 0
			cur_line := if is_inside_ternary {
				g.register_ternary_name(ident.name)
				g.empty_line = false
				g.go_before_ternary()
			} else {
				''
			}
			is_decl := assign_stmt.op == .decl_assign
			if right_sym.kind == .function {
				if is_inside_ternary {
					g.out.write(tabs[g.indent - g.inside_ternary])
				}
				func := right_sym.info as table.FnType
				ret_styp := g.typ(func.func.return_type)
				g.write('$ret_styp (*${g.get_ternary_name(ident.name)}) (')
				def_pos := g.definitions.len
				g.fn_args(func.func.args, func.func.is_variadic)
				g.definitions.go_back(g.definitions.len - def_pos)
				g.write(')')
			} else {
				if is_decl {
					if is_inside_ternary {
						g.out.write(tabs[g.indent - g.inside_ternary])
					}
					g.write('$styp ')
				}
				g.ident(ident)
			}
			if is_inside_ternary {
				g.write(';\n$cur_line')
				g.out.write(tabs[g.indent])
				g.ident(ident)
			}
			if g.autofree && right_sym.kind in [.array, .string] {
				if g.gen_clone_assignment(val, right_sym, true) {
					g.writeln(';')
					// g.expr_var_name = ''
					return
				}
			}
			if is_fixed_array_init {
				if has_val {
					g.write(' = ')
					g.expr(val)
				} else {
					g.write(' = {0}')
				}
			} else {
				g.write(' = ')
				if is_decl {
					g.expr(val)
				} else {
					g.expr_with_cast(val, assign_stmt.left_types[i], ident_var_info.typ)
				}
			}
		}
		g.is_assign_rhs = false
		if g.inside_ternary == 0 {
			g.writeln(';')
		}
	}
}

fn (mut g Gen) gen_default_init_value(val ast.Expr) (bool, bool) {
	mut is_fixed_array_init := false
	mut has_val := false
	match val {
		ast.ArrayInit {
			is_fixed_array_init = it.is_fixed
			has_val = it.has_val
			elem_type_str := g.typ(it.elem_type)
			if it.has_default {
				g.write('$elem_type_str _val_$it.pos.pos = ')
				g.expr(it.default_expr)
				g.writeln(';')
			} else if it.has_len && it.elem_type == table.string_type {
				g.writeln('$elem_type_str _val_$it.pos.pos = tos_lit("");')
			}
		}
		ast.StructInit {
			for field in it.fields {
				g.gen_default_init_value(field.expr)
			}
		}
		else {}
	}
	return is_fixed_array_init, has_val
}

fn (mut g Gen) register_ternary_name(name string) {
	level_key := g.inside_ternary.str()
	if level_key !in g.ternary_level_names {
		g.ternary_level_names[level_key] = []string{}
	}
	new_name := g.new_tmp_var()
	g.ternary_names[name] = new_name
	g.ternary_level_names[level_key] << name
}

fn (mut g Gen) get_ternary_name(name string) string {
	if g.inside_ternary == 0 {
		return name
	}
	if name !in g.ternary_names {
		return name
	}
	return g.ternary_names[name]
}

fn (mut g Gen) gen_clone_assignment(val ast.Expr, right_sym table.TypeSymbol, add_eq bool) bool {
	mut is_ident := false
	match val {
		ast.Ident { is_ident = true }
		ast.SelectorExpr { is_ident = true }
		else { return false }
	}
	if g.autofree && right_sym.kind == .array && is_ident {
		// `arr1 = arr2` => `arr1 = arr2.clone()`
		if add_eq {
			g.write('=')
		}
		g.write(' array_clone_static(')
		g.expr(val)
		g.write(')')
	} else if g.autofree && right_sym.kind == .string && is_ident {
		if add_eq {
			g.write('=')
		}
		// `str1 = str2` => `str1 = str2.clone()`
		g.write(' string_clone_static(')
		g.expr(val)
		g.write(')')
	}
	return true
}

fn (mut g Gen) autofree_scope_vars(pos int) string {
	// eprintln('> free_scope_vars($pos)')
	mut freeing_code := ''
	scope := g.file.scope.innermost(pos)
	for _, obj in scope.objects {
		match obj {
			ast.Var {
				// if var.typ == 0 {
				// // TODO why 0?
				// continue
				// }
				v := *it
				is_optional := v.typ.flag_is(.optional)
				if is_optional {
					// TODO: free optionals
					continue
				}
				freeing_code += g.autofree_variable(v)
			}
			else {}
		}
	}
	return freeing_code
}

fn (g &Gen) autofree_variable(v ast.Var) string {
	sym := g.table.get_type_symbol(v.typ)
	// if v.name.contains('output2') {
	// eprintln('   > var name: ${v.name:-20s} | is_arg: ${v.is_arg.str():6} | var type: ${int(v.typ):8} | type_name: ${sym.name:-33s}')
	// }
	if sym.kind == .array {
		return g.autofree_var_call('array_free', v)
	}
	if sym.kind == .string {
		// Don't free simple string literals.
		match v.expr {
			ast.StringLiteral {
				return '// str literal\n'
			}
			else {
				// NOTE/TODO: assign_stmt multi returns variables have no expr
				// since the type comes from the called fns return type
				/*
				f := v.name[0]
				if
					//!(f >= `a` && f <= `d`) {
					//f != `c` {
					v.name!='cvar_name' {
					t := typeof(v.expr)
				return '// other ' + t + '\n'
				}
				*/
			}
		}
		return g.autofree_var_call('string_free', v)
	}
	if sym.has_method('free') {
		return g.autofree_var_call(c_name(sym.name) + '_free', v)
	}
	return ''
}

fn (g &Gen) autofree_var_call(free_fn_name string, v ast.Var) string {
	if v.is_arg {
		// fn args should not be autofreed
		return ''
	}
	if v.typ.is_ptr() {
		return '\t${free_fn_name}($v.name); // autofreed ptr var\n'
	} else {
		return '\t${free_fn_name}(&$v.name); // autofreed var\n'
	}
}

fn (mut g Gen) expr(node ast.Expr) {
	// println('cgen expr() line_nr=$node.pos.line_nr')
	match node {
		ast.AnonFn {
			// TODO: dont fiddle with buffers
			pos := g.out.len
			def_pos := g.definitions.len
			g.stmt(it.decl)
			fn_body := g.out.after(pos)
			g.out.go_back(fn_body.len)
			g.definitions.go_back(g.definitions.len - def_pos)
			g.definitions.write(fn_body)
			fsym := g.table.get_type_symbol(it.typ)
			g.write('&${fsym.name}')
		}
		ast.ArrayInit {
			g.array_init(it)
		}
		ast.AsCast {
			g.as_cast(it)
		}
		ast.AssignExpr {
			g.assign_expr(it)
		}
		ast.Assoc {
			g.assoc(it)
		}
		ast.BoolLiteral {
			g.write(it.val.str())
		}
		ast.CallExpr {
			g.call_expr(it)
		}
		ast.CastExpr {
			// g.write('/*cast*/')
			if g.is_amp {
				// &Foo(0) => ((Foo*)0)
				g.out.go_back(1)
			}
			sym := g.table.get_type_symbol(it.typ)
			if sym.kind == .string && !it.typ.is_ptr() {
				// `string(x)` needs `tos()`, but not `&string(x)
				// `tos(str, len)`, `tos2(str)`
				if it.has_arg {
					g.write('tos((byteptr)')
				} else {
					g.write('tos2((byteptr)')
				}
				g.expr(it.expr)
				expr_sym := g.table.get_type_symbol(it.expr_type)
				if expr_sym.kind == .array {
					// if we are casting an array, we need to add `.data`
					g.write('.data')
				}
				if it.has_arg {
					// len argument
					g.write(', ')
					g.expr(it.arg)
				}
				g.write(')')
			} else if sym.kind == .sum_type {
				g.expr_with_cast(it.expr, it.expr_type, it.typ)
			} else {
				// styp := g.table.Type_to_str(it.typ)
				styp := g.typ(it.typ)
				// g.write('($styp)(')
				g.write('(($styp)(')
				// if g.is_amp {
				// g.write('*')
				// }
				// g.write(')(')
				g.expr(it.expr)
				g.write('))')
			}
		}
		ast.CharLiteral {
			g.write("'$it.val'")
		}
		ast.ConcatExpr {
			g.concat_expr(it)
		}
		ast.EnumVal {
			// g.write('${it.mod}${it.enum_name}_$it.val')
			styp := g.typ(it.typ)
			g.write('${styp}_$it.val')
		}
		ast.FloatLiteral {
			g.write(it.val)
		}
		ast.Ident {
			g.ident(it)
		}
		ast.IfExpr {
			g.if_expr(it)
		}
		ast.IfGuardExpr {
			g.write('/* guard */')
		}
		ast.IndexExpr {
			g.index_expr(it)
		}
		ast.InfixExpr {
			g.infix_expr(it)
		}
		ast.IntegerLiteral {
			if it.val.starts_with('0o') {
				g.write('0')
				g.write(it.val[2..])
			} else {
				g.write(it.val) // .int().str())
			}
		}
		ast.MatchExpr {
			g.match_expr(it)
		}
		ast.MapInit {
			key_typ_str := g.typ(it.key_type)
			value_typ_str := g.typ(it.value_type)
			size := it.vals.len
			if size > 0 {
				g.write('new_map_init($size, sizeof($value_typ_str), _MOV((${key_typ_str}[$size]){')
				for expr in it.keys {
					g.expr(expr)
					g.write(', ')
				}
				g.write('}), _MOV((${value_typ_str}[$size]){')
				for expr in it.vals {
					g.expr(expr)
					g.write(', ')
				}
				g.write('}))')
			} else {
				g.write('new_map_1(sizeof($value_typ_str))')
			}
		}
		ast.None {
			g.write('opt_none()')
		}
		ast.ParExpr {
			g.write('(')
			g.expr(it.expr)
			g.write(')')
		}
		ast.PostfixExpr {
			g.expr(it.expr)
			g.write(it.op.str())
		}
		ast.PrefixExpr {
			if it.op == .amp {
				g.is_amp = true
			}
			// g.write('/*pref*/')
			g.write(it.op.str())
			// g.write('(')
			g.expr(it.right)
			// g.write(')')
			g.is_amp = false
		}
		ast.SizeOf {
			mut styp := it.type_name
			if it.type_name == '' {
				styp = g.typ(it.typ)
			} else {
				sym := g.table.get_type_symbol(it.typ)
				if sym.kind == .struct_ {
					info := sym.info as table.Struct
					if !info.is_typedef {
						styp = 'struct ' + styp
					}
				}
			}
			/*
			if styp.starts_with('C__') {
				styp = styp[3..]
			}
			*/
			g.write('sizeof($styp)')
		}
		ast.StringLiteral {
			if it.is_raw {
				escaped_val := it.val.replace_each(['"', '\\"', '\\', '\\\\'])
				g.write('tos_lit("$escaped_val")')
				return
			}
			escaped_val := it.val.replace_each(['"', '\\"', '\r\n', '\\n', '\n', '\\n'])
			if g.is_c_call || it.language == .c {
				// In C calls we have to generate C strings
				// `C.printf("hi")` => `printf("hi");`
				g.write('"$escaped_val"')
			} else {
				// TODO calculate the literal's length in V, it's a bit tricky with all the
				// escape characters.
				// Clang and GCC optimize `strlen("lorem ipsum")` to `11`
				// g.write('tos4("$escaped_val", strlen("$escaped_val"))')
				// g.write('tos4("$escaped_val", $it.val.len)')
				// g.write('_SLIT("$escaped_val")')
				g.write('tos_lit("$escaped_val")')
				// g.write('tos_lit("$escaped_val")')
			}
		}
		ast.StringInterLiteral {
			g.string_inter_literal(it)
		}
		ast.StructInit {
			// `user := User{name: 'Bob'}`
			g.struct_init(it)
		}
		ast.SelectorExpr {
			g.expr(it.expr)
			if it.expr_type.is_ptr() {
				g.write('->')
			} else {
				// g.write('. /*typ=  $it.expr_type */') // ${g.typ(it.expr_type)} /')
				g.write('.')
			}
			if it.expr_type == 0 {
				verror('cgen: SelectorExpr | expr_type: 0 | it.expr: `${it.expr}` | field: `$it.field_name` | file: $g.file.path | line: $it.pos.line_nr')
			}
			g.write(c_name(it.field_name))
		}
		ast.Type {
			// match sum Type
			// g.write('/* Type */')
			type_idx := it.typ.idx()
			sym := g.table.get_type_symbol(it.typ)
			g.write('$type_idx /* $sym.name */')
		}
		ast.TypeOf {
			g.typeof_expr(it)
		}
		else {
			// #printf("node=%d\n", node.typ);
			println(term.red('cgen.expr(): bad node ' + typeof(node)))
		}
	}
}

fn (mut g Gen) typeof_expr(node ast.TypeOf) {
	sym := g.table.get_type_symbol(node.expr_type)
	if sym.kind == .sum_type {
		// When encountering a .sum_type, typeof() should be done at runtime,
		// because the subtype of the expression may change:
		sum_type_idx := node.expr_type.idx()
		g.write('tos3( /* ${sym.name} */ v_typeof_sumtype_${sum_type_idx}( (')
		g.expr(node.expr)
		g.write(').typ ))')
	} else if sym.kind == .array_fixed {
		fixed_info := sym.info as table.ArrayFixed
		typ_name := g.table.get_type_name(fixed_info.elem_type)
		g.write('tos_lit("[$fixed_info.size]${typ_name}")')
	} else if sym.kind == .function {
		info := sym.info as table.FnType
		fn_info := info.func
		mut repr := 'fn ('
		for i, arg in fn_info.args {
			if i > 0 {
				repr += ', '
			}
			repr += g.table.get_type_name(arg.typ)
		}
		repr += ')'
		if fn_info.return_type != table.void_type {
			repr += ' ${g.table.get_type_name(fn_info.return_type)}'
		}
		g.write('tos_lit("$repr")')
	} else {
		g.write('tos_lit("${sym.name}")')
	}
}

fn (mut g Gen) enum_expr(node ast.Expr) {
	match node {
		ast.EnumVal { g.write(it.val) }
		else { g.expr(node) }
	}
}

fn (mut g Gen) assign_expr(node ast.AssignExpr) {
	// g.write('/*assign_expr*/')
	mut is_call := false
	mut or_block := ast.OrExpr{}
	mut return_type := table.void_type
	match node.val {
		ast.CallExpr {
			is_call = true
			or_block = it.or_block
			return_type = it.return_type
		}
		else {}
	}
	gen_or := is_call && return_type.flag_is(.optional)
	tmp_opt := if gen_or { g.new_tmp_var() } else { '' }
	if gen_or {
		rstyp := g.typ(return_type)
		g.write('/*q*/ $rstyp $tmp_opt = ')
	}
	g.is_assign_rhs = true
	if ast.expr_is_blank_ident(node.left) {
		if is_call {
			g.expr(node.val)
		} else {
			// g.write('{${g.typ(node.left_type)} _ = ')
			g.write('{')
			g.expr(node.val)
			g.writeln(';}')
		}
	} else {
		g.is_assign_lhs = true
		if node.right_type.flag_is(.optional) {
			g.right_is_opt = true
		}
		mut str_add := false
		if node.left_type == table.string_type_idx && node.op == .plus_assign {
			// str += str2 => `str = string_add(str, str2)`
			g.expr(node.left)
			g.write(' = /*f*/string_add(')
			str_add = true
		}
		right_sym := g.table.get_type_symbol(node.right_type)
		if right_sym.kind == .array_fixed && node.op == .assign {
			right := node.val as ast.ArrayInit
			for j, expr in right.exprs {
				g.expr(node.left)
				g.write('[$j] = ')
				g.expr(expr)
				g.writeln(';')
			}
		} else {
			g.assign_op = node.op
			if !gen_or {
				// Don't need to generate `var = ` in `or {}` expressions, since we are doing
				// `Option_X tmp = ...; var = *(X*)tmp.data;`
				g.expr(node.left)
				// arr[i] = val => `array_set(arr, i, val)`, not `array_get(arr, i) = val`
				if !g.is_array_set && !str_add {
					g.write(' $node.op.str() ')
				} else if str_add {
					g.write(', ')
				}
			}
			g.is_assign_lhs = false
			// right_sym := g.table.get_type_symbol(node.right_type)
			// left_sym := g.table.get_type_symbol(node.left_type)
			mut cloned := false
			// !g.is_array_set
			if g.autofree && right_sym.kind in [.array, .string] {
				if g.gen_clone_assignment(node.val, right_sym, false) {
					cloned = true
				}
			}
			if !cloned {
				g.expr_with_cast(node.val, node.right_type, node.left_type)
			}
			if g.is_array_set {
				g.write(' })')
				g.is_array_set = false
			} else if str_add {
				g.write(')')
			}
		}
		g.right_is_opt = false
	}
	if gen_or {
		// g.write('/*777 $tmp_opt*/')
		g.or_block(tmp_opt, or_block, return_type)
		unwrapped_type_str := g.typ(return_type.set_flag(.unset))
		ident := node.left as ast.Ident
		if ident.kind != .blank_ident && ident.info is ast.IdentVar {
			ident_var := ident.info as ast.IdentVar
			if ident_var.is_optional {
				// var is already an optional, just copy the value
				// `var = tmp;`
				g.write('\n$ident.name = $tmp_opt')
			} else {
				// var = *(X*)tmp.data;`
				g.write('\n$ident.name = *($unwrapped_type_str*)${tmp_opt}.data')
			}
		}
		// g.expr(node.left)
	}
	g.is_assign_rhs = false
}

fn (mut g Gen) infix_expr(node ast.InfixExpr) {
	// println('infix_expr() op="$node.op.str()" line_nr=$node.pos.line_nr')
	// g.write('/*infix*/')
	// if it.left_type == table.string_type_idx {
	// g.write('/*$node.left_type str*/')
	// }
	// string + string, string == string etc
	// g.infix_op = node.op
	left_type := if node.left_type == table.t_type { g.cur_generic_type } else { node.left_type }
	left_sym := g.table.get_type_symbol(left_type)
	if node.op == .key_is {
		g.is_expr(node)
		return
	}
	right_sym := g.table.get_type_symbol(node.right_type)
	if left_type == table.ustring_type_idx && node.op != .key_in && node.op != .not_in {
		fn_name := match node.op {
			.plus {
				'ustring_add('
			}
			.eq {
				'ustring_eq('
			}
			.ne {
				'ustring_ne('
			}
			.lt {
				'ustring_lt('
			}
			.le {
				'ustring_le('
			}
			.gt {
				'ustring_gt('
			}
			.ge {
				'ustring_ge('
			}
			else {
				verror('op error for type `$left_sym.name`')
				'/*node error*/'
			}
		}
		g.write(fn_name)
		g.expr(node.left)
		g.write(', ')
		g.expr(node.right)
		g.write(')')
	} else if left_type == table.string_type_idx && node.op != .key_in && node.op != .not_in {
		fn_name := match node.op {
			.plus {
				'string_add('
			}
			.eq {
				'string_eq('
			}
			.ne {
				'string_ne('
			}
			.lt {
				'string_lt('
			}
			.le {
				'string_le('
			}
			.gt {
				'string_gt('
			}
			.ge {
				'string_ge('
			}
			else {
				verror('op error for type `$left_sym.name`')
				'/*node error*/'
			}
		}
		g.write(fn_name)
		g.expr(node.left)
		g.write(', ')
		g.expr(node.right)
		g.write(')')
	} else if node.op in [.eq, .ne] && left_sym.kind == .array && right_sym.kind == .array {
		styp := g.table.value_type(left_type)
		ptr_typ := g.typ(left_type).split('_')[1]
		if ptr_typ !in g.array_fn_definitions {
			sym := g.table.get_type_symbol(left_sym.array_info().elem_type)
			g.generate_array_equality_fn(ptr_typ, styp, sym)
		}
		if node.op == .eq {
			g.write('${ptr_typ}_arr_eq(')
		} else if node.op == .ne {
			g.write('!${ptr_typ}_arr_eq(')
		}
		g.expr(node.left)
		g.write(', ')
		g.expr(node.right)
		g.write(')')
	} else if node.op in [.key_in, .not_in] {
		if node.op == .not_in {
			g.write('!')
		}
		if right_sym.kind == .array {
			match node.right {
				ast.ArrayInit {
					// `a in [1,2,3]` optimization => `a == 1 || a == 2 || a == 3`
					// avoids an allocation
					// g.write('/*in opt*/')
					g.write('(')
					g.in_optimization(node.left, it)
					g.write(')')
					return
				}
				else {}
			}
			styp := g.typ(left_type)
			g.write('_IN($styp, ')
			g.expr(node.left)
			g.write(', ')
			g.expr(node.right)
			g.write(')')
		} else if right_sym.kind == .map {
			g.write('_IN_MAP(')
			g.expr(node.left)
			g.write(', ')
			g.expr(node.right)
			g.write(')')
		} else if right_sym.kind == .string {
			g.write('string_contains(')
			g.expr(node.right)
			g.write(', ')
			g.expr(node.left)
			g.write(')')
		}
	} else if node.op == .left_shift && g.table.get_type_symbol(left_type).kind == .array {
		// arr << val
		tmp := g.new_tmp_var()
		sym := g.table.get_type_symbol(left_type)
		info := sym.info as table.Array
		if right_sym.kind == .array && info.elem_type != node.right_type {
			// push an array => PUSH_MANY, but not if pushing an array to 2d array (`[][]int << []int`)
			g.write('_PUSH_MANY(&')
			g.expr(node.left)
			g.write(', (')
			g.expr_with_cast(node.right, node.right_type, left_type)
			styp := g.typ(left_type)
			g.write('), $tmp, $styp)')
		} else {
			// push a single element
			elem_type_str := g.typ(info.elem_type)
			g.write('array_push(&')
			g.expr(node.left)
			g.write(', _MOV(($elem_type_str[]){ ')
			elem_sym := g.table.get_type_symbol(info.elem_type)
			if elem_sym.kind == .interface_ && node.right_type != info.elem_type {
				g.interface_call(node.right_type, info.elem_type)
			}
			g.expr_with_cast(node.right, node.right_type, info.elem_type)
			if elem_sym.kind == .interface_ && node.right_type != info.elem_type {
				g.write(')')
			}
			g.write(' }))')
		}
	} else if (left_type == node.right_type) && left_type.is_float() && node.op in [.eq, .ne] {
		// floats should be compared with epsilon
		if left_type == table.f64_type_idx {
			if node.op == .eq {
				g.write('f64_eq(')
			} else {
				g.write('f64_ne(')
			}
		} else {
			if node.op == .eq {
				g.write('f32_eq(')
			} else {
				g.write('f32_ne(')
			}
		}
		g.expr(node.left)
		g.write(',')
		g.expr(node.right)
		g.write(')')
	} else if node.op in [.plus, .minus, .mul, .div, .mod] && (left_sym.name[0].is_capital() ||
		left_sym.name.contains('.')) && left_sym.kind != .alias || left_sym.kind == .alias && (left_sym.info as table.Alias).language ==
		.c {
		// !left_sym.is_number() {
		g.write(g.typ(left_type))
		g.write('_')
		g.write(util.replace_op(node.op.str()))
		g.write('(')
		g.expr(node.left)
		g.write(', ')
		g.expr(node.right)
		g.write(')')
	} else {
		need_par := node.op in [.amp, .pipe, .xor] // `x & y == 0` => `(x & y) == 0` in C
		if need_par {
			g.write('(')
		}
		g.expr(node.left)
		g.write(' $node.op.str() ')
		g.expr(node.right)
		if need_par {
			g.write(')')
		}
	}
}

fn (mut g Gen) match_expr(node ast.MatchExpr) {
	// println('match expr typ=$it.expr_type')
	// TODO
	if node.cond_type == 0 {
		g.writeln('// match 0')
		return
	}
	is_expr := (node.is_expr && node.return_type != table.void_type) || g.inside_ternary >
		0
	if is_expr {
		g.inside_ternary++
		// g.write('/* EM ret type=${g.typ(node.return_type)}		expected_type=${g.typ(node.expected_type)}  */')
	}
	type_sym := g.table.get_type_symbol(node.cond_type)
	mut tmp := ''
	if type_sym.kind != .void {
		tmp = g.new_tmp_var()
	}
	// styp := g.typ(node.expr_type)
	// g.write('$styp $tmp = ')
	// g.expr(node.cond)
	// g.writeln(';') // $it.blocks.len')
	// mut sum_type_str = ''
	for j, branch in node.branches {
		is_last := j == node.branches.len - 1
		if branch.is_else || node.is_expr && is_last {
			if node.branches.len > 1 {
				if is_expr {
					// TODO too many branches. maybe separate ?: matches
					g.write(' : ')
				} else {
					g.writeln('else {')
				}
			}
		} else {
			if j > 0 {
				if is_expr {
					g.write(' : ')
				} else {
					g.write('else ')
				}
			}
			if is_expr {
				g.write('(')
			} else {
				g.write('if (')
			}
			for i, expr in branch.exprs {
				if node.is_sum_type {
					g.expr(node.cond)
					g.write('.typ == ')
					// g.write('${tmp}.typ == ')
					// sum_type_str
				} else if type_sym.kind == .string {
					g.write('string_eq(')
					//
					g.expr(node.cond)
					g.write(', ')
					// g.write('string_eq($tmp, ')
				} else {
					g.expr(node.cond)
					g.write(' == ')
					// g.write('$tmp == ')
				}
				g.expr(expr)
				if type_sym.kind == .string {
					g.write(')')
				}
				if i < branch.exprs.len - 1 {
					g.write(' || ')
				}
			}
			if is_expr {
				g.write(') ? ')
			} else {
				g.writeln(') {')
			}
		}
		// g.writeln('/* M sum_type=$node.is_sum_type is_expr=$node.is_expr exp_type=${g.typ(node.expected_type)}*/')
		if node.is_sum_type && branch.exprs.len > 0 && !node.is_expr {
			// The first node in expr is an ast.Type
			// Use it to generate `it` variable.
			first_expr := branch.exprs[0]
			match first_expr {
				ast.Type {
					it_type := g.typ(it.typ)
					// g.writeln('$it_type* it = ($it_type*)${tmp}.obj; // ST it')
					g.write('\t$it_type* it = ($it_type*)')
					g.expr(node.cond)
					g.writeln('.obj; // ST it')
				}
				else {
					verror('match sum type')
				}
			}
		}
		g.stmts(branch.stmts)
		if g.inside_ternary == 0 && node.branches.len > 1 {
			g.write('}')
		}
	}
	if is_expr {
		g.decrement_inside_ternary()
	}
}

fn (mut g Gen) ident(node ast.Ident) {
	if node.name == 'lld' {
		return
	}
	if node.name.starts_with('C.') {
		g.write(node.name[2..].replace('.', '__'))
		return
	}
	if node.kind == .constant && !node.name.starts_with('g_') {
		// TODO globals hack
		g.write('_const_')
	}
	mut name := c_name(node.name)
	if node.info is ast.IdentVar {
		ident_var := node.info as ast.IdentVar
		// x ?int
		// `x = 10` => `x.data = 10` (g.right_is_opt == false)
		// `x = new_opt()` => `x = new_opt()` (g.right_is_opt == true)
		// `println(x)` => `println(*(int*)x.data)`
		if ident_var.is_optional && !(g.is_assign_lhs && g.right_is_opt) {
			g.write('/*opt*/')
			styp := g.base_type(ident_var.typ)
			g.write('(*($styp*)${name}.data)')
			return
		}
	}
	g.write(g.get_ternary_name(name))
}

fn (mut g Gen) concat_expr(node ast.ConcatExpr) {
	styp := g.typ(node.return_type)
	sym := g.table.get_type_symbol(node.return_type)
	is_multi := sym.kind == .multi_return
	if !is_multi {
		g.expr(node.vals[0])
	} else {
		g.write('($styp){')
		for i, expr in node.vals {
			g.write('.arg$i=')
			g.expr(expr)
			if i < node.vals.len - 1 {
				g.write(',')
			}
		}
		g.write('}')
	}
}

fn (mut g Gen) if_expr(node ast.IfExpr) {
	if node.is_expr || g.inside_ternary != 0 {
		g.inside_ternary++
		g.write('(')
		for i, branch in node.branches {
			if i > 0 {
				g.write(' : ')
			}
			if i < node.branches.len - 1 || !node.has_else {
				g.expr(branch.cond)
				g.write(' ? ')
			}
			g.stmts(branch.stmts)
		}
		if node.branches.len == 1 {
			g.write(': 0')
		}
		g.write(')')
		g.decrement_inside_ternary()
		return
	}
	mut is_guard := false
	for i, branch in node.branches {
		if i == 0 {
			match branch.cond {
				ast.IfGuardExpr {
					is_guard = true
					g.write('{ /* if guard */ ${g.typ(it.expr_type)} $it.var_name = ')
					g.expr(it.expr)
					g.writeln(';')
					g.writeln('if (${it.var_name}.ok) {')
				}
				else {
					g.write('if (')
					g.expr(branch.cond)
					g.writeln(') {')
				}
			}
		} else if i < node.branches.len - 1 || !node.has_else {
			g.write('} else if (')
			g.expr(branch.cond)
			g.writeln(') {')
		} else if i == node.branches.len - 1 && node.has_else {
			g.writeln('} else {')
		}
		g.stmts(branch.stmts)
	}
	if is_guard {
		g.write('}')
	}
	g.writeln('}')
}

fn (mut g Gen) index_expr(node ast.IndexExpr) {
	// TODO else doesn't work with sum types
	mut is_range := false
	match node.index {
		ast.RangeExpr {
			sym := g.table.get_type_symbol(node.left_type)
			is_range = true
			if sym.kind == .string {
				g.write('string_substr(')
				g.expr(node.left)
			} else if sym.kind == .array {
				g.write('array_slice(')
				g.expr(node.left)
			} else if sym.kind == .array_fixed {
				// Convert a fixed array to V array when doing `fixed_arr[start..end]`
				g.write('array_slice(new_array_from_c_array(_ARR_LEN(')
				g.expr(node.left)
				g.write('), _ARR_LEN(')
				g.expr(node.left)
				g.write('), sizeof(')
				g.expr(node.left)
				g.write('[0]), ')
				g.expr(node.left)
				g.write(')')
			} else {
				g.expr(node.left)
			}
			g.write(', ')
			if it.has_low {
				g.expr(it.low)
			} else {
				g.write('0')
			}
			g.write(', ')
			if it.has_high {
				g.expr(it.high)
			} else {
				g.expr(node.left)
				g.write('.len')
			}
			g.write(')')
			return
		}
		else {}
	}
	if !is_range {
		sym := g.table.get_type_symbol(node.left_type)
		left_is_ptr := node.left_type.is_ptr()
		if node.left_type.flag_is(.variadic) {
			g.expr(node.left)
			g.write('.args')
			g.write('[')
			g.expr(node.index)
			g.write(']')
		} else if sym.kind == .array {
			info := sym.info as table.Array
			elem_type_str := g.typ(info.elem_type)
			// `vals[i].field = x` is an exception and requires `array_get`:
			// `(*(Val*)array_get(vals, i)).field = x;`
			is_selector := node.left is ast.SelectorExpr
			if g.is_assign_lhs && !is_selector && node.is_setter {
				g.is_array_set = true
				g.write('array_set(')
				if !left_is_ptr {
					g.write('&')
				}
				g.expr(node.left)
				g.write(', ')
				g.expr(node.index)
				mut need_wrapper := true
				/*
				match node.right {
					ast.EnumVal, ast.Ident {
						// `&x` is enough for variables and enums
						// `&(Foo[]){ ... }` is only needed for function calls and literals
						need_wrapper = false
					}
					else {}
				}
				*/
				if need_wrapper {
					g.write(', &($elem_type_str[]) { \n')
				} else {
					g.write(', &')
				}
				// `x[0] *= y`
				if g.assign_op != .assign && g.assign_op in token.assign_tokens {
					// TODO move this
					g.write('*($elem_type_str*)array_get(')
					if left_is_ptr {
						g.write('*')
					}
					g.expr(node.left)
					g.write(', ')
					g.expr(node.index)
					g.write(') ')
					op := match g.assign_op {
						.mult_assign { '*' }
						.plus_assign { '+' }
						.minus_assign { '-' }
						.div_assign { '/' }
						.xor_assign { '^' }
						.mod_assign { '%' }
						.or_assign { '|' }
						.and_assign { '&' }
						.left_shift_assign { '<<' }
						.right_shift_assign { '>>' }
						else { '' }
					}
					g.write(op)
				}
			} else {
				g.write('(*($elem_type_str*)array_get(')
				if left_is_ptr {
					g.write('*')
				}
				g.expr(node.left)
				g.write(', ')
				g.expr(node.index)
				g.write('))')
			}
		} else if sym.kind == .map {
			info := sym.info as table.Map
			elem_type_str := g.typ(info.value_type)
			if g.is_assign_lhs && !g.is_array_set {
				g.is_array_set = true
				g.write('map_set(')
				if !left_is_ptr {
					g.write('&')
				}
				g.expr(node.left)
				g.write(', ')
				g.expr(node.index)
				g.write(', &($elem_type_str[]) { \n')
			} else {
				/*
				g.write('(*($elem_type_str*)map_get2(')
				g.expr(node.left)
					g.write(', ')
					g.expr(node.index)
					g.write('))')
				*/
				zero := g.type_default(info.value_type)
				g.write('(*($elem_type_str*)map_get3(')
				g.expr(node.left)
				g.write(', ')
				g.expr(node.index)
				g.write(', &($elem_type_str[]){ $zero }))\n')
			}
		} else if sym.kind == .string && !node.left_type.is_ptr() {
			g.write('string_at(')
			g.expr(node.left)
			g.write(', ')
			g.expr(node.index)
			g.write(')')
		} else {
			g.expr(node.left)
			g.write('[')
			g.expr(node.index)
			g.write(']')
		}
	}
}

fn (mut g Gen) return_statement(node ast.Return) {
	g.write('return ')
	if g.fn_decl.name == 'main' {
		g.writeln('0;')
		return
	}
	// got to do a correct check for multireturn
	sym := g.table.get_type_symbol(g.fn_decl.return_type)
	fn_return_is_multi := sym.kind == .multi_return
	fn_return_is_optional := g.fn_decl.return_type.flag_is(.optional)
	// handle none/error for optional
	if fn_return_is_optional {
		optional_none := node.exprs[0] is ast.None
		mut optional_error := false
		match node.exprs[0] {
			ast.CallExpr { optional_error = it.name == 'error' }
			else { false }
		}
		if optional_none || optional_error {
			g.expr_with_cast(node.exprs[0], node.types[0], g.fn_decl.return_type)
			g.write(';')
			return
		}
	}
	// regular cases
	if fn_return_is_multi { // not_optional_none { //&& !fn_return_is_optional {
		// typ_sym := g.table.get_type_symbol(g.fn_decl.return_type)
		// mr_info := typ_sym.info as table.MultiReturn
		mut styp := ''
		if fn_return_is_optional {
			styp = g.base_type(g.fn_decl.return_type)
			g.write('opt_ok(&($styp/*X*/[]) { ')
		} else {
			styp = g.typ(g.fn_decl.return_type)
		}
		g.write('($styp){')
		for i, expr in node.exprs {
			g.write('.arg$i=')
			g.expr(expr)
			if i < node.exprs.len - 1 {
				g.write(',')
			}
		}
		g.write('}')
		if fn_return_is_optional {
			g.write(' }, sizeof($styp))')
		}
	} else if node.exprs.len >= 1 {
		// normal return
		return_sym := g.table.get_type_symbol(node.types[0])
		// `return opt_ok(expr)` for functions that expect an optional
		if fn_return_is_optional && !node.types[0].flag_is(.optional) && return_sym.name !=
			'Option' {
			styp := g.base_type(g.fn_decl.return_type)
			g.write('/*:)$return_sym.name*/opt_ok(&($styp[]) { ')
			if !g.fn_decl.return_type.is_ptr() && node.types[0].is_ptr() {
				// Automatic Dereference for optional
				g.write('*')
			}
			for i, expr in node.exprs {
				g.expr(expr)
				if i < node.exprs.len - 1 {
					g.write(', ')
				}
			}
			g.writeln(' }, sizeof($styp));')
			return
		}
		g.expr_with_cast(node.exprs[0], node.types[0], g.fn_decl.return_type)
	}
	g.writeln(';')
}

fn (mut g Gen) const_decl(node ast.ConstDecl) {
	for field in node.fields {
		name := c_name(field.name)
		// TODO hack. Cut the generated value and paste it into definitions.
		pos := g.out.len
		g.expr(field.expr)
		val := g.out.after(pos)
		g.out.go_back(val.len)
		/*
		if field.typ == table.byte_type {
			g.const_decl_simple_define(name, val)
			return
		}
		*/
		/*
		if table.is_number(field.typ) {
			g.const_decl_simple_define(name, val)
		} else if field.typ == table.string_type {
			g.definitions.writeln('string _const_$name; // a string literal, inited later')
			if g.pref.build_mode != .build_module {
				g.stringliterals.writeln('\t_const_$name = $val;')
			}
		} else {
		*/
		match field.expr {
			ast.CharLiteral {
				g.const_decl_simple_define(name, val)
			}
			ast.FloatLiteral {
				g.const_decl_simple_define(name, val)
			}
			ast.IntegerLiteral {
				g.const_decl_simple_define(name, val)
			}
			ast.ArrayInit {
				if it.is_fixed {
					styp := g.typ(it.typ)
					g.definitions.writeln('$styp _const_$name = $val; // fixed array const')
				} else {
					g.const_decl_init_later(name, val, field.typ)
				}
			}
			ast.StringLiteral {
				g.definitions.writeln('string _const_$name; // a string literal, inited later')
				if g.pref.build_mode != .build_module {
					g.stringliterals.writeln('\t_const_$name = $val;')
				}
			}
			else {
				g.const_decl_init_later(name, val, field.typ)
			}
		}
	}
}

fn (mut g Gen) const_decl_simple_define(name, val string) {
	// Simple expressions should use a #define
	// so that we don't pollute the binary with unnecessary global vars
	// Do not do this when building a module, otherwise the consts
	// will not be accessible.
	g.definitions.write('#define _const_$name ')
	g.definitions.writeln(val)
}

fn (mut g Gen) const_decl_init_later(name, val string, typ table.Type) {
	// Initialize more complex consts in `void _vinit(){}`
	// (C doesn't allow init expressions that can't be resolved at compile time).
	styp := g.typ(typ)
	//
	cname := '_const_$name'
	g.definitions.writeln('$styp $cname; // inited later')
	g.inits.writeln('\t$cname = $val;')
	if g.pref.autofree {
		if styp.starts_with('array_') {
			g.cleanups.writeln('\tarray_free(&$cname);')
		}
		if styp == 'string' {
			g.cleanups.writeln('\tstring_free(&$cname);')
		}
	}
}

fn (mut g Gen) go_back_out(n int) {
	g.out.go_back(n)
}

fn (mut g Gen) struct_init(struct_init ast.StructInit) {
	skip_init := ['strconv__ftoa__Uf32', 'strconv__ftoa__Uf64', 'strconv__Float64u', 'struct stat',
		'struct addrinfo'
	]
	styp := g.typ(struct_init.typ)
	if styp in skip_init {
		g.go_back_out(3)
		return
	}
	sym := g.table.get_type_symbol(struct_init.typ)
	is_amp := g.is_amp
	g.is_amp = false // reset the flag immediately so that other struct inits in this expr are handled correctly
	if is_amp {
		g.out.go_back(1) // delete the `&` already generated in `prefix_expr()
		g.write('($styp*)memdup(&($styp){')
	} else {
		g.writeln('($styp){')
	}
	// mut fields := []string{}
	mut inited_fields := map[string]int{} // TODO this is done in checker, move to ast node
	/*
	if struct_init.fields.len == 0 && struct_init.exprs.len > 0 {
		// Get fields for {a,b} short syntax. Fields array wasn't set in the parser.
		for f in info.fields {
			fields << f.name
		}
	} else {
		fields = struct_init.fields
	}
	*/
	// User set fields
	mut initialized := false
	for i, field in struct_init.fields {
		inited_fields[field.name] = i
		if sym.kind != .struct_ {
			field_name := c_name(field.name)
			g.write('\t.$field_name = ')
			field_type_sym := g.table.get_type_symbol(field.typ)
			mut cloned := false
			if g.autofree && field_type_sym.kind in [.array, .string] {
				g.write('/*clone1*/')
				if g.gen_clone_assignment(field.expr, field_type_sym, false) {
					cloned = true
				}
			}
			if !cloned {
				if field.expected_type.is_ptr() && !field.typ.is_ptr() && !field.typ.is_number() {
					g.write('/* autoref */&')
				}
				g.expr_with_cast(field.expr, field.typ, field.expected_type)
			}
			g.writeln(',')
			initialized = true
		}
	}
	// The rest of the fields are zeroed.
	mut nr_info_fields := 0
	if sym.kind == .struct_ {
		info := sym.info as table.Struct
		if info.is_union && struct_init.fields.len > 1 {
			verror('union must not have more than 1 initializer')
		}
		nr_info_fields = info.fields.len
		for field in info.fields {
			if field.name in inited_fields {
				sfield := struct_init.fields[inited_fields[field.name]]
				field_name := c_name(sfield.name)
				g.write('\t.$field_name = ')
				field_type_sym := g.table.get_type_symbol(sfield.typ)
				mut cloned := false
				if g.autofree && field_type_sym.kind in [.array, .string] {
					g.write('/*clone1*/')
					if g.gen_clone_assignment(sfield.expr, field_type_sym, false) {
						cloned = true
					}
				}
				if !cloned {
					if sfield.expected_type.is_ptr() && !sfield.typ.is_ptr() && !sfield.typ.is_number() {
						g.write('/* autoref */&')
					}
					g.expr_with_cast(sfield.expr, sfield.typ, sfield.expected_type)
				}
				g.writeln(',')
				initialized = true
				continue
			}
			if info.is_union {
				// unions thould have exactly one explicit initializer
				continue
			}
			if field.typ.flag_is(.optional) {
				// TODO handle/require optionals in inits
				continue
			}
			field_name := c_name(field.name)
			g.write('\t.$field_name = ')
			if field.has_default_expr {
				g.expr(ast.fe2ex(field.default_expr))
			} else {
				g.write(g.type_default(field.typ))
			}
			g.writeln(',')
			initialized = true
		}
	}
	// if struct_init.fields.len == 0 && info.fields.len == 0 {
	if !initialized {
		g.write('\n#ifndef __cplusplus\n0\n#endif\n')
	}
	g.write('}')
	if is_amp {
		g.write(', sizeof($styp))')
	}
}

// { user | name: 'new name' }
fn (mut g Gen) assoc(node ast.Assoc) {
	g.writeln('// assoc')
	if node.typ == 0 {
		return
	}
	styp := g.typ(node.typ)
	g.writeln('($styp){')
	mut inited_fields := map[string]int{}
	for i, field in node.fields {
		inited_fields[field] = i
	}
	// Merge inited_fields in the rest of the fields.
	sym := g.table.get_type_symbol(node.typ)
	info := sym.info as table.Struct
	for field in info.fields {
		field_name := c_name(field.name)
		if field.name in inited_fields {
			g.write('\t.$field_name = ')
			g.expr(node.exprs[inited_fields[field.name]])
			g.writeln(', ')
		} else {
			g.writeln('\t.$field_name = ${node.var_name}.$field_name,')
		}
	}
	g.write('}')
	if g.is_amp {
		g.write(', sizeof($styp))')
	}
}

fn (mut g Gen) generate_array_equality_fn(ptr_typ string, styp table.Type, sym &table.TypeSymbol) {
	g.array_fn_definitions << ptr_typ
	g.definitions.writeln('bool ${ptr_typ}_arr_eq(array_${ptr_typ} a, array_${ptr_typ} b) {')
	g.definitions.writeln('\tif (a.len != b.len) {')
	g.definitions.writeln('\t\treturn false;')
	g.definitions.writeln('\t}')
	g.definitions.writeln('\tfor (int i = 0; i < a.len; i++) {')
	if styp == table.string_type_idx {
		g.definitions.writeln('\t\tif (string_ne(*((${ptr_typ}*)((byte*)a.data+(i*a.element_size))), *((${ptr_typ}*)((byte*)b.data+(i*b.element_size))))) {')
	} else if sym.kind == .struct_ {
		g.definitions.writeln('\t\tif (memcmp((byte*)a.data+(i*a.element_size), (byte*)b.data+(i*b.element_size), a.element_size)) {')
	} else {
		g.definitions.writeln('\t\tif (*((${ptr_typ}*)((byte*)a.data+(i*a.element_size))) != *((${ptr_typ}*)((byte*)b.data+(i*b.element_size)))) {')
	}
	g.definitions.writeln('\t\t\treturn false;')
	g.definitions.writeln('\t\t}')
	g.definitions.writeln('\t}')
	g.definitions.writeln('\treturn true;')
	g.definitions.writeln('}')
}

fn verror(s string) {
	util.verror('cgen error', s)
}

fn (mut g Gen) write_init_function() {
	if g.pref.is_liveshared {
		return
	}
	fn_vinit_start_pos := g.out.len
	g.writeln('void _vinit() {')
	g.writeln('\tbuiltin_init();')
	g.writeln('\tvinit_string_literals();')
	g.writeln(g.inits.str())
	for mod_name in g.table.imports {
		init_fn_name := '${mod_name}.init'
		if _ := g.table.find_fn(init_fn_name) {
			mod_c_name := mod_name.replace('.', '__')
			init_fn_c_name := '${mod_c_name}__init'
			g.writeln('\t${init_fn_c_name}();')
		}
	}
	g.writeln('}')
	if g.pref.printfn_list.len > 0 && '_vinit' in g.pref.printfn_list {
		println(g.out.after(fn_vinit_start_pos))
	}
	if g.autofree {
		fn_vcleanup_start_pos := g.out.len
		g.writeln('void _vcleanup() {')
		// g.writeln('puts("cleaning up...");')
		g.writeln(g.cleanups.str())
		g.writeln('}')
		if g.pref.printfn_list.len > 0 && '_vcleanup' in g.pref.printfn_list {
			println(g.out.after(fn_vcleanup_start_pos))
		}
	}
}

const (
	builtins = ['string', 'array', 'KeyValue', 'DenseArray', 'map', 'Option']
)

fn (mut g Gen) write_builtin_types() {
	mut builtin_types := []table.TypeSymbol{} // builtin types
	// builtin types need to be on top
	// everything except builtin will get sorted
	for builtin_name in builtins {
		builtin_types << g.table.types[g.table.type_idxs[builtin_name]]
	}
	g.write_types(builtin_types)
}

// C struct definitions, ordered
// Sort the types, make sure types that are referenced by other types
// are added before them.
fn (mut g Gen) write_sorted_types() {
	mut types := []table.TypeSymbol{} // structs that need to be sorted
	for typ in g.table.types {
		if typ.name !in builtins {
			types << typ
		}
	}
	// sort structs
	types_sorted := g.sort_structs(types)
	// Generate C code
	g.definitions.writeln('// builtin types:')
	g.definitions.writeln('//------------------ #endbuiltin')
	g.write_types(types_sorted)
}

fn (mut g Gen) write_types(types []table.TypeSymbol) {
	for typ in types {
		if typ.name.starts_with('C.') {
			continue
		}
		// sym := g.table.get_type_symbol(typ)
		name := typ.name.replace('.', '__')
		match typ.info {
			table.Struct {
				info := typ.info as table.Struct
				// g.definitions.writeln('typedef struct {')
				if info.is_union {
					g.definitions.writeln('union $name {')
				} else {
					g.definitions.writeln('struct $name {')
				}
				if info.fields.len > 0 {
					for field in info.fields {
						type_name := g.typ(field.typ)
						field_name := c_name(field.name)
						g.definitions.writeln('\t$type_name $field_name;')
					}
				} else {
					g.definitions.writeln('EMPTY_STRUCT_DECLARATION;')
				}
				// g.definitions.writeln('} $name;\n')
				//
				g.definitions.writeln('};\n')
			}
			table.Alias {
				// table.Alias, table.SumType { TODO
			}
			table.SumType {
				g.definitions.writeln('')
				g.definitions.writeln('// Sum type $name = ')
				for sv in it.variants {
					g.definitions.writeln('//          | ${sv:4d} = ${g.typ(sv):-20s}')
				}
				g.definitions.writeln('typedef struct {')
				g.definitions.writeln('    void* obj;')
				g.definitions.writeln('    int typ;')
				g.definitions.writeln('} $name;')
				g.definitions.writeln('')
			}
			table.ArrayFixed {
				// .array_fixed {
				styp := typ.name.replace('.', '__')
				// array_fixed_char_300 => char x[300]
				mut fixed := styp[12..]
				len := styp.after('_')
				fixed = fixed[..fixed.len - len.len - 1]
				if fixed.starts_with('C__') {
					fixed = fixed[3..]
				}
				g.definitions.writeln('typedef $fixed $styp [$len];')
				// }
			}
			else {}
		}
	}
}

// sort structs by dependant fields
fn (g Gen) sort_structs(typesa []table.TypeSymbol) []table.TypeSymbol {
	mut dep_graph := depgraph.new_dep_graph()
	// types name list
	mut type_names := []string{}
	for typ in typesa {
		type_names << typ.name
	}
	// loop over types
	for t in typesa {
		if t.kind == .interface_ {
			dep_graph.add(t.name, [])
			continue
		}
		// create list of deps
		mut field_deps := []string{}
		match t.info {
			table.ArrayFixed {
				dep := g.table.get_type_symbol(it.elem_type).name
				if dep in type_names {
					field_deps << dep
				}
			}
			table.Struct {
				info := t.info as table.Struct
				// if info.is_interface {
				// continue
				// }
				for field in info.fields {
					dep := g.table.get_type_symbol(field.typ).name
					// skip if not in types list or already in deps
					if dep !in type_names || dep in field_deps || field.typ.is_ptr() {
						continue
					}
					field_deps << dep
				}
			}
			// table.Interface {}
			else {}
		}
		// add type and dependant types to graph
		dep_graph.add(t.name, field_deps)
	}
	// sort graph
	dep_graph_sorted := dep_graph.resolve()
	if !dep_graph_sorted.acyclic {
		verror('cgen.sort_structs(): the following structs form a dependency cycle:\n' + dep_graph_sorted.display_cycles() +
			'\nyou can solve this by making one or both of the dependant struct fields references, eg: field &MyStruct' +
			'\nif you feel this is an error, please create a new issue here: https://github.com/vlang/v/issues and tag @joe-conigliaro')
	}
	// sort types
	mut types_sorted := []table.TypeSymbol{}
	for node in dep_graph_sorted.nodes {
		types_sorted << g.table.types[g.table.type_idxs[node.name]]
	}
	return types_sorted
}

fn (mut g Gen) string_inter_literal(node ast.StringInterLiteral) {
	if g.pref.autofree {
		g.write('_STR_TMP("')
	} else {
		g.write('_STR("')
	}
	// Build the string with %
	mut fieldwidths := []int{}
	mut specs := []byte{}
	mut end_string := false
	for i, val in node.vals {
		escaped_val := val.replace_each(['"', '\\"', '\r\n', '\\n', '\n', '\\n', '%', '%%'])
		if i >= node.exprs.len {
			if escaped_val.len > 0 {
				end_string = true
				if !g.pref.autofree {
					g.write('\\000')
				}
				g.write(escaped_val)
			}
			continue
		}
		g.write(escaped_val)
		sym := g.table.get_type_symbol(node.expr_types[i])
		sfmt := node.expr_fmts[i]
		mut fspec := `_` // placeholder
		mut fmt := '' // field width and precision
		if sfmt.len > 0 {
			// analyze and validate format specifier
			if sfmt[sfmt.len - 1] in [`E`, `F`, `G`, `e`, `f`, `g`,
				`d`, `u`, `x`, `X`, `o`, `c`, `s`, `p`] {
				fspec = sfmt[sfmt.len - 1]
			}
			fmt = if fspec == `_` {
				sfmt[1..sfmt.len]
			} else {
				sfmt[1..sfmt.len - 1]
			}
		}
		if fspec == `_` { // set default representation for type if still missing
			if node.expr_types[i].is_float() {
				fspec = `g`
			} else if node.expr_types[i].is_signed() || node.expr_types[i].is_any_int() {
				fspec = `d`
			} else if node.expr_types[i].is_unsigned() {
				fspec = `u`
			} else if node.expr_types[i].is_pointer() {
				fspec = `p`
			} else if node.expr_types[i] in [table.string_type, table.bool_type] || sym.kind in
				[.enum_, .array, .array_fixed, .struct_, .map] || g.typ(node.expr_types[i]).starts_with('Option') ||
				sym.has_method('str') {
				fspec = `s`
			} else {
				// default to int - TODO: should better be checked
				fspec = `d`
			}
		}
		fields := fmt.split('.')
		// validate format
		// only floats should have precision specifier
		if fields.len > 2 || fields.len == 2 && !(node.expr_types[i].is_float()) || node.expr_types[i].is_signed() &&
			fspec !in [`d`, `c`, `x`, `X`, `o`] || node.expr_types[i].is_unsigned() && fspec !in [`u`, `x`,
			`X`, `o`, `c`] || node.expr_types[i].is_any_int() && fspec !in [`d`, `c`, `x`, `X`,
			`o`, `u`,
			`x`, `X`, `o`] || node.expr_types[i].is_float() && fspec !in [`E`, `F`, `G`, `e`,
			`f`, `g`] || node.expr_types[i].is_pointer() && fspec !in [`p`, `x`, `X`] {
			verror('illegal format specifier ${fspec:c} for type ${g.table.get_type_name(node.expr_types[i])}')
		}
		// make sure that format paramters are valid numbers
		for j, f in fields {
			for k, c in f {
				if (c < `0` || c > `9`) && !(j == 0 && k == 0 && (node.expr_types[i].is_number() &&
					c == `+` || c == `-`)) {
					verror('illegal character ${c:c} in format specifier ${fmt}')
				}
			}
		}
		specs << fspec
		fieldwidths << if fields.len == 0 {
			0
		} else {
			strconv.atoi(fields[0])
		}
		// write correct format specifier to intermediate string
		g.write('%')
		if fspec == `s` {
			if fields.len == 0 || strconv.atoi(fields[0]) == 0 {
				g.write('.*s')
			} else {
				g.write('*.*s')
			}
		} else if node.expr_types[i].is_float() || node.expr_types[i].is_pointer() {
			g.write('$fmt${fspec:c}')
		} else if node.expr_types[i].is_pointer() {
			if fspec == `p` {
				g.write('${fmt}p')
			} else {
				g.write('${fmt}"PRI${fspec:c}PTR"')
			}
		} else if node.expr_types[i].is_int() {
			if fspec == `c` {
				if node.expr_types[i].idx() in [table.i64_type_idx, table.f64_type_idx] {
					verror('64 bit integer types cannot be interpolated as character')
				} else {
					g.write('${fmt}c')
				}
			} else {
				g.write('${fmt}"PRI${fspec:c}')
				if node.expr_types[i] in [table.i8_type, table.byte_type] {
					g.write('8')
				} else if node.expr_types[i] in [table.i16_type, table.u16_type] {
					g.write('16')
				} else if node.expr_types[i] in [table.i64_type, table.u64_type] {
					g.write('64')
				} else {
					g.write('32')
				}
				g.write('"')
			}
		} else {
			// TODO: better check this case
			g.write('${fmt}"PRId32"')
		}
		if i < node.exprs.len - 1 && !g.pref.autofree {
			g.write('\\000')
		}
	}
	num_string_parts := if end_string { node.exprs.len + 1 } else { node.exprs.len }
	g.write('", $num_string_parts, ')
	// Build args
	for i, expr in node.exprs {
		if node.expr_types[i] == table.string_type {
			g.expr(expr)
		} else if node.expr_types[i] == table.bool_type {
			g.expr(expr)
			g.write(' ? _SLIT("true") : _SLIT("false")')
		} else if node.expr_types[i].is_number() || node.expr_types[i].is_pointer() || specs[i] ==
			`d` {
			if node.expr_types[i].is_signed() && specs[i] in [`x`, `X`, `o`] {
				// convert to unsigned first befors C's integer propagation strikes
				if node.expr_types[i] == table.i8_type {
					g.write('(byte)(')
				} else if node.expr_types[i] == table.i16_type {
					g.write('(u16)(')
				} else if node.expr_types[i] == table.int_type {
					g.write('(u32)(')
				} else {
					g.write('(u64)(')
				}
				g.expr(expr)
				g.write(')')
			} else {
				g.expr(expr)
			}
		} else if specs[i] == `s` {
			sym := g.table.get_type_symbol(node.expr_types[i])
			sym_has_str_method, str_method_expects_ptr, _ := sym.str_method_info()
			if node.expr_types[i].flag_is(.variadic) {
				str_fn_name := g.gen_str_for_type(node.expr_types[i])
				g.write('${str_fn_name}(')
				g.expr(expr)
				g.write(')')
			} else if sym.kind == .enum_ {
				is_var := match node.exprs[i] {
					ast.SelectorExpr { true }
					ast.Ident { true }
					else { false }
				}
				if is_var {
					str_fn_name := g.gen_str_for_type(node.expr_types[i])
					g.write('${str_fn_name}(')
					g.enum_expr(expr)
					g.write(')')
				} else {
					g.write('tos_lit("')
					g.enum_expr(expr)
					g.write('")')
				}
			} else if sym_has_str_method || sym.kind in [.array, .array_fixed, .map, .struct_] {
				is_p := node.expr_types[i].is_ptr()
				val_type := if is_p { node.expr_types[i].deref() } else { node.expr_types[i] }
				str_fn_name := g.gen_str_for_type(val_type)
				if is_p && str_method_expects_ptr {
					g.write('string_add(_SLIT("&"), ${str_fn_name}(  (')
				}
				if is_p && !str_method_expects_ptr {
					g.write('string_add(_SLIT("&"), ${str_fn_name}( *(')
				}
				if !is_p && !str_method_expects_ptr {
					g.write('${str_fn_name}(  ')
				}
				if !is_p && str_method_expects_ptr {
					g.write('${str_fn_name}( &')
				}
				g.expr(expr)
				if sym.kind == .struct_ && !sym_has_str_method {
					if is_p {
						g.write('),0))')
					} else {
						g.write(',0)')
					}
				} else {
					if is_p {
						g.write(')))')
					} else {
						g.write(')')
					}
				}
			} else if g.typ(node.expr_types[i]).starts_with('Option') {
				str_fn_name := 'Option_str'
				g.write('${str_fn_name}(*(Option*)&')
				g.expr(expr)
				g.write(')')
			} else {
				verror('cannot convert to string')
			}
		} else {
			g.expr(expr)
		}
		if specs[i] == `s` && fieldwidths[i] != 0 {
			g.write(', ${fieldwidths[i]}')
		}
		if i < node.exprs.len - 1 {
			g.write(', ')
		}
	}
	g.write(')')
}

// `nums.map(it % 2 == 0)`
fn (mut g Gen) gen_map(node ast.CallExpr) {
	tmp := g.new_tmp_var()
	s := g.go_before_stmt(0)
	// println('filter s="$s"')
	ret_typ := g.typ(node.return_type)
	// inp_typ := g.typ(node.receiver_type)
	ret_sym := g.table.get_type_symbol(node.return_type)
	inp_sym := g.table.get_type_symbol(node.receiver_type)
	ret_info := ret_sym.info as table.Array
	ret_elem_type := g.typ(ret_info.elem_type)
	inp_info := inp_sym.info as table.Array
	inp_elem_type := g.typ(inp_info.elem_type)
	if inp_sym.kind != .array {
		verror('map() requires an array')
	}
	g.writeln('')
	g.write('int ${tmp}_len = ')
	g.expr(node.left)
	g.writeln('.len;')
	g.writeln('$ret_typ $tmp = __new_array(0, ${tmp}_len, sizeof($ret_elem_type));')
	i := g.new_tmp_var()
	g.writeln('for (int $i = 0; $i < ${tmp}_len; $i++) {')
	g.write('\t$inp_elem_type it = (($inp_elem_type*) ')
	g.expr(node.left)
	g.writeln('.data)[$i];')
	g.write('\t$ret_elem_type ti = ')
	match node.args[0].expr {
		ast.Ident {
			if it.kind == .function {
				g.writeln('${it.name}(it)')
			} else {
				g.expr(node.args[0].expr)
			}
		}
		else {
			g.expr(node.args[0].expr)
		}
	}
	g.writeln(';')
	g.writeln('\tarray_push(&$tmp, &ti);')
	g.writeln('}')
	g.write(s)
	g.write(tmp)
}

// `nums.filter(it % 2 == 0)`
fn (mut g Gen) gen_filter(node ast.CallExpr) {
	tmp := g.new_tmp_var()
	s := g.go_before_stmt(0)
	// println('filter s="$s"')
	sym := g.table.get_type_symbol(node.return_type)
	if sym.kind != .array {
		verror('filter() requires an array')
	}
	info := sym.info as table.Array
	styp := g.typ(node.return_type)
	elem_type_str := g.typ(info.elem_type)
	g.write('\nint ${tmp}_len = ')
	g.expr(node.left)
	g.writeln('.len;')
	g.writeln('$styp $tmp = __new_array(0, ${tmp}_len, sizeof($elem_type_str));')
	g.writeln('for (int i = 0; i < ${tmp}_len; i++) {')
	g.write('  $elem_type_str it = (($elem_type_str*) ')
	g.expr(node.left)
	g.writeln('.data)[i];')
	g.write('if (')
	match node.args[0].expr {
		ast.Ident {
			if it.kind == .function {
				g.writeln('${node.args[0]}(it)')
			} else {
				g.expr(node.args[0].expr)
			}
		}
		else {
			g.expr(node.args[0].expr)
		}
	}
	g.writeln(') array_push(&$tmp, &it); \n }')
	g.write(s)
	g.write(' ')
	g.write(tmp)
}

[inline]
fn (g &Gen) nth_stmt_pos(n int) int {
	return g.stmt_path_pos[g.stmt_path_pos.len - (1 + n)]
}

fn (mut g Gen) go_before_stmt(n int) string {
	stmt_pos := g.nth_stmt_pos(n)
	cur_line := g.out.after(stmt_pos)
	g.out.go_back(cur_line.len)
	return cur_line
}

[inline]
fn (mut g Gen) go_before_ternary() string {
	return g.go_before_stmt(g.inside_ternary)
}

fn (mut g Gen) insert_before_stmt(s string) {
	cur_line := g.go_before_stmt(0)
	g.writeln(s)
	g.write(cur_line)
}

// If user is accessing the return value eg. in assigment, pass the variable name.
// If the user is not using the optional return value. We need to pass a temp var
// to access its fields (`.ok`, `.error` etc)
// `os.cp(...)` => `Option bool tmp = os__cp(...); if (!tmp.ok) { ... }`
// Returns the type of the last stmt
fn (mut g Gen) or_block(var_name string, or_block ast.OrExpr, return_type table.Type) {
	cvar_name := c_name(var_name)
	mr_styp := g.base_type(return_type)
	g.writeln(';') // or')
	g.writeln('if (!${cvar_name}.ok) {')
	if or_block.kind == .block {
		g.writeln('\tstring err = ${cvar_name}.v_error;')
		g.writeln('\tint errcode = ${cvar_name}.ecode;')
		stmts := or_block.stmts
		if stmts.len > 0 && stmts[or_block.stmts.len - 1] is ast.ExprStmt && (stmts[stmts.len -
			1] as ast.ExprStmt).typ != table.void_type {
			g.indent++
			for i, stmt in stmts {
				if i == stmts.len - 1 {
					expr_stmt := stmt as ast.ExprStmt
					g.stmt_path_pos << g.out.len
					g.write('*(${mr_styp}*) ${cvar_name}.data = ')
					is_opt_call := expr_stmt.expr is ast.CallExpr && expr_stmt.typ.flag_is(.optional)
					if is_opt_call {
						g.write('*(${mr_styp}*) ')
					}
					g.expr(expr_stmt.expr)
					if is_opt_call {
						g.write('.data')
					}
					if g.inside_ternary == 0 && !(expr_stmt.expr is ast.IfExpr) {
						g.writeln(';')
					}
					g.stmt_path_pos.delete(g.stmt_path_pos.len - 1)
				} else {
					g.stmt(stmt)
				}
			}
			g.indent--
		} else {
			g.stmts(stmts)
		}
	} else if or_block.kind == .propagate {
		if g.file.mod.name == 'main' && g.cur_fn.name == 'main' {
			if g.pref.is_debug {
				paline, pafile, pamod, pafn := g.panic_debug_info(or_block.pos)
				g.writeln('panic_debug($paline, tos3("$pafile"), tos3("$pamod"), tos3("$pafn"), ${cvar_name}.v_error );')
			} else {
				g.writeln('\tv_panic(${cvar_name}.v_error);')
			}
		} else {
			g.writeln('\treturn $cvar_name;')
		}
	}
	g.write('}')
}

fn (mut g Gen) type_of_call_expr(node ast.Expr) string {
	match node {
		ast.CallExpr { return g.typ(it.return_type) }
		else { return typeof(node) }
	}
	return ''
}

// `a in [1,2,3]` => `a == 1 || a == 2 || a == 3`
fn (mut g Gen) in_optimization(left ast.Expr, right ast.ArrayInit) {
	is_str := right.elem_type == table.string_type
	for i, array_expr in right.exprs {
		if is_str {
			g.write('string_eq(')
		}
		g.expr(left)
		if is_str {
			g.write(', ')
		} else {
			g.write(' == ')
		}
		g.expr(array_expr)
		if is_str {
			g.write(')')
		}
		if i < right.exprs.len - 1 {
			g.write(' || ')
		}
	}
}

fn op_to_fn_name(name string) string {
	return match name {
		'+' { '_op_plus' }
		'-' { '_op_minus' }
		'*' { '_op_mul' }
		'/' { '_op_div' }
		'%' { '_op_mod' }
		else { 'bad op $name' }
	}
}

fn (mut g Gen) comp_if_to_ifdef(name string, is_comptime_optional bool) string {
	match name {
		// platforms/os-es:
		'windows' {
			return '_WIN32'
		}
		'mac' {
			return '__APPLE__'
		}
		'macos' {
			return '__APPLE__'
		}
		'linux' {
			return '__linux__'
		}
		'freebsd' {
			return '__FreeBSD__'
		}
		'openbsd' {
			return '__OpenBSD__'
		}
		'netbsd' {
			return '__NetBSD__'
		}
		'dragonfly' {
			return '__DragonFly__'
		}
		'android' {
			return '__ANDROID__'
		}
		'solaris' {
			return '__sun'
		}
		'haiku' {
			return '__haiku__'
		}
		'linux_or_macos' {
			return ''
		}
		//
		'js' {
			return '_VJS'
		}
		// compilers:
		'tinyc' {
			return '__TINYC__'
		}
		'clang' {
			return '__clang__'
		}
		'mingw' {
			return '__MINGW32__'
		}
		'msvc' {
			return '_MSC_VER'
		}
		'cplusplus' {
			return '__cplusplus'
		}
		// other:
		'debug' {
			return '_VDEBUG'
		}
		'glibc' {
			return '__GLIBC__'
		}
		'prealloc' {
			return 'VPREALLOC'
		}
		'no_bounds_checking' {
			return 'CUSTOM_DEFINE_no_bounds_checking'
		}
		'x64' {
			return 'TARGET_IS_64BIT'
		}
		'x32' {
			return 'TARGET_IS_32BIT'
		}
		'little_endian' {
			return 'TARGET_ORDER_IS_LITTLE'
		}
		'big_endian' {
			return 'TARGET_ORDER_IS_BIG'
		}
		else {
			if is_comptime_optional || g.pref.compile_defines_all.len > 0 && name in g.pref.compile_defines_all {
				return 'CUSTOM_DEFINE_${name}'
			}
			verror('bad os ifdef name "$name"')
		}
	}
	// verror('bad os ifdef name "$name"')
	return ''
}

[inline]
fn c_name(name_ string) string {
	name := name_.replace('.', '__')
	if name in c_reserved {
		return 'v_$name'
	}
	return name
}

fn (g Gen) type_default(typ table.Type) string {
	sym := g.table.get_type_symbol(typ)
	if sym.kind == .array {
		elem_sym := g.table.get_type_symbol(sym.array_info().elem_type)
		mut elem_type_str := elem_sym.name.replace('.', '__')
		if elem_type_str.starts_with('C__') {
			elem_type_str = elem_type_str[3..]
		}
		return '__new_array(0, 1, sizeof($elem_type_str))'
	}
	if sym.kind == .map {
		value_type_str := g.typ(sym.map_info().value_type)
		return 'new_map_1(sizeof($value_type_str))'
	}
	// Always set pointers to 0
	if typ.is_ptr() {
		return '0'
	}
	// User struct defined in another module.
	// if typ.contains('__') {
	if sym.kind == .struct_ {
		return '{0}'
	}
	// if typ.ends_with('Fn') { // TODO
	// return '0'
	// }
	// Default values for other types are not needed because of mandatory initialization
	idx := int(typ)
	if idx >= 1 && idx <= 17 {
		return '0'
	}
	/*
	match idx {
		table.bool_type_idx {
			return '0'
		}
		else {}
	}
	*/
	match sym.name {
		'string' { return '(string){.str=""}' }
		'rune' { return '0' }
		else {}
	}
	return '{0}'
	// TODO this results in
	// error: expected a field designator, such as '.field = 4'
	// - Empty ee= (Empty) { . =  {0}  } ;
	/*
	return match typ {
	'bool'{ '0'}
	'string'{ 'tos_lit("")'}
	'i8'{ '0'}
	'i16'{ '0'}
	'i64'{ '0'}
	'u16'{ '0'}
	'u32'{ '0'}
	'u64'{ '0'}
	'byte'{ '0'}
	'int'{ '0'}
	'rune'{ '0'}
	'f32'{ '0.0'}
	'f64'{ '0.0'}
	'byteptr'{ '0'}
	'voidptr'{ '0'}
	else { '{0} '}
}
	*/
}

pub fn (mut g Gen) write_tests_main() {
	g.definitions.writeln('int g_test_oks = 0;')
	g.definitions.writeln('int g_test_fails = 0;')
	$if windows {
		g.writeln('int wmain() {')
	} $else {
		g.writeln('int main() {')
	}
	g.writeln('\t_vinit();')
	g.writeln('')
	all_tfuncs := g.get_all_test_function_names()
	if g.pref.is_stats {
		g.writeln('\tBenchedTests bt = start_testing(${all_tfuncs.len}, tos_lit("$g.pref.path"));')
	}
	for t in all_tfuncs {
		g.writeln('')
		if g.pref.is_stats {
			g.writeln('\tBenchedTests_testing_step_start(&bt, tos_lit("$t"));')
		}
		g.writeln('\t${t}();')
		if g.pref.is_stats {
			g.writeln('\tBenchedTests_testing_step_end(&bt);')
		}
	}
	g.writeln('')
	if g.pref.is_stats {
		g.writeln('\tBenchedTests_end_testing(&bt);')
	}
	g.writeln('')
	if g.autofree {
		g.writeln('\t_vcleanup();')
	}
	g.writeln('\treturn g_test_fails > 0;')
	g.writeln('}')
}

fn (g Gen) get_all_test_function_names() []string {
	mut tfuncs := []string{}
	mut tsuite_begin := ''
	mut tsuite_end := ''
	for _, f in g.table.fns {
		if f.name == 'testsuite_begin' {
			tsuite_begin = f.name
			continue
		}
		if f.name == 'testsuite_end' {
			tsuite_end = f.name
			continue
		}
		if f.name.starts_with('test_') {
			tfuncs << f.name
			continue
		}
		// What follows is for internal module tests
		// (they are part of a V module, NOT in main)
		if f.name.contains('.test_') {
			tfuncs << f.name
			continue
		}
		if f.name.ends_with('.testsuite_begin') {
			tsuite_begin = f.name
			continue
		}
		if f.name.ends_with('.testsuite_end') {
			tsuite_end = f.name
			continue
		}
	}
	mut all_tfuncs := []string{}
	if tsuite_begin.len > 0 {
		all_tfuncs << tsuite_begin
	}
	all_tfuncs << tfuncs
	if tsuite_end.len > 0 {
		all_tfuncs << tsuite_end
	}
	mut all_tfuncs_c := []string{}
	for f in all_tfuncs {
		all_tfuncs_c << f.replace('.', '__')
	}
	return all_tfuncs_c
}

fn (g Gen) is_importing_os() bool {
	return 'os' in g.table.imports
}

fn (mut g Gen) comp_if(it ast.CompIf) {
	ifdef := g.comp_if_to_ifdef(it.val, it.is_opt)
	if it.is_not {
		g.writeln('\n// \$if !${it.val} {\n#ifndef ' + ifdef)
	} else {
		g.writeln('\n// \$if  ${it.val} {\n#ifdef ' + ifdef)
	}
	// NOTE: g.defer_ifdef is needed for defers called witin an ifdef
	// in v1 this code would be completely excluded
	g.defer_ifdef = if it.is_not {
		'\n#ifndef ' + ifdef
	} else {
		'\n#ifdef ' + ifdef
	}
	// println('comp if stmts $g.file.path:$it.pos.line_nr')
	g.stmts(it.stmts)
	g.defer_ifdef = ''
	if it.has_else {
		g.writeln('\n#else')
		g.defer_ifdef = if it.is_not {
			'\n#ifdef ' + ifdef
		} else {
			'\n#ifndef ' + ifdef
		}
		g.stmts(it.else_stmts)
		g.defer_ifdef = ''
	}
	g.writeln('\n// } ${it.val}\n#endif\n')
}

fn (mut g Gen) go_stmt(node ast.GoStmt) {
	tmp := g.new_tmp_var()
	// x := node.call_expr as ast.CallEpxr // TODO
	match node.call_expr {
		ast.CallExpr {
			mut name := it.name // .replace('.', '__')
			if it.is_method {
				receiver_sym := g.table.get_type_symbol(it.receiver_type)
				name = receiver_sym.name + '_' + name
			}
			name = name.replace('.', '__')
			g.writeln('// go')
			wrapper_struct_name := 'thread_arg_' + name
			wrapper_fn_name := name + '_thread_wrapper'
			arg_tmp_var := 'arg_' + tmp
			g.writeln('$wrapper_struct_name *$arg_tmp_var = malloc(sizeof(thread_arg_$name));')
			if it.is_method {
				g.write('${arg_tmp_var}->arg0 = ')
				g.expr(it.left)
				g.writeln(';')
			}
			for i, arg in it.args {
				g.write('${arg_tmp_var}->arg${i+1} = ')
				g.expr(arg.expr)
				g.writeln(';')
			}
			if g.pref.os == .windows {
				g.writeln('CreateThread(0,0, (LPTHREAD_START_ROUTINE)$wrapper_fn_name, $arg_tmp_var, 0,0);')
			} else {
				g.writeln('pthread_t thread_$tmp;')
				g.writeln('pthread_create(&thread_$tmp, NULL, (void*)$wrapper_fn_name, $arg_tmp_var);')
			}
			g.writeln('// endgo\n')
			// Register the wrapper type and function
			if name in g.threaded_fns {
				return
			}
			g.definitions.writeln('\ntypedef struct $wrapper_struct_name {')
			if it.is_method {
				styp := g.typ(it.receiver_type)
				g.definitions.writeln('\t$styp arg0;')
			}
			for i, arg in it.args {
				styp := g.typ(arg.typ)
				g.definitions.writeln('\t$styp arg${i+1};')
			}
			g.definitions.writeln('} $wrapper_struct_name;')
			g.definitions.writeln('void* ${wrapper_fn_name}($wrapper_struct_name *arg);')
			g.gowrappers.writeln('void* ${wrapper_fn_name}($wrapper_struct_name *arg) {')
			g.gowrappers.write('\t${name}(')
			if it.is_method {
				g.gowrappers.write('arg->arg0')
				if it.args.len > 0 {
					g.gowrappers.write(', ')
				}
			}
			for i in 0 .. it.args.len {
				g.gowrappers.write('arg->arg${i+1}')
				if i < it.args.len - 1 {
					g.gowrappers.write(', ')
				}
			}
			g.gowrappers.writeln(');')
			g.gowrappers.writeln('\treturn 0;')
			g.gowrappers.writeln('}')
			g.threaded_fns << name
		}
		else {}
	}
}

fn (mut g Gen) as_cast(node ast.AsCast) {
	// Make sure the sum type can be cast to this type (the types
	// are the same), otherwise panic.
	// g.insert_before('
	styp := g.typ(node.typ)
	expr_type_sym := g.table.get_type_symbol(node.expr_type)
	if expr_type_sym.kind == .sum_type {
		/*
		g.write('*($styp*)')
		g.expr(node.expr)
		g.write('.obj')
		*/
		dot := if node.expr_type.is_ptr() { '->' } else { '.' }
		g.write('/* as */ ($styp*)__as_cast(')
		g.expr(node.expr)
		g.write(dot)
		g.write('obj, ')
		g.expr(node.expr)
		g.write(dot)
		g.write('typ, /*expected:*/$node.typ)')
	}
}

fn (mut g Gen) is_expr(node ast.InfixExpr) {
	g.expr(node.left)
	if node.left_type.is_ptr() {
		g.write('->')
	} else {
		g.write('.')
	}
	sym := g.table.get_type_symbol(node.left_type)
	if sym.kind == .interface_ {
		g.write('_interface_idx == ')
	} else if sym.kind == .sum_type {
		g.write('typ == ')
	}
	g.expr(node.right)
}

[inline]
fn styp_to_str_fn_name(styp string) string {
	return styp.replace('*', '_ptr') + '_str'
}

[inline]
fn (mut g Gen) gen_str_for_type(typ table.Type) string {
	styp := g.typ(typ)
	return g.gen_str_for_type_with_styp(typ, styp)
}

// already generated styp, reuse it
fn (mut g Gen) gen_str_for_type_with_styp(typ table.Type, styp string) string {
	sym := g.table.get_type_symbol(typ)
	str_fn_name := styp_to_str_fn_name(styp)
	sym_has_str_method, str_method_expects_ptr, str_nr_args := sym.str_method_info()
	// generate for type
	if sym_has_str_method && str_method_expects_ptr && str_nr_args == 1 {
		// TODO: optimize out this.
		// It is needed, so that println() can be called with &T and T has `fn (t &T).str() string`
		/*
		eprintln('>> gsftws: typ: $typ | typ_is_ptr $typ_is_ptr | styp: $styp ' +
			'| $str_fn_name | sym.name: $sym.name has_str: $sym_has_str_method ' +
			'| expects_ptr: $str_method_expects_ptr')
		*/
		str_fn_name_no_ptr := '${str_fn_name}_no_ptr'
		already_generated_key_no_ptr := '${styp}:${str_fn_name_no_ptr}'
		if already_generated_key_no_ptr !in g.str_types {
			g.str_types << already_generated_key_no_ptr
			g.definitions.writeln('string ${str_fn_name_no_ptr}(${styp} it); // auto no_ptr version')
			g.auto_str_funcs.writeln('string ${str_fn_name_no_ptr}(${styp} it){ return ${str_fn_name}(&it); }')
		}
		/*
		typ_is_ptr := typ.is_ptr()
		ret_type := if typ_is_ptr { str_fn_name } else { str_fn_name_no_ptr }
		eprintln('    ret_type: $ret_type')
		return ret_type
		*/
		return str_fn_name_no_ptr
	}
	already_generated_key := '${styp}:${str_fn_name}'
	if !sym_has_str_method && already_generated_key !in g.str_types {
		g.str_types << already_generated_key
		match sym.info {
			table.Alias { g.gen_str_default(sym, styp, str_fn_name) }
			table.Array { g.gen_str_for_array(it, styp, str_fn_name) }
			table.ArrayFixed { g.gen_str_for_array_fixed(it, styp, str_fn_name) }
			table.Enum { g.gen_str_for_enum(it, styp, str_fn_name) }
			table.Struct { g.gen_str_for_struct(it, styp, str_fn_name) }
			table.Map { g.gen_str_for_map(it, styp, str_fn_name) }
			else { verror("could not generate string method $str_fn_name for type \'${styp}\'") }
		}
	}
	// if varg, generate str for varg
	if typ.flag_is(.variadic) {
		varg_already_generated_key := 'varg_$already_generated_key'
		if varg_already_generated_key !in g.str_types {
			g.gen_str_for_varg(styp, str_fn_name, sym_has_str_method)
			g.str_types << varg_already_generated_key
		}
		return 'varg_$str_fn_name'
	}
	return str_fn_name
}

fn (mut g Gen) gen_str_default(sym table.TypeSymbol, styp, str_fn_name string) {
	mut convertor := ''
	mut typename_ := ''
	if sym.parent_idx in table.integer_type_idxs {
		convertor = 'int'
		typename_ = 'int'
	} else if sym.parent_idx == table.f32_type_idx {
		convertor = 'float'
		typename_ = 'f32'
	} else if sym.parent_idx == table.f64_type_idx {
		convertor = 'double'
		typename_ = 'f64'
	} else if sym.parent_idx == table.bool_type_idx {
		convertor = 'bool'
		typename_ = 'bool'
	} else {
		verror("could not generate string method for type \'${styp}\'")
	}
	g.definitions.writeln('string ${str_fn_name}($styp it); // auto')
	g.auto_str_funcs.writeln('string ${str_fn_name}($styp it) {')
	if convertor == 'bool' {
		g.auto_str_funcs.writeln('\tstring tmp1 = string_add(tos_lit("${styp}("), (${convertor})it ? tos_lit("true") : tos_lit("false"));')
	} else {
		g.auto_str_funcs.writeln('\tstring tmp1 = string_add(tos_lit("${styp}("), tos3(${typename_}_str((${convertor})it).str));')
	}
	g.auto_str_funcs.writeln('\tstring tmp2 = string_add(tmp1, tos_lit(")"));')
	g.auto_str_funcs.writeln('\tstring_free(&tmp1);')
	g.auto_str_funcs.writeln('\treturn tmp2;')
	g.auto_str_funcs.writeln('}')
}

fn (mut g Gen) gen_str_for_enum(info table.Enum, styp, str_fn_name string) {
	s := styp.replace('.', '__')
	g.definitions.writeln('string ${str_fn_name}($styp it); // auto')
	g.auto_str_funcs.writeln('string ${str_fn_name}($styp it) { /* gen_str_for_enum */')
	g.auto_str_funcs.writeln('\tswitch(it) {')
	for val in info.vals {
		g.auto_str_funcs.writeln('\t\tcase ${s}_$val: return tos_lit("$val");')
	}
	g.auto_str_funcs.writeln('\t\tdefault: return tos_lit("unknown enum value");')
	g.auto_str_funcs.writeln('\t}')
	g.auto_str_funcs.writeln('}')
}

fn (mut g Gen) gen_str_for_struct(info table.Struct, styp, str_fn_name string) {
	// TODO: short it if possible
	// generates all definitions of substructs
	mut fnames2strfunc := {
		'': ''
	} // map[string]string // TODO vfmt bug
	for field in info.fields {
		sym := g.table.get_type_symbol(field.typ)
		if !sym.has_method('str') {
			field_styp := g.typ(field.typ)
			field_fn_name := g.gen_str_for_type_with_styp(field.typ, field_styp)
			fnames2strfunc[field_styp] = field_fn_name
		}
	}
	g.definitions.writeln('string ${str_fn_name}($styp x, int indent_count); // auto')
	g.auto_str_funcs.writeln('string ${str_fn_name}($styp x, int indent_count) {')
	mut clean_struct_v_type_name := styp.replace('__', '.')
	if styp.ends_with('*') {
		deref_typ := styp.replace('*', '')
		g.auto_str_funcs.writeln('\t${deref_typ} *it = x;')
		clean_struct_v_type_name = '&' + clean_struct_v_type_name.replace('*', '')
	} else {
		deref_typ := styp
		g.auto_str_funcs.writeln('\t${deref_typ} *it = &x;')
	}
	// generate ident / indent length = 4 spaces
	g.auto_str_funcs.writeln('\tstring indents = tos_lit("");')
	g.auto_str_funcs.writeln('\tfor (int i = 0; i < indent_count; i++) {')
	g.auto_str_funcs.writeln('\t\tindents = string_add(indents, tos_lit("    "));')
	g.auto_str_funcs.writeln('\t}')
	g.auto_str_funcs.writeln('\treturn _STR("${clean_struct_v_type_name} {\\n"')
	for field in info.fields {
		fmt := g.type_to_fmt(field.typ)
		g.auto_str_funcs.writeln('\t\t"%.*s\\000    ' + '$field.name: $fmt\\n"')
	}
	g.auto_str_funcs.write('\t\t"%.*s\\000}", ${2*(info.fields.len+1)}')
	if info.fields.len > 0 {
		g.auto_str_funcs.write(',\n\t\t')
		for i, field in info.fields {
			sym := g.table.get_type_symbol(field.typ)
			has_custom_str := sym.has_method('str')
			second_str_param := if has_custom_str { '' } else { ', indent_count + 1' }
			mut field_styp := g.typ(field.typ)
			if field_styp.ends_with('*') {
				field_styp = field_styp.replace('*', '')
			}
			field_styp_fn_name := if has_custom_str { '${field_styp}_str' } else { fnames2strfunc[field_styp] }
			if sym.kind == .enum_ {
				g.auto_str_funcs.write('indents, ')
				g.auto_str_funcs.write('${field_styp_fn_name}( it->${field.name} ) ')
			} else if sym.kind == .struct_ {
				g.auto_str_funcs.write('indents, ')
				g.auto_str_funcs.write('${field_styp_fn_name}( it->${field.name}${second_str_param} ) ')
			} else if sym.kind in [.array, .array_fixed, .map] {
				g.auto_str_funcs.write('indents, ')
				g.auto_str_funcs.write('${field_styp_fn_name}( it->${field.name}) ')
			} else {
				g.auto_str_funcs.write('indents, it->${field.name}')
				if field.typ == table.bool_type {
					g.auto_str_funcs.write(' ? _SLIT("true") : _SLIT("false")')
				}
			}
			if i < info.fields.len - 1 {
				g.auto_str_funcs.write(',\n\t\t')
			}
		}
	}
	g.auto_str_funcs.writeln(',')
	g.auto_str_funcs.writeln('\t\tindents);')
	g.auto_str_funcs.writeln('}')
}

fn (mut g Gen) gen_str_for_array(info table.Array, styp, str_fn_name string) {
	sym := g.table.get_type_symbol(info.elem_type)
	field_styp := g.typ(info.elem_type)
	is_elem_ptr := info.elem_type.is_ptr()
	sym_has_str_method, str_method_expects_ptr, _ := sym.str_method_info()
	mut elem_str_fn_name := ''
	if sym_has_str_method {
		elem_str_fn_name = if is_elem_ptr {
			field_styp.replace('*', '') + '_str'
		} else {
			field_styp + '_str'
		}
	} else {
		elem_str_fn_name = styp_to_str_fn_name(field_styp)
	}
	if !sym_has_str_method {
		// eprintln('> sym.name: does not have method `str`')
		g.gen_str_for_type_with_styp(info.elem_type, field_styp)
	}
	g.definitions.writeln('string ${str_fn_name}($styp a); // auto')
	g.auto_str_funcs.writeln('string ${str_fn_name}($styp a) {')
	g.auto_str_funcs.writeln('\tstrings__Builder sb = strings__new_builder(a.len * 10);')
	g.auto_str_funcs.writeln('\tstrings__Builder_write(&sb, tos_lit("["));')
	g.auto_str_funcs.writeln('\tfor (int i = 0; i < a.len; i++) {')
	g.auto_str_funcs.writeln('\t\t${field_styp} it = (*(${field_styp}*)array_get(a, i));')
	if sym.kind == .struct_ && !sym_has_str_method {
		if is_elem_ptr {
			g.auto_str_funcs.writeln('\t\tstring x = ${elem_str_fn_name}(*it,0);')
		} else {
			g.auto_str_funcs.writeln('\t\tstring x = ${elem_str_fn_name}(it,0);')
		}
	} else if sym.kind in [.f32, .f64] {
		g.auto_str_funcs.writeln('\t\tstring x = _STR("%g", 1, it);')
	} else {
		// There is a custom .str() method, so use it.
		// NB: we need to take account of whether the user has defined
		// `fn (x T) str() {` or `fn (x &T) str() {`, and convert accordingly
		if str_method_expects_ptr && is_elem_ptr || !str_method_expects_ptr && !is_elem_ptr {
			g.auto_str_funcs.writeln('\t\tstring x = ${elem_str_fn_name}(it);')
		} else if str_method_expects_ptr && !is_elem_ptr {
			g.auto_str_funcs.writeln('\t\tstring x = ${elem_str_fn_name}(&it);')
		} else if !str_method_expects_ptr && is_elem_ptr {
			g.auto_str_funcs.writeln('\t\tstring x = ${elem_str_fn_name}(*it);')
		}
	}
	g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, x);')
	if g.pref.autofree && info.elem_type != table.bool_type {
		// no need to free "true"/"false" literals
		g.auto_str_funcs.writeln('\t\tstring_free(&x);')
	}
	g.auto_str_funcs.writeln('\t\tif (i < a.len-1) {')
	g.auto_str_funcs.writeln('\t\t\tstrings__Builder_write(&sb, tos_lit(", "));')
	g.auto_str_funcs.writeln('\t\t}')
	g.auto_str_funcs.writeln('\t}')
	g.auto_str_funcs.writeln('\tstrings__Builder_write(&sb, tos_lit("]"));')
	g.auto_str_funcs.writeln('\tstring res = strings__Builder_str(&sb);')
	g.auto_str_funcs.writeln('\tstrings__Builder_free(&sb);')
	// g.auto_str_funcs.writeln('\treturn strings__Builder_str(&sb);')
	g.auto_str_funcs.writeln('\treturn res;')
	g.auto_str_funcs.writeln('}')
}

fn (mut g Gen) gen_str_for_array_fixed(info table.ArrayFixed, styp, str_fn_name string) {
	sym := g.table.get_type_symbol(info.elem_type)
	field_styp := g.typ(info.elem_type)
	is_elem_ptr := info.elem_type.is_ptr()
	sym_has_str_method, str_method_expects_ptr, _ := sym.str_method_info()
	mut elem_str_fn_name := ''
	if sym_has_str_method {
		elem_str_fn_name = if is_elem_ptr {
			field_styp.replace('*', '') + '_str'
		} else {
			field_styp + '_str'
		}
	} else {
		elem_str_fn_name = styp_to_str_fn_name(field_styp)
	}
	if !sym.has_method('str') {
		g.gen_str_for_type_with_styp(info.elem_type, field_styp)
	}
	g.definitions.writeln('string ${str_fn_name}($styp a); // auto')
	g.auto_str_funcs.writeln('string ${str_fn_name}($styp a) {')
	g.auto_str_funcs.writeln('\tstrings__Builder sb = strings__new_builder($info.size * 10);')
	g.auto_str_funcs.writeln('\tstrings__Builder_write(&sb, tos_lit("["));')
	g.auto_str_funcs.writeln('\tfor (int i = 0; i < $info.size; i++) {')
	if sym.kind == .struct_ && !sym_has_str_method {
		g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, ${elem_str_fn_name}(a[i],0));')
	} else if sym.kind in [.f32, .f64] {
		g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, _STR("%g", 1, a[i]));')
	} else if sym.kind == .string {
		g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, _STR("\'%.*s\\000\'", 2, a[i]));')
	} else {
		if str_method_expects_ptr && is_elem_ptr || !str_method_expects_ptr && !is_elem_ptr {
			g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, ${elem_str_fn_name}(a[i]));')
		} else if str_method_expects_ptr && !is_elem_ptr {
			g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, ${elem_str_fn_name}(&a[i]));')
		} else if !str_method_expects_ptr && is_elem_ptr {
			g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, ${elem_str_fn_name}(*a[i]));')
		}
	}
	g.auto_str_funcs.writeln('\t\tif (i < ${info.size-1}) {')
	g.auto_str_funcs.writeln('\t\t\tstrings__Builder_write(&sb, tos_lit(", "));')
	g.auto_str_funcs.writeln('\t\t}')
	g.auto_str_funcs.writeln('\t}')
	g.auto_str_funcs.writeln('\tstrings__Builder_write(&sb, tos_lit("]"));')
	g.auto_str_funcs.writeln('\treturn strings__Builder_str(&sb);')
	g.auto_str_funcs.writeln('}')
}

fn (mut g Gen) gen_str_for_map(info table.Map, styp, str_fn_name string) {
	key_sym := g.table.get_type_symbol(info.key_type)
	key_styp := g.typ(info.key_type)
	if !key_sym.has_method('str') {
		g.gen_str_for_type_with_styp(info.key_type, key_styp)
	}
	val_sym := g.table.get_type_symbol(info.value_type)
	val_styp := g.typ(info.value_type)
	elem_str_fn_name := val_styp.replace('*', '') + '_str'
	if !val_sym.has_method('str') {
		g.gen_str_for_type_with_styp(info.value_type, val_styp)
	}
	zero := g.type_default(info.value_type)
	g.definitions.writeln('string ${str_fn_name}($styp m); // auto')
	g.auto_str_funcs.writeln('string ${str_fn_name}($styp m) { /* gen_str_for_map */')
	g.auto_str_funcs.writeln('\tstrings__Builder sb = strings__new_builder(m.key_values.size*10);')
	g.auto_str_funcs.writeln('\tstrings__Builder_write(&sb, tos_lit("{"));')
	g.auto_str_funcs.writeln('\tfor (unsigned int i = 0; i < m.key_values.size; i++) {')
	g.auto_str_funcs.writeln('\t\tstring key = (*(string*)DenseArray_get(m.key_values, i));')
	g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, _STR("\'%.*s\\000\'", 2, key));')
	g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, tos_lit(": "));')
	g.auto_str_funcs.write('\t$val_styp it = (*($val_styp*)map_get3(')
	g.auto_str_funcs.write('m, (*(string*)DenseArray_get(m.key_values, i))')
	g.auto_str_funcs.write(', ')
	g.auto_str_funcs.writeln(' &($val_styp[]) { $zero }));')
	if val_sym.kind == .string {
		g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, _STR("\'%.*s\\000\'", 2, it));')
	} else if val_sym.kind == .struct_ && !val_sym.has_method('str') {
		g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, ${elem_str_fn_name}(it,0));')
	} else if val_sym.kind in [.f32, .f64] {
		g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, _STR("%g", 1, it));')
	} else {
		g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, ${elem_str_fn_name}(it));')
	}
	g.auto_str_funcs.writeln('\t\tif (i != m.key_values.size-1) {')
	g.auto_str_funcs.writeln('\t\t\tstrings__Builder_write(&sb, tos_lit(", "));')
	g.auto_str_funcs.writeln('\t\t}')
	g.auto_str_funcs.writeln('\t}')
	g.auto_str_funcs.writeln('\tstrings__Builder_write(&sb, tos_lit("}"));')
	g.auto_str_funcs.writeln('\treturn strings__Builder_str(&sb);')
	g.auto_str_funcs.writeln('}')
}

fn (mut g Gen) gen_str_for_varg(styp, str_fn_name string, has_str_method bool) {
	g.definitions.writeln('string varg_${str_fn_name}(varg_$styp it); // auto')
	g.auto_str_funcs.writeln('string varg_${str_fn_name}(varg_$styp it) {')
	g.auto_str_funcs.writeln('\tstrings__Builder sb = strings__new_builder(it.len);')
	g.auto_str_funcs.writeln('\tstrings__Builder_write(&sb, tos_lit("["));')
	g.auto_str_funcs.writeln('\tfor(int i=0; i<it.len; i++) {')
	if has_str_method {
		g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, ${str_fn_name}(it.args[i]));')
	} else {
		// autogenerated str methods take the indent level as a second argument:
		g.auto_str_funcs.writeln('\t\tstrings__Builder_write(&sb, ${str_fn_name}(it.args[i], 0));')
	}
	g.auto_str_funcs.writeln('\t\tif (i < it.len-1) {')
	g.auto_str_funcs.writeln('\t\t\tstrings__Builder_write(&sb, tos_lit(", "));')
	g.auto_str_funcs.writeln('\t\t}')
	g.auto_str_funcs.writeln('\t}')
	g.auto_str_funcs.writeln('\tstrings__Builder_write(&sb, tos_lit("]"));')
	g.auto_str_funcs.writeln('\treturn strings__Builder_str(&sb);')
	g.auto_str_funcs.writeln('}')
}

fn (g Gen) type_to_fmt(typ table.Type) string {
	sym := g.table.get_type_symbol(typ)
	if sym.kind in [.struct_, .array, .array_fixed, .map] {
		return '%.*s\\000'
	} else if typ == table.string_type {
		return "\'%.*s\\000\'"
	} else if typ == table.bool_type {
		return '%.*s\\000'
	} else if sym.kind == .enum_ {
		return '%.*s\\000'
	} else if typ in [table.f32_type, table.f64_type] {
		return '%g\\000' // g removes trailing zeros unlike %f
	}
	return '%d\\000'
}

// Generates interface table and interface indexes
fn (g &Gen) interface_table() string {
	mut sb := strings.new_builder(100)
	for ityp in g.table.types {
		if ityp.kind != .interface_ {
			continue
		}
		inter_info := ityp.info as table.Interface
		if inter_info.types.len == 0 {
			continue
		}
		sb.writeln('// NR interfaced types= $inter_info.types.len')
		// interface_name is for example Speaker
		interface_name := c_name(ityp.name)
		// generate a struct that references interface methods
		methods_struct_name := 'struct _${interface_name}_interface_methods'
		mut methods_typ_def := strings.new_builder(100)
		mut methods_struct_def := strings.new_builder(100)
		methods_struct_def.writeln('$methods_struct_name {')
		mut imethods := map[string]string{} // a map from speak -> _Speaker_speak_fn
		mut methodidx := map[string]int{}
		for k, method in ityp.methods {
			methodidx[method.name] = k
			typ_name := '_${interface_name}_${method.name}_fn'
			ret_styp := g.typ(method.return_type)
			methods_typ_def.write('typedef $ret_styp (*$typ_name)(void* _')
			// the first param is the receiver, it's handled by `void*` above
			for i in 1 .. method.args.len {
				arg := method.args[i]
				methods_typ_def.write(', ${g.typ(arg.typ)} $arg.name')
			}
			// TODO g.fn_args(method.args[1..], method.is_variadic)
			methods_typ_def.writeln(');')
			methods_struct_def.writeln('\t$typ_name ${c_name(method.name)};')
			imethods[method.name] = typ_name
		}
		methods_struct_def.writeln('};')
		// generate an array of the interface methods for the structs using the interface
		// as well as case functions from the struct to the interface
		mut methods_struct := strings.new_builder(100)
		methods_struct.writeln('$methods_struct_name ${interface_name}_name_table[$inter_info.types.len] = {')
		mut cast_functions := strings.new_builder(100)
		cast_functions.write('// Casting functions for interface "${interface_name}"')
		mut methods_wrapper := strings.new_builder(100)
		methods_wrapper.writeln('// Methods wrapper for interface "${interface_name}"')
		for i, st in inter_info.types {
			// cctype is the Cleaned Concrete Type name, *without ptr*,
			// i.e. cctype is always just Cat, not Cat_ptr:
			cctype := g.cc_type(st)
			// Speaker_Cat_index = 0
			interface_index_name := '_${interface_name}_${cctype}_index'
			cast_functions.writeln('
_Interface I_${cctype}_to_Interface_${interface_name}(${cctype}* x) {
	return (_Interface) {
		._object = (void*) (x),
		._interface_idx = ${interface_index_name}
	};
}

_Interface* I_${cctype}_to_Interface_${interface_name}_ptr(${cctype}* x) {
	/* TODO Remove memdup */
	return (_Interface*) memdup(&(_Interface) {
		._object = (void*) (x),
		._interface_idx = ${interface_index_name}
	}, sizeof(_Interface));
}')
			methods_struct.writeln('\t{')
			st_sym := g.table.get_type_symbol(st)
			mut method := table.Fn{}
			for _, m in ityp.methods {
				for mm in st_sym.methods {
					if mm.name == m.name {
						method = mm
						break
					}
				}
				if method.name !in imethods {
					// a method that is not part of the interface should be just skipped
					continue
				}
				// .speak = Cat_speak
				mut method_call := '${cctype}_${method.name}'
				if !method.args[0].typ.is_ptr() {
					// inline void Cat_speak_method_wrapper(Cat c) { return Cat_speak(*c); }
					methods_wrapper.write('static inline ${g.typ(method.return_type)}')
					methods_wrapper.write(' ${method_call}_method_wrapper(')
					methods_wrapper.write('${cctype}* ${method.args[0].name}')
					// TODO g.fn_args
					for j in 1 .. method.args.len {
						arg := method.args[j]
						methods_wrapper.write(', ${g.typ(arg.typ)} $arg.name')
					}
					methods_wrapper.writeln(') {')
					methods_wrapper.write('\t')
					if method.return_type != table.void_type {
						methods_wrapper.write('return ')
					}
					methods_wrapper.write('${method_call}(*${method.args[0].name}')
					for j in 1 .. method.args.len {
						methods_wrapper.write(', ${method.args[j].name}')
					}
					methods_wrapper.writeln(');')
					methods_wrapper.writeln('}')
					// .speak = Cat_speak_method_wrapper
					method_call += '_method_wrapper'
				}
				methods_struct.writeln('\t\t.${c_name(method.name)} = $method_call,')
			}
			methods_struct.writeln('\t},')
			sb.writeln('int ${interface_index_name} = $i;')
		}
		methods_struct.writeln('};')
		// add line return after interface index declarations
		sb.writeln('')
		sb.writeln(methods_wrapper.str())
		sb.writeln(methods_typ_def.str())
		sb.writeln(methods_struct_def.str())
		sb.writeln(methods_struct.str())
		sb.writeln(cast_functions.str())
	}
	return sb.str()
}

fn (mut g Gen) array_init(it ast.ArrayInit) {
	type_sym := g.table.get_type_symbol(it.typ)
	if type_sym.kind == .array_fixed {
		g.write('{')
		for i, expr in it.exprs {
			g.expr(expr)
			if i != it.exprs.len - 1 {
				g.write(', ')
			}
		}
		g.write('}')
		return
	}
	// elem_sym := g.table.get_type_symbol(it.elem_type)
	elem_type_str := g.typ(it.elem_type)
	if it.exprs.len == 0 {
		g.write('__new_array_with_default(')
		if it.has_len {
			g.expr(it.len_expr)
			g.write(', ')
		} else {
			g.write('0, ')
		}
		if it.has_cap {
			g.expr(it.cap_expr)
			g.write(', ')
		} else {
			g.write('0, ')
		}
		g.write('sizeof($elem_type_str), ')
		if it.has_default || (it.has_len && it.elem_type == table.string_type) {
			g.write('&_val_$it.pos.pos)')
		} else {
			g.write('0)')
		}
		return
	}
	len := it.exprs.len
	g.write('new_array_from_c_array($len, $len, sizeof($elem_type_str), _MOV(($elem_type_str[$len]){')
	g.writeln('')
	for i, expr in it.exprs {
		if it.is_interface {
			// sym := g.table.get_type_symbol(it.interface_types[i])
			// isym := g.table.get_type_symbol(it.interface_type)
			g.interface_call(it.interface_types[i], it.interface_type)
		}
		g.expr(expr)
		if it.is_interface {
			g.write(')')
		}
		g.write(', ')
	}
	g.writeln('')
	g.write('}))')
}

// `ui.foo(button)` =>
// `ui__foo(I_ui__Button_to_ui__Widget(` ...
fn (g &Gen) interface_call(typ, interface_type table.Type) {
	interface_styp := g.cc_type(interface_type)
	styp := g.cc_type(typ)
	mut cast_fn_name := 'I_${styp}_to_Interface_${interface_styp}'
	if interface_type.is_ptr() {
		cast_fn_name += '_ptr'
	}
	g.write('${cast_fn_name}(')
	if !typ.is_ptr() {
		g.write('&')
	}
}

fn (mut g Gen) panic_debug_info(pos token.Position) (int, string, string, string) {
	paline := pos.line_nr + 1
	pafile := g.fn_decl.file.replace('\\', '/')
	pafn := g.fn_decl.name.after('.')
	mut pamod := g.fn_decl.name.all_before_last('.')
	if pamod == pafn {
		pamod = if g.fn_decl.is_builtin {
			'builtin'
		} else {
			'main'
		}
	}
	return paline, pafile, pamod, pafn
}
import os
import v.pref
import v.builder
import term

const (
	nr_tests  = 4
	term_ok   = term.ok_message('OK')
	term_fail = term.fail_message('FAIL')
)

fn test_c_files() {
	if true {
		return
	}
	println('Running V => C tests')
	vexe := os.getenv('VEXE')
	vroot := os.dir(vexe)
	for i in 1 .. (nr_tests + 1) {
		path := '$vroot/vlib/v/gen/tests/${i}.vv'
		ctext := os.read_file('$vroot/vlib/v/gen/tests/${i}.c') or {
			panic(err)
		}
		mut b := builder.new_builder(pref.Preferences{})
		b.module_search_paths = ['$vroot/vlib/v/gen/tests/']
		mut res := b.gen_c([path]).after('#endbuiltin')
		if res.contains('string _STR') {
			pos := res.index('string _STR') or {
				-1
			}
			end := res.index_after('endof _STR_TMP', pos)
			res = res[..pos] + res[end + 15..]
		}
		if compare_texts(res, ctext, path) {
			println('${term_ok} ${i}')
		} else {
			assert false
		}
	}
}

fn compare_texts(a, b, path string) bool {
	lines_a_ := a.trim_space().split_into_lines()
	lines_b_ := b.trim_space().split_into_lines()
	lines_a := lines_a_.filter(it != '')
	mut lines_b := lines_b_.filter(it != '')
	lines_b << ''
	lines_b << ''
	/*
	if lines_a.len != lines_b.len {
		println(term.red('different len'))
		println('${path}: got\n$a')
		return false
	}
	*/
	for i, line_a in lines_a {
		if i >= lines_b.len {
			println(line_a)
			return false
		}
		line_b := lines_b[i]
		if line_a.trim_space() != line_b.trim_space() {
			println('${path}: Got\n$a')
			println('${path}:${i}: ${term_fail}')
			println(term.bold(term.bright_yellow('actual  : ')) + line_a)
			println(term.green('expected: ') + line_b)
			println(lines_b[i + 1])
			println(lines_b[i + 2])
			// exit(1)
			return false
		}
	}
	return true
}

fn test_nested_if() {
	a := if true { if true { 'a' } else { 'b' } } else { 'c' }
	assert a == 'a'
}
module gen

// NB: @@@ here serve as placeholders.
// They will be replaced with correct strings
// for each constant, during C code generation.

const (
	// V_COMMIT_HASH is generated by cmd/tools/gen_vc.v .
	c_commit_hash_default = '
#ifndef V_COMMIT_HASH
#define V_COMMIT_HASH "@@@"
#endif

'
	// V_CURRENT_COMMIT_HASH is updated, when V is rebuilt inside a git repo.
	c_current_commit_hash_default = '
#ifndef V_CURRENT_COMMIT_HASH
#define V_CURRENT_COMMIT_HASH "@@@"
#endif

'

	c_common_macros = '
#define EMPTY_STRUCT_DECLARATION
#define EMPTY_STRUCT_INITIALIZATION 0
// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])
#define TCCSKIP(x) x

#ifdef __TINYC__
#undef EMPTY_STRUCT_DECLARATION
#undef EMPTY_STRUCT_INITIALIZATION
#define EMPTY_STRUCT_DECLARATION char _dummy
#define EMPTY_STRUCT_INITIALIZATION 0
#undef EMPTY_ARRAY_OF_ELEMS
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])
#undef TCCSKIP
#define TCCSKIP(x)
#include <byteswap.h>
#endif

// for __offset_of
#ifndef __offsetof
#define __offsetof(s,memb) \\
    ((size_t)((char *)&((s *)0)->memb - (char *)0))
#endif

#define OPTION_CAST(x) (x)

#ifndef V64_PRINTFORMAT
#ifdef PRIx64
#define V64_PRINTFORMAT "0x%"PRIx64
#elif defined(__WIN32__)
#define V64_PRINTFORMAT "0x%I64x"
#elif defined(__linux__) && defined(__LP64__)
#define V64_PRINTFORMAT "0x%lx"
#else
#define V64_PRINTFORMAT "0x%llx"
#endif
#endif

'
	c_headers = '

// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>

#ifdef __cplusplus
#   include <utility>
#   define _MOV std::move
#else
#   define _MOV
#endif

#ifndef _WIN32
#if defined __has_include
#if __has_include (<execinfo.h>)
#	include <execinfo.h>
#else
// Most probably musl OR __ANDROID__ ...
int backtrace (void **__array, int __size) { return 0; }
char **backtrace_symbols (void *const *__array, int __size){ return 0; }
void backtrace_symbols_fd (void *const *__array, int __size, int __fd){}	
#endif
#endif
#endif

//#include "fns.h"
#include <signal.h>
#include <stdarg.h> // for va_list
#include <string.h> // memcpy

#if INTPTR_MAX == INT32_MAX
    #define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
    #define TARGET_IS_64BIT 1
#else
    #error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
    #define TARGET_ORDER_IS_BIG
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)
    #define TARGET_ORDER_IS_LITTLE
#else
    #error "Unknown architecture endianness"
#endif

#ifndef _WIN32
#include <ctype.h>
#include <locale.h> // tolower
#include <sys/time.h>
#include <unistd.h> // sleep
extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif


#ifdef __linux__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __FreeBSD__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __DragonFly__
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __NetBSD__
#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __sun
#include <sys/types.h>
#include <sys/wait.h> // os__wait uses wait on nix
#endif

$c_common_macros

#ifdef _WIN32
#define WINVER 0x0600
#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#define _WIN32_WINNT 0x0600
#define WIN32_LEAN_AND_MEAN
#define _UNICODE
#define UNICODE
#include <windows.h>

#include <io.h> // _waccess
#include <direct.h> // _wgetcwd
//#include <WinSock2.h>
#ifdef _MSC_VER

// On MSVC these are the same (as long as /volatile:ms is passed)
#define _Atomic volatile

// MSVC cannot parse some things properly
#undef EMPTY_STRUCT_DECLARATION
#undef OPTION_CAST

#define EMPTY_STRUCT_DECLARATION int ____dummy_variable
#define OPTION_CAST(x)

#include <dbghelp.h>
#pragma comment(lib, "Dbghelp.lib")

extern wchar_t **_wenviron;

#endif

#else
#include <pthread.h>
#endif

// g_live_info is used by live.info()
void* g_live_info = NULL;

//============================== HELPER C MACROS =============================*/
//#define tos4(s, slen) ((string){.str=(s), .len=(slen)})
#define _SLIT(s) ((string){.str=(s), .len=(strlen(s))})
#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}
#define _IN(typ, val, arr) array_##typ##_contains(arr, val)
#define _IN_MAP(val, m) map_exists(m, val)
#define DEFAULT_EQUAL(a, b) (a == b)
#define DEFAULT_NOT_EQUAL(a, b) (a != b)
#define DEFAULT_LT(a, b) (a < b)
#define DEFAULT_LE(a, b) (a <= b)
#define DEFAULT_GT(a, b) (a > b)
#define DEFAULT_GE(a, b) (a >= b)

// NB: macro_fXX_eq and macro_fXX_ne are NOT used
// in the generated C code. They are here just for
// completeness/testing.

#define macro_f64_eq(a, b) (a == b)
#define macro_f64_ne(a, b) (a != b)
#define macro_f64_lt(a, b) (a <  b)
#define macro_f64_le(a, b) (a <= b)
#define macro_f64_gt(a, b) (a >  b)
#define macro_f64_ge(a, b) (a >= b)

#define macro_f32_eq(a, b) (a == b)
#define macro_f32_ne(a, b) (a != b)
#define macro_f32_lt(a, b) (a <  b)
#define macro_f32_le(a, b) (a <= b)
#define macro_f32_gt(a, b) (a >  b)
#define macro_f32_ge(a, b) (a >= b)

#if defined(__MINGW32__) || defined(__MINGW64__)
#undef PRId64
#undef PRIi64
#undef PRIo64
#undef PRIu64
#undef PRIx64
#undef PRIX64
#define PRId64 "lld"
#define PRIi64 "lli"
#define PRIo64 "llo"
#define PRIu64 "llu"
#define PRIx64 "llx"
#define PRIX64 "llX"
#endif

//================================== GLOBALS =================================*/
byte g_str_buf[1024];
int load_so(byteptr);
void reload_so();
void _vinit();
void _vcleanup();
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )

// ============== wyhash ==============
//Author: Wang Yi
#ifndef wyhash_version_gamma
#define wyhash_version_gamma
#define WYHASH_CONDOM 0
#include <stdint.h>
#include <string.h>
#if defined(_MSC_VER) && defined(_M_X64)
#include <intrin.h>
#pragma intrinsic(_umul128)
#endif

//const uint64_t _wyp0=0xa0761d6478bd642full, _wyp1=0xe7037ed1a0b428dbull;
#define _wyp0 ((uint64_t)0xa0761d6478bd642full)
#define _wyp1 ((uint64_t)0xe7037ed1a0b428dbull)


#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__) || defined(__TINYC__)
#define _likely_(x) __builtin_expect(x, 1)
#else
#define _likely_(x) (x)
#endif

#if defined(TARGET_ORDER_IS_LITTLE)
#define WYHASH_LITTLE_ENDIAN 1
#elif defined(TARGET_ORDER_IS_BIG)
#define WYHASH_LITTLE_ENDIAN 0
#endif

#if (WYHASH_LITTLE_ENDIAN)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return v;}
#else
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#elif defined(__TINYC__)
  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return bswap_64(v);}
  static inline uint64_t _wyr4(const uint8_t *p) { unsigned v; memcpy(&v, p, 4); return bswap_32(v);}
#endif
#endif

static inline uint64_t _wyr3(const uint8_t *p, unsigned k) { return (((uint64_t)p[0]) << 16) | (((uint64_t)p[k >> 1]) << 8) | p[k - 1];}
static inline uint64_t _wyrotr(uint64_t v, unsigned k) { return (v >> k) | (v << (64 - k));}
static inline void _wymix128(uint64_t A, uint64_t B, uint64_t *C, uint64_t *D){
	A^=*C;	B^=*D;
#ifdef UNOFFICIAL_WYHASH_32BIT
	uint64_t hh=(A>>32)*(B>>32), hl=(A>>32)*(unsigned)B, lh=(unsigned)A*(B>>32), ll=(uint64_t)(unsigned)A*(unsigned)B;
	*C=_wyrotr(hl,32)^hh; *D=_wyrotr(lh,32)^ll;
#else
#ifdef __SIZEOF_INT128__
	__uint128_t r=A; r*=B; *C=(uint64_t)r; *D=(uint64_t)(r>>64);
#elif defined(_MSC_VER) && defined(_M_X64)
	A=_umul128(A,B,&B); *C=A; *D=B;
#else
	uint64_t ha=A>>32, hb=B>>32, la=(uint32_t)A, lb=(uint32_t)B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	*C=lo;	*D=hi;
#endif
#endif
}
static inline uint64_t wyhash(const void *key, uint64_t len, uint64_t seed){
	const uint8_t *p=(const uint8_t *)key;
	uint64_t i=len, see1=seed;
	start:
	if(_likely_(i<=16)){
	#ifndef	WYHASH_CONDOM
		uint64_t shift=(i<8)*((8-i)<<3);
		//WARNING: intended reading outside buffer, trading for speed.
		_wymix128((_wyr8(p)<<shift)^_wyp0,(_wyr8(p+i-8)>>shift)^_wyp1, &seed, &see1);
	#else
		if(_likely_(i<=8)){
			if(_likely_(i>=4))	_wymix128(_wyr4(p)^_wyp0,_wyr4(p+i-4)^_wyp1, &seed, &see1);
			else if (_likely_(i))	_wymix128(_wyr3(p,i)^_wyp0,_wyp1, &seed, &see1);
			else	_wymix128(_wyp0,_wyp1, &seed, &see1);
		}
  		else	_wymix128(_wyr8(p)^_wyp0,_wyr8(p+i-8)^_wyp1, &seed, &see1);
	#endif
		_wymix128(len,_wyp0, &seed, &see1);
		return	seed^see1;
	}
	_wymix128(_wyr8(p)^_wyp0,_wyr8(p+8)^_wyp1, &seed, &see1);
	i-=16;	p+=16;	goto start;
}
static inline uint64_t wyhash64(uint64_t A, uint64_t B){
	_wymix128(_wyp0,_wyp1,&A,&B);
	_wymix128(0,0,&A,&B);
	return	A^B;
}
static inline uint64_t wyrand(uint64_t *seed){
	*seed+=_wyp0;
	uint64_t	a=0, b=0;
	_wymix128(*seed,*seed^_wyp1,&a,&b);
	return	a^b;
}
static inline double wy2u01(uint64_t r) {
	const double _wynorm=1.0/(1ull<<52);
	return (r>>12)*_wynorm;
}
static inline double wy2gau(uint64_t r) {
	const double _wynorm=1.0/(1ull<<20);
	return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;
}
#endif

'
	c_builtin_types = '

//================================== builtin types ================================*/

typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t byte;
typedef uint32_t rune;
typedef float f32;
typedef double f64;
typedef int64_t any_int;
typedef double any_float;
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef struct array array;
typedef struct map map;
typedef array array_string;
typedef array array_int;
typedef array array_byte;
typedef array array_f32;
typedef array array_f64;
typedef array array_u16;
typedef array array_u32;
typedef array array_u64;
typedef map map_int;
typedef map map_string;
typedef byte array_fixed_byte_300 [300];
typedef byte array_fixed_byte_400 [400];
#ifndef __cplusplus
#ifndef bool
        typedef int bool;
        #define true 1
        #define false 0
#endif
#endif

'
	bare_c_headers = '

$c_common_macros

#ifndef exit
#define exit(rc) sys_exit(rc)
void sys_exit (int);
#endif

'
)
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module gen

import vweb.tmpl
import os

// $vweb.html()
fn (mut g Gen) vweb_html() {
	// Compile vweb html template to V code, parse that V code and embed the resulting V functions
	// that returns an html string
	mut path := g.cur_fn.name + '.html'
	println('html path=$path')
	if g.pref.is_debug {
		println('>>> compiling vweb HTML template "$path"')
	}
	if !os.exists(path) {
		// Can't find the template file in current directory,
		// try looking next to the vweb program, in case it's run with
		// v path/to/vweb_app.v
		// path = os.dir(g.scanner.file_path) + '/' + path
		// if !os.exists(path) {
		verror('vweb HTML template "$path" not found')
		// }
	}
	v_code := tmpl.compile_template(path)
	if g.pref.is_verbose {
		println('\n\n')
		println('>>> vweb template for ${path}:')
		println(v_code)
		println('>>> vweb template END')
		println('\n\n')
	}
	// is_strings_imorted := p.import_table.known_import('strings')
	// if !is_strings_imorted {
	// p.register_import('strings', 0) // used by v_code
	// }
	// p.import_table.register_used_import('strings')
	g.writeln('/////////////////// tmpl start')
	// g.statements_from_text(v_code, false, path)
	g.writeln('/////////////////// tmpl end')
	receiver := g.cur_fn.args[0]
	dot := '.' // if receiver.is_mut || receiver.ptr || receiver.typ.ends_with('*') { '->' } else { '.' }
	g.writeln('vweb__Context_html(&$receiver.name /*!*/$dot vweb, tmpl_res)')
}

fn fooo() {
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module gen

import v.ast
import v.table
import v.util

fn (mut g Gen) gen_fn_decl(it ast.FnDecl) {
	if it.language == .c {
		// || it.no_body {
		return
	}
	former_cur_fn := g.cur_fn
	g.cur_fn = &it
	defer {
		g.cur_fn = former_cur_fn
	}
	is_main := it.name == 'main'
	if it.is_generic && g.cur_generic_type == 0 { // need the cur_generic_type check to avoid inf. recursion
		// loop thru each generic type and generate a function
		for gen_type in g.table.fn_gen_types[it.name] {
			sym := g.table.get_type_symbol(gen_type)
			if g.pref.is_verbose {
				println('gen fn `$it.name` for type `$sym.name`')
			}
			g.cur_generic_type = gen_type
			g.gen_fn_decl(it)
		}
		g.cur_generic_type = 0
		return
	}
	//
	if is_main && g.pref.is_liveshared {
		return
	}
	//
	fn_start_pos := g.out.len
	if g.attr == 'inline' {
		g.write('inline ')
	}
	//
	is_livefn := g.attr == 'live'
	is_livemain := g.pref.is_livemain && is_livefn
	is_liveshared := g.pref.is_liveshared && is_livefn
	is_livemode := g.pref.is_livemain || g.pref.is_liveshared
	is_live_wrap := is_livefn && is_livemode
	if is_livefn && !is_livemode {
		eprintln('INFO: compile with `v -live $g.pref.path `, if you want to use the [live] function ${it.name} .')
	}
	//
	g.reset_tmp_count()
	if is_main {
		if g.pref.os == .windows {
			if g.is_gui_app() {
				// GUI application
				g.writeln('int WINAPI wWinMain(HINSTANCE instance, HINSTANCE prev_instance, LPWSTR cmd_line, int show_cmd){')
				g.last_fn_c_name = 'wWinMain'
			} else {
				// Console application
				g.writeln('int wmain(int ___argc, wchar_t* ___argv[], wchar_t* ___envp[]){')
				g.last_fn_c_name = 'wmain'
			}
		} else {
			g.writeln('int main(int ___argc, char** ___argv){')
			g.last_fn_c_name = it.name
		}
	} else {
		mut name := it.name
		if name[0] in [`+`, `-`, `*`, `/`, `%`] {
			name = util.replace_op(name)
		}
		if it.is_method {
			name = g.table.get_type_symbol(it.receiver.typ).name + '_' + name
		}
		if it.language == .c {
			name = name.replace('.', '__')
		} else {
			name = c_name(name)
		}
		if g.cur_generic_type != 0 {
			// foo<T>() => foo_int(), foo_string() etc
			name += '_' + g.typ(g.cur_generic_type)
		}
		// if g.pref.show_cc && it.is_builtin {
		// println(name)
		// }
		// type_name := g.table.Type_to_str(it.return_type)
		// Live functions are protected by a mutex, because otherwise they
		// can be changed by the live reload thread, *while* they are
		// running, with unpredictable results (usually just crashing).
		// For this purpose, the actual body of the live function,
		// is put under a non publicly accessible function, that is prefixed
		// with 'impl_live_' .
		if is_livemain {
			g.hotcode_fn_names << name
		}
		mut impl_fn_name := if is_live_wrap { 'impl_live_${name}' } else { name }
		g.last_fn_c_name = impl_fn_name
		type_name := g.typ(it.return_type)
		//
		if is_live_wrap {
			if is_livemain {
				g.definitions.write('$type_name (* ${impl_fn_name})(')
				g.write('$type_name no_impl_${name}(')
			}
			if is_liveshared {
				g.definitions.write('$type_name ${impl_fn_name}(')
				g.write('$type_name ${impl_fn_name}(')
			}
		} else {
			if !(it.is_pub || g.pref.is_debug) {
				g.write('static ')
				g.definitions.write('static ')
			}
			g.definitions.write('$type_name ${name}(')
			g.write('$type_name ${name}(')
		}
		fargs, fargtypes := g.fn_args(it.args, it.is_variadic)
		if it.no_body || (g.pref.use_cache && it.is_builtin) {
			// Just a function header. Builtin function bodies are defined in builtin.o
			g.definitions.writeln(');')
			g.writeln(');')
			return
		}
		g.definitions.writeln(');')
		g.writeln(') {')
		if is_live_wrap {
			// The live function just calls its implementation dual, while ensuring
			// that the call is wrapped by the mutex lock & unlock calls.
			// Adding the mutex lock/unlock inside the body of the implementation
			// function is not reliable, because the implementation function can do
			// an early exit, which will leave the mutex locked.
			mut fn_args_list := []string{}
			for ia, fa in fargs {
				fn_args_list << '${fargtypes[ia]} ${fa}'
			}
			mut live_fncall := '${impl_fn_name}(' + fargs.join(', ') + ');'
			mut live_fnreturn := ''
			if type_name != 'void' {
				live_fncall = '${type_name} res = ${live_fncall}'
				live_fnreturn = 'return res;'
			}
			g.definitions.writeln('$type_name ${name}(' + fn_args_list.join(', ') + ');')
			g.hotcode_definitions.writeln('$type_name ${name}(' + fn_args_list.join(', ') +
				'){')
			g.hotcode_definitions.writeln('  pthread_mutex_lock(&live_fn_mutex);')
			g.hotcode_definitions.writeln('  $live_fncall')
			g.hotcode_definitions.writeln('  pthread_mutex_unlock(&live_fn_mutex);')
			g.hotcode_definitions.writeln('  $live_fnreturn')
			g.hotcode_definitions.writeln('}')
		}
	}
	if is_main {
		if g.pref.os == .windows && g.is_gui_app() {
			g.writeln('\ttypedef LPWSTR*(WINAPI *cmd_line_to_argv)(LPCWSTR, int*);')
			g.writeln('\tHMODULE shell32_module = LoadLibrary(L"shell32.dll");')
			g.writeln('\tcmd_line_to_argv CommandLineToArgvW = (cmd_line_to_argv)GetProcAddress(shell32_module, "CommandLineToArgvW");')
			g.writeln('\tint ___argc;')
			g.writeln('\twchar_t** ___argv = CommandLineToArgvW(cmd_line, &___argc);')
		}
		g.writeln('\t_vinit();')
		if g.is_importing_os() {
			if g.autofree {
				g.writeln('free(_const_os__args.data); // empty, inited in _vinit()')
			}
			if g.pref.os == .windows {
				g.writeln('\t_const_os__args = os__init_os_args_wide(___argc, ___argv);')
			} else {
				g.writeln('\t_const_os__args = os__init_os_args(___argc, (byteptr*)___argv);')
			}
		}
	}
	if g.pref.is_livemain && is_main {
		g.generate_hotcode_reloading_main_caller()
	}
	// Profiling mode? Start counting at the beginning of the function (save current time).
	if g.pref.is_prof {
		g.profile_fn(it.name, is_main)
	}
	g.stmts(it.stmts)
	// ////////////
	if is_main {
		if g.autofree {
			g.writeln('\t_vcleanup();')
		}
		if g.is_test {
			verror('test files cannot have function `main`')
		}
	}
	g.write_defer_stmts_when_needed()
	// /////////
	if g.autofree {
		// TODO: remove this, when g.write_autofree_stmts_when_needed works properly
		g.writeln(g.autofree_scope_vars(it.body_pos.pos))
	}
	if is_main {
		g.writeln('\treturn 0;')
	}
	g.writeln('}')
	g.defer_stmts = []
	if g.pref.printfn_list.len > 0 && g.last_fn_c_name in g.pref.printfn_list {
		println(g.out.after(fn_start_pos))
	}
}

fn (mut g Gen) write_autofree_stmts_when_needed(r ast.Return) {
	// TODO: write_autofree_stmts_when_needed should account for the current local scope vars.
	// TODO: write_autofree_stmts_when_needed should not free the returned variables.
	// It may require rewriting g.return_statement to assign the expressions
	// to temporary variables, then protecting *them* from autofreeing ...
	/*
	g.writeln('/* autofreeings before return:              -------')
	//g.write( g.autofree_scope_vars(r.pos.pos) )
	g.write( g.autofree_scope_vars(g.fn_decl.body_pos.pos) )
	g.writeln('--------------------------------------------------- */')
	*/
}

fn (mut g Gen) write_defer_stmts_when_needed() {
	if g.defer_stmts.len > 0 {
		g.write_defer_stmts()
	}
	if g.defer_profile_code.len > 0 {
		g.writeln('')
		g.writeln('\t// defer_profile_code')
		g.writeln(g.defer_profile_code)
		g.writeln('')
	}
}

fn (mut g Gen) fn_args(args []table.Arg, is_variadic bool) ([]string, []string) {
	mut fargs := []string{}
	mut fargtypes := []string{}
	no_names := args.len > 0 && args[0].name == 'arg_1'
	for i, arg in args {
		caname := c_name(arg.name)
		arg_type_sym := g.table.get_type_symbol(arg.typ)
		mut arg_type_name := g.typ(arg.typ) // arg_type_sym.name.replace('.', '__')
		// if arg.name == 'xxx' {
		// println('! ' + arg_type_name)
		// }
		is_varg := i == args.len - 1 && is_variadic
		if is_varg {
			varg_type_str := int(arg.typ).str()
			if varg_type_str !in g.variadic_args {
				g.variadic_args[varg_type_str] = 0
			}
			arg_type_name = 'varg_' + g.typ(arg.typ).replace('*', '_ptr')
		}
		if arg_type_sym.kind == .function {
			info := arg_type_sym.info as table.FnType
			func := info.func
			if !info.is_anon {
				g.write(arg_type_name + ' ' + caname)
				g.definitions.write(arg_type_name + ' ' + caname)
				fargs << caname
				fargtypes << arg_type_name
			} else {
				g.write('${g.typ(func.return_type)} (*$caname)(')
				g.definitions.write('${g.typ(func.return_type)} (*$caname)(')
				g.fn_args(func.args, func.is_variadic)
				g.write(')')
				g.definitions.write(')')
			}
		} else if no_names {
			g.write(arg_type_name)
			g.definitions.write(arg_type_name)
			fargs << ''
			fargtypes << arg_type_name
		} else {
			mut nr_muls := arg.typ.nr_muls()
			s := arg_type_name + ' ' + caname
			if arg.is_mut {
				// mut arg needs one *
				nr_muls = 1
			}
			// if nr_muls > 0 && !is_varg {
			// s = arg_type_name + strings.repeat(`*`, nr_muls) + ' ' + caname
			// }
			g.write(s)
			g.definitions.write(s)
			fargs << caname
			fargtypes << arg_type_name
		}
		if i < args.len - 1 {
			g.write(', ')
			g.definitions.write(', ')
		}
	}
	return fargs, fargtypes
}

fn (mut g Gen) call_expr(node ast.CallExpr) {
	if node.should_be_skipped {
		return
	}
	gen_or := node.or_block.kind != .absent
	cur_line := if gen_or && g.is_assign_rhs {
		line := g.go_before_stmt(0)
		g.out.write(tabs[g.indent])
		line
	} else {
		''
	}
	tmp_opt := if gen_or { g.new_tmp_var() } else { '' }
	if gen_or {
		styp := g.typ(node.return_type.set_flag(.optional))
		g.write('$styp $tmp_opt = ')
	}
	if node.is_method {
		g.method_call(node)
	} else {
		g.fn_call(node)
	}
	if gen_or {
		g.or_block(tmp_opt, node.or_block, node.return_type)
		g.write('\n${cur_line}${tmp_opt}')
	}
}

fn (mut g Gen) method_call(node ast.CallExpr) {
	// TODO: there are still due to unchecked exprs (opt/some fn arg)
	if node.left_type == 0 {
		verror('method receiver type is 0, this means there are some uchecked exprs')
	}
	// mut receiver_type_name := g.cc_type(node.receiver_type)
	// mut receiver_type_name := g.typ(node.receiver_type)
	typ_sym := g.table.get_type_symbol(node.receiver_type)
	mut receiver_type_name := typ_sym.name.replace('.', '__')
	if typ_sym.kind == .interface_ {
		// Speaker_name_table[s._interface_idx].speak(s._object)
		g.write('${c_name(receiver_type_name)}_name_table[')
		g.expr(node.left)
		dot := if node.left_type.is_ptr() { '->' } else { '.' }
		g.write('${dot}_interface_idx].${node.name}(')
		g.expr(node.left)
		g.write('${dot}_object')
		if node.args.len > 0 {
			g.write(', ')
			g.call_args(node.args, node.expected_arg_types)
		}
		g.write(')')
		return
	}
	if typ_sym.kind == .array && node.name == 'map' {
		g.gen_map(node)
		return
	}
	// rec_sym := g.table.get_type_symbol(node.receiver_type)
	if typ_sym.kind == .array && node.name == 'filter' {
		g.gen_filter(node)
		return
	}
	if node.name == 'str' {
		mut styp := g.typ(node.receiver_type)
		if node.receiver_type.is_ptr() {
			styp = styp.replace('*', '')
		}
		g.gen_str_for_type_with_styp(node.receiver_type, styp)
	}
	// TODO performance, detect `array` method differently
	if typ_sym.kind == .array && node.name in ['repeat', 'sort_with_compare', 'free', 'push_many',
		'trim',
		'first',
		'last',
		'clone',
		'reverse',
		'slice'
	] {
		// && rec_sym.name == 'array' {
		// && rec_sym.name == 'array' && receiver_name.starts_with('array') {
		// `array_byte_clone` => `array_clone`
		receiver_type_name = 'array'
		if node.name in ['last', 'first'] {
			return_type_str := g.typ(node.return_type)
			g.write('*($return_type_str*)')
		}
	}
	name := '${receiver_type_name}_$node.name'.replace('.', '__')
	// if node.receiver_type != 0 {
	// g.write('/*${g.typ(node.receiver_type)}*/')
	// g.write('/*expr_type=${g.typ(node.left_type)} rec type=${g.typ(node.receiver_type)}*/')
	// }
	if !node.receiver_type.is_ptr() && node.left_type.is_ptr() && node.name == 'str' {
		g.write('ptr_str(')
	} else {
		g.write('${name}(')
	}
	if node.receiver_type.is_ptr() && !node.left_type.is_ptr() {
		// The receiver is a reference, but the caller provided a value
		// Add `&` automatically.
		// TODO same logic in call_args()
		g.write('&')
	} else if !node.receiver_type.is_ptr() && node.left_type.is_ptr() && node.name != 'str' {
		g.write('/*rec*/*')
	}
	g.expr(node.left)
	is_variadic := node.expected_arg_types.len > 0 && node.expected_arg_types[node.expected_arg_types.len -
		1].flag_is(.variadic)
	if node.args.len > 0 || is_variadic {
		g.write(', ')
	}
	// /////////
	/*
	if name.contains('subkeys') {
	println('call_args $name $node.arg_types.len')
	for t in node.arg_types {
		sym := g.table.get_type_symbol(t)
		print('$sym.name ')
	}
	println('')
}
	*/
	// ///////
	g.call_args(node.args, node.expected_arg_types)
	g.write(')')
	// if node.or_block.stmts.len > 0 {
	// g.or_block(node.or_block.stmts, node.return_type)
	// }
}

fn (mut g Gen) fn_call(node ast.CallExpr) {
	// call struct field with fn type
	// TODO: test node.left instead
	// left & left_type will be `x` and `x type` in `x.fieldfn()`
	// will be `0` for `foo()`
	if node.left_type != 0 {
		g.expr(node.left)
		if node.left_type.is_ptr() {
			g.write('->')
		} else {
			g.write('.')
		}
	}
	mut name := node.name
	is_print := name == 'println' || name == 'print'
	print_method := if name == 'println' { 'println' } else { 'print' }
	is_json_encode := name == 'json.encode'
	is_json_decode := name == 'json.decode'
	g.is_json_fn = is_json_encode || is_json_decode
	mut json_type_str := ''
	if g.is_json_fn {
		if name == 'json.encode' {
			g.write('json__json_print(')
			g.gen_json_for_type(node.args[0].typ)
			json_type_str = g.table.get_type_symbol(node.args[0].typ).name
		} else {
			g.insert_before_stmt('// json.decode')
			ast_type := node.args[0].expr as ast.Type
			// `json.decode(User, s)` => json.decode_User(s)
			sym := g.table.get_type_symbol(ast_type.typ)
			name += '_' + sym.name
			g.gen_json_for_type(ast_type.typ)
		}
	}
	if node.language == .c {
		// Skip "C."
		g.is_c_call = true
		name = name[2..].replace('.', '__')
	} else {
		name = c_name(name)
	}
	if is_json_encode {
		// `json__encode` => `json__encode_User`
		name += '_' + json_type_str.replace('.', '__')
	}
	if node.generic_type != table.void_type && node.generic_type != 0 {
		// `foo<int>()` => `foo_int()`
		name += '_' + g.typ(node.generic_type)
	}
	// Generate tmp vars for values that have to be freed.
	/*
	mut tmps := []string{}
	for arg in node.args {
		if arg.typ == table.string_type_idx || is_print {
			tmp := g.new_tmp_var()
			tmps << tmp
			g.write('string $tmp = ')
			g.expr(arg.expr)
			g.writeln('; //memory')
		}
	}
	*/
	if is_print && node.args[0].typ != table.string_type {
		typ := node.args[0].typ
		mut styp := g.typ(typ)
		sym := g.table.get_type_symbol(typ)
		if typ.is_ptr() {
			styp = styp.replace('*', '')
		}
		mut str_fn_name := g.gen_str_for_type_with_styp(typ, styp)
		if g.autofree && !typ.flag_is(.optional) {
			// Create a temporary variable so that the value can be freed
			tmp := g.new_tmp_var()
			// tmps << tmp
			g.write('string $tmp = ${str_fn_name}(')
			g.expr(node.args[0].expr)
			g.writeln('); ${print_method}($tmp); string_free(&$tmp); //MEM2 $styp')
		} else {
			expr := node.args[0].expr
			is_var := match expr {
				ast.SelectorExpr { true }
				ast.Ident { true }
				else { false }
			}
			if typ.is_ptr() && sym.kind != .struct_ {
				// ptr_str() for pointers
				styp = 'ptr'
				str_fn_name = 'ptr_str'
			}
			if sym.kind == .enum_ {
				if is_var {
					g.write('${print_method}(${str_fn_name}(')
				} else {
					// when no var, print string directly
					g.write('${print_method}(tos3("')
				}
				if typ.is_ptr() {
					// dereference
					g.write('*')
				}
				g.enum_expr(expr)
				if !is_var {
					// end of string
					g.write('"')
				}
			} else {
				g.write('${print_method}(${str_fn_name}(')
				if typ.is_ptr() && sym.kind == .struct_ {
					// dereference
					g.write('*')
				}
				g.expr(expr)
				if !typ.flag_is(.variadic) && sym.kind == .struct_ && styp != 'ptr' && !sym.has_method('str') {
					g.write(', 0') // trailing 0 is initial struct indent count
				}
			}
			g.write('))')
		}
	} else if g.pref.is_debug && node.name == 'panic' {
		paline, pafile, pamod, pafn := g.panic_debug_info(node.pos)
		g.write('panic_debug($paline, tos3("$pafile"), tos3("$pamod"), tos3("$pafn"),  ')
		g.call_args(node.args, node.expected_arg_types)
		g.write(')')
	} else {
		g.write('${g.get_ternary_name(name)}(')
		if is_json_decode {
			g.write('json__json_parse(')
			// Skip the first argument in json.decode which is a type
			// its name was already used to generate the function call
			g.call_args(node.args[1..], node.expected_arg_types)
		} else {
			g.call_args(node.args, node.expected_arg_types)
		}
		g.write(')')
	}
	// if node.or_block.stmts.len > 0 {
	// g.or_block(node.or_block.stmts, node.return_type)
	// }
	g.is_c_call = false
	if g.is_json_fn {
		g.write(')')
		g.is_json_fn = false
	}
}

fn (mut g Gen) call_args(args []ast.CallArg, expected_types []table.Type) {
	is_variadic := expected_types.len > 0 && expected_types[expected_types.len - 1].flag_is(.variadic)
	is_forwarding_varg := args.len > 0 && args[args.len - 1].typ.flag_is(.variadic)
	gen_vargs := is_variadic && !is_forwarding_varg
	for i, arg in args {
		if gen_vargs && i == expected_types.len - 1 {
			break
		}
		// if arg.typ.name.starts_with('I') {
		// }
		mut is_interface := false
		// some c fn definitions dont have args (cfns.v) or are not updated in checker
		// when these are fixed we wont need this check
		if i < expected_types.len {
			if expected_types[i] != 0 {
				// Cast a type to interface
				// `foo(dog)` => `foo(I_Dog_to_Animal(dog))`
				exp_sym := g.table.get_type_symbol(expected_types[i])
				// exp_styp := g.typ(expected_types[arg_no]) // g.table.get_type_symbol(expected_types[arg_no])
				// styp := g.typ(arg.typ) // g.table.get_type_symbol(arg.typ)
				if exp_sym.kind == .interface_ {
					g.interface_call(arg.typ, expected_types[i])
					is_interface = true
				}
			}
			if is_interface {
				g.expr(arg.expr)
			} else {
				g.ref_or_deref_arg(arg, expected_types[i])
			}
		} else {
			g.expr(arg.expr)
		}
		if is_interface {
			g.write(')')
		}
		if i < args.len - 1 || gen_vargs {
			g.write(', ')
		}
	}
	arg_nr := expected_types.len - 1
	if gen_vargs {
		varg_type := expected_types[expected_types.len - 1]
		struct_name := 'varg_' + g.typ(varg_type).replace('*', '_ptr')
		variadic_count := args.len - arg_nr
		varg_type_str := int(varg_type).str()
		if variadic_count > g.variadic_args[varg_type_str] {
			g.variadic_args[varg_type_str] = variadic_count
		}
		g.write('($struct_name){.len=$variadic_count,.args={')
		if variadic_count > 0 {
			for j in arg_nr .. args.len {
				g.ref_or_deref_arg(args[j], varg_type)
				if j < args.len - 1 {
					g.write(', ')
				}
			}
		} else {
			g.write('0')
		}
		g.write('}}')
	}
}

[inline]
fn (mut g Gen) ref_or_deref_arg(arg ast.CallArg, expected_type table.Type) {
	arg_is_ptr := expected_type.is_ptr() || expected_type.idx() in table.pointer_type_idxs
	expr_is_ptr := arg.typ.is_ptr() || arg.typ.idx() in table.pointer_type_idxs
	exp_sym := g.table.get_type_symbol(expected_type)
	if arg.is_mut && !arg_is_ptr {
		g.write('&/*mut*/')
	} else if arg_is_ptr && !expr_is_ptr {
		if arg.is_mut {
			if exp_sym.kind == .array {
				// Special case for mutable arrays. We can't `&` function
				// results,	have to use `(array[]){ expr }[0]` hack.
				g.write('&/*111*/(array[]){')
				g.expr(arg.expr)
				g.write('}[0]')
				return
			}
		}
		if !g.is_json_fn {
			g.write('(voidptr)&/*qq*/')
		}
	}
	g.expr_with_cast(arg.expr, arg.typ, expected_type)
}

fn (mut g Gen) is_gui_app() bool {
	$if windows {
		for cf in g.table.cflags {
			if cf.value == 'gdi32' {
				return true
			}
		}
	}
	return false
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module gen

import v.table
import strings

// TODO replace with comptime code generation.
// TODO remove cJSON dependency.
// OLD: User decode_User(string js) {
// now it's
// User decode_User(cJSON* root) {
// User res;
// res.name = decode_string(js_get(root, "name"));
// res.profile = decode_Profile(js_get(root, "profile"));
// return res;
// }
// Codegen json_decode/encode funcs
fn (mut g Gen) gen_json_for_type(typ table.Type) {
	mut dec := strings.new_builder(100)
	mut enc := strings.new_builder(100)
	sym := g.table.get_type_symbol(typ)
	styp := g.typ(typ)
	if sym.name in ['int', 'string', 'bool'] {
		return
	}
	if sym.kind == .array {
		// return
	}
	if sym.name in g.json_types {
		return
	}
	g.json_types << sym.name
	// println('gen_json_for_type($sym.name)')
	// decode_TYPE funcs receive an actual cJSON* object to decode
	// cJSON_Parse(str) call is added by the compiler
	// Code gen decoder
	dec_fn_name := js_dec_name(sym.name)
	dec.writeln('
//Option ${dec_fn_name}(cJSON* root, $styp* res) {
Option ${dec_fn_name}(cJSON* root) {
  $styp res;
  if (!root) {
    const char *error_ptr = cJSON_GetErrorPtr();
    if (error_ptr != NULL)	{
//      fprintf(stderr, "Error in decode() for $styp error_ptr=: %%s\\n", error_ptr);
//      printf("\\nbad js=%%s\\n", js.str);
      return v_error(tos2(error_ptr));
    }
  }
')
	// Code gen encoder
	// encode_TYPE funcs receive an object to encode
	enc_fn_name := js_enc_name(sym.name)
	enc.writeln('
cJSON* ${enc_fn_name}($styp val) {
\tcJSON *o = cJSON_CreateObject();')
	if sym.kind == .array {
		// Handle arrays
		value_type := g.table.value_type(typ)
		g.gen_json_for_type(value_type)
		dec.writeln(g.decode_array(value_type))
		enc.writeln(g.encode_array(value_type))
		// enc += g.encode_array(t)
	} else {
		// Structs. Range through fields
		if !(sym.info is table.Struct) {
			verror('json: $sym.name is not struct')
		}
		info := sym.info as table.Struct
		for field in info.fields {
			if 'skip' in field.attrs {
				continue
			}
			mut name := field.name
			for attr in field.attrs {
				if attr.starts_with('json:') {
					name = attr[5..]
					break
				}
			}
			field_type := g.typ(field.typ)
			enc_name := js_enc_name(field_type)
			if 'raw' in field.attrs {
				dec.writeln(' res . $field.name = tos2(cJSON_PrintUnformatted(' + 'js_get(root, "$name")));')
			} else {
				// Now generate decoders for all field types in this struct
				// need to do it here so that these functions are generated first
				g.gen_json_for_type(field.typ)
				dec_name := js_dec_name(field_type)
				if is_js_prim(field_type) {
					dec.writeln(' res . $field.name = $dec_name (js_get(root, "$name"));')
				} else {
					// dec.writeln(' $dec_name (js_get(root, "$name"), & (res . $field.name));')
					dec.writeln('  res . $field.name = *($field_type*) $dec_name (js_get(root,"$name")).data;')
				}
			}
			enc.writeln('\tcJSON_AddItemToObject(o, "$name", ${enc_name}(val.$field.name));')
		}
	}
	// cJSON_delete
	// p.cgen.fns << '$dec return opt_ok(res); \n}'
	dec.writeln('return opt_ok(&res, sizeof(res)); \n}')
	enc.writeln('\treturn o;\n}')
	g.definitions.writeln(dec.str())
	g.gowrappers.writeln(enc.str())
}

fn js_enc_name(typ string) string {
	name := 'json__encode_$typ'
	return name.replace('.', '__')
}

fn js_dec_name(typ string) string {
	name := 'json__decode_$typ'
	return name.replace('.', '__')
}

fn is_js_prim(typ string) bool {
	return typ == 'int' || typ == 'string' || typ == 'bool' || typ == 'f32' || typ == 'f64' ||
		typ == 'i8' || typ == 'i16' || typ == 'i64' || typ == 'u16' || typ == 'u32' || typ == 'u64'
}

fn (mut g Gen) decode_array(value_type table.Type) string {
	styp := g.typ(value_type)
	fn_name := js_dec_name(styp)
	// If we have `[]Profile`, have to register a Profile en(de)coder first
	g.gen_json_for_type(value_type)
	mut s := ''
	if is_js_prim(styp) {
		s = '$styp val = ${fn_name}(jsval); '
	} else {
		s = '\t$styp val = *($styp*) ${fn_name}(jsval).data; '
	}
	return '
res = __new_array(0, 0, sizeof($styp));
const cJSON *jsval = NULL;
cJSON_ArrayForEach(jsval, root)
{
$s
  array_push(&res, &val);
}
'
}

fn (mut g Gen) encode_array(value_type table.Type) string {
	styp := g.typ(value_type)
	fn_name := js_enc_name(styp)
	return '
o = cJSON_CreateArray();
for (int i = 0; i < val.len; i++){
  cJSON_AddItemToArray(o, $fn_name (  (($styp*)val.data)[i]  ));
}
'
}
module gen

import v.pref
import v.util

fn (g &Gen) generate_hotcode_reloading_declarations() {
	if g.pref.os == .windows {
		if g.pref.is_livemain {
			g.hotcode_definitions.writeln('HANDLE live_fn_mutex = 0;')
		}
		if g.pref.is_liveshared {
			g.hotcode_definitions.writeln('HANDLE live_fn_mutex;')
		}
		g.hotcode_definitions.writeln('
void pthread_mutex_lock(HANDLE *m) {
	WaitForSingleObject(*m, INFINITE);
}
void pthread_mutex_unlock(HANDLE *m) {
	ReleaseMutex(*m);
}
')
	} else {
		if g.pref.is_livemain {
			g.hotcode_definitions.writeln('pthread_mutex_t live_fn_mutex = PTHREAD_MUTEX_INITIALIZER;')
		}
		if g.pref.is_liveshared {
			g.hotcode_definitions.writeln('pthread_mutex_t live_fn_mutex;')
		}
	}
}

fn (g &Gen) generate_hotcode_reloader_code() {
	if g.pref.is_liveshared {
		g.hotcode_definitions.writeln('')
		return
	}
	// Hot code reloading
	if g.pref.is_livemain {
		mut phd := ''
		mut load_code := []string{}
		if g.pref.os != .windows {
			for so_fn in g.hotcode_fn_names {
				load_code << 'impl_live_${so_fn} = dlsym(live_lib, "impl_live_${so_fn}");'
			}
			phd = posix_hotcode_definitions_1
		} else {
			for so_fn in g.hotcode_fn_names {
				load_code << 'impl_live_${so_fn} = (void *)GetProcAddress(live_lib, "impl_live_${so_fn}");  '
			}
			phd = windows_hotcode_definitions_1
		}
		g.hotcode_definitions.writeln(phd.replace('@LOAD_FNS@', load_code.join('\n')))
	}
}

const (
	posix_hotcode_definitions_1 = '
void v_bind_live_symbols(void* live_lib){
    @LOAD_FNS@
}
'
	windows_hotcode_definitions_1 = '
void v_bind_live_symbols(void* live_lib){
    @LOAD_FNS@
}
'
)

fn (g &Gen) generate_hotcode_reloading_main_caller() {
	if !g.pref.is_livemain {
		return
	}
	g.writeln('')
	// We are in live code reload mode, so start the .so loader in the background
	g.writeln('\t// live code initialization section:')
	g.writeln('\t{')
	g.writeln('\t\t// initialization of live function pointers')
	for fname in g.hotcode_fn_names {
		g.writeln('\t\timpl_live_${fname} = 0;')
	}
	vexe := util.cescaped_path( pref.vexe_path() )
	file := util.cescaped_path( g.pref.path )
	msvc := if g.pref.ccompiler == 'msvc' { '-cc msvc' } else { '' }
	so_debug_flag := if g.pref.is_debug { '-cg' } else { '' }
	vopts := '$msvc $so_debug_flag -keepc -sharedlive -shared'
	//
	g.writeln('\t\t// start background reloading thread')
	if g.pref.os == .windows {
		g.writeln('\t\tlive_fn_mutex = CreateMutexA(0, 0, 0);')
	}
	g.writeln('\t\tlive__LiveReloadInfo* live_info = live__executable__new_live_reload_info(')
	g.writeln('\t\t\t\t\t tos2("$file"),')
	g.writeln('\t\t\t\t\t tos2("$vexe"),')
	g.writeln('\t\t\t\t\t tos2("$vopts"),')
	g.writeln('\t\t\t\t\t &live_fn_mutex,')
	g.writeln('\t\t\t\t\t v_bind_live_symbols')
	g.writeln('\t\t);')
	// g_live_info gives access to the LiveReloadInfo methods,
	// to the custom user code, through calling v_live_info()
	g.writeln('\t\t   g_live_info = (void*)live_info;')
	g.writeln('\t\tlive__executable__start_reloader(live_info);')
	g.writeln('\t}\t// end of live code initialization section')
	g.writeln('')
}
module gen

pub struct ProfileCounterMeta{
	fn_name string
	vpc_name string
	vpc_calls string
}

fn (mut g Gen) profile_fn(fn_name string, is_main bool){
	if is_main {
		g.writeln('')
		g.writeln('\tatexit(vprint_profile_stats);')
		g.writeln('')
	}
	if g.pref.profile_no_inline && g.attr == 'inline' {
		g.defer_profile_code = ''
		return        
	}
	if fn_name.starts_with('time.vpc_now') {
		g.defer_profile_code = ''
	} else {
		measure_fn_name := if g.pref.os == .mac { 'time__vpc_now_darwin' } else { 'time__vpc_now' }
		fn_profile_counter_name := 'vpc_${g.last_fn_c_name}'
		fn_profile_counter_name_calls := '${fn_profile_counter_name}_calls'
		g.writeln('')
		g.writeln('\tdouble _PROF_FN_START = ${measure_fn_name}(); ${fn_profile_counter_name_calls}++; // $fn_name')
		g.writeln('')
		g.defer_profile_code = '\t${fn_profile_counter_name} += ${measure_fn_name}() - _PROF_FN_START;'
		g.pcs_declarations.writeln('double ${fn_profile_counter_name} = 0.0; u64 ${fn_profile_counter_name_calls} = 0;')
		g.pcs << ProfileCounterMeta{ g.last_fn_c_name, fn_profile_counter_name, fn_profile_counter_name_calls }
	}
}

pub fn (mut g Gen) gen_vprint_profile_stats() {
	g.pcs_declarations.writeln('void vprint_profile_stats(){')
	fstring := '"%14llu %14.3fms %14.0fns %s \\n"'
	if g.pref.profile_file == '-' {
		for pc_meta in g.pcs {
			g.pcs_declarations.writeln('\tif (${pc_meta.vpc_calls}) printf($fstring, ${pc_meta.vpc_calls}, ${pc_meta.vpc_name}/1000000.0, ${pc_meta.vpc_name}/${pc_meta.vpc_calls}, "${pc_meta.fn_name}" );')
		}
	} else {
		g.pcs_declarations.writeln('\tFILE * fp;')
		g.pcs_declarations.writeln('\tfp = fopen ("${g.pref.profile_file}", "w+");')
		for pc_meta in g.pcs {
			g.pcs_declarations.writeln('\tif (${pc_meta.vpc_calls}) fprintf(fp, $fstring, ${pc_meta.vpc_calls}, ${pc_meta.vpc_name}/1000000.0, ${pc_meta.vpc_name}/${pc_meta.vpc_calls}, "${pc_meta.fn_name}" );')
		}
		g.pcs_declarations.writeln('\tfclose(fp);')
	}
	g.pcs_declarations.writeln('}')
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module gen

fn (mut g Gen) write_str_fn_definitions() {
	// _STR function can't be defined in vlib
	g.writeln("
void _STR_PRINT_ARG(const char *fmt, char** refbufp, int *nbytes, int *memsize, int guess, ...) {
	va_list args;
	va_start(args, guess);
	// NB: (*memsize - *nbytes) === how much free space is left at the end of the current buffer refbufp
	// *memsize === total length of the buffer refbufp
	// *nbytes === already occupied bytes of buffer refbufp
	// guess === how many bytes were taken during the current vsnprintf run
	for(;;) {
		if (guess < *memsize - *nbytes) {
			guess = vsnprintf(*refbufp + *nbytes, *memsize - *nbytes, fmt, args);
			if (guess < *memsize - *nbytes) { // result did fit into buffer
				*nbytes += guess;
				return;
			}
		}
		// increase buffer (somewhat exponentially)
		*memsize += (*memsize + *memsize) / 3 + guess;
		*refbufp = (char*)realloc((void*)*refbufp, *memsize);
	}
}

string _STR(const char *fmt, int nfmts, ...) {
	va_list argptr;
	int memsize = 128;
	int nbytes = 0;
	char* buf = (char*)malloc(memsize);
	va_start(argptr, nfmts);
	for (int i=0; i<nfmts; i++) {
		int k = strlen(fmt);
		bool is_fspec = false;
		for (int j=0; j<k; j++) {
			if (fmt[j] == '%') {
				j++;
				if (fmt[j] != '%') {
					is_fspec = true;
					break;
				}
			}
		}
		if (is_fspec) {
			char f = fmt[k-1];
			char fup = f & 0xdf; // toupper
			bool l = fmt[k-2] == 'l';
			bool ll = l && fmt[k-3] == 'l';
			if (f == 'u' || fup == 'X' || f == 'o' || f == 'd' || f == 'c') { // int...
				if (ll) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+16, va_arg(argptr, long long));
				else if (l) _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, long));
				else _STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+8, va_arg(argptr, int));
			} else if (fup >= 'E' && fup <= 'G') { // floating point
				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+10, va_arg(argptr, double));
			} else if (f == 'p') {
				_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+14, va_arg(argptr, void*));
			} else if (f == 's') { // v string
				string s = va_arg(argptr, string);
				if (fmt[k-4] == '*') { // %*.*s
					int fwidth = va_arg(argptr, int);
					if (fwidth < 0)
						fwidth -= (s.len - utf8_str_visible_length(s));
					else
						fwidth += (s.len - utf8_str_visible_length(s));
					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, fwidth, s.len, s.str);
				} else { // %.*s
					_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k+s.len-4, s.len, s.str);
				}
			} else {
				//v_panic(tos3('Invaid format specifier'));
			}
		} else {
			_STR_PRINT_ARG(fmt, &buf, &nbytes, &memsize, k);
		}
		fmt += k+1;
	}
	va_end(argptr);
	buf[nbytes] = 0;
	buf = (char*)realloc((void*)buf, nbytes+1);
#ifdef DEBUG_ALLOC
	//puts('_STR:');
	puts(buf);
#endif
	return tos2((byteptr)buf);
}

string _STR_TMP(const char *fmt, ...) {
	va_list argptr;
	va_start(argptr, fmt);
	size_t len = vsnprintf(0, 0, fmt, argptr) + 1;
	va_end(argptr);
	va_start(argptr, fmt);
	vsprintf((char *)g_str_buf, fmt, argptr);
	va_end(argptr);
#ifdef DEBUG_ALLOC
	//puts('_STR_TMP:');
	//puts(g_str_buf);
#endif
	string res = tos(g_str_buf,  len);
	res.is_lit = true;
	return res;
} // endof _STR_TMP

")
}
module js

import strings
import v.ast
import v.table
import v.pref
import v.util
import v.depgraph

const (
	// https://ecma-international.org/ecma-262/#sec-reserved-words
	js_reserved = ['await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger',
		'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'finally', 'for', 'function',
		'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'new', 'package', 'private',
		'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'try', 'typeof',
		'var', 'void', 'while', 'with', 'yield']
	tabs = ['', '\t', '\t\t', '\t\t\t', '\t\t\t\t', '\t\t\t\t\t', '\t\t\t\t\t\t', '\t\t\t\t\t\t\t', '\t\t\t\t\t\t\t\t']
	builtin_globals = ['println', 'print']
	type_values = {

	}
)

struct JsGen {
	table             &table.Table
	definitions       strings.Builder
	pref              &pref.Preferences
mut:
	out               strings.Builder
	namespaces        map[string]strings.Builder
	namespaces_pub    map[string][]string
	namespace_imports map[string]map[string]string
	namespace         string
	doc               &JsDoc
	enable_doc        bool
	constants         strings.Builder // all global V constants
	file              ast.File
	tmp_count         int
	inside_ternary    bool
	inside_loop       bool
	is_test           bool
	indents           map[string]int // indentations mapped to namespaces
	stmt_start_pos    int
	defer_stmts       []ast.DeferStmt
	fn_decl           &ast.FnDecl // pointer to the FnDecl we are currently inside otherwise 0
	str_types         []string // types that need automatic str() generation
	method_fn_decls   map[string][]ast.Stmt
	empty_line        bool
}

pub fn gen(files []ast.File, table &table.Table, pref &pref.Preferences) string {
	mut g := &JsGen{
		out: strings.new_builder(100)
		definitions: strings.new_builder(100)
		constants: strings.new_builder(100)
		table: table
		pref: pref
		fn_decl: 0
		empty_line: true
		doc: 0
		enable_doc: true
	}
	g.doc = new_jsdoc(g)
	// TODO: Add '[-no]-jsdoc' flag
	if pref.is_prod {
		g.enable_doc = false
	}
	g.init()

	mut graph := depgraph.new_dep_graph()

	// Get class methods
	for file in files {
		g.file = file
		g.enter_namespace(g.file.mod.name)
		g.is_test = g.file.path.ends_with('_test.v')
		g.find_class_methods(file.stmts)
		g.escape_namespace()
	}

	for file in files {
		g.file = file
		g.enter_namespace(g.file.mod.name)
		g.is_test = g.file.path.ends_with('_test.v')

		// store imports
		mut imports := []string{}
		for imp in g.file.imports {
			imports << imp.mod
		}
		graph.add(g.file.mod.name, imports)

		g.stmts(file.stmts)
		// store the current namespace
		g.escape_namespace()
	}

	// resolve imports
	deps_resolved := graph.resolve()

	g.finish()
	mut out := g.hashes() + g.definitions.str() + g.constants.str()
	for node in deps_resolved.nodes {
		out += g.doc.gen_namespace(node.name)
		out += 'const $node.name = (function ('
		imports := g.namespace_imports[node.name]
		for i, key in imports.keys() {
			if i > 0 { out += ', ' }
			out += imports[key]
		}
		out += ') {\n\t'
		// private scope
		out += g.namespaces[node.name].str().trim_space()
		// public scope
		out += '\n\n\t/* module exports */'
		out += '\n\treturn {'
		for pub_var in g.namespaces_pub[node.name] {
			out += '\n\t\t$pub_var,'
		}
		if g.namespaces_pub[node.name].len > 0 { out += '\n\t' }
		out += '};'
		out += '\n})('
		for i, key in imports.keys() {
			if i > 0 { out += ', ' }
			out += key
		}
		out += ');\n\n'
	}
	return out
}

pub fn (mut g JsGen) enter_namespace(n string) {
	g.namespace = n
	if g.namespaces[g.namespace].len == 0 {
		// create a new namespace
		g.out = strings.new_builder(100)
		g.indents[g.namespace] = 0
	} else {
		g.out = g.namespaces[g.namespace]
	}
}

pub fn (mut g JsGen) escape_namespace() {
	g.namespaces[g.namespace] = g.out
	g.namespace = ''
}

pub fn (mut g JsGen) push_pub_var(s string) {
	mut arr := g.namespaces_pub[g.namespace]
	arr << g.js_name(s)
	g.namespaces_pub[g.namespace] = arr
}

pub fn (mut g JsGen) find_class_methods(stmts []ast.Stmt) {
	for stmt in stmts {
		match stmt {
			ast.FnDecl {
				if it.is_method {
					// Found struct method, store it to be generated along with the class.
					class_name := g.table.get_type_name(it.receiver.typ)
					// Workaround until `map[key] << val` works.
					mut arr := g.method_fn_decls[class_name]
					arr << stmt
					g.method_fn_decls[class_name] = arr
				}
			}
			else {}
		}
	}
}

pub fn (mut g JsGen) init() {
	g.definitions.writeln('// Generated by the V compiler\n')
	g.definitions.writeln('"use strict";')
	g.definitions.writeln('')
}

pub fn (mut g JsGen) finish() {
	if g.constants.len > 0 {
		constants := g.constants.str()
		g.constants = strings.new_builder(100)
		g.constants.writeln('const _CONSTS = Object.freeze({')
		g.constants.write(constants)
		g.constants.writeln('});')
		g.constants.writeln('')
	}
}

pub fn (g JsGen) hashes() string {
	mut res := '// V_COMMIT_HASH ${util.vhash()}\n'
	res += '// V_CURRENT_COMMIT_HASH ${util.githash(g.pref.building_v)}\n'
	return res
}

// V type to JS type
pub fn (mut g JsGen) typ(t table.Type) string {
	sym := g.table.get_type_symbol(t)
	mut styp := sym.name
	if styp.starts_with('JS.') {
		styp = styp[3..]
	}
	// 'multi_return_int_int' => '[number, number]'
	if styp.starts_with('multi_return_') {
		tokens := styp.replace('multi_return_', '').split('_')
		return '[' + tokens.map(g.to_js_typ(it)).join(', ') + ']'
	}
	// 'anon_fn_7_7_1' => '(a number, b number) => void'
	if styp.starts_with('anon_') {
		info := sym.info as table.FnType
		mut res := '('
		for i, arg in info.func.args {
			res += '$arg.name: ${g.typ(arg.typ)}'
			if i < info.func.args.len - 1 { res += ', ' }
		}
		return res + ') => ' + g.typ(info.func.return_type)
	}
	// Struct instance => ns["class"]["prototype"]
	if sym.kind == .struct_ && get_ns(styp).len > 0 {
		return g.to_js_typ(g.get_alias(styp)) + '["prototype"]'
	}
	return g.to_js_typ(styp)
}

fn (mut g JsGen) to_js_typ(typ string) string {
	mut styp := ''
	match typ {
		'int' {
			styp = 'number'
		}
		'bool' {
			styp = 'boolean'
		}
		'voidptr' {
			styp = 'Object'
		}
		'byteptr' {
			styp = 'string'
		}
		'charptr' {
			styp = 'string'
		}
		else {
			if typ.starts_with('array_') {
				styp = g.to_js_typ(typ.replace('array_', '')) + '[]'
			} else if typ.starts_with('map_') {
				tokens := typ.split('_')
				styp = 'Map<${g.to_js_typ(tokens[1])}, ${g.to_js_typ(tokens[2])}>'
			} else {
				styp = typ
			}
		}
	}
	// ns.export => ns["export"]
	for i, v in styp.split('.') {
		if i == 0 {
			styp = v
			continue
		}
		styp += '["$v"]'
	}
	return styp
}

fn (mut g JsGen) to_js_typ_val(typ string) string {
	mut styp := ''
	match typ {
		'number' {
			styp = '0'
		}
		'boolean' {
			styp = 'false'
		}
		'Object' {
			styp = '{}'
		}
		'string' {
			styp = '""'
		}
		else {
			if typ.starts_with('Map') {
				styp = 'new Map()'
			} else if typ.ends_with('[]') {
				styp = '[]'
			} else {
				styp = '{}'
			}
		}
	}
	// ns.export => ns["export"]
	for i, v in styp.split('.') {
		if i == 0 {
			styp = v
			continue
		}
		styp += '["$v"]'
	}
	return styp
}

pub fn (g &JsGen) save() {}

pub fn (mut g JsGen) gen_indent() {
	if g.indents[g.namespace] > 0 && g.empty_line {
		g.out.write(tabs[g.indents[g.namespace]])
	}
	g.empty_line = false
}

pub fn (mut g JsGen) inc_indent() {
	g.indents[g.namespace]++
}

pub fn (mut g JsGen) dec_indent() {
	g.indents[g.namespace]--
}

pub fn (mut g JsGen) write(s string) {
	g.gen_indent()
	g.out.write(s)
}

pub fn (mut g JsGen) writeln(s string) {
	g.gen_indent()
	g.out.writeln(s)
	g.empty_line = true
}

pub fn (mut g JsGen) new_tmp_var() string {
	g.tmp_count++
	return '_tmp$g.tmp_count'
}

// 'mod1.mod2.fn' => 'mod1.mod2'
// 'fn' => ''
[inline]
fn get_ns(s string) string {
	parts := s.split('.')
	mut res := ''
	for i, p in parts {
		if i == parts.len - 1 { break } // Last part (fn/struct/var name): skip
		res += p
		if i < parts.len - 2 { res += '.' } // Avoid trailing dot
	}
	return res
}

fn (mut g JsGen) get_alias(name string) string {
	// TODO: This is a hack; find a better way to do this
	split := name.split('.')
	if split.len > 1 {
		imports := g.namespace_imports[g.namespace]
		alias := imports[split[0]]

		if alias != '' {
			return alias + '.' + split[1..].join('.')
		}
	}
	return name // No dot == no alias
}

fn (mut g JsGen) js_name(name_ string) string {
	ns := get_ns(name_)
	mut name := if ns == g.namespace { name_.split('.').last() } else { g.get_alias(name_) }
	mut parts := name.split('.')
	for i, p in parts {
		if p in js_reserved { parts[i] = 'v_$p' }
	}
	return parts.join('.')
}

fn (mut g JsGen) stmts(stmts []ast.Stmt) {
	g.inc_indent()
	for stmt in stmts {
		g.stmt(stmt)
	}
	g.dec_indent()
}

fn (mut g JsGen) stmt(node ast.Stmt) {
	g.stmt_start_pos = g.out.len

	match node {
		ast.AssertStmt {
			g.gen_assert_stmt(it)
		}
		ast.AssignStmt {
			g.gen_assign_stmt(it)
		}
		ast.Attr {
			g.gen_attr(it)
		}
		ast.Block {
			g.gen_block(it)
			g.writeln('')
		}
		ast.BranchStmt {
			g.gen_branch_stmt(it)
		}
		ast.Comment {
			// Skip: don't generate comments
		}
		ast.CompIf {
			// skip: JS has no compile time if
		}
		ast.ComptimeCall {
			// TODO
		}
		ast.ConstDecl {
			g.gen_const_decl(it)
		}
		ast.DeferStmt {
			g.defer_stmts << *it
		}
		ast.EnumDecl {
			g.gen_enum_decl(it)
			g.writeln('')
		}
		ast.ExprStmt {
			g.gen_expr_stmt(it)
		}
		ast.FnDecl {
			g.fn_decl = it
			g.gen_fn_decl(it)
			g.writeln('')
		}
		ast.ForCStmt {
			g.gen_for_c_stmt(it)
			g.writeln('')
		}
		ast.ForInStmt {
			g.gen_for_in_stmt(it)
			g.writeln('')
		}
		ast.ForStmt {
			g.gen_for_stmt(it)
			g.writeln('')
		}
		ast.GlobalDecl {
			// TODO
		}
		ast.GoStmt {
			g.gen_go_stmt(it)
			g.writeln('')
		}
		ast.GotoLabel {
			g.writeln('${g.js_name(it.name)}:')
		}
		ast.GotoStmt {
			// skip: JS has no goto
		}
		ast.HashStmt {
			// skip: nothing with # in JS
		}
		ast.Import {
			g.gen_import_stmt(it)
		}
		ast.InterfaceDecl {
			// TODO skip: interfaces not implemented yet
		}
		ast.Module {
			// skip: namespacing implemented externally
		}
		ast.Return {
			if g.defer_stmts.len > 0 {
				g.gen_defer_stmts()
			}
			g.gen_return_stmt(it)
		}
		ast.StructDecl {
			g.gen_struct_decl(it)
		}
		ast.TypeDecl {
			// skip JS has no typedecl
		}
		ast.UnsafeStmt {
			g.stmts(it.stmts)
		}
		/*
		else {
			verror('jsgen.stmt(): bad node ${typeof(node)}')
		}
		*/
	}
}

fn (mut g JsGen) expr(node ast.Expr) {
	match node {
		ast.AnonFn {
			g.gen_fn_decl(it.decl)
		}
		ast.ArrayInit {
			g.gen_array_init_expr(it)
		}
		ast.AsCast {
			// skip: JS has no types, so no need to cast
			// TODO: Is jsdoc needed here for TS support?
		}
		ast.AssignExpr {
			g.gen_assign_expr(it)
		}
		ast.Assoc {
			// TODO
		}
		ast.BoolLiteral {
			if it.val == true {
				g.write('true')
			} else {
				g.write('false')
			}
		}
		ast.CallExpr {
			g.gen_call_expr(it)
		}
		ast.CastExpr {
			// skip: JS has no types, so no need to cast
			// TODO: Check if jsdoc is needed for TS support
		}
		ast.CharLiteral {
			g.write("'$it.val'")
		}
		ast.ConcatExpr {
			// TODO
		}
		ast.EnumVal {
			styp := g.typ(it.typ)
			g.write('${styp}.${it.val}')
		}
		ast.FloatLiteral {
			g.write(it.val)
		}
		ast.Ident {
			g.gen_ident(it)
		}
		ast.IfExpr {
			g.gen_if_expr(it)
		}
		ast.IfGuardExpr {
			// TODO no optionals yet
		}
		ast.IndexExpr {
			g.gen_index_expr(it)
		}
		ast.InfixExpr {
			g.gen_infix_expr(it)
		}
		ast.IntegerLiteral {
			g.write(it.val)
		}
		ast.MapInit {
			g.gen_map_init_expr(it)
		}
		ast.MatchExpr {
			// TODO
		}
		ast.None {
			// TODO
		}
		ast.OrExpr {
			// TODO
		}
		ast.ParExpr {
			// TODO
		}
		ast.PostfixExpr {
			g.expr(it.expr)
			g.write(it.op.str())
		}
		ast.PrefixExpr {
			// TODO
		}
		ast.RangeExpr {
			// Only used in IndexExpr, requires index type info
		}
		ast.SelectorExpr {
			g.gen_selector_expr(it)
		}
		ast.SizeOf {
			// TODO
		}
		ast.StringInterLiteral {
			g.gen_string_inter_literal(it)
		}
		ast.StringLiteral {
			g.write('"$it.val"')
		}
		ast.StructInit {
			// `user := User{name: 'Bob'}`
			g.gen_struct_init(it)
		}
		ast.Type {
			// skip: JS has no types
			// TODO maybe?
		}
		ast.TypeOf {
			g.gen_typeof_expr(it)
			// TODO: Should this print the V type or the JS type?
		}
		/*
		else {
			println(term.red('jsgen.expr(): unhandled node "${typeof(node)}"'))
		}
		*/
	}
}


// TODO
fn (mut g JsGen) gen_assert_stmt(a ast.AssertStmt) {
	g.writeln('// assert')
	g.write('if( ')
	g.expr(a.expr)
	g.write(' ) {')
	s_assertion := a.expr.str().replace('"', "\'")
	mut mod_path := g.file.path
	if g.is_test {
		g.writeln('	g_test_oks++;')
		g.writeln('	cb_assertion_ok("${mod_path}", ${a.pos.line_nr+1}, "assert ${s_assertion}", "${g.fn_decl.name}()" );')
		g.writeln('} else {')
		g.writeln('	g_test_fails++;')
		g.writeln('	cb_assertion_failed("${mod_path}", ${a.pos.line_nr+1}, "assert ${s_assertion}", "${g.fn_decl.name}()" );')
		g.writeln('	exit(1);')
		g.writeln('}')
		return
	}
	g.writeln('} else {')
	g.writeln('	eprintln("${mod_path}:${a.pos.line_nr+1}: FAIL: fn ${g.fn_decl.name}(): assert $s_assertion");')
	g.writeln('	exit(1);')
	g.writeln('}')
}

fn (mut g JsGen) gen_assign_stmt(it ast.AssignStmt) {
	if it.left.len > it.right.len {
		// multi return
		jsdoc := strings.new_builder(50)
		jsdoc.write('[')
		stmt := strings.new_builder(50)
		stmt.write('const [')
		for i, ident in it.left {
			ident_var_info := ident.var_info()
			styp := g.typ(ident_var_info.typ)
			jsdoc.write(styp)

			stmt.write(g.js_name(ident.name))

			if i < it.left.len - 1 {
				jsdoc.write(', ')
				stmt.write(', ')
			}
		}
		jsdoc.write(']')
		stmt.write('] = ')
		g.writeln(g.doc.gen_typ(jsdoc.str(), ''))
		g.write(stmt.str())
		g.expr(it.right[0])
		g.writeln(';')
	} else {
		// `a := 1` | `a,b := 1,2`
		for i, ident in it.left {
			val := it.right[i]
			ident_var_info := ident.var_info()
			mut styp := g.typ(ident_var_info.typ)

			if val is ast.EnumVal {
				// we want the type of the enum value not the enum
				styp = 'number'
			} else if val is ast.StructInit {
				// no need to print jsdoc for structs
				styp = ''
			}

			if !g.inside_loop && styp.len > 0 {
				g.writeln(g.doc.gen_typ(styp, ident.name))
			}

			if g.inside_loop || ident.is_mut {
				g.write('let ')
			} else {
				g.write('const ')
			}

			g.write('${g.js_name(ident.name)} = ')
			g.expr(val)

			if g.inside_loop {
				g.write('; ')
			} else {
				g.writeln(';')
			}
		}
	}
}

fn (mut g JsGen) gen_attr(it ast.Attr) {
	g.writeln('/* [$it.name] */')
}

fn (mut g JsGen) gen_block(it ast.Block) {
	g.writeln('{')
	g.stmts(it.stmts)
	g.writeln('}')
}

fn (mut g JsGen) gen_branch_stmt(it ast.BranchStmt) {
	// continue or break
	g.write(it.tok.kind.str())
	g.writeln(';')
}

fn (mut g JsGen) gen_const_decl(it ast.ConstDecl) {
	// old_indent := g.indents[g.namespace]
	for i, field in it.fields {
		// TODO hack. Cut the generated value and paste it into definitions.
		pos := g.out.len
		g.expr(field.expr)
		val := g.out.after(pos)
		g.out.go_back(val.len)
		if g.enable_doc {
			typ := g.typ(field.typ)
			g.constants.write('\t')
			g.constants.writeln(g.doc.gen_typ(typ, field.name))
		}
		g.constants.write('\t')
		g.constants.write('${g.js_name(field.name)}: $val')
		if i < it.fields.len - 1 {
			g.constants.writeln(',')
		}
	}
	g.constants.writeln('')
}

fn (mut g JsGen) gen_defer_stmts() {
	g.writeln('(function defer() {')
	for defer_stmt in g.defer_stmts {
		g.stmts(defer_stmt.stmts)
	}
	g.defer_stmts = []
	g.writeln('})();')
}

fn (mut g JsGen) gen_enum_decl(it ast.EnumDecl) {
	g.writeln('const ${g.js_name(it.name)} = Object.freeze({')
	g.inc_indent()
	for i, field in it.fields {
		g.write('$field.name: ')
		if field.has_expr {
			pos := g.out.len
			g.expr(field.expr)
			expr_str := g.out.after(pos)
			g.out.go_back(expr_str.len)
			g.write('$expr_str')
		} else {
			g.write('$i')
		}
		g.writeln(',')
	}
	g.dec_indent()
	g.writeln('});')
	if it.is_pub {
		g.push_pub_var(it.name)
	}
}

fn (mut g JsGen) gen_expr_stmt(it ast.ExprStmt) {
	g.expr(it.expr)
	expr := it.expr
	if expr is ast.IfExpr { } // no ; after an if expression
	else if !g.inside_ternary { g.writeln(';') }
}

fn (mut g JsGen) gen_fn_decl(it ast.FnDecl) {
	if it.is_method {
		// Struct methods are handled by class generation code.
		return
	}
	if it.no_body {
		return
	}
	g.gen_method_decl(it)
}

fn fn_has_go(it ast.FnDecl) bool {
	mut has_go := false
	for stmt in it.stmts {
		if stmt is ast.GoStmt { has_go = true }
	}
	return has_go
}

fn (mut g JsGen) gen_method_decl(it ast.FnDecl) {
	g.fn_decl = &it
	has_go := fn_has_go(it)
	is_main := it.name == 'main'
	if is_main {
		// there is no concept of main in JS but we do have iife
		g.writeln('/* program entry point */')
		g.write('(')
		if has_go {
			g.write('async ')
		}
		g.write('function(')
	} else if it.is_anon {
		g.write('function (')
	} else {
		mut name := g.js_name(it.name)
		c := name[0]
		if c in [`+`, `-`, `*`, `/`] {
			name = util.replace_op(name)
		}

		// type_name := g.typ(it.return_type)

		// generate jsdoc for the function
		g.writeln(g.doc.gen_fn(it))

		if has_go {
			g.write('async ')
		}
		if !it.is_method {
			g.write('function ')
		}
		g.write('${name}(')

		if it.is_pub && !it.is_method {
			g.push_pub_var(name)
		}
	}

	mut args := it.args
	if it.is_method {
		args = args[1..]
	}
	g.fn_args(args, it.is_variadic)
	g.writeln(') {')

	if it.is_method {
		g.inc_indent()
		g.writeln('const ${it.args[0].name} = this;')
		g.dec_indent()
	}

	g.stmts(it.stmts)
	g.write('}')
	if is_main {
		g.write(')();')
	}
	if !it.is_anon && !it.is_method {
		g.writeln('')
	}

	g.fn_decl = 0
}

fn (mut g JsGen) fn_args(args []table.Arg, is_variadic bool) {
	// no_names := args.len > 0 && args[0].name == 'arg_1'
	for i, arg in args {
		name := g.js_name(arg.name)
		is_varg := i == args.len - 1 && is_variadic
		if is_varg {
			g.write('...$name')
		} else {
			g.write(name)
		}
		// if its not the last argument
		if i < args.len - 1 {
			g.write(', ')
		}
	}
}

fn (mut g JsGen) gen_for_c_stmt(it ast.ForCStmt) {
	g.inside_loop = true
	g.write('for (')
	if it.has_init {
		g.stmt(it.init)
	} else {
		g.write('; ')
	}
	if it.has_cond {
		g.expr(it.cond)
	}
	g.write('; ')
	if it.has_inc {
		g.expr(it.inc)
	}
	g.writeln(') {')
	g.stmts(it.stmts)
	g.writeln('}')
	g.inside_loop = false
}

fn (mut g JsGen) gen_for_in_stmt(it ast.ForInStmt) {
	if it.is_range {
		// `for x in 1..10 {`
		i := it.val_var
		g.inside_loop = true
		g.write('for (let $i = ')
		g.expr(it.cond)
		g.write('; $i < ')
		g.expr(it.high)
		g.writeln('; ++$i) {')
		g.inside_loop = false
		g.stmts(it.stmts)
		g.writeln('}')
	} else if it.kind == .array || it.cond_type.flag_is(.variadic) {
		// `for num in nums {`
		i := if it.key_var == '' { g.new_tmp_var() } else { it.key_var }
		// styp := g.typ(it.val_type)
		g.inside_loop = true
		g.write('for (let $i = 0; $i < ')
		g.expr(it.cond)
		g.writeln('.length; ++$i) {')
		g.inside_loop = false
		g.write('\tlet $it.val_var = ')
		g.expr(it.cond)
		g.writeln('[$i];')
		g.stmts(it.stmts)
		g.writeln('}')
	} else if it.kind == .map {
		// `for key, val in map[string]int {`
		// key_styp := g.typ(it.key_type)
		// val_styp := g.typ(it.val_type)
		key := if it.key_var == '' { g.new_tmp_var() } else { it.key_var }
		g.write('for (let [$key, $it.val_var] of ')
		g.expr(it.cond)
		g.writeln(') {')
		g.stmts(it.stmts)
		g.writeln('}')
	} else if it.kind == .string {
		// `for x in 'hello' {`
		i := if it.key_var == '' { g.new_tmp_var() } else { it.key_var }
		g.inside_loop = true
		g.write('for (let $i = 0; $i < ')
		g.expr(it.cond)
		g.writeln('.length; ++$i) {')
		g.inside_loop = false
		g.write('\tlet $it.val_var = ')
		g.expr(it.cond)
		g.writeln('[$i];')
		g.stmts(it.stmts)
		g.writeln('}')
	}
}

fn (mut g JsGen) gen_for_stmt(it ast.ForStmt) {
	g.write('while (')
	if it.is_inf {
		g.write('true')
	} else {
		g.expr(it.cond)
	}
	g.writeln(') {')
	g.stmts(it.stmts)
	g.writeln('}')
}

fn (mut g JsGen) gen_go_stmt(node ast.GoStmt) {
	// x := node.call_expr as ast.CallEpxr // TODO
	match node.call_expr {
		ast.CallExpr {
			mut name := it.name
			if it.is_method {
				receiver_sym := g.table.get_type_symbol(it.receiver_type)
				name = receiver_sym.name + '.' + name
			}
			g.writeln('await new Promise(function(resolve){')
			g.inc_indent()
			g.write('${name}(')
			for i, arg in it.args {
				g.expr(arg.expr)
				if i < it.args.len - 1 {
					g.write(', ')
				}
			}
			g.writeln(');')
			g.writeln('resolve();')
			g.dec_indent()
			g.writeln('});')
		}
		else {}
	}
}

fn (mut g JsGen) gen_import_stmt(it ast.Import) {
	mut imports := g.namespace_imports[g.namespace]
	imports[it.mod] = it.alias
	g.namespace_imports[g.namespace] = imports
}

fn (mut g JsGen) gen_return_stmt(it ast.Return) {
	if it.exprs.len == 0 {
		// Returns nothing
		g.write('return;')
		return
	}

	g.write('return ')
	if it.exprs.len == 1 {
		g.expr(it.exprs[0])
	} else {
		// Multi return
		g.write('[')
		for i, expr in it.exprs {
			g.expr(expr)
			if i < it.exprs.len - 1 {
				g.write(', ')
			}
		}
		g.write(']')
	}
	g.writeln(';')
}

fn (mut g JsGen) gen_struct_decl(node ast.StructDecl) {
	g.writeln(g.doc.gen_fac_fn(node.fields))
	g.write('function ${g.js_name(node.name)}({ ')
	for i, field in node.fields {
		g.write('$field.name = ')
		if field.has_default_expr {
			g.expr(field.default_expr)
		} else {
			g.write('${g.to_js_typ_val(g.typ(field.typ))}')
		}
		if i < node.fields.len - 1 { g.write(', ') }
	}
	g.writeln(' }) {')
	g.inc_indent()
	for field in node.fields {
		g.writeln('this.$field.name = $field.name')
	}
	g.dec_indent()
	g.writeln('};')

	g.writeln('${g.js_name(node.name)}.prototype = {')
	g.inc_indent()

	fns := g.method_fn_decls[node.name]

	for i, field in node.fields {
		g.writeln(g.doc.gen_typ(g.typ(field.typ), field.name))
		g.write('$field.name: ${g.to_js_typ_val(g.typ(field.typ))}')
		if i < node.fields.len - 1 || fns.len > 0 { g.writeln(',') } else { g.writeln('') }
	}

	for i, cfn in fns {
		// TODO: Move cast to the entire array whenever it's possible
		it := cfn as ast.FnDecl
		g.gen_method_decl(it)
		if i < fns.len - 1 { g.writeln(',') } else { g.writeln('') }
	}
	g.dec_indent()
	g.writeln('};\n')
	if node.is_pub {
		g.push_pub_var(node.name)
	}
}

fn (mut g JsGen) gen_array_init_expr(it ast.ArrayInit) {
	type_sym := g.table.get_type_symbol(it.typ)
	if type_sym.kind != .array_fixed {
		g.write('[')
		for i, expr in it.exprs {
			g.expr(expr)
			if i < it.exprs.len - 1 {
				g.write(', ')
			}
		}
		g.write(']')
	} else {}
}

fn (mut g JsGen) gen_assign_expr(it ast.AssignExpr) {
	g.expr(it.left)
	g.write(' $it.op ')
	g.expr(it.val)
}

fn (mut g JsGen) gen_call_expr(it ast.CallExpr) {
	mut name := ''
	if it.name.starts_with('JS.') {
		name = it.name[3..]
	} else {
		name = g.js_name(it.name)
	}
	g.expr(it.left)
	if it.is_method {
		// example: foo.bar.baz()
		g.write('.')
	} else {
		if name in builtin_globals {
			g.write('builtin.')
		}
	}
	g.write('${g.js_name(name)}(')
	for i, arg in it.args {
		g.expr(arg.expr)
		if i != it.args.len - 1 {
			g.write(', ')
		}
	}
	g.write(')')
}

fn (mut g JsGen) gen_ident(node ast.Ident) {
	if node.kind == .constant {
		// TODO: Handle const namespacing: only consts in the main module are handled rn
		g.write('_CONSTS.')
	}

	name := g.js_name(node.name)
	// TODO `is`
	// TODO handle optionals
	g.write(name)
}

fn (mut g JsGen) gen_if_expr(node ast.IfExpr) {
	type_sym := g.table.get_type_symbol(node.typ)

	// one line ?:
	if node.is_expr && node.branches.len >= 2 && node.has_else && type_sym.kind != .void {
		// `x := if a > b {  } else if { } else { }`
		g.write('(')
		g.inside_ternary = true
		for i, branch in node.branches {
			if i > 0 {
				g.write(' : ')
			}
			if i < node.branches.len - 1 || !node.has_else {
				g.expr(branch.cond)
				g.write(' ? ')
			}
			g.stmts(branch.stmts)
		}
		g.inside_ternary = false
		g.write(')')
	} else {
		// mut is_guard = false
		for i, branch in node.branches {
			if i == 0 {
				match branch.cond {
					ast.IfGuardExpr {
						// TODO optionals
					}
					else {
						g.write('if (')
						g.expr(branch.cond)
						g.writeln(') {')
					}
				}
			} else if i < node.branches.len - 1 || !node.has_else {
				g.write('} else if (')
				g.expr(branch.cond)
				g.writeln(') {')
			} else if i == node.branches.len - 1 && node.has_else {
				/* if is_guard {
					//g.writeln('} if (!$guard_ok) { /* else */')
				} else { */
				g.writeln('} else {')
				// }
			}
			g.stmts(branch.stmts)
		}
		/* if is_guard {
			g.write('}')
		} */
		g.writeln('}')
		g.writeln('')
	}
}

fn (mut g JsGen) gen_index_expr(it ast.IndexExpr) {
	// TODO: Handle splice setting if it's implemented
	if it.index is ast.RangeExpr {
		range := it.index as ast.RangeExpr
		g.expr(it.left)
		g.write('.slice(')
		if range.has_low {
			g.expr(range.low)
		} else {
			g.write('0')
		}
		g.write(', ')
		if range.has_high {
			g.expr(range.high)
		} else {
			g.expr(it.left)
			g.write('.length')
		}
		g.write(')')
	} else {
		// TODO Does this work in all cases?
		g.expr(it.left)
		g.write('[')
		g.expr(it.index)
		g.write(']')
	}
}

fn (mut g JsGen) gen_infix_expr(it ast.InfixExpr) {
	g.expr(it.left)

	mut op := it.op.str()
	// in js == is non-strict & === is strict, always do strict
	if op == '==' { op = '===' }
	else if op == '!=' { op = '!==' }

	g.write(' $op ')
	g.expr(it.right)
}


fn (mut g JsGen) gen_map_init_expr(it ast.MapInit) {
	// key_typ_sym := g.table.get_type_symbol(it.key_type)
	// value_typ_sym := g.table.get_type_symbol(it.value_type)
	// key_typ_str := key_typ_sym.name.replace('.', '__')
	// value_typ_str := value_typ_sym.name.replace('.', '__')
	if it.vals.len > 0 {
		g.writeln('new Map([')
		g.inc_indent()
		for i, key in it.keys {
			val := it.vals[i]
			g.write('[')
			g.expr(key)
			g.write(', ')
			g.expr(val)
			g.write(']')
			if i < it.keys.len - 1 {
				g.write(',')
			}
			g.writeln('')
		}
		g.dec_indent()
		g.write('])')
	} else {
		g.write('new Map()')
	}
}

fn (mut g JsGen) gen_selector_expr(it ast.SelectorExpr) {
	g.expr(it.expr)
	g.write('.$it.field_name')
}

fn (mut g JsGen) gen_string_inter_literal(it ast.StringInterLiteral) {
	// TODO Implement `tos3`
	g.write('tos3(`')
	for i, val in it.vals {
		escaped_val := val.replace_each(['`', '\`', '\r\n', '\n'])
		g.write(escaped_val)
		if i >= it.exprs.len {
			continue
		}
		expr := it.exprs[i]
		sfmt := it.expr_fmts[i]
		g.write('\${')
		if sfmt.len > 0 {
			fspec := sfmt[sfmt.len - 1]
			if fspec == `s` && it.expr_types[i] == table.string_type {
				g.expr(expr)
				g.write('.str')
			} else {
				g.expr(expr)
			}
		} else if it.expr_types[i] == table.string_type {
			// `name.str`
			g.expr(expr)
			g.write('.str')
		} else if it.expr_types[i] == table.bool_type {
			// `expr ? "true" : "false"`
			g.expr(expr)
			g.write(' ? "true" : "false"')
		} else {
			sym := g.table.get_type_symbol(it.expr_types[i])

			match sym.kind {
				.struct_ {
					g.expr(expr)
					if sym.has_method('str') {
						g.write('.str()')
					}
				}
				else {
					g.expr(expr)
				}
			}
		}
		g.write('}')
	}
	g.write('`)')
}

fn (mut g JsGen) gen_struct_init(it ast.StructInit) {
	type_sym := g.table.get_type_symbol(it.typ)
	name := type_sym.name
	if it.fields.len == 0 {
		g.write('new ${g.js_name(name)}({})')
	} else {
		g.writeln('new ${g.js_name(name)}({')
		g.inc_indent()
		for i, field in it.fields {
			g.write('$field.name: ')
			g.expr(field.expr)
			if i < it.fields.len - 1 {
				g.write(',')
			}
			g.writeln('')
		}
		g.dec_indent()
		g.write('})')
	}
}

fn (mut g JsGen) gen_typeof_expr(it ast.TypeOf) {
	sym := g.table.get_type_symbol(it.expr_type)
	if sym.kind == .sum_type {
		// TODO: JS sumtypes not implemented yet
	} else if sym.kind == .array_fixed {
		fixed_info := sym.info as table.ArrayFixed
		typ_name := g.table.get_type_name(fixed_info.elem_type)
		g.write('"[$fixed_info.size]${typ_name}"')
	} else if sym.kind == .function {
		info := sym.info as table.FnType
		fn_info := info.func
		mut repr := 'fn ('
		for i, arg in fn_info.args {
			if i > 0 {
				repr += ', '
			}
			repr += g.table.get_type_name(arg.typ)
		}
		repr += ')'
		if fn_info.return_type != table.void_type {
			repr += ' ${g.table.get_type_name(fn_info.return_type)}'
		}
		g.write('"$repr"')
	} else {
		g.write('"${sym.name}"')
	}
}
module js

import strings
import v.ast

struct JsDoc {
	gen        &JsGen
mut:
	out        strings.Builder
	empty_line bool
}

fn new_jsdoc(gen &JsGen) &JsDoc {
	return &JsDoc{
		out: strings.new_builder(20)
		gen: gen
	}
}

fn (mut d JsDoc) gen_indent() {
	if d.gen.indents[d.gen.namespace] > 0 && d.empty_line {
		d.out.write(tabs[d.gen.indents[d.gen.namespace]])
	}
	d.empty_line = false
}

fn (mut d JsDoc) write(s string) {
	if !d.gen.enable_doc { return }
	d.gen_indent()
	d.out.write(s)
}

fn (mut d JsDoc) writeln(s string) {
	if !d.gen.enable_doc { return }
	d.gen_indent()
	d.out.writeln(s)
	d.empty_line = true
}

fn (mut d JsDoc) reset() {
	d.out = strings.new_builder(20)
	d.empty_line = false
}

fn (mut d JsDoc) gen_typ(typ, name string) string {
	d.reset()
	d.write('/**')
	d.write(' @type {$typ}')
	if name.len > 0 {
		d.write(' - ${d.gen.js_name(name)}')
	}
	d.write(' */')
	return d.out.str()
}

fn (mut d JsDoc) gen_fac_fn(fields []ast.StructField) string {
	d.reset()
	d.writeln('/**')
	d.write(' * @param {{')
	for i, field in fields {
		// Marked as optional: structs have default default values,
		// so all struct members don't have to be initialized.
		// TODO: Actually generate default struct init values :P
		d.write('$field.name?: ${d.gen.typ(field.typ)}')
		if i < fields.len - 1 { d.write(', ') }
	}
	d.writeln('}} values - values for this class fields')
	d.writeln(' * @constructor')
	d.write('*/')
	return d.out.str()
}

fn (mut d JsDoc) gen_fn(it ast.FnDecl) string {
	d.reset()
	type_name := d.gen.typ(it.return_type)
	d.writeln('/**')
	if it.is_deprecated {
		d.writeln(' * @deprecated')
	}
	for i, arg in it.args {
		if it.is_method && i == 0 {
			continue
		}
		arg_type_name := d.gen.typ(arg.typ)
		is_varg := i == it.args.len - 1 && it.is_variadic
		name := d.gen.js_name(arg.name)
		if is_varg {
			d.writeln(' * @param {...$arg_type_name} $name')
		} else {
			d.writeln(' * @param {$arg_type_name} $name')
		}
	}
	d.writeln(' * @returns {$type_name}')
	d.writeln(' * @function')
	d.write('*/')
	return d.out.str()
}

fn (mut d JsDoc) gen_namespace(ns string) string {
	d.reset()
	d.writeln('/** @namespace ${ns} */')
	return d.out.str()
}
// V_COMMIT_HASH 0de70e8
// V_CURRENT_COMMIT_HASH 4271eb4
// Generated by the V compiler

"use strict";

/** @namespace builtin */
const builtin = (function () {
	/**
	 * @param {any} s
	 * @returns {void}
	 * @function
	*/
	function println(s) {
		console.log(s);
	}
	
	/**
	 * @param {any} s
	 * @returns {void}
	 * @function
	*/
	function print(s) {
		process.stdout.write(s);
	}

	/* module exports */
	return {
		println,
		print,
	};
})();

/** @namespace main */
const main = (function () {
	/**
	 * @param {...number} args
	 * @returns {void}
	 * @function
	*/
	function variadic(...args) {
		builtin.println(args);
		builtin.println(args[0]);
		builtin.println(args[1]);
	}
	
	/**
	 * @returns {void}
	 * @function
	*/
	function vararg_test() {
		variadic(1, 2, 3);
	}
	
	/* program entry point */
	(function() {
		vararg_test();
		/** @type {string[]} - arr1 */
		const arr1 = ["Hello", "JS", "Backend"];
		/** @type {number[]} - arr2 */
		let arr2 = [1, 2, 3, 4, 5];
		/** @type {string[]} - slice1 */
		const slice1 = arr1.slice(1, 3);
		/** @type {number[]} - slice2 */
		const slice2 = arr2.slice(0, 3);
		/** @type {number[]} - slice3 */
		const slice3 = arr2.slice(3, arr2.length);
		/** @type {string} - idx1 */
		const idx1 = slice1[1];
		arr2[0] = 1;
		arr2[0 + 1] = 2;
		builtin.println(arr2);
		/** @type {string} - slice4 */
		const slice4 = idx1.slice(0, 4);
		builtin.println(slice4);
		/** @type {byte} - idx2 */
		const idx2 = slice4[0];
		/** @type {Map<string, string>} - m */
		let m = new Map();
		/** @type {string} - key */
		const key = "key";
		m[key] = "value";
		/** @type {string} - val */
		const val = m["key"];
		builtin.println(val);
	})();

	/* module exports */
	return {};
})();


fn variadic(args ...int) {
	println(args)
	println(args[0])
	println(args[1])
}

fn vararg_test() {
	variadic(1, 2, 3)
}

vararg_test()

arr1 := ['Hello', 'JS', 'Backend']
mut arr2 := [1, 2, 3, 4, 5]

// Array slices
slice1 := arr1[1..3]
slice2 := arr2[..3]
slice3 := arr2[3..]

// Array indexes
idx1 := slice1[1]
arr2[0] = 1
arr2[0 + 1] = 2
println(arr2)

// String slices
slice4 := idx1[..4]
println(slice4) // 'Back'

// String indexes
idx2 := slice4[0]

// TODO: This does not work for now
// arr2[0..1] = arr2[3..4]
// println(arr2)


// Maps
mut m := map[string]string
key := 'key'
m[key] = 'value'
val := m['key']
println(val)// V_COMMIT_HASH 0de70e8
// V_CURRENT_COMMIT_HASH 4271eb4
// Generated by the V compiler

"use strict";

const _CONSTS = Object.freeze({
	/** @type {number} - i_am_a_const */
	i_am_a_const: 	21214,
	/** @type {string} - v_super */
	v_super: "amazing keyword"
});

/** @namespace builtin */
const builtin = (function () {
	/**
	 * @param {any} s
	 * @returns {void}
	 * @function
	*/
	function println(s) {
		console.log(s);
	}
	
	/**
	 * @param {any} s
	 * @returns {void}
	 * @function
	*/
	function print(s) {
		process.stdout.write(s);
	}

	/* module exports */
	return {
		println,
		print,
	};
})();

/** @namespace hello */
const hello = (function () {
	/**
	 * @param {{foo?: string}} values - values for this class fields
	 * @constructor
	*/
	function A({ foo = "" }) {
		this.foo = foo
	};
	A.prototype = {
		/** @type {string} - foo */
		foo: "",
		/**
		 * @param {string} s
		 * @returns {void}
		 * @function
		*/
		update(s) {
			const a = this;
			a.foo = s;
		}
	};

	
	/**
	 * @param {{}} values - values for this class fields
	 * @constructor
	*/
	function B({  }) {
	};
	B.prototype = {
	};

	const C = Object.freeze({
	});
	
	/**
	 * @returns {string}
	 * @function
	*/
	function v_debugger() {
		const v = new B({});
		return "Hello";
	}
	
	/**
	 * @returns {string}
	 * @function
	*/
	function excited() {
		return v_debugger() + "!";
	}

	/* module exports */
	return {
		A,
		C,
		v_debugger,
		excited,
	};
})();

/** @namespace main */
const main = (function (hl) {
	/**
	 * @param {{a?: hl["A"]["prototype"]}} values - values for this class fields
	 * @constructor
	*/
	function Foo({ a = {} }) {
		this.a = a
	};
	Foo.prototype = {
		/** @type {hl["A"]["prototype"]} - a */
		a: {}
	};

	/**
	 * @param {{google?: number, amazon?: boolean, yahoo?: string}} values - values for this class fields
	 * @constructor
	*/
	function Companies({ google = 0, amazon = false, yahoo = "" }) {
		this.google = google
		this.amazon = amazon
		this.yahoo = yahoo
	};
	Companies.prototype = {
		/** @type {number} - google */
		google: 0,
		/** @type {boolean} - amazon */
		amazon: false,
		/** @type {string} - yahoo */
		yahoo: "",
		/**
		 * @returns {number}
		 * @function
		*/
		method() {
			const it = this;
			const ss = new Companies({
				google: 2,
				amazon: true,
				yahoo: "hello"
			});
			/** @type {[number, number]} */
			const [a, b] = hello(2, "google", "not google");
			/** @type {string} - glue */
			const glue = (a > 2 ? "more_glue" : a > 5 ? "more glueee" : "less glue");
			if (a !== 2) {
			}
			
			return 0;
		}
	};

	const POSITION = Object.freeze({
		go_back: 0,
		dont_go_back: 1,
	});
	
	/**
	 * @param {string} v_extends
	 * @param {number} v_instanceof
	 * @returns {void}
	 * @function
	*/
	function v_class(v_extends, v_instanceof) {
		/** @type {number} - v_delete */
		const v_delete = v_instanceof;
	}
	
	/* program entry point */
	(async function() {
		builtin.println("Hello from V.js!");
		/** @type {number} - a */
		let a = 1;
		a *= 2;
		a += 3;
		builtin.println(a);
		const b = new hl.A({});
		b.update("an update");
		builtin.println(b);
		const c = new Foo({
			a: new hl.A({})
		});
		c.a.update("another update");
		builtin.println(c);
		/** @type {string} - v */
		const v = "done";
		{
			/** @type {string} - _ */
			const _ = "block";
		}
		
		/** @type {number} - pos */
		const pos = POSITION.go_back;
		/** @type {string} - v_debugger */
		const v_debugger = "JS keywords";
		/** @type {string} - v_await */
		const v_await = _CONSTS.v_super + ": " + v_debugger;
		/** @type {string} - v_finally */
		let v_finally = "implemented";
		console.log(v_await, v_finally);
		/** @type {number} - dun */
		const dun = _CONSTS.i_am_a_const * 20;
		for (let i = 0; i < 10; i++) {
		}
		
		for (let i = 0; i < "hello".length; ++i) {
			let x = "hello"[i];
		}
		
		for (let x = 1; x < 10; ++x) {
		}
		
		/** @type {number[]} - arr */
		const arr = [1, 2, 3, 4, 5];
		for (let _tmp1 = 0; _tmp1 < arr.length; ++_tmp1) {
			let i = arr[_tmp1];
		}
		
		/** @type {Map<string, string>} - ma */
		const ma = new Map([
			["str", "done"],
			["ddo", "baba"]
		]);
		for (let [m, n] of ma) {
			/** @type {string} - iss */
			const iss = m;
		}
		
		await new Promise(function(resolve){
			async(0, "hello");
			resolve();
		});
		
		/** @type {(number: number) => void} - fn_in_var */
		const fn_in_var = function (number) {
			builtin.println(tos3(`number: ${number}`));
		};
		hl.v_debugger();
		anon_consumer(hl.excited(), function (message) {
			builtin.println(message);
		});
	})();
	
	/**
	 * @param {string} greeting
	 * @param {(message: string) => void} anon
	 * @returns {void}
	 * @function
	*/
	function anon_consumer(greeting, anon) {
		anon(greeting);
	}
	
	/**
	 * @param {number} num
	 * @param {string} def
	 * @returns {void}
	 * @function
	*/
	function async(num, def) {
	}
	
	/* [inline] */
	/* [deprecated] */
	/**
	 * @deprecated
	 * @param {number} game_on
	 * @param {...string} dummy
	 * @returns {[number, number]}
	 * @function
	*/
	function hello(game_on, ...dummy) {
		for (let _tmp2 = 0; _tmp2 < dummy.length; ++_tmp2) {
			let dd = dummy[_tmp2];
			/** @type {string} - l */
			const l = dd;
		}
		
		(function defer() {
			/** @type {string} - v_do */
			const v_do = "not";
		})();
		return [game_on + 2, 221];
	}

	/* module exports */
	return {};
})(hello);


import hello as hl

fn JS.alert(arg string)

const (
    i_am_a_const = 21214
    super = 'amazing keyword'
)

struct Foo {
    a hl.A
}

struct Companies {
	google int
    amazon bool
    yahoo string
}

enum POSITION {
    go_back
    dont_go_back
}

fn class(extends string, instanceof int) {
    delete := instanceof
}


fn main() {
    println('Hello from V.js!')

    mut a := 1
    a *= 2
    a += 3
    println(a) // TODO: Handle string interpolation

    b := hl.A{}
    b.update('an update')
    println(b)

    c := Foo{ hl.A{} }
    c.a.update('another update')
    println(c)

    v := "done"
    {
        _ := "block"
    }

    pos := POSITION.go_back

    debugger := 'JS keywords'
    // TODO: Implement interpolation
    await := super + ': ' + debugger
    mut finally := 'implemented'

    JS.console.log(await, finally)

    dun := i_am_a_const * 20

    for i := 0; i < 10; i++ {}

    for i, x in 'hello' {}

    for x in 1..10 {}

    arr := [1,2,3,4,5]
    for i in arr {}

    ma := {
        'str':  "done"
        'ddo': "baba"
    }

    for m, n in ma {
        iss := m
    }

    go async(0, "hello")

    fn_in_var := fn (number int) {
        println("number: $number")
    }

    hl.debugger()
    anon_consumer(hl.excited(), fn (message string) {
        println(message)
    })
}

fn anon_consumer (greeting string, anon fn(message string)) {
    anon(greeting)
}

fn async(num int, def string) {}

[inline]
[deprecated]
fn hello(game_on int, dummy ...string) (int, int) {
    defer {
        do := "not"
    }
    for dd in dummy {
        l := dd
    }
    return game_on + 2, 221
}

fn (it Companies) method() int {

    ss := Companies {
        google: 2
        amazon: true
        yahoo: "hello"
	}

    a, b := hello(2, 'google', 'not google')

    glue := if a > 2 { 'more_glue' } else if a > 5 {'more glueee'} else { 'less glue' }

    if a != 2 {}

    return 0
}
// V_COMMIT_HASH 0de70e8
// V_CURRENT_COMMIT_HASH 0de70e8
// Generated by the V compiler

"use strict";

/* namespace: builtin */
const builtin = (function () {
	/**
	 * @param {string} s
	 * @returns {void}
	*/
	function println(s) {
		console.log(s);
	}
	
	/**
	 * @param {string} s
	 * @returns {void}
	*/
	function print(s) {
		process.stdout.write(s);
	}

	/* module exports */
	return {
		println,
		print,
	};
})();

/* namespace: main */
const main = (function () {
	/* program entry point */
	(function() {
		builtin.println("hello world");
	})();

	/* module exports */
	return {
	};
})();


module main

fn main() {
	println("hello world")
}
// V_COMMIT_HASH 7e55261
// V_CURRENT_COMMIT_HASH 79b1f27
// Generated by the V compiler

"use strict";

/** @namespace builtin */
const builtin = (function () {
	/**
	 * @param {any} s
	 * @returns {void}
	 * @function
	*/
	function println(s) {
		console.log(s);
	}
	
	/**
	 * @param {any} s
	 * @returns {void}
	 * @function
	*/
	function print(s) {
		process.stdout.write(s);
	}

	/* module exports */
	return {
		println,
		print,
	};
})();

/** @namespace main */
const main = (function () {
	/**
	 * @param {{value?: number, test?: Map<string, number>, hello?: number[]}} values - values for this class fields
	 * @constructor
	*/
	function Int({ value = 0, test = new Map(), hello = [] }) {
		this.value = value
		this.test = test
		this.hello = hello
	};
	Int.prototype = {
		/** @type {number} - value */
		value: 0,
		/** @type {Map<string, number>} - test */
		test: new Map(),
		/** @type {number[]} - hello */
		hello: [],
		/**
		 * @param {number} value
		 * @returns {void}
		 * @function
		*/
		add(value) {
			const i = this;
			i.value += value;
		},
		/**
		 * @returns {number}
		 * @function
		*/
		get() {
			const i = this;
			return i.value;
		}
	};

	
	
	/* program entry point */
	(function() {
		const a = new Int({
			value: 10
		});
		a.add(5);
		builtin.println(a);
		const b = new Int({});
		b.add(10);
		builtin.println(b.get());
	})();

	/* module exports */
	return {};
})();


module main

struct Int {
mut:
  value int
  test map[string]int
  hello []int
}

fn (mut i Int) add(value int) {
  i.value += value
}

fn (i Int) get() int {
  return i.value
}

fn main() {
  a := Int { value: 10 }
  a.add(5)
  println(a) // 15

  b := Int{}
  b.add(10)
  println(b.get()) // 10
}
module hello

// TODO: Fix const namespacing, uncomment once it works
/*
pub const (
	hello = 'Hello'
)
*/

pub struct A {
pub mut:
	foo string
}

pub fn (mut a A) update(s string) {
	a.foo = s
}

struct B {}

pub enum C {}

pub fn debugger() string {
	v := B{}
	return 'Hello'
}

pub fn excited() string {
	return debugger() + "!"
}module hello1

// Unused for now: nested modules do not work yet

pub fn nested() string {
	return 'Nested'
}
typedef enum {
	Color_red, // 0
	Color_green, // 1
	Color_blue, // 2
} Color;

struct Two {
};

struct User {
	int age;
	string name;
};

struct One {
	Two two;
};

// multi return structs
typedef struct {
	int arg0;
	string arg1;
} multi_return_int_string;
// end of definitions #endif
#define _const_pi 3
int _const_pi2; // inited later
string int_str(int* x) { return tos3("TODO_str"); }
void foo(int a);
void User_inc_age(User* u, int n);
int get_int(string a);
bool get_bool();
int get_int2();
void myuser();
multi_return_int_string multi_return();
void variadic(varg_int a);
void ensure_cap(int required, int cap);
void println(string s);
void matches();
#define _const_path_sep 10
void end();
int function1();
void foo(int a);
void init_user();
User get_user();
void puts(string s);
void function2();
void init_array();
#define _const_localmod__pub_int_const 20
void localmod__pub_foo();
int localmod__get_int_10();
// variadic structs
struct varg_int {
	int len;
	int args[0];
};

// >> typeof() support for sum types
// << typeof() support for sum types

//
int main(int argc, char** argv) {
	_vinit();
	int a = 10;
	a++;
	int negative = -a;
	2 < 3;
	a == 1;
	a++;
	foo(3);
	int ak = 10;
	int mypi = _const_pi;
	Color color = Color_red;
	localmod__pub_foo();
	int ten = localmod__get_int_10();
	println(int_str(_const_localmod__pub_int_const));
	int g = ((int)(3.0));
	byte* bytes = ((byte*)(0));
    User* user_ptr = (User*)memdup(&(User){	.age = 0,
   .name = tos3(""),
}, sizeof(User));
	return 0;
}

void foo(int a) {
	while (true) {
	}
	for (int i = 0;
i < 10; i++) {
	}
	array_int nums = new_array_from_c_array(3, 3, sizeof(int), (int[3]){
		1, 2, 3,
	});
	array_int nums2 = array_slice(nums, 0, 2);
	array_int nums3 = array_slice(nums, 1, 2);
	array_int nums4 = array_slice(nums, 1, nums.len);
	int number = (*(int*)array_get(nums, 0));
	array_set(&nums, 1, &(int[]) { 10 });
	array_bool bools = new_array_from_c_array(2, 2, sizeof(bool), (bool[2]){
		true, false,
	});
	array_User users = new_array_from_c_array(1, 1, sizeof(User), (User[1]){
		(User){
		.age = 0,
		   .name = tos3(""),
		},
	});
	bool b = (*(bool*)array_get(bools, 0));
	array_string mystrings = new_array_from_c_array(2, 2, sizeof(string), (string[2]){
		tos3("a"), tos3("b"),
	});
	string s = (*(string*)array_get(mystrings, 0));
	int x = 0;
	x = get_int2();
	int n = get_int2();
	bool q = true || false;
	bool b2 = (*(bool*)array_get(bools, 0)) || true;
	bool b3 = get_bool() || true;
	int f = *(int*)array_first(nums);
	array_int c = array_clone(&nums);
	string d = tos3("d");
	println(string_add(s, d));
}

void User_inc_age(User* u, int n) {
	printf("%d", u->age);
	u->age += n;
}

int get_int(string a) {
	return 10;
}

bool get_bool() {
	return true;
}

int get_int2() {
	string a = tos3("hello");
	return get_int(a);
}

void myuser() {
	int x = 1;
	int q = x | 0x1004;
	User user = (User){
		.age = 30,
		.name = tos3(""),
	};
	int age = user.age + 1;
	int boo = 2;
	int boo2 = boo + 1;
	bool b = age > 0;
	bool b2 = user.age > 0;
	User user2 = (User){
		.age = 20,
		.name = tos3(""),
	};
	user2.age = 20 + boo;
}

multi_return_int_string multi_return() {
	return (multi_return_int_string){.arg0=4,.arg1=tos3("four")};
}

void variadic(varg_int a) {
	int x = _const_path_sep;
	int y = (true ? 1 : 0);
}

void ensure_cap(int required, int cap) {
	if (required < cap) {
		return;
	}
}

void println(string s) {
}

void matches() {
	int a = 100;
	if (a == 10) {
		println(tos3("10"));
	}
	else if (a == 20) {
		int k = a + 1;
	}
	else {
	}
	;
	string x = (a == 10) ? tos3("ten") : (a == 30) ? tos3("thirty") : tos3("unknown");
	int xx = (a == 10) ? 100 : (a == 30) ? 300 : 0;
	println((a == 10) ? tos3("ten") : tos3("not ten"));
}

void end() {
	int i = 2;
	int key = 10;
	bool x = i != -1 && key == 10;
	int e = 2 + 3 * 4;
}

int function1() {
	int a = 10 + 1;
	int b = a + 1;
	return 0;
}


void foo(int a) {
}

void init_user() {
	User user = (User){
		.name = tos3("Bob"),
		.age = 0,
	};
}

User get_user() {
	User user = (User){
		.age = 0,
		.name = tos3(""),
	};
	return user;
}

void puts(string s) {
}

void function2() {
	int x = 0;
	f64 f = 10.1;
	string s = tos3("hi");
	int m = 10;
	x += 10;
	x += 1;
	m += 2;
	function1();
	if (true) {
		foo(10);
		x += 8;
	}
	if (false) {
		foo(1);
	} else {
		puts(tos3("else"));
		foo(100);
	}
	while (true) {
		init_user();
	}
	bool e = 1 + 2 > 0;
	bool e2 = 1 + 2 < 0;
	int j = 0;
}

void init_array() {
	array_int nums = new_array_from_c_array(3, 3, sizeof(int), (int[3]){
		4, 2, 3,
	});
}

void localmod__pub_foo() {
	int a = 10;
}

int localmod__get_int_10() {
	return 10;
}


void _vinit() {
	_const_pi2 = _const_pi;
}



//import moda
//import modb as mb

import localmod

const (
	pi = 3
	pi2 = pi
	//s = 'hi'

)

struct User {
	age  int
	name string
}

enum Color {
	red green blue
}

fn main() {
	a := 10
	//bb := 2 + 'hi'
	a++
	negative := -a
	2 < 3
	a == 1
	a++
	foo(3)
	ak := 10
	mypi := pi
	color := Color.red
	localmod.pub_foo()
	ten := localmod.get_int_10()
	println(localmod.pub_int_const)
	g := int(3.0)
	bytes := &byte(0)
	user_ptr := &User{}
}
	/*
	user := User{}
	user.age = 10
	mut x := if user.age == 10 { 20 } else { user.age * 2 }
	for x > 3 {

	}
	*/

struct One {
	two Two
}

struct Two {

}

fn foo(a int) {
	for true {

	}
	for i := 0; i < 10; i++ {

	}
	mut nums := [1,2,3]
	nums2 := nums[..2]
	nums3 := nums[1..2]
	nums4 := nums[1..]
	number := nums[0]
	nums[1] = 10
	bools := [true, false]
	users := [User{}]
	//ptr := &User{}
	b := bools[0]
	mystrings := ['a', 'b']
	s := mystrings[0]
	//////////
	mut x := 0
	x=get_int2()
	n := get_int2()
	q := true || false
	b2 := bools[0] || true
	b3 := get_bool() || true
	f := nums.first()
	c := nums.clone()
	d := 'd'
	println(s + d)
	//cloned = nums.clone()
	//cloned1 := cloned[0]
	//println(cloned1 == 1)
	/*
	mut strings := ['hi', 'hello']
	strings << 'a' + b
	*/

}

fn C.printf()

fn (u mut User) inc_age(n int) {
	C.printf("%d", u.age)
	u.age += n
}

fn get_int(a string) int {
	return 10
}

fn get_bool() bool {
	return true
}

fn get_int2() int {
	a := 'hello'
	//return get_int('sdf')
	return get_int(a)
}

fn myuser() {
	x := 1
	q := x | 0x1004
	user := User{age:30}
	age := user.age + 1 // crash here
	boo := 2
	boo2 := boo+1
	b := age > 0
	b2 := user.age > 0
	mut user2 := User{age:20}
	user2.age = 20 + boo
}

fn multi_return() (int,string) {
	return 4, 'four'
}

fn variadic(a ...int) {
	x := path_sep
	y := if true { 1 } else { 0 } // TODO cgen
}

fn ensure_cap(required int, cap int) {
	if required < cap {
		return
	}
}

fn println(s string){}

fn matches() {
	a := 100
	match a {
		10 {
			println('10')
		}
		20 {
			k := a + 1
		}
		else{}
	}
	x := match a {
		10 { 'ten' }
		30 { 'thirty' }
		else { 'unknown' }
	}
	xx := match a {
		10 { 100 }
		30 { 300 }
		else { 0 }
	}
	println(match a {  10 { 'ten' } else { 'not ten' } })
	/*
	n := match a {
		1 { 10 }
		2 { 20 }
		else { 30 }
	}
	*/
}

const (
	path_sep = 10
)

fn end() {
	i := 2
	key := 10
	x := i != -1 && key == 10 // key == keys[i]
	e := 2 + 3 * 4
	//mut a := [1,2,3]
	//(a << 4) + 2
}

///////////////////////////////////////////////////////////

fn function1() int {
	a := 10 + 1
	b := a + 1
	//return a
	return 0
}

fn foo(a int) {
	//end()
}

struct User {
	name string
}

fn init_user() {
	user := User{
		name: 'Bob'
	}
}

fn get_user() User {
	user := User{}
	return user
}


fn puts(s string) {}

// comment
fn function2() {
	mut x := 0
	//mut negative := -1
	f := 10.1
	s := 'hi'
	mut m := 10
	x += 10
	x += 1
	m += 2
	function1()
	// a += 1
	// c := 0
	if true {
		foo(10)
		x += 8
	}
	if false {
		foo(1)
	}
	else {
		puts('else')
		foo(100)
	}
	for true {
		init_user()
	}
	e := 1 + 2 > 0
	e2 := 1 + 2 < 0
	// x += 1
	j := 0
}

fn init_array() {
	nums := [4,2,3]

}


/*
fn bool_array() {
       a := [true, false]
       b := a[0]
       if b {
               println('ok')
       }
}
*/



struct User {
	string name;
};

// multi return structs
// end of definitions #endif
int function1();
void foo(int a);
void init_user();
User get_user();
void puts(string s);
void function2();
void init_array();
void end();
// >> typeof() support for sum types
// << typeof() support for sum types

int function1() { 
	int a = 10 + 1;
	int b = a + 1;
	return 0;
}

void foo(int a) { 
}

void init_user() { 
	User user = (User){
		.name = tos3("Bob"),
	};
}

User get_user() { 
	User user = (User){
		.name = tos3(""),
	};
	return user;
}

void puts(string s) { 
}

void function2() { 
	int x = 0;
	f64 f = 10.1;
	string s = tos3("hi");
	int m = 10;
	x += 10;
	x += 1;
	m += 2;
	function1();
	if (true) {
		foo(10);
		x += 8;
	}
	if (false) {
		foo(1);
	} else {
		puts(tos3("else"));
		foo(100);
	}
	while (true) {
		init_user();
	}
	bool e = 1 + 2 > 0;
	bool e2 = 1 + 2 < 0;
	int j = 0;
}

void init_array() { 
	array_int nums = new_array_from_c_array(3, 3, sizeof(int), (int[3]){
		4, 2, 3, 
	});
}

void end() { 
}

int main(int argc, char** argv) { 
	_vinit();
	return 0;
}

void _vinit() {

}
fn function1() int {
	a := 10 + 1
	b := a + 1
	//return a
	return 0
}

fn foo(a int) {
	//end()
}

struct User {
	name string
}

fn init_user() {
	user := User{
		name: 'Bob'
	}
}

fn get_user() User {
	user := User{}
	return user
}


fn puts(s string) {}

// comment
fn function2() {
	mut x := 0
	//mut negative := -1
	f := 10.1
	s := 'hi'
	mut m := 10
	x += 10
	x += 1
	m += 2
	function1()
	// a += 1
	// c := 0
	if true {
		foo(10)
		x += 8
	}
	if false {
		foo(1)
	}
	else {
		puts('else')
		foo(100)
	}
	for true {
		init_user()
	}
	e := 1 + 2 > 0
	e2 := 1 + 2 < 0
	// x += 1
	j := 0
}

fn init_array() {
	nums := [4,2,3]

}

fn end() {

}

/*
fn bool_array() {
       a := [true, false]
       b := a[0]
       if b {
               println('ok')
       }
}
*/

fn main() {
	}
struct IfExpr {
};

struct IntegerLiteral {
};

// Sum type
typedef struct {
	void* obj;
	int typ;
} Expr;

struct User {
	int age;
	string name;
};

// multi return structs
// end of definitions #endif
typedef Option Option_int;
Option_int get_opt();
void User_foo(User* u);
void println(string s);
void handle_expr(Expr e);
// >> typeof() support for sum types
char * v_typeof_sumtype_28(int sidx) { /* Expr */ 
	switch(sidx) {
		case 28: return "Expr";
		case 26: return "IfExpr";
		case 27: return "IntegerLiteral";
		default: return "unknown Expr";
	}
}
// << typeof() support for sum types

// TypeDecl

Option_int get_opt() {
	return opt_ok(& (int []) { 0 }, sizeof(int));
}

void User_foo(User* u) {
	int age = u->age;
	array_string zzz = array_repeat(new_array_from_c_array(1, 1, sizeof(string), (string[1]){
tos3(""),
}), u->age);
	int a = 10;
	if ((a == 10 || a == 20 || a == 30)) {
		int b = 10;
	}
	string name = tos3("Bob");
	println(tos3("hello"));
	println(_STR("Hello, %.*s", name.len, name.str));
	println(_STR("age = %d", age));
	println(_STR("name=%.*s age=%d", name.len, name.str, age));
}

void println(string s) {
}

void handle_expr(Expr e) {
	if (e.typ == 26 /* IfExpr */) {
		IfExpr* it = (IfExpr*)e.obj; // ST it
		println(tos3("if"));
	}
	else if (e.typ == 27 /* IntegerLiteral */) {
		IntegerLiteral* it = (IntegerLiteral*)e.obj; // ST it
		println(tos3("integer"));
	}
	else {
		println(tos3("else"));
	}
	;
}

int main(int argc, char** argv) {
	_vinit();
	User user = (User){
		.age = 0,
		.name = tos3(""),
	};
	user.age = 10;
	user.age++;
	user.name = tos3("bob");
	Option_int n = get_opt();
	if (!n.ok) {
		string err = n.v_error;
		int errcode = n.ecode;
		return 0;
	};
	int a = /*opt*/(*(int*)n.data) + 3;
	handle_expr(/* sum type cast */ (Expr) {.obj = memdup(&(IfExpr[]) {(IfExpr){
0}}, sizeof(IfExpr)), .typ = 26 /* IfExpr */});
	return 0;
}

void _vinit() {

}
type Expr = IfExpr | IntegerLiteral

struct IfExpr{}
struct IntegerLiteral{}

struct User {
	age int
	name string
}

fn get_opt() ?int {
	return 0
}

/*
fn new_user() User {
	return User{}
}

fn get_user_opt() ?User {
	return new_user()
	//return User{age:20, name:'Peter'}
}
*/

fn (u &User) foo() {
	age := u.age
	zzz := [''].repeat(u.age)
	a := 10
	if a in [10, 20, 30] {
		b := 10
	}
	name := 'Bob'
	println('hello')
	println('Hello, $name')
	println('age = $age')
	println('name=$name age=$age')
}

fn println(s string) {}

fn handle_expr(e Expr) {
	match e {
		IfExpr {
			println('if')


		}
		IntegerLiteral {
			println('integer')

		}
		else {
			println('else')
		}
	}

}

fn main() {
	user := User{}
	user.age = 10
	user.age++
	user.name = 'bob'
	n := get_opt() or {
		return
	}
	a := n + 3
	handle_expr(IfExpr{})
}
struct Bar {
	int a;
};

struct Foo {
	string a;
	Bar b;
};

// multi return structs
typedef struct {
	int arg0;
	string arg1;
} multi_return_int_string;

// end of definitions #endif
typedef Option Option_string;
typedef Option Option_multi_return_int_string;
multi_return_int_string mr_test();
int testa();
string testb(int a);
int testc(int a);
int Foo_testa(Foo* f);
int Foo_testb(Foo* f);
int Bar_testa(Bar* b);
Option_string optional_a();
Option_string optional_b();
Option_multi_return_int_string optional_mr();
// >> typeof() support for sum types
// << typeof() support for sum types

int main(int argc, char** argv) {
	_vinit();
    Bar b = (Bar){
        .a = 122,
    };
    Foo a = (Foo){
        .a = tos3("hello"),
        .b = b,
    };
    a.a = tos3("da");
    a.b.a = 111;
    string a1 = a.a;
    int a2 = Bar_testa(&b);
    int c = testa();
    c = 1;
    string d = testb(1);
    d = tos3("hello");
    string e = tos3("hello");
    e = testb(111);
	e = tos3("world");
	array_int f = new_array_from_c_array(4, 4, sizeof(int), (int[4]){
        testa(), 2, 3, 4,
	});
	array_string g = new_array_from_c_array(2, 2, sizeof(string), (string[2]){
		testb(1), tos3("hello"),
	});
	array_Foo arr_foo = new_array_from_c_array(1, 1, sizeof(Foo), (Foo[1]){
		a,
	});
	Foo af_idx_el = (*(Foo*)array_get(arr_foo, 0));
	string foo_a = af_idx_el.a;
    map_string_string m1 = new_map(sizeof(string));
    map_string_int m2 = new_map_init(2, sizeof(int), (string[2]){tos3("v"), tos3("lang"), }, (int[2]){1, 2, });
    string ma1 = tos3("hello");
    string ma2 = tos3("vlang");
	multi_return_int_string mr_566 = mr_test();
	int mr1 = mr_566.arg0;
	string mr2 = mr_566.arg1;
	string opt1 = tos3("opt1");
	Option_string opt2 = optional_a();
	if (!opt2.ok) {
        string err = opt2.v_error;
        int errcode = opt2.ecode;
	};
	string opt3 = tos3("opt3");
	Option_string opt4 = optional_b();
	if (!opt4.ok) {
        string err = opt4.v_error;
        int errcode = opt4.ecode;
	};
	Option_multi_return_int_string mr_669 = optional_mr();
	if (!mr_669.ok) {
        string err = mr_669.v_error;
        int errcode = mr_669.ecode;
	};
	int opt_mr1 = (*(multi_return_int_string*)mr_669.data).arg0;
	string opt_mr12 = (*(multi_return_int_string*)mr_669.data).arg1;
    return 0;
}

multi_return_int_string mr_test() {
    return (multi_return_int_string){.arg0=1,.arg1=tos3("v")};
}

int testa() {
    return testc(1);
}

string testb(int a) {
    return tos3("hello");
}

int testc(int a) {
    return a;
}

int Foo_testa(Foo* f) {
    int a = Foo_testb(f);
    a = 1;
    return 4;
}

int Foo_testb(Foo* f) {
    return 4;
}

int Bar_testa(Bar* b) {
    return 4;
}

Option_string optional_a() { 
	return opt_ok(& (string []) { tos3("111") }, sizeof(string));
}

Option_string optional_b() { 
	return opt_ok(& (string []) { tos3("222") }, sizeof(string));
}

Option_multi_return_int_string optional_mr() { 
	return opt_ok(& (multi_return_int_string []) { (multi_return_int_string){.arg0=1,.arg1=tos3("111")} }, sizeof(multi_return_int_string));
}

void _vinit() {

}
module main

// import moda

// import (
// 	modb
// 	modc
// )

fn main() {
	b := Bar{a: 122}
	mut a := Foo{
			a: 'hello'
			b: b
	}
	a.a = 'da'
	a.b.a = 111

	a1 := a.a
	a2 := b.testa()

	mut c := testa()
	c = 1
	mut d := testb(1)
	d = 'hello'

	mut e := 'hello'
	e = testb(111)
	e = 'world'

	mut f := [testa(),2,3,4]
	mut g := [testb(1),'hello']

	//mut arr_foo := []Foo
	arr_foo := [a]
	//arr_foo << a // TODO
	af_idx_el := arr_foo[0]
	foo_a := af_idx_el.a

	mut m1 := map[string]string
	mut m2 := {'v': 1, 'lang': 2}

	ma1, ma2 := 'hello', 'vlang'
	mr1, mr2 := mr_test()

	opt1, opt2, opt3, opt4 := 'opt1', optional_a(), 'opt3', optional_b()
	opt_mr1, opt_mr12 := optional_mr() or {
		// err
	}
}

fn mr_test() (int, string) {
	return 1,'v'
}

fn testa() int {
	return testc(1)
}

fn testb(a int) string {
	return 'hello'
}

fn testc(a int) int {
	return a
}

fn (f &Foo) testa() int {
	mut a := f.testb()
	a = 1
	return 4
}

fn (f &Foo) testb() int {
	return 4
}

fn (b &Bar) testa() int {
	return 4
}

struct Bar {
	a int
}

struct Foo{
	a string
	b Bar
}

fn optional_a() ?string {
	return '111'
}

fn optional_b() ?string {
	return '222'
}

fn optional_mr() ?(int, string) {
	return 1, '111'
}

fn foo() {
	a := if true { 1 } else { 2 }


}
module localmod

pub const (
	pub_int_const = 20
)

pub fn pub_foo() {
	a := 10
}

pub fn get_int_10() int {
	return 10
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module x64

import os

const (
	mag0        = byte(0x7f)
	mag1        = `E`
	mag2        = `L`
	mag3        = `F`
	ei_class    = 4
	elfclass64  = 2
	elfdata2lsb = 1
	ev_current  = 1
)

// ELF file types
const (
	elf_osabi  = 0
	et_rel     = 1
	et_exec    = 2
	et_dyn     = 3
	e_machine  = 0x3e
	shn_xindex = 0xffff
	sht_null   = 0
)

const (
	segment_start = 0x400000
	placeholder   = 0
	sevens        = 0x77777777
)

pub fn (mut g Gen) generate_elf_header() {
	g.buf << [byte(mag0),
		mag1,
		mag2,
		mag3
	]
	g.buf << elfclass64 // file class
	g.buf << elfdata2lsb // data encoding
	g.buf << ev_current // file version
	g.buf << 1 // elf_osabi
	g.write64(0) // et_rel) // et_rel for .o
	g.write16(2) // e_type
	g.write16(e_machine) //
	g.write32(ev_current) // e_version
	eh_size := 0x40
	phent_size := 0x38
	g.write64(segment_start + eh_size + phent_size) // e_entry
	g.write64(0x40) // e_phoff
	g.write64(0) // e_shoff
	g.write32(0) // e_flags
	g.write16(eh_size) // e_ehsize
	g.write16(phent_size) // e_phentsize
	g.write16(1) // e_phnum
	g.write16(0) // e_shentsize
	g.write16(0) // e_shnum (number of sections)
	g.write16(0) // e_shstrndx
	// Elf64_Phdr
	g.write32(1) // p_type
	g.write32(5) // p_flags
	g.write64(0) // p_offset
	g.write64(segment_start) // p_vaddr addr:050
	g.write64(segment_start) //
	g.file_size_pos = g.buf.len
	g.write64(0) // p_filesz PLACEHOLDER, set to file_size later // addr: 060
	g.write64(0) // p_memsz
	g.write64(0x1000) // p_align
	// user code starts here at
	// address: 00070 and a half
	println('code_start_pos = $g.buf.len.hex()')
	g.code_start_pos = g.buf.len
	g.debug_pos = g.buf.len
	g.call(placeholder) // call main function, it's not guaranteed to be the first, we don't know its address yet
	g.println('call fn main')
}

pub fn (mut g Gen) generate_elf_footer() {
	// Return 0
	/*
	g.mov(.edi, 0) // ret value
	g.mov(.eax, 60)
	g.syscall()
	*/
	// Strings table
	// Loop thru all strings and set the right addresses
	for i, s in g.strings {
		g.write64_at(segment_start + g.buf.len, int(g.str_pos[i]))
		g.write_string(s)
		g.write8(0)
	}
	// Now we know the file size, set it
	file_size := g.buf.len
	g.write64_at(file_size, g.file_size_pos) // set file size 64 bit value
	g.write64_at(file_size, g.file_size_pos + 8)
	// call main function, it's not guaranteed to be the first
	// we generated call(0) ("e8 0")
	// now need to replace "0" with a relative address of the main function
	// +1 is for "e8"
	// -5 is for "e8 00 00 00 00"
	g.write32_at(g.code_start_pos + 1, int(g.main_fn_addr - g.code_start_pos) - 5)
	// Create the binary
	mut f := os.create(g.out_name) or {
		panic(err)
	}
	os.chmod(g.out_name, 0o775) // make it an executable
	f.write_bytes(g.buf.data, g.buf.len)
	f.close()
	println('\nx64 elf binary has been successfully generated')
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module x64

/*
This file is unused right now, since binaries without sections
are generated.

But it will be necessary once we have dynamic linking.
*/
enum SectionType {
	null = 0
	progbits = 1
	symtab = 2
	strtab = 3
	rela = 4
}

struct SectionConfig {
	name    string
	typ     SectionType
	flags   i64
	data    voidptr
	is_saa  bool
	datalen i64
	link    int
	info    int
	align   i64
	entsize i64
}

fn (mut g Gen) section_header(c SectionConfig) {
	g.write32(g.sect_header_name_pos)
	g.sect_header_name_pos += c.name.len + 1
	g.write32(int(c.typ))
	g.write64(c.flags)
	g.write64(0) // sh_addr
	g.write64(g.offset) // offset
	g.offset += c.datalen + 1
	g.write64(c.datalen)
	g.write32(c.link)
	g.write32(c.info)
	g.write64(c.align)
	g.write64(c.entsize)
}

fn genobj() {
	/*
	// SHN_UNDEF
	mut g := Gen{}
	nr_sections := 7
	g.section_header(SectionConfig{
		name: ''
		typ: .null
		flags:0
		data: 0
		is_saa: false
		link: 0
		info:0
		align:0
		entsize: 0
	})

		/*
	for sect in sections {
		g.section_header(SectionConfig{
			name:0
			typ: sect.typ
			flags: sect.flags
			data: sect.data
			is_saa: true
			datalen: sect.len
			link: 0
			info: 0
			align: sect.align
			entsize: sect.entsize
		})

	}
	*/

	g.section_header(SectionConfig{
		name: '.DATA'
		typ: .progbits
		flags: 0x2
		//data: sect.data
		is_saa: true
		datalen: 0xd
		link: 0
		info: 0
		align: 1
		entsize: 0
	})

	g.section_header(SectionConfig{
		name: '.TEXT'
		typ: .progbits
		flags: 0x2
		//data: sect.data
		is_saa: true
		datalen: 0xd
		link: 0
		info: 0
		align: 1
		entsize: 0
	})
	g.section_header(SectionConfig{
		name: '.shstrtab'
		typ: .strtab
		flags: 0x2
		//data: sect.data
		is_saa: true
		datalen: 0x22
		link: 0
		info: 0
		align: 1
		entsize: 0
	})
	g.section_header(SectionConfig{
		name: '.symtab'
		typ: .symtab
		flags: 0x2
		//data: sect.data
		is_saa: true
		datalen: 0xd
		link: 0
		info: 0
		align: 1
		entsize: 0
	})
	g.section_header(SectionConfig{
		name: '.strtab'
		typ: .symtab
		flags: 0x2
		//data: sect.data
		is_saa: true
		datalen: 0xd
		link: 0
		info: 0
		align: 1
		entsize: 0
	})
	g.section_header(SectionConfig{
		name: '.rela.TEXT'
		typ: .rela
		flags: 0x0
		//data: sect.data
		is_saa: true
		datalen: 0x18
		link: 4
		info: 2
		align: 8
		entsize: 0x18
	})
	*/
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module x64

import v.ast
import v.util
import v.token
import v.errors
import v.pref
import term
import strings

pub struct Gen {
	out_name             string
	pref                 &pref.Preferences // Preferences shared from V struct
mut:
	buf                  []byte
	sect_header_name_pos int
	offset               i64
	str_pos              []i64
	strings              []string // TODO use a map and don't duplicate strings
	file_size_pos        i64
	main_fn_addr         i64
	code_start_pos       i64 // location of the start of the assembly instructions
	fn_addr              map[string]i64
	var_offset           map[string]int // local var stack offset
	stack_var_pos        int
	debug_pos            int
	errors               []errors.Error
	warnings             []errors.Warning
}

// string_addr map[string]i64
// The registers are ordered for faster generation
// push rax => 50
// push rcx => 51 etc
enum Register {
	rax
	rcx
	rdx
	rbx
	rsp
	rbp
	rsi
	rdi
	eax
	edi
	edx
	r8
	r9
	r10
	r11
	r12
	r13
	r14
	r15
}

const (
	fn_arg_registers = [x64.Register.rdi, .rsi, .rdx, .rcx, .r8, .r9]
)

/*
rax // 0
	rcx // 1
	rdx // 2
	rbx // 3
	rsp // 4
	rbp // 5
	rsi // 6
	rdi // 7
*/
enum Size {
	_8
	_16
	_32
	_64
}

pub fn gen(files []ast.File, out_name string, pref &pref.Preferences) {
	mut g := Gen{
		sect_header_name_pos: 0
		out_name: out_name
		pref: pref
	}
	g.generate_elf_header()
	for file in files {
		g.stmts(file.stmts)
	}
	g.generate_elf_footer()
}

pub fn (mut g Gen) stmts(stmts []ast.Stmt) {
	for stmt in stmts {
		g.stmt(stmt)
	}
}

/*
pub fn new_gen(out_name string) &Gen {
	return &Gen{
		sect_header_name_pos: 0
		buf: []
		out_name: out_name
	}
}
*/
pub fn (g &Gen) pos() i64 {
	return g.buf.len
}

fn (mut g Gen) write8(n int) {
	// write 1 byte
	g.buf << byte(n)
}

fn (mut g Gen) write16(n int) {
	// write 2 bytes
	g.buf << byte(n)
	g.buf << byte(n >> 8)
}

fn (mut g Gen) write32(n int) {
	// write 4 bytes
	g.buf << byte(n)
	g.buf << byte(n >> 8)
	g.buf << byte(n >> 16)
	g.buf << byte(n >> 24)
}

fn (mut g Gen) write64(n i64) {
	// write 8 bytes
	g.buf << byte(n)
	g.buf << byte(n >> 8)
	g.buf << byte(n >> 16)
	g.buf << byte(n >> 24)
	g.buf << byte(n >> 32)
	g.buf << byte(n >> 40)
	g.buf << byte(n >> 48)
	g.buf << byte(n >> 56)
}

fn (mut g Gen) write64_at(n, at i64) {
	// write 8 bytes
	g.buf[at] = byte(n)
	g.buf[at + 1] = byte(n >> 8)
	g.buf[at + 2] = byte(n >> 16)
	g.buf[at + 3] = byte(n >> 24)
	g.buf[at + 4] = byte(n >> 32)
	g.buf[at + 5] = byte(n >> 40)
	g.buf[at + 6] = byte(n >> 48)
	g.buf[at + 7] = byte(n >> 56)
}

fn (mut g Gen) write32_at(at i64, n int) {
	// write 4 bytes
	g.buf[at] = byte(n)
	g.buf[at + 1] = byte(n >> 8)
	g.buf[at + 2] = byte(n >> 16)
	g.buf[at + 3] = byte(n >> 24)
}

fn (mut g Gen) write_string(s string) {
	for c in s {
		g.write8(int(c))
	}
}

fn (mut g Gen) inc(reg Register) {
	g.write16(0xff49)
	match reg {
		.r12 { g.write8(0xc4) }
		else { panic('unhandled inc $reg') }
	}
}

fn (mut g Gen) cmp(reg Register, size Size, val i64) {
	g.write8(0x49)
	// Second byte depends on the size of the value
	match size {
		._8 { g.write8(0x83) }
		._32 { g.write8(0x81) }
		else { panic('unhandled cmp') }
	}
	// Third byte depends on the register being compared to
	match reg {
		.r12 { g.write8(0xfc) }
		else { panic('unhandled cmp') }
	}
	g.write8(int(val))
}

fn (mut g Gen) get_var_offset(var_name string) int {
	offset := g.var_offset[var_name]
	if offset == 0 {
		panic('0 offset for var `$var_name`')
	}
	return offset
}

// `a == 1`
// `cmp DWORD [rbp-0x4],0x1`
fn (mut g Gen) cmp_var(var_name string, val int) {
	g.write8(0x81) // 83 for 1 byte?
	g.write8(0x7d)
	offset := g.get_var_offset(var_name)
	g.write8(0xff - offset + 1)
	g.write32(val)
	g.println('cmp var `$var_name` $val')
}

// `add DWORD [rbp-0x4], 1`
fn (mut g Gen) inc_var(var_name string) {
	g.write16(0x4581) // 83 for 1 byte
	offset := g.get_var_offset(var_name)
	g.write8(0xff - offset + 1)
	g.write32(1)
	g.println('inc_var `$var_name`')
}

// Returns the position of the address to jump to (set later).
fn (mut g Gen) jne() int {
	g.write16(0x850f)
	pos := g.pos()
	g.write32(placeholder)
	g.println('jne')
	return pos
}

fn (mut g Gen) jge() int {
	g.write16(0x8d0f)
	pos := g.pos()
	g.write32(placeholder)
	g.println('jne')
	return pos
}

fn (mut g Gen) jmp(addr int) {
	g.write8(0xe9)
	g.write32(addr) // 0xffffff
	g.println('jmp')
}

fn abs(a i64) i64 {
	return if a < 0 {
		-a
	} else {
		a
	}
}

fn (mut g Gen) jle(addr i64) {
	// Calculate the relative offset to jump to
	// (`addr` is absolute address)
	offset := 0xff - int(abs(addr - g.buf.len)) - 1
	g.write8(0x7e)
	g.write8(offset)
	g.println('jle')
}

fn (mut g Gen) println(comment string) {
	addr := g.debug_pos.hex()
	// println('$g.debug_pos "$addr"')
	print(term.red(strings.repeat(`0`, 6 - addr.len) + addr + '  '))
	for i := g.debug_pos; i < g.buf.len; i++ {
		s := g.buf[i].hex()
		if s.len == 1 {
			print(term.blue('0'))
		}
		print(term.blue(g.buf[i].hex()) + ' ')
	}
	g.debug_pos = g.buf.len
	print(' ' + comment)
	println('')
}

fn (mut g Gen) jl(addr i64) {
	offset := 0xff - int(abs(addr - g.buf.len)) - 1
	g.write8(0x7c)
	g.write8(offset)
	g.println('jl')
}

fn (g &Gen) abs_to_rel_addr(addr i64) int {
	return int(abs(addr - g.buf.len)) - 1
}

/*
fn (mut g Gen) jmp(addr i64) {
	offset := 0xff - g.abs_to_rel_addr(addr)
	g.write8(0xe9)
	g.write8(offset)
}
*/
fn (mut g Gen) mov64(reg Register, val i64) {
	match reg {
		.rsi {
			g.write8(0x48)
			g.write8(0xbe)
		}
		else {
			println('unhandled mov $reg')
		}
	}
	g.write64(val)
	g.println('mov64 $reg, $val')
}

fn (mut g Gen) mov_from_reg(var_offset int, reg Register) {
	// 89 7d fc                mov    DWORD PTR [rbp-0x4],edi
	g.write8(0x89)
	match reg {
		.edi, .rdi { g.write8(0x7d) }
		.rsi { g.write8(0x75) }
		.rdx { g.write8(0x55) }
		.rcx { g.write8(0x4d) }
		else { verror('mov_from_reg $reg') }
	}
	g.write8(0xff - var_offset + 1)
	g.println('mov from reg')
}

fn (mut g Gen) call(addr int) {
	// Need to calculate the difference between current position (position after the e8 call)
	// and the function to call.
	// +5 is to get the posistion "e8 xx xx xx xx"
	// Not sure about the -1.
	rel := 0xffffffff - (g.buf.len + 5 - addr - 1)
	// println('call addr=$addr.hex() rel_addr=$rel.hex() pos=$g.buf.len')
	g.write8(0xe8)
	g.write32(rel)
	// g.println('fn call')
}

fn (mut g Gen) syscall() {
	// g.write(0x050f)
	g.write8(0x0f)
	g.write8(0x05)
	g.println('syscall')
}

pub fn (mut g Gen) ret() {
	g.write8(0xc3)
	g.println('ret')
}

pub fn (mut g Gen) push(reg Register) {
	if reg < .r8 {
		g.write8(0x50 + reg)
	} else {
		g.write8(0x41)
		g.write8(0x50 + reg - 8)
	}
	/*
	match reg {
		.rbp { g.write8(0x55) }
		else {}
	}
	*/
	g.println('push $reg')
}

pub fn (mut g Gen) pop(reg Register) {
	g.write8(0x58 + reg)
	// TODO r8...
	g.println('pop $reg')
}

pub fn (mut g Gen) sub32(reg Register, val int) {
	g.write8(0x48)
	g.write8(0x81)
	g.write8(0xe8 + reg) // TODO rax is different?
	g.write32(val)
	g.println('sub $reg,0x$val.hex()')
}

pub fn (mut g Gen) add(reg Register, val int) {
	g.write8(0x48)
	g.write8(0x81)
	g.write8(0xe8 + reg) // TODO rax is different?
	g.write32(val)
	g.println('add $reg,0x$val.hex()')
}

fn (mut g Gen) leave() {
	g.write8(0xc9)
	g.println('leave')
}

// returns label's relative address
pub fn (mut g Gen) gen_loop_start(from int) int {
	g.mov(.r12, from)
	label := g.buf.len
	g.inc(.r12)
	return label
}

pub fn (mut g Gen) gen_loop_end(to, label int) {
	g.cmp(.r12, ._8, to)
	g.jl(label)
}

pub fn (mut g Gen) save_main_fn_addr() {
	g.main_fn_addr = g.buf.len
}

pub fn (mut g Gen) gen_print_from_expr(expr ast.Expr, newline bool) {
	match expr {
		ast.StringLiteral {
			if newline {
				g.gen_print(it.val + '\n')
			} else {
				g.gen_print(it.val)
			}
		}
		else {}
	}
}

pub fn (mut g Gen) gen_print(s string) {
	//
	// qq := s + '\n'
	//
	g.strings << s
	// g.string_addr[s] = str_pos
	g.mov(.eax, 1)
	g.mov(.edi, 1)
	str_pos := g.buf.len + 2
	g.str_pos << str_pos
	g.mov64(.rsi, 0) // segment_start +  0x9f) // str pos // placeholder
	g.mov(.edx, s.len) // len
	g.syscall()
}

pub fn (mut g Gen) gen_exit() {
	// Return 0
	g.mov(.edi, 0) // ret value
	g.mov(.eax, 60)
	g.syscall()
}

fn (mut g Gen) mov(reg Register, val int) {
	match reg {
		.eax, .rax {
			g.write8(0xb8)
		}
		.edi, .rdi {
			g.write8(0xbf)
		}
		.edx {
			g.write8(0xba)
		}
		.rsi {
			g.write8(0x48)
			g.write8(0xbe)
		}
		.r12 {
			g.write8(0x41)
			g.write8(0xbc) // r11 is 0xbb etc
		}
		else {
			panic('unhandled mov $reg')
		}
	}
	g.write32(val)
	g.println('mov $reg, $val')
}

fn (mut g Gen) mov_reg(a, b Register) {
	match a {
		.rbp {
			g.write8(0x48)
			g.write8(0x89)
		}
		else {}
	}
}

// generates `mov rbp, rsp`
fn (mut g Gen) mov_rbp_rsp() {
	g.write8(0x48)
	g.write8(0x89)
	g.write8(0xe5)
	g.println('mov rbp,rsp')
}

pub fn (mut g Gen) register_function_address(name string) {
	addr := g.pos()
	// println('reg fn addr $name $addr')
	g.fn_addr[name] = addr
}

pub fn (mut g Gen) call_fn(node ast.CallExpr) {
	name := node.name
	// println('call fn $name')
	addr := g.fn_addr[name]
	if addr == 0 {
		verror('fn addr of `$name` = 0')
	}
	// Copy values to registers (calling convention)
	// g.mov(.eax, 0)
	for i in 0 .. node.args.len {
		expr := node.args[i].expr
		int_lit := expr as ast.IntegerLiteral
		g.mov(fn_arg_registers[i], int_lit.val.int())
	}
	if node.args.len > 6 {
		verror('more than 6 args not allowed for now')
	}
	g.call(int(addr))
	g.println('fn call `${name}()`')
	// println('call $name $addr')
}

fn (mut g Gen) stmt(node ast.Stmt) {
	match node {
		ast.AssignStmt {
			g.assign_stmt(it)
		}
		ast.ConstDecl {}
		ast.ExprStmt {
			g.expr(it.expr)
		}
		ast.FnDecl {
			g.fn_decl(it)
		}
		ast.ForStmt {
			g.for_stmt(it)
		}
		ast.HashStmt {
			words := it.val.split(' ')
			for word in words {
				if word.len != 2 {
					verror('opcodes format: xx xx xx xx')
				}
				b := C.strtol(word.str, 0, 16)
				// b := word.byte()
				// println('"$word" $b')
				g.write8(b)
			}
		}
		ast.Module {}
		ast.Return {
			g.gen_exit()
			g.ret()
		}
		ast.StructDecl {}
		ast.UnsafeStmt {
			g.stmts(it.stmts)
		}
		else {
			println('x64.stmt(): bad node: ' + typeof(node))
		}
	}
}

fn C.strtol() int

fn (mut g Gen) expr(node ast.Expr) {
	// println('cgen expr()')
	match node {
		ast.ArrayInit {}
		ast.AssignExpr {}
		ast.CallExpr {
			if it.name in ['println', 'print', 'eprintln', 'eprint'] {
				expr := it.args[0].expr
				g.gen_print_from_expr(expr, it.name in ['println', 'eprintln'])
				return
			}
			g.call_fn(it)
		}
		ast.FloatLiteral {}
		ast.Ident {}
		ast.IfExpr {
			g.if_expr(it)
		}
		ast.InfixExpr {}
		ast.IntegerLiteral {}
		ast.PostfixExpr {
			g.postfix_expr(it)
		}
		ast.StringLiteral {}
		ast.StructInit {}
		ast.BoolLiteral {}
		else {
			println(term.red('x64.expr(): unhandled node: ' + typeof(node)))
		}
	}
}

fn (mut g Gen) allocate_var(name string, size, initial_val int) {
	// `a := 3`  =>
	// `move DWORD [rbp-0x4],0x3`
	match size {
		1 {
			// BYTE
			g.write8(0xc6)
			g.write8(0x45)
		}
		4 {
			// DWORD
			g.write8(0xc7)
			g.write8(0x45)
		}
		8 {
			// QWORD
			g.write8(0x48)
			g.write8(0xc7)
			g.write8(0x45)
		}
		else {
			verror('allocate_var: bad size $size')
		}
	}
	// Generate N in `[rbp-N]`
	n := g.stack_var_pos + size
	g.write8(0xff - n + 1)
	g.stack_var_pos += size
	g.var_offset[name] = g.stack_var_pos
	// Generate the value assigned to the variable
	g.write32(initial_val)
	// println('allocate_var(size=$size, initial_val=$initial_val)')
	g.println('mov DWORD [rbp-0x$n],$initial_val (Aallocate var `$name`)')
}

fn (mut g Gen) assign_stmt(node ast.AssignStmt) {
	// `a := 1` | `a,b := 1,2`
	for ident in node.left {
		match node.right[0] {
			ast.IntegerLiteral {
				g.allocate_var(ident.name, 4, it.val.int())
			}
			ast.InfixExpr {
				g.infix_expr(it)
				g.allocate_var(ident.name, 4, 0)
			}
			else {
				g.error_with_pos('assign_stmt unhandled expr: ' + typeof(node.right[0]), node.right[0].position())
			}
		}
	}
}

fn (mut g Gen) infix_expr(node ast.InfixExpr) {
	println('infix expr op=$node.op')
	match node.op {
		.plus {}
		else {}
	}
}

fn (mut g Gen) if_expr(node ast.IfExpr) {
	branch := node.branches[0]
	infix_expr := branch.cond as ast.InfixExpr
	mut jne_addr := 0 // location of `jne *00 00 00 00*`
	match infix_expr.left {
		ast.Ident {
			lit := infix_expr.right as ast.IntegerLiteral
			g.cmp_var(it.name, lit.val.int())
			jne_addr = g.jne()
		}
		else {
			verror('unhandled infix.left')
		}
	}
	g.stmts(branch.stmts)
	// Now that we know where we need to jump if the condition is false, update the `jne` call.
	// The value is the relative address, difference between current position and the location
	// after `jne 00 00 00 00`
	// println('after if g.pos=$g.pos() jneaddr=$jne_addr')
	g.write32_at(jne_addr, g.pos() - jne_addr - 4) // 4 is for "00 00 00 00"
}

fn (mut g Gen) for_stmt(node ast.ForStmt) {
	infix_expr := node.cond as ast.InfixExpr
	// g.mov(.eax, 0x77777777)
	mut jump_addr := 0 // location of `jne *00 00 00 00*`
	start := g.pos()
	match infix_expr.left {
		ast.Ident {
			lit := infix_expr.right as ast.IntegerLiteral
			g.cmp_var(it.name, lit.val.int())
			jump_addr = g.jge()
		}
		else {
			verror('unhandled infix.left')
		}
	}
	g.stmts(node.stmts)
	// Go back to `cmp ...`
	// Diff between `jmp 00 00 00 00 X` and `cmp`
	g.jmp(0xffffffff - (g.pos() + 5 - start) + 1)
	// Update the jump addr to current pos
	g.write32_at(jump_addr, g.pos() - jump_addr - 4) // 4 is for "00 00 00 00"
	g.println('jpm after for')
}

fn (mut g Gen) fn_decl(node ast.FnDecl) {
	println(term.green('\n$node.name:'))
	g.stack_var_pos = 0
	is_main := node.name == 'main'
	// println('saving addr $node.name $g.buf.len.hex()')
	if is_main {
		g.save_main_fn_addr()
	} else {
		g.register_function_address(node.name)
	}
	g.push(.rbp)
	g.mov_rbp_rsp()
	if !is_main {
		g.sub32(.rsp, 0x20)
	}
	if node.args.len > 0 {
		// g.mov(.r12, 0x77777777)
	}
	// Copy values from registers to local vars (calling convention)
	mut offset := 0
	for i in 0 .. node.args.len {
		name := node.args[i].name
		// TODO optimize. Right now 2 mov's are used instead of 1.
		g.allocate_var(name, 4, 0)
		// `mov DWORD PTR [rbp-0x4],edi`
		offset += 4
		g.mov_from_reg(offset, fn_arg_registers[i])
	}
	//
	g.stmts(node.stmts)
	if is_main {
		// println('end of main: gen exit')
		g.gen_exit()
		// return
	}
	if !is_main {
		g.leave()
		// g.add(.rsp, 0x20)
		// g.pop(.rbp)
	}
	g.ret()
}

fn (mut g Gen) postfix_expr(node ast.PostfixExpr) {
	if !(node.expr is ast.Ident) {
		return
	}
	ident := node.expr as ast.Ident
	var_name := ident.name
	if node.op == .inc {
		g.inc_var(var_name)
	}
}

fn verror(s string) {
	util.verror('x64 gen error', s)
}

pub fn (mut g Gen) error_with_pos(s string, pos token.Position) {
	// TODO: store a file index in the Position too,
	// so that the file path can be retrieved from the pos, instead
	// of guessed from the pref.path ...
	mut kind := 'error:'
	if g.pref.output_mode == .stdout {
		ferror := util.formatted_error(kind, s, g.pref.path, pos)
		eprintln(ferror)
		exit(1)
	} else {
		g.errors << errors.Error{
			file_path: g.pref.path
			pos: pos
			reporter: .gen
			message: s
		}
	}
}
fn if_test() {
	a := 1
	if a == 1 {
		println('a == 1')
		b := 2
		if b == 2 {
			println('b == 2')
		}
		//if b != 2 {
			//println('b != 2')
		//}
	}
	if a == 2 {
		println('a == 2')
	}
	a++
	if a == 2 {
		println('now a == 2')
	}
}

fn loop() {
	mut i := 0
	for i < 5 {
		println('hello')
		i++
	}
}

fn foo(a int) {
	println('foo:')
	if a == 1 {
		println('a == 1')
	}
	a++
	if a == 2 {
		println('a == 2')
	}
	if a == 3 {
		println('a == 3')
	}
}

fn args() {
	println('===args===')
	foo(1)
	foo(2)
}

/*
fn expr() {
	println('===expr===')
	a := 1
	b := 2
	c := a + b
	println('c==')
	if c == 0 {
		println('0')
	}
	if c == 3 {
		println('3')
	}
}
*/


struct User {
	age int
	nr_orders int
}

fn main() {
	if_test()
	loop()
	args()
	//expr()
}
a == 1
b == 2
now a == 2
hello
hello
hello
hello
hello
===args===
foo:
a == 1
a == 2
foo:
a == 3

fn main() {
	println('hello from x64')
}
hello from x64
fn print_greeting(){
	println('hello from x64')
}

fn print_number() {
	println('123')
}

fn main() {
	println('start')
	print_greeting()
	print_number()
	println('end')
}
start
hello from x64
123
end
import os
import benchmark
import term

// TODO some logic copy pasted from valgrind_test.v and compiler_test.v, move to a module
fn test_x64() {
	if os.user_os() != 'linux' {
		eprintln('x64 tests can only be run on Linux for now.')
		exit(0)
	}
	mut bench := benchmark.new_benchmark()
	vexe := os.getenv('VEXE')
	vroot := os.dir(vexe)
	dir := os.join_path(vroot, 'vlib/v/gen/x64/tests')
	files := os.ls(dir) or {
		panic(err)
	}
	//
	wrkdir := os.join_path(os.temp_dir(), 'vtests', 'x64')
	os.mkdir_all(wrkdir)
	os.chdir(wrkdir)
	tests := files.filter(it.ends_with('.vv'))
	if tests.len == 0 {
		println('no x64 tests found')
		assert false
	}
	bench.set_total_expected_steps(tests.len)
	for test in tests {
		bench.step()
		full_test_path := os.real_path(test)
		println('x.v: $wrkdir/x.v')
		os.system('cp ${dir}/${test} $wrkdir/x.v') // cant run .vv file
		os.exec('$vexe -o exe -x64 $wrkdir/x.v') or {
			bench.fail()
			eprintln(bench.step_message_fail('x64 $test failed'))
			continue
		}
		res := os.exec('./exe') or {
			bench.fail()
			continue
		}
		if res.exit_code != 0 {
			bench.fail()
			eprintln(bench.step_message_fail('$full_test_path failed to run'))
			eprintln(res.output)
			continue
		}
		mut expected := os.read_file('$dir/${test}.out') or {
			panic(err)
		}
		expected = expected.trim_space().trim('\n').replace('\r\n', '\n')
		mut found := res.output.trim_space().trim('\n').replace('\r\n', '\n')
		found = found.trim_space()
		if expected != found {
			println(term.red('FAIL'))
			println('============')
			println('expected: "$expected" len=$expected.len')
			println('============')
			println('found:"$found" len=$found.len')
			println('============\n')
			bench.fail()
			continue
		}
		bench.ok()
		eprintln(bench.step_message_ok('testing file: $test'))
	}
	bench.stop()
	eprintln(term.h_divider('-'))
	eprintln(bench.total_message('x64'))
	if bench.nfail > 0 {
		exit(1)
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

import v.ast

fn (mut p Parser) assign_stmt() ast.Stmt {
	return p.partial_assign_stmt([])
}

fn (mut p Parser) check_undefined_variables(idents []ast.Ident, expr ast.Expr) {
	match expr {
		ast.Ident {
			for ident in idents {
				if ident.name == it.name {
					p.error_with_pos('undefined: `$it.name`', it.pos)
				}
			}
		}
		ast.InfixExpr {
			p.check_undefined_variables(idents, it.left)
			p.check_undefined_variables(idents, it.right)
		}
		ast.StringInterLiteral {
			for expr_ in it.exprs {
				p.check_undefined_variables(idents, expr_)
			}
		}
		else {}
	}
}

fn (mut p Parser) partial_assign_stmt(known_lhs []ast.Ident) ast.Stmt {
	mut idents := known_lhs
	mut op := p.tok.kind
	// read (more) idents until assignment sign
	for op !in [.decl_assign, .assign] {
		idents << p.parse_assign_ident()
		if p.tok.kind == .comma {
			p.next()
		}
		op = p.tok.kind
	}
	p.next()
	pos := p.tok.position()
	exprs := p.parse_assign_rhs()
	is_decl := op == .decl_assign
	if is_decl {
		// a, b := a + 1, b
		for expr in exprs {
			p.check_undefined_variables(idents, expr)
		}
	}
	for i, ident in idents {
		known_var := p.scope.known_var(ident.name)
		if !is_decl && !known_var {
			p.error('unknown variable `$ident.name`')
		}
		if is_decl && ident.kind != .blank_ident {
			if p.scope.known_var(ident.name) {
				p.error('redefinition of `$ident.name`')
			}
			if idents.len == exprs.len {
				p.scope.register(ident.name, ast.Var{
					name: ident.name
					expr: exprs[i]
					is_mut: ident.is_mut || p.inside_for
					pos: ident.pos
				})
			} else {
				p.scope.register(ident.name, ast.Var{
					name: ident.name
					is_mut: ident.is_mut || p.inside_for
					pos: ident.pos
				})
			}
		}
	}
	return ast.AssignStmt{
		left: idents
		right: exprs
		op: op
		pos: pos
		is_static: false // individual idents may be static
	}
}

// TODO: is it possible to merge with AssignStmt?
pub fn (mut p Parser) assign_expr(left ast.Expr) ast.AssignExpr {
	op := p.tok.kind
	pos := p.tok.position()
	p.next()
	val := p.expr(0)
	match left {
		ast.IndexExpr {
			// it.mark_as_setter()
			it.is_setter = true
		}
		else {}
	}
	node := ast.AssignExpr{
		left: left
		val: val
		op: op
		pos: pos
	}
	return node
}

fn (mut p Parser) parse_assign_ident() ast.Ident {
	/// returns a single parsed ident
	return p.parse_ident(.v)
}

// right hand side of `=` or `:=` in `a,b,c := 1,2,3`
fn (mut p Parser) parse_assign_rhs() []ast.Expr {
	mut exprs := []ast.Expr{}
	for {
		expr := p.expr(0)
		exprs << expr
		if p.tok.kind == .comma {
			p.next()
		} else {
			break
		}
	}
	return exprs
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

import v.ast
import v.pref
import v.vmod
import v.table

const (
	supported_platforms = ['windows', 'mac', 'macos', 'darwin', 'linux', 'freebsd', 'openbsd',
		'netbsd', 'dragonfly', 'android', 'js', 'solaris', 'haiku', 'linux_or_macos']
)

// // #include, #flag, #v
fn (mut p Parser) hash() ast.HashStmt {
	val := p.tok.lit
	p.next()
	if val.starts_with('flag') {
		// #flag linux -lm
		mut flag := val[5..]
		// expand `@VROOT` to its absolute path
		if flag.contains('@VROOT') {
			vmod_file_location := vmod.mod_file_cacher.get(p.file_name_dir)
			if vmod_file_location.vmod_file.len == 0 {
				// There was no actual v.mod file found.
				p.error('To use @VROOT, you need' + ' to have a "v.mod" file in ${p.file_name_dir},' +
					' or in one of its parent folders.')
			}
			flag = flag.replace('@VROOT', vmod_file_location.vmod_folder)
		}
		for deprecated in ['@VMOD', '@VMODULE', '@VPATH', '@VLIB_PATH'] {
			if flag.contains(deprecated) {
				p.error('${deprecated} had been deprecated, use @VROOT instead.')
			}
		}
		// println('adding flag "$flag"')
		p.table.parse_cflag(flag, p.mod, p.pref.compile_defines_all) or {
			p.error(err)
		}
		/*
		words := val.split(' ')
		if words.len > 1 && words[1] in supported_platforms {
			if p.pref.os == .mac && words[1] == 'darwin' {
				p.pref.cflags += val.after('darwin')
			}
		}
		*/
	}
	return ast.HashStmt{
		val: val
		mod: p.mod
	}
}

fn (mut p Parser) vweb() ast.ComptimeCall {
	p.check(.name) // skip `vweb.html()` TODO
	p.check(.dot)
	p.check(.name)
	p.check(.lpar)
	p.check(.rpar)
	return ast.ComptimeCall{}
}

fn (mut p Parser) comp_if() ast.Stmt {
	pos := p.tok.position()
	p.next()
	if p.tok.kind == .name && p.tok.lit == 'vweb' {
		return p.vweb()
	}
	p.check(.key_if)
	is_not := p.tok.kind == .not
	if is_not {
		p.next()
	}
	val := p.check_name()
	mut stmts := []ast.Stmt{}
	mut skip_os := false
	if val in supported_platforms {
		os := os_from_string(val)
		// `$if os {` for a different target, skip everything inside
		// to avoid compilation errors (like including <windows.h> or calling WinAPI fns
		// on non-Windows systems)
		if !p.pref.is_fmt && ((!is_not && os != p.pref.os) || (is_not && os == p.pref.os)) &&
			!p.pref.output_cross_c {
			skip_os = true
			p.check(.lcbr)
			// p.warn('skipping $if $val os=$os p.pref.os=$p.pref.os')
			mut stack := 1
			for {
				if p.tok.kind == .key_return {
					p.returns = true
				}
				if p.tok.kind == .lcbr {
					stack++
				} else if p.tok.kind == .rcbr {
					stack--
				}
				if p.tok.kind == .eof {
					break
				}
				if stack <= 0 && p.tok.kind == .rcbr {
					// p.warn('exiting $stack')
					p.next()
					break
				}
				p.next()
			}
		}
	}
	mut is_opt := false
	if p.tok.kind == .question {
		p.next()
		is_opt = true
	}
	if !skip_os {
		stmts = p.parse_block()
	}
	mut node := ast.CompIf{
		is_not: is_not
		is_opt: is_opt
		pos: pos
		val: val
		stmts: stmts
	}
	if p.tok.kind == .dollar && p.peek_tok.kind == .key_else {
		p.next()
		p.next()
		node.has_else = true
		node.else_stmts = p.parse_block()
	}
	return node
}

// TODO import warning bug
const (
	todo_delete_me = pref.OS.linux
)

fn os_from_string(os string) pref.OS {
	match os {
		'linux' {
			return .linux
		}
		'windows' {
			return .windows
		}
		'mac' {
			return .mac
		}
		'macos' {
			return .mac
		}
		'freebsd' {
			return .freebsd
		}
		'openbsd' {
			return .openbsd
		}
		'netbsd' {
			return .netbsd
		}
		'dragonfly' {
			return .dragonfly
		}
		'js' {
			return .js
		}
		'solaris' {
			return .solaris
		}
		'android' {
			return .android
		}
		'msvc' {
			// notice that `-os msvc` became `-cc msvc`
			verror('use the flag `-cc msvc` to build using msvc')
		}
		'haiku' {
			return .haiku
		}
		'linux_or_macos' {
			return .linux
		}
		else {
			panic('bad os $os')
		}
	}
	// println('bad os $os') // todo panic?
	return .linux
}

// `user.$method()` (`method` is a string)
fn (mut p Parser) comptime_method_call(typ table.Type) {
	p.check(.dollar)
	method_name := p.check_name()
	_ = method_name
	mut j := 0
	sym := p.table.get_type_symbol(typ)
	if sym.kind != .struct_ {
		p.error('not a struct')
	}
	// info := sym.info as table.Struct
	for method in sym.methods {
		if method.return_type != table.void_type {
			continue
		}
		/*
		receiver := method.args[0]
		if !p.expr_var.ptr {
			p.error('`$p.expr_var.name` needs to be a reference')
		}
		amp := if receiver.is_mut && !p.expr_var.ptr { '&' } else { '' }
		if j > 0 {
			p.gen(' else ')
		}
		p.genln('if (string_eq($method_name, _STR("$method.name")) ) ' + '${typ.name}_$method.name ($amp $p.expr_var.name);')
		*/
		j++
	}
	p.check(.lpar)
	p.check(.rpar)
	if p.tok.kind == .key_orelse {
		p.check(.key_orelse)
		// p.genln('else {')
		p.check(.lcbr)
		// p.statements()
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

import v.ast
import v.table
import v.token

fn (mut p Parser) array_init() ast.ArrayInit {
	first_pos := p.tok.position()
	mut last_pos := p.tok.position()
	p.check(.lsbr)
	// p.warn('array_init() exp=$p.expected_type')
	mut array_type := table.void_type
	mut elem_type := table.void_type
	mut exprs := []ast.Expr{}
	mut is_fixed := false
	mut has_val := false
	mut has_type := false
	if p.tok.kind == .rsbr {
		// []typ => `[]` and `typ` must be on the same line
		line_nr := p.tok.line_nr
		p.next()
		// []string
		if p.tok.kind in [.name, .amp] && p.tok.line_nr == line_nr {
			elem_type = p.parse_type()
			// this is set here becasue its a known type, others could be the
			// result of expr so we do those in checker
			idx := p.table.find_or_register_array(elem_type, 1)
			array_type = table.new_type(idx)
			has_type = true
		}
	} else {
		// [1,2,3] or [const]byte
		for i := 0; p.tok.kind != .rsbr; i++ {
			expr := p.expr(0)
			exprs << expr
			if p.tok.kind == .comma {
				p.next()
			}
			// p.check_comment()
		}
		line_nr := p.tok.line_nr
		$if tinyc {
			// NB: do not remove the next line without testing
			// v selfcompilation with tcc first
			tcc_stack_bug := 12345
			_ = tcc_stack_bug
		}
		last_pos = p.tok.position()
		p.check(.rsbr)
		if exprs.len == 1 && p.tok.kind in [.name, .amp] && p.tok.line_nr == line_nr {
			// [100]byte
			elem_type = p.parse_type()
			is_fixed = true
		} else {
			if p.tok.kind == .not {
				last_pos = p.tok.position()
				p.next()
			}
			if p.tok.kind == .not {
				last_pos = p.tok.position()
				p.next()
				is_fixed = true
				has_val = true
			}
		}
	}
	if exprs.len == 0 && p.tok.kind != .lcbr && has_type {
		p.warn_with_pos('use `x := []Type{}` instead of `x := []Type`', last_pos)
	}
	mut has_len := false
	mut has_cap := false
	mut has_default := false
	mut len_expr := ast.Expr{}
	mut cap_expr := ast.Expr{}
	mut default_expr := ast.Expr{}
	if p.tok.kind == .lcbr && exprs.len == 0 {
		// `[]int{ len: 10, cap: 100}` syntax
		p.next()
		for p.tok.kind != .rcbr {
			key := p.check_name()
			p.check(.colon)
			match key {
				'len' {
					has_len = true
					len_expr = p.expr(0)
				}
				'cap' {
					has_cap = true
					cap_expr = p.expr(0)
				}
				'init' {
					has_default = true
					default_expr = p.expr(0)
				}
				else {
					p.error('wrong field `$key`, expecting `len`, `cap`, or `init`')
				}
			}
			if p.tok.kind != .rcbr {
				p.check(.comma)
			}
		}
		p.check(.rcbr)
	}
	pos := token.Position{
		line_nr: first_pos.line_nr
		pos: first_pos.pos
		len: last_pos.pos - first_pos.pos + last_pos.len
	}
	return ast.ArrayInit{
		is_fixed: is_fixed
		has_val: has_val
		mod: p.mod
		elem_type: elem_type
		typ: array_type
		exprs: exprs
		pos: pos
		has_len: has_len
		len_expr: len_expr
		has_cap: has_cap
		has_default: has_default
		cap_expr: cap_expr
		default_expr: default_expr
	}
}

fn (mut p Parser) map_init() ast.MapInit {
	pos := p.tok.position()
	mut keys := []ast.Expr{}
	mut vals := []ast.Expr{}
	for p.tok.kind != .rcbr && p.tok.kind != .eof {
		// p.check(.str)
		key := p.expr(0)
		keys << key
		p.check(.colon)
		val := p.expr(0)
		vals << val
		if p.tok.kind == .comma {
			p.next()
		}
	}
	return ast.MapInit{
		keys: keys
		vals: vals
		pos: pos
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

import v.ast
import v.table
import v.token
import v.util

pub fn (mut p Parser) call_expr(language table.Language, mod string) ast.CallExpr {
	first_pos := p.tok.position()
	fn_name := if language == .c {
		'C.${p.check_name()}'
	} else if language == .js {
		'JS.${p.check_js_name()}'
	} else if mod.len > 0 {
		'${mod}.${p.check_name()}'
	} else {
		p.check_name()
	}
	mut or_kind := ast.OrKind.absent
	if fn_name == 'json.decode' {
		p.expecting_type = true // Makes name_expr() parse the type `User` in `json.decode(User, txt)`
		p.expr_mod = ''
		or_kind = .block
	}
	mut generic_type := table.void_type
	if p.tok.kind == .lt {
		// `foo<int>(10)`
		p.next() // `<`
		generic_type = p.parse_type()
		p.check(.gt) // `>`
		p.table.register_fn_gen_type(fn_name, generic_type)
	}
	p.check(.lpar)
	args := p.call_args()
	last_pos := p.tok.position()
	p.check(.rpar)
	pos := token.Position{
		line_nr: first_pos.line_nr
		pos: first_pos.pos
		len: last_pos.pos - first_pos.pos + last_pos.len
	}
	mut or_stmts := []ast.Stmt{}
	if p.tok.kind == .key_orelse {
		// `foo() or {}``
		was_inside_or_expr := p.inside_or_expr
		p.inside_or_expr = true
		p.next()
		p.open_scope()
		p.scope.register('err', ast.Var{
			name: 'err'
			typ: table.string_type
			pos: p.tok.position()
			is_used: true
		})
		p.scope.register('errcode', ast.Var{
			name: 'errcode'
			typ: table.int_type
			pos: p.tok.position()
			is_used: true
		})
		or_kind = .block
		or_stmts = p.parse_block_no_scope()
		p.close_scope()
		p.inside_or_expr = was_inside_or_expr
	}
	if p.tok.kind == .question {
		// `foo()?`
		p.next()
		or_kind = .propagate
	}
	node := ast.CallExpr{
		name: fn_name
		args: args
		mod: p.mod
		pos: pos
		language: language
		or_block: ast.OrExpr{
			stmts: or_stmts
			kind: or_kind
			pos: pos
		}
		generic_type: generic_type
	}
	return node
}

pub fn (mut p Parser) call_args() []ast.CallArg {
	mut args := []ast.CallArg{}
	for p.tok.kind != .rpar {
		mut is_mut := false
		if p.tok.kind == .key_mut {
			p.next()
			is_mut = true
		}
		e := p.expr(0)
		args << ast.CallArg{
			is_mut: is_mut
			expr: e
		}
		if p.tok.kind != .rpar {
			p.check(.comma)
		}
	}
	return args
}

fn (mut p Parser) fn_decl() ast.FnDecl {
	start_pos := p.tok.position()
	is_deprecated := p.attr == 'deprecated'
	is_pub := p.tok.kind == .key_pub
	if is_pub {
		p.next()
	}
	p.check(.key_fn)
	p.open_scope()
	// C. || JS.
	language := if p.tok.kind == .name && p.tok.lit == 'C' {
		table.Language.c
	} else if p.tok.kind == .name && p.tok.lit == 'JS' {
		table.Language.js
	} else {
		table.Language.v
	}
	if language != .v {
		p.next()
		p.check(.dot)
	}
	// Receiver?
	mut rec_name := ''
	mut is_method := false
	mut receiver_pos := token.Position{}
	mut rec_type := table.void_type
	mut rec_mut := false
	mut args := []table.Arg{}
	if p.tok.kind == .lpar {
		p.next() // (
		is_method = true
		rec_mut = p.tok.kind == .key_mut
		if rec_mut {
			p.next() // `mut`
		}
		rec_start_pos := p.tok.position()
		rec_name = p.check_name()
		if !rec_mut {
			rec_mut = p.tok.kind == .key_mut
			if rec_mut {
				p.warn_with_pos('use `(mut f Foo)` instead of `(f mut Foo)`', p.tok.position())
			}
		}
		receiver_pos = rec_start_pos.extend(p.tok.position())
		is_amp := p.tok.kind == .amp
		// if rec_mut {
		// p.check(.key_mut)
		// }
		// TODO: talk to alex, should mut be parsed with the type like this?
		// or should it be a property of the arg, like this ptr/mut becomes indistinguishable
		rec_type = p.parse_type_with_mut(rec_mut)
		sym := p.table.get_type_symbol(rec_type)
		if sym.mod != p.mod && sym.mod != '' {
			p.error('cannot define methods on types from other modules (current module is `$p.mod`, `$sym.name` is from `$sym.mod`)')
		}
		if is_amp && rec_mut {
			p.error('use `(mut f Foo)` or `(f &Foo)` instead of `(mut f &Foo)`')
		}
		args << table.Arg{
			name: rec_name
			is_mut: rec_mut
			typ: rec_type
		}
		p.check(.rpar)
	}
	mut name := ''
	if p.tok.kind == .name {
		// TODO high order fn
		name = if language == .js {
			p.check_js_name()
		} else {
			p.check_name()
		}
		if language == .v && !p.pref.translated && util.contains_capital(name) {
			p.error('function names cannot contain uppercase letters, use snake_case instead')
		}
		if is_method && p.table.get_type_symbol(rec_type).has_method(name) {
			p.error('duplicate method `$name`')
		}
	}
	if p.tok.kind in [.plus, .minus, .mul, .div, .mod] {
		name = p.tok.kind.str() // op_to_fn_name()
		p.next()
	}
	// <T>
	is_generic := p.tok.kind == .lt
	if is_generic {
		p.next()
		p.next()
		p.check(.gt)
	}
	// Args
	args2, is_variadic := p.fn_args()
	args << args2
	for i, arg in args {
		if p.scope.known_var(arg.name) {
			p.error('redefinition of parameter `$arg.name`')
		}
		p.scope.register(arg.name, ast.Var{
			name: arg.name
			typ: arg.typ
			is_mut: arg.is_mut
			pos: p.tok.position()
			is_used: true
			is_arg: true
		})
		// Do not allow `mut` with simple types
		// TODO move to checker?
		if arg.is_mut {
			if i == 0 && is_method {
				continue
			}
			sym := p.table.get_type_symbol(arg.typ)
			if sym.kind !in [.array, .struct_, .map, .placeholder] && !arg.typ.is_ptr() {
				p.error('mutable arguments are only allowed for arrays, maps, and structs\n' +
					'return values instead: `fn foo(n mut int) {` => `fn foo(n int) int {`')
			}
		}
	}
	mut end_pos := p.prev_tok.position()
	// Return type
	mut return_type := table.void_type
	if p.tok.kind.is_start_of_type() {
		end_pos = p.tok.position()
		return_type = p.parse_type()
	}
	ctdefine := p.attr_ctdefine
	// Register
	if is_method {
		mut type_sym := p.table.get_type_symbol(rec_type)
		// p.warn('reg method $type_sym.name . $name ()')
		type_sym.register_method(table.Fn{
			name: name
			args: args
			return_type: return_type
			is_variadic: is_variadic
			is_generic: is_generic
			is_pub: is_pub
			ctdefine: ctdefine
		})
	} else {
		if language == .c {
			name = 'C.$name'
		} else if language == .js {
			name = 'JS.$name'
		} else {
			name = p.prepend_mod(name)
		}
		if _ := p.table.find_fn(name) {
			p.fn_redefinition_error(name)
		}
		p.table.register_fn(table.Fn{
			name: name
			args: args
			return_type: return_type
			is_variadic: is_variadic
			language: language
			is_generic: is_generic
			is_pub: is_pub
			ctdefine: ctdefine
			mod: p.mod
		})
	}
	// Body
	mut stmts := []ast.Stmt{}
	no_body := p.tok.kind != .lcbr
	body_start_pos := p.peek_tok.position()
	if p.tok.kind == .lcbr {
		stmts = p.parse_block_no_scope()
	}
	p.close_scope()
	p.attr = ''
	p.attr_ctdefine = ''
	return ast.FnDecl{
		name: name
		stmts: stmts
		return_type: return_type
		args: args
		is_deprecated: is_deprecated
		is_pub: is_pub
		is_generic: is_generic
		is_variadic: is_variadic
		receiver: ast.Field{
			name: rec_name
			typ: rec_type
		}
		receiver_pos: receiver_pos
		is_method: is_method
		rec_mut: rec_mut
		language: language
		no_body: no_body
		pos: start_pos.extend(end_pos)
		body_pos: body_start_pos
		file: p.file_name
		is_builtin: p.builtin_mod || p.mod in util.builtin_module_parts
		ctdefine: ctdefine
	}
}

fn (mut p Parser) anon_fn() ast.AnonFn {
	pos := p.tok.position()
	p.check(.key_fn)
	p.open_scope()
	// TODO generics
	args, is_variadic := p.fn_args()
	for arg in args {
		p.scope.register(arg.name, ast.Var{
			name: arg.name
			typ: arg.typ
			pos: p.tok.position()
			is_used: true
			is_arg: true
		})
	}
	mut return_type := table.void_type
	if p.tok.kind.is_start_of_type() {
		return_type = p.parse_type()
	}
	mut stmts := []ast.Stmt{}
	no_body := p.tok.kind != .lcbr
	if p.tok.kind == .lcbr {
		stmts = p.parse_block_no_scope()
	}
	p.close_scope()
	mut func := table.Fn{
		args: args
		is_variadic: is_variadic
		return_type: return_type
	}
	name := 'anon_${p.tok.pos}_$func.signature()'
	func.name = name
	idx := p.table.find_or_register_fn_type(p.mod, func, true, false)
	typ := table.new_type(idx)
	// name := p.table.get_type_name(typ)
	return ast.AnonFn{
		decl: ast.FnDecl{
			name: name
			stmts: stmts
			return_type: return_type
			args: args
			is_variadic: is_variadic
			is_method: false
			is_anon: true
			no_body: no_body
			pos: pos
			file: p.file_name
		}
		typ: typ
	}
}

fn (mut p Parser) fn_args() ([]table.Arg, bool) {
	p.check(.lpar)
	mut args := []table.Arg{}
	mut is_variadic := false
	// `int, int, string` (no names, just types)
	types_only := p.tok.kind in [.amp, .and] || (p.peek_tok.kind == .comma && p.table.known_type(p.tok.lit)) ||
		p.peek_tok.kind == .rpar
	// TODO copy pasta, merge 2 branches
	if types_only {
		// p.warn('types only')
		mut arg_no := 1
		for p.tok.kind != .rpar {
			arg_name := 'arg_$arg_no'
			is_mut := p.tok.kind == .key_mut
			if is_mut {
				p.next()
			}
			if p.tok.kind == .ellipsis {
				p.next()
				is_variadic = true
			}
			mut arg_type := p.parse_type()
			if is_mut {
				// if arg_type.is_ptr() {
				// p.error('cannot mut')
				// }
				// arg_type = arg_type.to_ptr()
				arg_type = arg_type.set_nr_muls(1)
			}
			if is_variadic {
				arg_type = arg_type.set_flag(.variadic)
			}
			if p.tok.kind == .comma {
				if is_variadic {
					p.error('cannot use ...(variadic) with non-final parameter no $arg_no')
				}
				p.next()
			}
			args << table.Arg{
				name: arg_name
				is_mut: is_mut
				typ: arg_type
			}
			arg_no++
		}
	} else {
		for p.tok.kind != .rpar {
			mut is_mut := p.tok.kind == .key_mut
			if is_mut {
				p.next()
			}
			mut arg_names := [p.check_name()]
			// `a, b, c int`
			for p.tok.kind == .comma {
				p.next()
				arg_names << p.check_name()
			}
			if p.tok.kind == .key_mut {
				// TODO remove old syntax
				is_mut = true
			}
			if p.tok.kind == .ellipsis {
				p.next()
				is_variadic = true
			}
			mut typ := p.parse_type()
			if is_mut {
				if typ.is_ptr() {
					// name := p.table.get_type_name(typ)
					// p.warn('`$name` is already a reference, it cannot be marked as `mut`')
				}
				typ = typ.set_nr_muls(1)
			}
			if is_variadic {
				typ = typ.set_flag(.variadic)
			}
			for arg_name in arg_names {
				args << table.Arg{
					name: arg_name
					is_mut: is_mut
					typ: typ
				}
				// if typ.typ.kind == .variadic && p.tok.kind == .comma {
				if is_variadic && p.tok.kind == .comma {
					p.error('cannot use ...(variadic) with non-final parameter $arg_name')
				}
			}
			if p.tok.kind != .rpar {
				p.check(.comma)
			}
		}
	}
	p.check(.rpar)
	return args, is_variadic
}

fn (p &Parser) fileis(s string) bool {
	return p.file_name.contains(s)
}

fn (mut p Parser) fn_redefinition_error(name string) {
	// Find where this function was already declared
	// TODO
	/*
	for file in p.ast_files {

	}
	*/
	p.table.redefined_fns << name
	// p.error('redefinition of function `$name`')
}

fn have_fn_main(stmts []ast.Stmt) bool {
	mut has_main_fn := false
	for stmt in stmts {
		match stmt {
			ast.FnDecl {
				if it.name == 'main' {
					has_main_fn = true
				}
			}
			else {}
		}
	}
	return has_main_fn
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

import v.ast
import v.table

fn (mut p Parser) for_stmt() ast.Stmt {
	p.check(.key_for)
	pos := p.tok.position()
	p.open_scope()
	p.inside_for = true
	// defer { p.close_scope() }
	// Infinite loop
	if p.tok.kind == .lcbr {
		p.inside_for = false
		stmts := p.parse_block()
		p.close_scope()
		return ast.ForStmt{
			stmts: stmts
			pos: pos
			is_inf: true
		}
	} else if p.tok.kind == .key_mut {
		p.error('`mut` is not needed in for loops')
	} else if p.peek_tok.kind in [.decl_assign, .assign, .semicolon] || p.tok.kind == .semicolon {
		// `for i := 0; i < 10; i++ {`
		mut init := ast.Stmt{}
		mut cond := p.new_true_expr()
		// mut inc := ast.Stmt{}
		mut inc := ast.Expr{}
		mut has_init := false
		mut has_cond := false
		mut has_inc := false
		if p.peek_tok.kind in [.assign, .decl_assign] {
			init = p.assign_stmt()
			has_init = true
		} else if p.tok.kind != .semicolon {
		}
		// allow `for ;; i++ {`
		// Allow `for i = 0; i < ...`
		p.check(.semicolon)
		if p.tok.kind != .semicolon {
			cond = p.expr(0)
			has_cond = true
		}
		p.check(.semicolon)
		if p.tok.kind != .lcbr {
			// inc = p.stmt()
			inc = p.expr(0)
			has_inc = true
		}
		p.inside_for = false
		stmts := p.parse_block()
		p.close_scope()
		return ast.ForCStmt{
			stmts: stmts
			has_init: has_init
			has_cond: has_cond
			has_inc: has_inc
			init: init
			cond: cond
			inc: inc
			pos: pos
		}
	} else if p.peek_tok.kind in [.key_in, .comma] {
		// `for i in vals`, `for i in start .. end`
		key_var_pos := p.tok.position()
		mut val_var_pos := p.tok.position()
		mut key_var_name := ''
		mut val_var_name := p.check_name()
		if p.tok.kind == .comma {
			p.next()
			key_var_name = val_var_name
			val_var_pos = p.tok.position()
			val_var_name = p.check_name()
			if p.scope.known_var(key_var_name) {
				p.error('redefinition of key iteration variable `$key_var_name`')
			}
			if p.scope.known_var(val_var_name) {
				p.error('redefinition of value iteration variable `$val_var_name`')
			}
			p.scope.register(key_var_name, ast.Var{
				name: key_var_name
				typ: table.int_type
				pos: key_var_pos
			})
		} else if p.scope.known_var(val_var_name) {
			p.error('redefinition of value iteration variable `$val_var_name`')
		}
		p.check(.key_in)
		if p.tok.kind == .name && p.tok.lit in [key_var_name, val_var_name] {
			p.error('in a `for x in array` loop, the key or value iteration variable `$p.tok.lit` can not be the same as the array variable')
		}
		// arr_expr
		cond := p.expr(0)
		// 0 .. 10
		// start := p.tok.lit.int()
		// TODO use RangeExpr
		mut high_expr := ast.Expr{}
		mut is_range := false
		if p.tok.kind == .dotdot {
			is_range = true
			p.next()
			high_expr = p.expr(0)
			p.scope.register(val_var_name, ast.Var{
				name: val_var_name
				typ: table.int_type
				pos: val_var_pos
			})
		} else {
			// this type will be set in checker
			p.scope.register(val_var_name, ast.Var{
				name: val_var_name
				pos: val_var_pos
			})
		}
		p.inside_for = false
		stmts := p.parse_block()
		// println('nr stmts=$stmts.len')
		p.close_scope()
		return ast.ForInStmt{
			stmts: stmts
			cond: cond
			key_var: key_var_name
			val_var: val_var_name
			high: high_expr
			is_range: is_range
			pos: pos
		}
	}
	// `for cond {`
	cond := p.expr(0)
	p.inside_for = false
	stmts := p.parse_block()
	p.close_scope()
	return ast.ForStmt{
		cond: cond
		stmts: stmts
		pos: pos
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

import v.ast
import v.table
import v.token

fn (mut p Parser) if_expr() ast.IfExpr {
	was_inside_if_expr := p.inside_if_expr
	defer {
		p.inside_if_expr = was_inside_if_expr
	}
	p.inside_if_expr = true
	pos := p.tok.position()
	mut branches := []ast.IfBranch{}
	mut has_else := false
	for p.tok.kind in [.key_if, .key_else] {
		p.inside_if = true
		start_pos := p.tok.position()
		mut comment := ast.Comment{}
		if p.tok.kind == .key_if {
			p.next()
		} else {
			// if p.tok.kind == .comment {
			// p.error('place comments inside {}')
			// }
			// comment = p.check_comment()
			p.check(.key_else)
			if p.tok.kind == .key_if {
				p.next()
			} else {
				has_else = true
				p.inside_if = false
				end_pos := p.prev_tok.position()
				branches << ast.IfBranch{
					stmts: p.parse_block()
					pos: start_pos.extend(end_pos)
					comment: comment
				}
				break
			}
		}
		mut cond := ast.Expr{}
		mut is_or := false
		// `if x := opt() {`
		if p.peek_tok.kind == .decl_assign {
			is_or = true
			p.open_scope()
			var_pos := p.tok.position()
			var_name := p.check_name()
			p.check(.decl_assign)
			expr := p.expr(0)
			p.scope.register(var_name, ast.Var{
				name: var_name
				expr: expr
				pos: var_pos
			})
			cond = ast.IfGuardExpr{
				var_name: var_name
				expr: expr
			}
		} else {
			cond = p.expr(0)
		}
		end_pos := p.prev_tok.position()
		p.inside_if = false
		stmts := p.parse_block()
		if is_or {
			p.close_scope()
		}
		branches << ast.IfBranch{
			cond: cond
			stmts: stmts
			pos: start_pos.extend(end_pos)
			comment: ast.Comment{}
		}
		if p.tok.kind != .key_else {
			break
		}
	}
	return ast.IfExpr{
		branches: branches
		pos: pos
		has_else: has_else
	}
}

fn (mut p Parser) match_expr() ast.MatchExpr {
	match_first_pos := p.tok.position()
	p.inside_match = true
	p.check(.key_match)
	is_mut := p.tok.kind == .key_mut
	mut is_sum_type := false
	if is_mut {
		p.next()
	}
	cond_pos := p.tok.position()
	cond := p.expr(0)
	p.inside_match = false
	p.check(.lcbr)
	mut branches := []ast.MatchBranch{}
	for {
		branch_first_pos := p.tok.position()
		comment := p.check_comment() // comment before {}
		mut exprs := []ast.Expr{}
		p.open_scope()
		// final else
		mut is_else := false
		if p.tok.kind == .key_else {
			is_else = true
			p.next()
		} else if p.tok.kind == .name && !(p.tok.lit == 'C' && p.peek_tok.kind == .dot) &&
			(p.tok.lit in table.builtin_type_names || (p.tok.lit[0].is_capital() && !p.tok.lit.is_upper()) ||
			p.peek_tok.kind == .dot) {
			// Sum type match
			typ := p.parse_type()
			exprs << ast.Type{
				typ: typ
			}
			p.scope.register('it', ast.Var{
				name: 'it'
				typ: typ.to_ptr()
				pos: cond_pos
				is_used: true
				is_mut: is_mut
			})
			// TODO
			if p.tok.kind == .comma {
				p.next()
				p.parse_type()
			}
			is_sum_type = true
			// Make sure a variable used for the sum type match
			mut var_name := ''
			match cond {
				ast.Ident {
					var_name = it.name
				}
				else {
					// p.error('only variables can be used in sum types matches')
				}
			}
			if var_name != '' {
				// Register a shadow variable with the actual type
				// (this replaces the old `it`)
				// TODO doesn't work right now (fixed, uncomment when merging)
				// p.scope.register(var_name, ast.Var{
				// name: var_name
				// typ: typ.to_ptr()
				// })
				// println(var_name)
			}
		} else {
			// Expression match
			for {
				p.inside_match_case = true
				expr := p.expr(0)
				p.inside_match_case = false
				exprs << expr
				if p.tok.kind != .comma {
					break
				}
				p.check(.comma)
			}
		}
		branch_last_pos := p.tok.position()
		// p.warn('match block')
		p.inside_match_body = true
		stmts := p.parse_block()
		p.inside_match_body = false
		pos := token.Position{
			line_nr: branch_first_pos.line_nr
			pos: branch_first_pos.pos
			len: branch_last_pos.pos - branch_first_pos.pos + branch_last_pos.len
		}
		branches << ast.MatchBranch{
			exprs: exprs
			stmts: stmts
			pos: pos
			comment: comment
			is_else: is_else
		}
		p.close_scope()
		if p.tok.kind == .rcbr {
			break
		}
	}
	match_last_pos := p.tok.position()
	pos := token.Position{
		line_nr: match_first_pos.line_nr
		pos: match_first_pos.pos
		len: match_last_pos.pos - match_first_pos.pos + match_last_pos.len
	}
	p.check(.rcbr)
	return ast.MatchExpr{
		branches: branches
		cond: cond
		is_sum_type: is_sum_type
		pos: pos
		is_mut: is_mut
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

// return true if file being parsed imports `mod`
pub fn (p &Parser) known_import(mod string) bool {
	return mod in p.imports
}

fn (p &Parser) prepend_mod(name string) string {
	if p.expr_mod != '' {
		return p.expr_mod + '.' + name
	}
	if p.builtin_mod || p.mod == 'main' {
		return name
	}
	return '${p.mod}.$name'
}

fn (p &Parser) is_used_import(alias string) bool {
	return alias in p.used_imports
}

fn (mut p Parser) register_used_import(alias string) {
	if !p.is_used_import(alias) {
		p.used_imports << alias
	}
}

fn (mut p Parser) check_unused_imports() {
	if p.pref.is_repl {
		// The REPL should be much more liberal, and should not warn about
		// unused imports, because they probably will be in the next few lines...
		return
	}
	for import_m in p.ast_imports {
		alias := import_m.alias
		mod := import_m.mod
		if !p.is_used_import(alias) {
			mod_alias := if alias == mod { alias } else { '$alias ($mod)' }
			p.warn_with_pos("module '$mod_alias' is imported but never used", import_m.pos)
		}
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

import v.scanner
import v.ast
import v.token
import v.table
import v.pref
import v.util
import v.errors
import os
import runtime
import sync
import time

pub struct Parser {
	scanner           &scanner.Scanner
	file_name         string // "/home/user/hello.v"
	file_name_dir     string // "/home/user"
mut:
	tok               token.Token
	prev_tok          token.Token
	peek_tok          token.Token
	peek_tok2         token.Token
	peek_tok3         token.Token
	table             &table.Table
	language          table.Language
	inside_if         bool
	inside_if_expr    bool
	inside_or_expr    bool
	inside_for        bool
	inside_fn         bool
	pref              &pref.Preferences
	builtin_mod       bool // are we in the `builtin` module?
	mod               string // current module name
	attr              string
	attr_ctdefine     string
	expr_mod          string // for constructing full type names in parse_type()
	scope             &ast.Scope
	global_scope      &ast.Scope
	imports           map[string]string // alias => mod_name
	ast_imports       []ast.Import // mod_names
	used_imports      []string // alias
	is_amp            bool // for generating the right code for `&Foo{}`
	returns           bool
	inside_match      bool // to separate `match A { }` from `Struct{}`
	inside_match_case bool // to separate `match_expr { }` from `Struct{}`
	inside_match_body bool // to fix eval not used TODO
	inside_unsafe     bool
	is_stmt_ident     bool // true while the beginning of a statement is an ident/selector
	expecting_type    bool // `is Type`, expecting type
	errors            []errors.Error
	warnings          []errors.Warning
}

// for tests
pub fn parse_stmt(text string, table &table.Table, scope &ast.Scope) ast.Stmt {
	s := scanner.new_scanner(text, .skip_comments)
	mut p := Parser{
		scanner: s
		table: table
		pref: &pref.Preferences{}
		scope: scope
		global_scope: &ast.Scope{
			start_pos: 0
			parent: 0
		}
	}
	p.init_parse_fns()
	p.read_first_token()
	return p.stmt()
}

pub fn parse_file(path string, b_table &table.Table, comments_mode scanner.CommentsMode, pref &pref.Preferences, global_scope &ast.Scope) ast.File {
	// println('parse_file("$path")')
	// text := os.read_file(path) or {
	// panic(err)
	// }
	mut stmts := []ast.Stmt{}
	mut p := Parser{
		scanner: scanner.new_scanner_file(path, comments_mode)
		table: b_table
		file_name: path
		file_name_dir: os.dir(path)
		pref: pref
		scope: &ast.Scope{
			start_pos: 0
			parent: 0
		}
		errors: []errors.Error{}
		warnings: []errors.Warning{}
		global_scope: global_scope
	}
	// comments_mode: comments_mode
	p.read_first_token()
	for p.tok.kind == .comment {
		stmts << p.comment()
	}
	// module
	mut mstmt := ast.Stmt{}
	module_decl := p.module_decl()
	mstmt = module_decl
	stmts << mstmt
	// imports
	for p.tok.kind == .key_import {
		stmts << p.import_stmt()
	}
	for {
		if p.tok.kind == .eof {
			if p.pref.is_script && !p.pref.is_test && p.mod == 'main' && !have_fn_main(stmts) {
				stmts << ast.FnDecl{
					name: 'main'
					file: p.file_name
					return_type: table.void_type
				}
			} else {
				p.check_unused_imports()
			}
			break
		}
		// println('stmt at ' + p.tok.str())
		stmts << p.top_stmt()
	}
	// println('nr stmts = $stmts.len')
	// println(stmts[0])
	p.scope.end_pos = p.tok.pos
	return ast.File{
		path: path
		mod: module_decl
		imports: p.ast_imports
		stmts: stmts
		scope: p.scope
		global_scope: p.global_scope
		errors: p.errors
		warnings: p.warnings
	}
}

struct Queue {
mut:
	idx              int
	mu               &sync.Mutex
	mu2              &sync.Mutex
	paths            []string
	table            &table.Table
	parsed_ast_files []ast.File
	pref             &pref.Preferences
	global_scope     &ast.Scope
}

fn (mut q Queue) run() {
	for {
		q.mu.lock()
		idx := q.idx
		if idx >= q.paths.len {
			q.mu.unlock()
			return
		}
		q.idx++
		q.mu.unlock()
		println('run(idx=$idx)')
		path := q.paths[idx]
		file := parse_file(path, q.table, .skip_comments, q.pref, q.global_scope)
		q.mu2.lock()
		q.parsed_ast_files << file
		q.mu2.unlock()
		println('run done(idx=$idx)')
	}
}

pub fn parse_files(paths []string, table &table.Table, pref &pref.Preferences, global_scope &ast.Scope) []ast.File {
	// println('nr_cpus= $nr_cpus')
	$if macos {
		if pref.is_parallel && paths[0].contains('/array.v') {
			println('\n\n\nparse_files() nr_files=$paths.len')
			println(paths)
			nr_cpus := runtime.nr_cpus()
			mut q := &Queue{
				paths: paths
				table: table
				pref: pref
				global_scope: global_scope
				mu: sync.new_mutex()
				mu2: sync.new_mutex()
			}
			for _ in 0 .. nr_cpus - 1 {
				go q.run()
			}
			time.sleep_ms(1000)
			println('all done')
			return q.parsed_ast_files
		}
	}
	if false {
		// TODO: remove this; it just prevents warnings about unused time and runtime
		time.sleep_ms(1)
		println(runtime.nr_cpus())
	}
	// ///////////////
	mut files := []ast.File{}
	for path in paths {
		// println('parse_files $path')
		files << parse_file(path, table, .skip_comments, pref, global_scope)
	}
	return files
}

pub fn (p &Parser) init_parse_fns() {
	// p.prefix_parse_fns = make(100, 100, sizeof(PrefixParseFn))
	// p.prefix_parse_fns[token.Kind.name] = parse_name
	println('')
}

pub fn (mut p Parser) read_first_token() {
	// need to call next() 4 times to get peek token 1,2,3 and current token
	p.next()
	p.next()
	p.next()
	p.next()
}

pub fn (mut p Parser) open_scope() {
	p.scope = &ast.Scope{
		parent: p.scope
		start_pos: p.tok.pos
	}
}

pub fn (mut p Parser) close_scope() {
	if !p.pref.is_repl && !p.scanner.is_fmt {
		for _, obj in p.scope.objects {
			match obj {
				ast.Var {
					if !it.is_used && !it.name.starts_with('__') {
						if p.pref.is_prod {
							p.error_with_pos('unused variable: `$it.name`', it.pos)
						} else {
							p.warn_with_pos('unused variable: `$it.name`', it.pos)
						}
					}
				}
				else {}
			}
		}
	}
	p.scope.end_pos = p.tok.pos
	p.scope.parent.children << p.scope
	p.scope = p.scope.parent
}

pub fn (mut p Parser) parse_block() []ast.Stmt {
	p.open_scope()
	// println('parse block')
	stmts := p.parse_block_no_scope()
	p.close_scope()
	// println('nr exprs in block = $exprs.len')
	return stmts
}

pub fn (mut p Parser) parse_block_no_scope() []ast.Stmt {
	p.check(.lcbr)
	mut stmts := []ast.Stmt{}
	if p.tok.kind != .rcbr {
		for {
			stmts << p.stmt()
			// p.warn('after stmt(): tok=$p.tok.str()')
			if p.tok.kind in [.eof, .rcbr] {
				break
			}
		}
	}
	p.check(.rcbr)
	return stmts
}

/*
fn (mut p Parser) next_with_comment() {
	p.tok = p.peek_tok
	p.peek_tok = p.scanner.scan()
}
*/
fn (mut p Parser) next() {
	p.prev_tok = p.tok
	p.tok = p.peek_tok
	p.peek_tok = p.peek_tok2
	p.peek_tok2 = p.peek_tok3
	p.peek_tok3 = p.scanner.scan()
	/*
	if p.tok.kind==.comment {
		p.comments << ast.Comment{text:p.tok.lit, line_nr:p.tok.line_nr}
		p.next()
	}
	*/
}

fn (mut p Parser) check(expected token.Kind) {
	// for p.tok.kind in [.line_comment, .mline_comment] {
	// p.next()
	// }
	if p.tok.kind != expected {
		p.error('unexpected `${p.tok.kind.str()}`, expecting `${expected.str()}`')
	}
	p.next()
}

// JS functions can have multiple dots in their name:
// JS.foo.bar.and.a.lot.more.dots()
fn (mut p Parser) check_js_name() string {
	mut name := ''
	for p.peek_tok.kind == .dot {
		name += '${p.tok.lit}.'
		p.next() // .name
		p.next() // .dot
	}
	// last .name
	name += p.tok.lit
	p.next()
	return name
}

fn (mut p Parser) check_name() string {
	name := p.tok.lit
	if p.peek_tok.kind == .dot && name in p.imports {
		p.register_used_import(name)
	}
	p.check(.name)
	return name
}

pub fn (mut p Parser) top_stmt() ast.Stmt {
	match p.tok.kind {
		.key_pub {
			match p.peek_tok.kind {
				.key_const {
					return p.const_decl()
				}
				.key_fn {
					return p.fn_decl()
				}
				.key_struct, .key_union {
					return p.struct_decl()
				}
				.key_interface {
					return p.interface_decl()
				}
				.key_enum {
					return p.enum_decl()
				}
				.key_type {
					return p.type_decl()
				}
				else {
					p.error('wrong pub keyword usage')
					return ast.Stmt{}
				}
			}
		}
		.lsbr {
			attrs := p.attributes()
			if attrs.len > 1 {
				p.error('multiple attributes detected')
			}
			return attrs[0]
		}
		.key_interface {
			return p.interface_decl()
		}
		.key_import {
			p.error_with_pos('`import x` can only be declared at the beginning of the file',
				p.tok.position())
			return p.import_stmt()
		}
		.key_global {
			return p.global_decl()
		}
		.key_const {
			return p.const_decl()
		}
		.key_fn {
			return p.fn_decl()
		}
		.key_struct {
			return p.struct_decl()
		}
		.dollar {
			return p.comp_if()
		}
		.hash {
			return p.hash()
		}
		.key_type {
			return p.type_decl()
		}
		.key_enum {
			return p.enum_decl()
		}
		.key_union {
			return p.struct_decl()
		}
		.comment {
			return p.comment()
		}
		else {
			if p.pref.is_script && !p.pref.is_test {
				mut stmts := []ast.Stmt{}
				for p.tok.kind != .eof {
					stmts << p.stmt()
				}
				return ast.FnDecl{
					name: 'main'
					stmts: stmts
					file: p.file_name
					return_type: table.void_type
				}
			} else {
				p.error('bad top level statement ' + p.tok.str())
				return ast.Stmt{}
			}
		}
	}
}

// TODO [if vfmt]
pub fn (mut p Parser) check_comment() ast.Comment {
	if p.tok.kind == .comment {
		return p.comment()
	}
	return ast.Comment{}
}

pub fn (mut p Parser) comment() ast.Comment {
	pos := p.tok.position()
	text := p.tok.lit
	p.next()
	// p.next_with_comment()
	return ast.Comment{
		text: text
		pos: pos
	}
}

pub fn (mut p Parser) stmt() ast.Stmt {
	p.is_stmt_ident = p.tok.kind == .name
	match p.tok.kind {
		.lcbr {
			stmts := p.parse_block()
			return ast.Block{
				stmts: stmts
			}
		}
		.key_assert {
			p.next()
			assert_pos := p.tok.position()
			expr := p.expr(0)
			return ast.AssertStmt{
				expr: expr
				pos: assert_pos
			}
		}
		.key_mut, .key_static {
			return p.assign_stmt()
		}
		.key_for {
			return p.for_stmt()
		}
		.name {
			if p.peek_tok.kind == .decl_assign {
				// `x := ...`
				return p.assign_stmt()
			} else if p.peek_tok.kind == .comma {
				// `a, b ...`
				return p.parse_multi_expr()
			} else if p.peek_tok.kind == .colon {
				// `label:`
				name := p.check_name()
				p.next()
				return ast.GotoLabel{
					name: name
				}
			} else if p.peek_tok.kind == .name {
				p.error_with_pos('unexpected name `$p.peek_tok.lit`', p.peek_tok.position())
			} else if !p.inside_if_expr && !p.inside_match_body && !p.inside_or_expr && p.peek_tok.kind in
				[.rcbr, .eof] {
				p.error_with_pos('`$p.tok.lit` evaluated but not used', p.tok.position())
			}
			return p.parse_multi_expr()
		}
		.comment {
			return p.comment()
		}
		.key_return {
			return p.return_stmt()
		}
		.dollar {
			return p.comp_if()
		}
		.key_continue, .key_break {
			tok := p.tok
			p.next()
			return ast.BranchStmt{
				tok: tok
			}
		}
		.key_unsafe {
			p.next()
			p.inside_unsafe = true
			stmts := p.parse_block()
			p.inside_unsafe = false
			return ast.UnsafeStmt{
				stmts: stmts
			}
		}
		.hash {
			return p.hash()
		}
		.key_defer {
			p.next()
			stmts := p.parse_block()
			return ast.DeferStmt{
				stmts: stmts
			}
		}
		.key_go {
			p.next()
			expr := p.expr(0)
			// mut call_expr := &ast.CallExpr(0) // TODO
			// { call_expr = it }
			match expr {
				ast.CallExpr {}
				else {}
			}
			return ast.GoStmt{
				call_expr: expr
			}
		}
		.key_goto {
			p.next()
			name := p.check_name()
			return ast.GotoStmt{
				name: name
			}
		}
		.key_const {
			p.error_with_pos('const can only be defined at the top level (outside of functions)',
				p.tok.position())
		}
		// literals, 'if', etc. in here
		else {
			return p.parse_multi_expr()
		}
	}
}

fn (mut p Parser) attributes() []ast.Attr {
	mut attrs := []ast.Attr{}
	p.check(.lsbr)
	for p.tok.kind != .rsbr {
		attr := p.parse_attr()
		attrs << attr
		if p.tok.kind != .semicolon {
			expected := `;`
			if p.tok.kind == .rsbr {
				p.next()
				break
			}
			p.error('unexpected `${p.tok.kind.str()}`, expecting `${expected.str()}`')
		}
		p.next()
	}
	return attrs
}

fn (mut p Parser) parse_attr() ast.Attr {
	mut is_if_attr := false
	if p.tok.kind == .key_if {
		p.next()
		is_if_attr = true
	}
	mut name := p.check_name()
	if p.tok.kind == .colon {
		name += ':'
		p.next()
		if p.tok.kind == .name {
			name += p.check_name()
		} else if p.tok.kind == .string {
			name += p.tok.lit
			p.next()
		}
	}
	p.attr = name
	if is_if_attr {
		p.attr_ctdefine = name
	}
	return ast.Attr{
		name: name
	}
}

/*
fn (mut p Parser) range_expr(low ast.Expr) ast.Expr {
	// ,table.Type) {
	if p.tok.kind != .dotdot {
		p.next()
	}
	p.check(.dotdot)
	mut high := ast.Expr{}
	if p.tok.kind != .rsbr {
		high = p.expr(0)
		// if typ.typ.kind != .int {
		// p.error('non-integer index `$typ.typ.name`')
		// }
	}
	node := ast.RangeExpr{
		low: low
		high: high
	}
	return node
}
*/
pub fn (mut p Parser) error(s string) {
	p.error_with_pos(s, p.tok.position())
}

pub fn (mut p Parser) warn(s string) {
	p.warn_with_pos(s, p.tok.position())
}

pub fn (mut p Parser) error_with_pos(s string, pos token.Position) {
	mut kind := 'error:'
	if p.pref.output_mode == .stdout {
		if p.pref.is_verbose {
			print_backtrace()
			kind = 'parser error:'
		}
		ferror := util.formatted_error(kind, s, p.file_name, pos)
		eprintln(ferror)
		exit(1)
	} else {
		p.errors << errors.Error{
			file_path: p.file_name
			pos: pos
			reporter: .parser
			message: s
		}
	}
}

pub fn (mut p Parser) warn_with_pos(s string, pos token.Position) {
	if p.pref.skip_warnings {
		return
	}
	if p.pref.output_mode == .stdout {
		ferror := util.formatted_error('warning:', s, p.file_name, pos)
		eprintln(ferror)
	} else {
		p.warnings << errors.Warning{
			file_path: p.file_name
			pos: pos
			reporter: .parser
			message: s
		}
	}
}

fn (mut p Parser) parse_multi_expr() ast.Stmt {
	// in here might be 1) multi-expr 2) multi-assign
	// 1, a, c ... }       // multi-expression
	// a, mut b ... :=/=   // multi-assign
	// collect things upto hard boundaries
	mut collected := []ast.Expr{}
	for {
		collected << p.expr(0)
		if p.tok.kind == .comma {
			p.next()
		} else {
			break
		}
	}
	// TODO: Try to merge assign_expr and assign_stmt
	if p.tok.kind == .decl_assign || (p.tok.kind == .assign && collected.len > 1) {
		mut idents := []ast.Ident{}
		for c in collected {
			idents << c as ast.Ident
		}
		return p.partial_assign_stmt(idents)
	} else if p.tok.kind.is_assign() {
		epos := p.tok.position()
		if collected.len == 1 {
			return ast.ExprStmt{
				expr: p.assign_expr(collected[0])
				pos: epos
			}
		}
		return ast.ExprStmt{
			expr: p.assign_expr(ast.ConcatExpr{
				vals: collected
			})
			pos: epos
		}
	} else {
		if collected.len == 1 {
			return ast.ExprStmt{
				expr: collected[0]
				pos: p.tok.position()
			}
		}
		return ast.ExprStmt{
			expr: ast.ConcatExpr{
				vals: collected
			}
			pos: p.tok.position()
		}
	}
}

pub fn (mut p Parser) parse_ident(language table.Language) ast.Ident {
	// p.warn('name ')
	is_mut := p.tok.kind == .key_mut
	if is_mut {
		p.next()
	}
	is_static := p.tok.kind == .key_static
	if is_static {
		p.next()
	}
	if p.tok.kind == .name {
		pos := p.tok.position()
		mut name := p.check_name()
		if name == '_' {
			return ast.Ident{
				name: '_'
				kind: .blank_ident
				pos: pos
				info: ast.IdentVar{
					is_mut: false
					is_static: false
				}
			}
		}
		if p.expr_mod.len > 0 {
			name = '${p.expr_mod}.$name'
		}
		mut ident := ast.Ident{
			kind: .unresolved
			name: name
			language: language
			mod: p.mod
			pos: pos
		}
		ident.is_mut = is_mut
		ident.info = ast.IdentVar{
			is_mut: is_mut
			is_static: is_static
		}
		return ident
	} else {
		p.error('unexpected token `$p.tok.lit`')
	}
}

pub fn (mut p Parser) name_expr() ast.Expr {
	mut node := ast.Expr{}
	if p.expecting_type {
		p.expecting_type = false
		// get type position before moving to next
		type_pos := p.tok.position()
		typ := p.parse_type()
		return ast.Type{
			typ: typ
			pos: type_pos
		}
	}
	language := if p.tok.lit == 'C' {
		table.Language.c
	} else if p.tok.lit == 'JS' {
		table.Language.js
	} else {
		table.Language.v
	}
	mut mod := ''
	// p.warn('resetting')
	p.expr_mod = ''
	// `map[string]int` initialization
	if p.tok.lit == 'map' && p.peek_tok.kind == .lsbr {
		map_type := p.parse_map_type()
		if p.tok.kind == .lcbr && p.peek_tok.kind == .rcbr {
			p.next()
			p.next()
		}
		return ast.MapInit{
			typ: map_type
		}
	}
	// Raw string (`s := r'hello \n ')
	if p.tok.lit in ['r', 'c', 'js'] && p.peek_tok.kind == .string && p.prev_tok.kind != .str_dollar {
		return p.string_expr()
	}
	mut known_var := false
	if obj := p.scope.find(p.tok.lit) {
		match mut obj {
			ast.Var {
				known_var = true
				it.is_used = true
			}
			else {}
		}
	}
	if p.peek_tok.kind == .dot && !known_var && (language != .v || p.known_import(p.tok.lit) ||
		p.mod.all_after_last('.') == p.tok.lit) {
		if language == .c {
			mod = 'C'
		} else if language == .js {
			mod = 'JS'
		} else {
			if p.tok.lit in p.imports {
				p.register_used_import(p.tok.lit)
			}
			// prepend the full import
			mod = p.imports[p.tok.lit]
		}
		p.next()
		p.check(.dot)
		p.expr_mod = mod
	}
	// p.warn('name expr  $p.tok.lit $p.peek_tok.str()')
	// fn call or type cast
	if p.peek_tok.kind == .lpar || (p.peek_tok.kind == .lt && p.peek_tok2.kind == .name && p.peek_tok3.kind == .gt ){
		// foo() or foo<int>()
		mut name := p.tok.lit
		if mod.len > 0 {
			name = '${mod}.$name'
		}
		name_w_mod := p.prepend_mod(name)
		// type cast. TODO: finish
		// if name in table.builtin_type_names {
		if !known_var && (name in p.table.type_idxs || name_w_mod in p.table.type_idxs) &&
			name !in ['C.stat', 'C.sigaction'] {
			// TODO handle C.stat()
			mut to_typ := p.parse_type()
			if p.is_amp {
				// Handle `&Foo(0)`
				to_typ = to_typ.to_ptr()
			}
			p.check(.lpar)
			mut expr := ast.Expr{}
			mut arg := ast.Expr{}
			mut has_arg := false
			expr = p.expr(0)
			// TODO, string(b, len)
			if p.tok.kind == .comma && to_typ.idx() == table.string_type_idx {
				p.next()
				arg = p.expr(0) // len
				has_arg = true
			}
			p.check(.rpar)
			node = ast.CastExpr{
				typ: to_typ
				expr: expr
				arg: arg
				has_arg: has_arg
				pos: expr.position()
			}
			p.expr_mod = ''
			return node
		} else {
			// fn call
			// println('calling $p.tok.lit')
			node = p.call_expr(language, mod)
		}
	} else if p.peek_tok.kind == .lcbr && !p.inside_match && !p.inside_match_case && !p.inside_if &&
		!p.inside_for {
		return p.struct_init(false) // short_syntax: false
	} else if p.peek_tok.kind == .dot && (p.tok.lit[0].is_capital() && !known_var) {
		// `Color.green`
		mut enum_name := p.check_name()
		if mod != '' {
			enum_name = mod + '.' + enum_name
		} else {
			enum_name = p.prepend_mod(enum_name)
		}
		// p.warn('Color.green $enum_name ' + p.prepend_mod(enum_name) + 'mod=$mod')
		p.check(.dot)
		val := p.check_name()
		// println('enum val $enum_name . $val')
		p.expr_mod = ''
		return ast.EnumVal{
			enum_name: enum_name
			val: val
			pos: p.tok.position()
			mod: mod
		}
	} else if p.peek_tok.kind == .colon && p.prev_tok.kind != .str_dollar {
		// `foo(key:val, key2:val2)`
		return p.struct_init(true) // short_syntax:true
		// JS. function call with more than 1 dot
	} else if language == .js && p.peek_tok.kind == .dot && p.peek_tok2.kind == .name {
		node = p.call_expr(language, mod)
	} else {
		node = p.parse_ident(language)
	}
	p.expr_mod = ''
	return node
}

fn (mut p Parser) index_expr(left ast.Expr) ast.IndexExpr {
	// left == `a` in `a[0]`
	p.next() // [
	mut has_low := true
	if p.tok.kind == .dotdot {
		has_low = false
		// [..end]
		p.next()
		high := p.expr(0)
		p.check(.rsbr)
		return ast.IndexExpr{
			left: left
			pos: p.tok.position()
			index: ast.RangeExpr{
				low: ast.Expr{}
				high: high
				has_high: true
			}
		}
	}
	expr := p.expr(0) // `[expr]` or  `[expr..]`
	mut has_high := false
	if p.tok.kind == .dotdot {
		// [start..end] or [start..]
		p.next()
		mut high := ast.Expr{}
		if p.tok.kind != .rsbr {
			has_high = true
			high = p.expr(0)
		}
		p.check(.rsbr)
		return ast.IndexExpr{
			left: left
			pos: p.tok.position()
			index: ast.RangeExpr{
				low: expr
				high: high
				has_high: has_high
				has_low: has_low
			}
		}
	}
	// [expr]
	p.check(.rsbr)
	return ast.IndexExpr{
		left: left
		index: expr
		pos: p.tok.position()
	}
}

fn (mut p Parser) scope_register_it() {
	p.scope.register('it', ast.Var{
		name: 'it'
		pos: p.tok.position()
		is_used: true
	})
}

fn (mut p Parser) dot_expr(left ast.Expr) ast.Expr {
	p.next()
	mut name_pos := p.tok.position()
	field_name := p.check_name()
	is_filter := field_name in ['filter', 'map']
	if is_filter {
		p.open_scope()
		name_pos = p.tok.position()
		p.scope_register_it()
		// wrong tok position when using defer
		// defer {
		// p.close_scope()
		// }
	}
	// Method call
	if p.tok.kind == .lpar {
		p.next()
		args := p.call_args()
		if is_filter && args.len != 1 {
			p.error('needs exactly 1 argument')
		}
		p.check(.rpar)
		mut or_stmts := []ast.Stmt{}
		mut or_kind := ast.OrKind.absent
		if p.tok.kind == .key_orelse {
			p.next()
			p.open_scope()
			p.scope.register('errcode', ast.Var{
				name: 'errcode'
				typ: table.int_type
				pos: p.tok.position()
				is_used: true
			})
			p.scope.register('err', ast.Var{
				name: 'err'
				typ: table.string_type
				pos: p.tok.position()
				is_used: true
			})
			or_kind = .block
			or_stmts = p.parse_block_no_scope()
			p.close_scope()
		}
		if p.tok.kind == .question {
			// `foo()?`
			p.next()
			or_kind = .propagate
		}
		end_pos := p.tok.position()
		pos := token.Position{
			line_nr: name_pos.line_nr
			pos: name_pos.pos
			len: end_pos.pos - name_pos.pos
		}
		mcall_expr := ast.CallExpr{
			left: left
			name: field_name
			args: args
			pos: pos
			is_method: true
			or_block: ast.OrExpr{
				stmts: or_stmts
				kind: or_kind
				pos: pos
			}
		}
		if is_filter {
			p.close_scope()
		}
		return mcall_expr
	}
	sel_expr := ast.SelectorExpr{
		expr: left
		field_name: field_name
		pos: name_pos
	}
	mut node := ast.Expr{}
	node = sel_expr
	if is_filter {
		p.close_scope()
	}
	return node
}

// `.green`
// `pref.BuildMode.default_mode`
fn (mut p Parser) enum_val() ast.EnumVal {
	p.check(.dot)
	val := p.check_name()
	return ast.EnumVal{
		val: val
		pos: p.tok.position()
	}
}

fn (mut p Parser) string_expr() ast.Expr {
	is_raw := p.tok.kind == .name && p.tok.lit == 'r'
	is_cstr := p.tok.kind == .name && p.tok.lit == 'c'
	if is_raw || is_cstr {
		p.next()
	}
	mut node := ast.Expr{}
	val := p.tok.lit
	pos := p.tok.position()
	if p.peek_tok.kind != .str_dollar {
		p.next()
		node = ast.StringLiteral{
			val: val
			is_raw: is_raw
			language: if is_cstr {
				table.Language.c
			} else {
				table.Language.v
			}
			pos: pos
		}
		return node
	}
	mut exprs := []ast.Expr{}
	mut vals := []string{}
	mut efmts := []string{}
	// Handle $ interpolation
	for p.tok.kind == .string {
		vals << p.tok.lit
		p.next()
		if p.tok.kind != .str_dollar {
			continue
		}
		p.next()
		exprs << p.expr(0)
		mut efmt := []string{}
		if p.tok.kind == .colon {
			efmt << ':'
			p.next()
			// ${num:-2d}
			if p.tok.kind == .minus {
				efmt << '-'
				p.next()
			}
			// ${num:2d}
			if p.tok.kind == .number {
				efmt << p.tok.lit
				p.next()
			}
			if p.tok.kind == .name && p.tok.lit.len == 1 {
				efmt << p.tok.lit
				p.next()
			}
		}
		efmts << efmt.join('')
	}
	node = ast.StringInterLiteral{
		vals: vals
		exprs: exprs
		expr_fmts: efmts
		pos: pos
	}
	return node
}

fn (mut p Parser) parse_number_literal() ast.Expr {
	lit := p.tok.lit
	pos := p.tok.position()
	mut node := ast.Expr{}
	if lit.index_any('.eE') >= 0 && lit[..2] !in ['0x', '0X', '0o', '0O', '0b', '0B'] {
		node = ast.FloatLiteral{
			val: lit
			pos: pos
		}
	} else {
		node = ast.IntegerLiteral{
			val: lit
			pos: pos
		}
	}
	p.next()
	return node
}

fn (mut p Parser) module_decl() ast.Module {
	mut name := 'main'
	is_skipped := p.tok.kind != .key_module
	mut module_pos := token.Position{}
	if !is_skipped {
		module_pos = p.tok.position()
		p.next()
		mut pos := p.tok.position()
		name = p.check_name()
		if module_pos.line_nr != pos.line_nr {
			p.error_with_pos('`module` and `$name` must be at same line', pos)
		}
		pos = p.tok.position()
		if module_pos.line_nr == pos.line_nr {
			if p.tok.kind != .name {
				p.error_with_pos('`module x` syntax error', pos)
			} else {
				p.error_with_pos('`module x` can only declare one module', pos)
			}
		}
		module_pos = module_pos.extend(pos)
	}
	full_mod := p.table.qualify_module(name, p.file_name)
	p.mod = full_mod
	p.builtin_mod = p.mod == 'builtin'
	return ast.Module{
		name: full_mod
		is_skipped: is_skipped
		pos: module_pos
	}
}

fn (mut p Parser) import_stmt() ast.Import {
	import_pos := p.tok.position()
	p.check(.key_import)
	pos := p.tok.position()
	if p.tok.kind == .lpar {
		p.error_with_pos('`import()` has been deprecated, use `import x` instead', pos)
	}
	mut mod_name := p.check_name()
	if import_pos.line_nr != pos.line_nr {
		p.error_with_pos('`import` and `module` must be at same line', pos)
	}
	mut mod_alias := mod_name
	for p.tok.kind == .dot {
		p.next()
		pos_t := p.tok.position()
		if p.tok.kind != .name {
			p.error_with_pos('module syntax error, please use `x.y.z`', pos)
		}
		if import_pos.line_nr != pos_t.line_nr {
			p.error_with_pos('`import` and `submodule` must be at same line', pos)
		}
		submod_name := p.check_name()
		mod_name += '.' + submod_name
		mod_alias = submod_name
	}
	if p.tok.kind == .key_as {
		p.next()
		mod_alias = p.check_name()
	}
	pos_t := p.tok.position()
	if import_pos.line_nr == pos_t.line_nr {
		if p.tok.kind != .name {
			p.error_with_pos('module syntax error, please use `x.y.z`', pos_t)
		} else {
			p.error_with_pos('cannot import multiple modules at a time', pos_t)
		}
	}
	p.imports[mod_alias] = mod_name
	p.table.imports << mod_name
	node := ast.Import{
		mod: mod_name
		alias: mod_alias
		pos: pos
	}
	p.ast_imports << node
	return node
}

fn (mut p Parser) const_decl() ast.ConstDecl {
	start_pos := p.tok.position()
	is_pub := p.tok.kind == .key_pub
	if is_pub {
		p.next()
	}
	end_pos := p.tok.position()
	p.check(.key_const)
	if p.tok.kind != .lpar {
		p.error('consts must be grouped, e.g.\nconst (\n\ta = 1\n)')
	}
	p.next() // (
	mut fields := []ast.ConstField{}
	for p.tok.kind != .rpar {
		mut comment := ast.Comment{}
		if p.tok.kind == .comment {
			comment = p.comment()
		}
		pos := p.tok.position()
		name := p.check_name()
		if util.contains_capital(name) {
			p.warn_with_pos('const names cannot contain uppercase letters, use snake_case instead', pos)
		}
		full_name := p.prepend_mod(name)
		// name := p.check_name()
		// println('!!const: $name')
		p.check(.assign)
		expr := p.expr(0)
		field := ast.ConstField{
			name: full_name
			expr: expr
			pos: pos
			comment: comment
		}
		fields << field
		p.global_scope.register(field.name, field)
	}
	p.check(.rpar)
	return ast.ConstDecl{
		pos: start_pos.extend(end_pos)
		fields: fields
		is_pub: is_pub
	}
}

fn (mut p Parser) return_stmt() ast.Return {
	first_pos := p.tok.position()
	p.next()
	// return expressions
	mut exprs := []ast.Expr{}
	if p.tok.kind == .rcbr {
		return ast.Return{
			pos: first_pos
		}
	}
	for {
		expr := p.expr(0)
		exprs << expr
		if p.tok.kind == .comma {
			p.next()
		} else {
			break
		}
	}
	end_pos := exprs.last().position()
	return ast.Return{
		exprs: exprs
		pos: first_pos.extend(end_pos)
	}
}

// left hand side of `=` or `:=` in `a,b,c := 1,2,3`
fn (mut p Parser) global_decl() ast.GlobalDecl {
	if !p.pref.translated && !p.pref.is_livemain && !p.builtin_mod && !p.pref.building_v &&
		p.mod != 'ui' && p.mod != 'gg2' && p.mod != 'uiold' && !os.getwd().contains('/volt') && !p.pref.enable_globals {
		p.error('use `v --enable-globals ...` to enable globals')
	}
	start_pos := p.tok.position()
	p.next()
	pos := start_pos.extend(p.tok.position())
	name := p.check_name()
	// println(name)
	typ := p.parse_type()
	mut expr := ast.Expr{}
	has_expr := p.tok.kind == .assign
	if has_expr {
		p.next()
		expr = p.expr(0)
	}
	// p.genln(p.table.cgen_name_type_pair(name, typ))
	/*
	mut g := p.table.cgen_name_type_pair(name, typ)
	if p.tok == .assign {
		p.next()
		g += ' = '
		_,expr := p.tmp_expr()
		g += expr
	}
	// p.genln('; // global')
	g += '; // global'
	if !p.cgen.nogen {
		p.cgen.consts << g
	}
	*/
	glob := ast.GlobalDecl{
		name: name
		typ: typ
		pos: pos
		has_expr: has_expr
		expr: expr
	}
	p.global_scope.register(name, glob)
	return glob
}

fn (mut p Parser) enum_decl() ast.EnumDecl {
	is_pub := p.tok.kind == .key_pub
	start_pos := p.tok.position()
	if is_pub {
		p.next()
	}
	p.check(.key_enum)
	end_pos := p.tok.position()
	enum_name := p.check_name()
	name := p.prepend_mod(enum_name)
	p.check(.lcbr)
	mut vals := []string{}
	// mut default_exprs := []ast.Expr{}
	mut fields := []ast.EnumField{}
	for p.tok.kind != .eof && p.tok.kind != .rcbr {
		pos := p.tok.position()
		val := p.check_name()
		vals << val
		mut expr := ast.Expr{}
		mut has_expr := false
		// p.warn('enum val $val')
		if p.tok.kind == .assign {
			p.next()
			expr = p.expr(0)
			has_expr = true
		}
		fields << ast.EnumField{
			name: val
			pos: pos
			expr: expr
			has_expr: has_expr
		}
	}
	p.check(.rcbr)
	p.table.register_type_symbol(table.TypeSymbol{
		kind: .enum_
		name: name
		mod: p.mod
		info: table.Enum{
			vals: vals
		}
	})
	return ast.EnumDecl{
		name: name
		is_pub: is_pub
		fields: fields
		pos: start_pos.extend(end_pos)
	}
}

fn (mut p Parser) type_decl() ast.TypeDecl {
	start_pos := p.tok.position()
	is_pub := p.tok.kind == .key_pub
	if is_pub {
		p.next()
	}
	p.check(.key_type)
	end_pos := p.tok.position()
	decl_pos := start_pos.extend(end_pos)
	name := p.check_name()
	mut sum_variants := []table.Type{}
	if p.tok.kind == .assign {
		p.next() // TODO require `=`
	}
	if p.tok.kind == .key_fn {
		// function type: `type mycallback fn(string, int)`
		fn_name := p.prepend_mod(name)
		fn_type := p.parse_fn_type(fn_name)
		return ast.FnTypeDecl{
			name: fn_name
			is_pub: is_pub
			typ: fn_type
			pos: decl_pos
		}
	}
	first_type := p.parse_type() // need to parse the first type before we can check if it's `type A = X | Y`
	if p.tok.kind == .pipe {
		p.next()
		sum_variants << first_type
		// type SumType = A | B | c
		for {
			variant_type := p.parse_type()
			sum_variants << variant_type
			if p.tok.kind != .pipe {
				break
			}
			p.check(.pipe)
		}
		p.table.register_type_symbol(table.TypeSymbol{
			kind: .sum_type
			name: p.prepend_mod(name)
			mod: p.mod
			info: table.SumType{
				variants: sum_variants
			}
			is_public: is_pub
		})
		return ast.SumTypeDecl{
			name: name
			is_pub: is_pub
			sub_types: sum_variants
			pos: decl_pos
		}
	}
	// type MyType int
	parent_type := first_type
	parent_name := p.table.get_type_symbol(parent_type).name
	pid := parent_type.idx()
	language := if parent_name.len > 2 && parent_name.starts_with('C.') {
		table.Language.c
	} else if parent_name.len > 2 && parent_name.starts_with('JS.') {
		table.Language.js
	} else {
		table.Language.v
	}
	p.table.register_type_symbol(table.TypeSymbol{
		kind: .alias
		name: p.prepend_mod(name)
		parent_idx: pid
		mod: p.mod
		info: table.Alias{
			parent_typ: parent_type
			language: language
		}
		is_public: is_pub
	})
	return ast.AliasTypeDecl{
		name: name
		is_pub: is_pub
		parent_type: parent_type
		pos: decl_pos
	}
}

fn (mut p Parser) assoc() ast.Assoc {
	var_name := p.check_name()
	pos := p.tok.position()
	mut v := p.scope.find_var(var_name) or {
		p.error('unknown variable `$var_name`')
		return ast.Assoc{}
	}
	v.is_used = true
	// println('assoc var $name typ=$var.typ')
	mut fields := []string{}
	mut vals := []ast.Expr{}
	p.check(.pipe)
	for {
		fields << p.check_name()
		p.check(.colon)
		expr := p.expr(0)
		vals << expr
		if p.tok.kind == .comma {
			p.next()
		}
		if p.tok.kind == .rcbr {
			break
		}
	}
	return ast.Assoc{
		var_name: var_name
		fields: fields
		exprs: vals
		pos: pos
	}
}

fn (p &Parser) new_true_expr() ast.Expr {
	return ast.BoolLiteral{
		val: true
		pos: p.tok.position()
	}
}

fn verror(s string) {
	util.verror('parser error', s)
}
module parser

import v.ast
import v.gen
import v.table
import v.checker
//import v.eval
import v.pref
import term

fn test_eval() {
	/*
	inputs := [
	//
	'2+2',
	'struct User { age int }',
	'2+3',
	'4',
	'x := 10',
	'x',
	'x + 1',
	'y := 2',
	'x * y', // 20
	//
	]
	expected := [
	//
	'5',
	'4',
	'>>',
	'10',
	'11',
	'>>',
	'20',
	//
	]
	table := table.new_table()
	vpref := &pref.Preferences{}
	mut scope := &ast.Scope{
		start_pos: 0
		parent: 0
	}
	mut stmts := []ast.Stmt{}
	for input in inputs {
		stmts << parse_stmt(input, table, scope)
	}
	file := ast.File{
		stmts: stmts
		scope: scope
	}
	mut checker := checker.new_checker(table, vpref)
	checker.check(file)
	mut ev := eval.Eval{}
	s := ev.eval(file, table)
	println('eval done')
	println(s)
	assert s == expected.join('\n')
	exit(0)
	*/
	return
}

fn test_parse_file() {
	if true {
		return
	}
	s := '
fn foo() int {
	f := 23
	return 10+4
}

12 + 3
x := 10
5+7
8+4
'
	table := &table.Table{}
	vpref := &pref.Preferences{}
	gscope := &ast.Scope{ parent: 0 }
	prog := parse_file(s, table, .skip_comments, vpref, gscope)
	mut checker := checker.new_checker(table, vpref)
	checker.check(prog)
	res := gen.cgen([prog], table, vpref)
	println(res)
}

fn test_one() {
	if true {
		return
	}
	println('\n\ntest_one()')
	input := ['a := 10',
	// 'a = 20',
	'b := -a',
	'c := 20',
	//
	]
	expected := 'int a = 10;int b = -a;int c = 20;'
	table := table.new_table()
	vpref := &pref.Preferences{}
	scope := &ast.Scope{
		start_pos: 0
		parent: 0
	}
	mut e := []ast.Stmt{}
	for line in input {
		e << parse_stmt(line, table, scope)
	}
	program := ast.File{
		stmts: e
		scope: scope
		global_scope: scope
	}
	mut checker := checker.new_checker(table, vpref)
	checker.check(program)
	res := gen.cgen([program], table, vpref).replace('\n', '').trim_space().after('#endif')
	println(res)
	ok := expected == res
	println(res)
	assert ok
	if !ok {}
	// exit(0)
}

fn test_parse_expr() {
	if true {
		return
	}
	input := ['1 == 1',
	'234234',
	'2 * 8 + 3',
	'a := 3',
	'a++',
	'b := 4 + 2',
	'neg := -a',
	'a + a',
	'bo := 2 + 3 == 5',
	'2 + 1',
	'q := 1',
	'q + 777',
	'2 + 3',
	'2+2*4',
	// '(2+2)*4',
	'x := 10',
	'mut aa := 12',
	'ab := 10 + 3 * 9',
	's := "hi"',
	// '1 += 2',
	'x = 11',
	'a += 10',
	'1.2 + 3.4',
	'4 + 4',
	'1 + 2 * 5',
	'-a+1',
	'2+2',
	/*
	/*
		'(2 * 3) / 2',
		'3 + (7 * 6)',
		'2 ^ 8 * (7 * 6)',
		'20 + (10 * 15) / 5', // 50
		'(2) + (17*2-30) * (5)+2 - (8/2)*4', // 8
		//'2 + "hi"',
		*/
		*/

	]
	expecting := ['1 == 1;',
	'234234;',
	'2 * 8 + 3;',
	'int a = 3;',
	'a++;',
	'int b = 4 + 2;',
	'int neg = -a;',
	'a + a;',
	'bool bo = 2 + 3 == 5;',
	'2 + 1;',
	'int q = 1;',
	'q + 777;',
	'2 + 3;',
	'2 + 2 * 4;',
	// '(2 + 2) * 4',
	'int x = 10;',
	'int aa = 12;',
	'int ab = 10 + 3 * 9;',
	'string s = tos3("hi");',
	// '1 += 2;',
	'x = 11;',
	'a += 10;',
	'1.2 + 3.4;',
	'4 + 4;',
	'1 + 2 * 5;',
	'-a + 1;',
	'2 + 2;',
	]
	mut e := []ast.Stmt{}
	table := table.new_table()
	vpref := &pref.Preferences{}
	mut checker := checker.new_checker(table, vpref)
	scope := &ast.Scope{
		start_pos: 0
		parent: 0
	}
	for s in input {
		println('\n\nst="$s"')
		e << parse_stmt(s, table, scope)
	}
	program := ast.File{
		stmts: e
		scope: scope
		global_scope: scope
	}
	checker.check(program)
	res := gen.cgen([program], table, vpref).after('#endif')
	println('========')
	println(res)
	println('========')
	lines := res.trim_space().split_into_lines()
	mut i := 0
	for line in lines {
		if line == '' {
			continue
		}
		if line != expecting[i] {
			println('V:"$line" expecting:"${expecting[i]}"')
		}
		assert line == expecting[i]
		println(term.green('$i OK'))
		println(line)
		println('')
		i++
		if i >= expecting.len {
			break
		}
	}
}

/*
	table := &table.Table{}
	for s in text_expr {
		// print using str method
		x := parse_expr(s, table)
		println('source: $s')
		println('parsed: $x')
		println('===================')
*/
module parser

// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
import v.table

pub fn (mut p Parser) parse_array_type() table.Type {
	p.check(.lsbr)
	// fixed array
	if p.tok.kind == .number {
		size := p.tok.lit.int()
		p.next()
		p.check(.rsbr)
		elem_type := p.parse_type()
		idx := p.table.find_or_register_array_fixed(elem_type, size, 1)
		return table.new_type(idx)
	}
	// array
	p.check(.rsbr)
	elem_type := p.parse_type()
	mut nr_dims := 1

	// detect attr
	not_attr := p.peek_tok.kind != .name && p.peek_tok2.kind !in [.semicolon, .rsbr]

	for p.tok.kind == .lsbr && not_attr {
		p.next()
		p.check(.rsbr)
		nr_dims++
	}
	idx := p.table.find_or_register_array(elem_type, nr_dims)
	return table.new_type(idx)
}

pub fn (mut p Parser) parse_map_type() table.Type {
	p.next()
	if p.tok.kind != .lsbr {
		return table.map_type
	}
	p.check(.lsbr)
	key_type := p.parse_type()
	// key_type_sym := p.get_type_symbol(key_type)
	// if key_type_sym.kind != .string {
	if key_type.idx() != table.string_type_idx {
		p.error('maps can only have string keys for now')
	}
	p.check(.rsbr)
	value_type := p.parse_type()
	idx := p.table.find_or_register_map(key_type, value_type)
	return table.new_type(idx)
}

pub fn (mut p Parser) parse_multi_return_type() table.Type {
	p.check(.lpar)
	mut mr_types := []table.Type{}
	for {
		mr_type := p.parse_type()
		mr_types << mr_type
		if p.tok.kind == .comma {
			p.next()
		} else {
			break
		}
	}
	p.check(.rpar)
	idx := p.table.find_or_register_multi_return(mr_types)
	return table.new_type(idx)
}

// given anon name based off signature when `name` is blank
pub fn (mut p Parser) parse_fn_type(name string) table.Type {
	// p.warn('parse fn')
	p.check(.key_fn)
	line_nr := p.tok.line_nr
	args, is_variadic := p.fn_args()
	mut return_type := table.void_type
	if p.tok.line_nr == line_nr && p.tok.kind.is_start_of_type() {
		return_type = p.parse_type()
	}
	func := table.Fn{
		name: name
		args: args
		is_variadic: is_variadic
		return_type: return_type
	}
	idx := p.table.find_or_register_fn_type(p.mod, func, false, false)
	return table.new_type(idx)
}

pub fn (mut p Parser) parse_type_with_mut(is_mut bool) table.Type {
	typ := p.parse_type()
	if is_mut {
		return typ.set_nr_muls(1)
	}
	return typ
}

pub fn (mut p Parser) parse_type() table.Type {
	// optional
	mut is_optional := false
	if p.tok.kind == .question {
		p.next()
		is_optional = true
	}
	mut nr_muls := 0
	if p.tok.kind == .key_mut {
		nr_muls++
		p.next()
	}
	// &Type
	for p.tok.kind in [.and, .amp] {
		if p.tok.kind == .and {
			nr_muls += 2
		} else {
			nr_muls++
		}
		p.next()
	}

	language := if p.tok.lit == 'C' {
		table.Language.c
	} else if p.tok.lit == 'JS' {
		table.Language.js
	} else {
		table.Language.v
	}

	if language != .v {
		p.next()
		p.check(.dot)
	}
	mut typ := table.void_type
	if p.tok.kind != .lcbr {
		typ = p.parse_any_type(language, nr_muls > 0)
	}
	if is_optional {
		typ = typ.set_flag(.optional)
	}
	if nr_muls > 0 {
		typ = typ.set_nr_muls(nr_muls)
	}
	return typ
}

pub fn (mut p Parser) parse_any_type(language table.Language, is_ptr bool) table.Type {
	mut name := p.tok.lit
	if language == .c {
		name = 'C.$name'
	} else if language == .js {
		name = 'JS.$name'
	} else if p.peek_tok.kind == .dot {
		// `module.Type`
		// /if !(p.tok.lit in p.table.imports) {
		if !p.known_import(name) {
			println(p.table.imports)
			p.error('unknown module `$p.tok.lit`')
		}
		if p.tok.lit in p.imports {
			p.register_used_import(p.tok.lit)
		}
		p.next()
		p.check(.dot)
		// prefix with full module
		name = '${p.imports[name]}.$p.tok.lit'
	} else if p.expr_mod != '' {
		name = p.expr_mod + '.' + name
	} else if p.mod !in ['builtin', 'main'] && name !in table.builtin_type_names {
		// `Foo` in module `mod` means `mod.Foo`
		name = p.mod + '.' + name
	}
	// p.warn('get type $name')
	match p.tok.kind {
		.key_fn {
			// func
			return p.parse_fn_type('')
		}
		.lsbr {
			// array
			return p.parse_array_type()
		}
		.lpar {
			// multiple return
			if is_ptr {
				p.error('parse_type: unexpected `&` before multiple returns')
			}
			return p.parse_multi_return_type()
		}
		else {
			// no defer
			if name == 'map' {
				return p.parse_map_type()
			}
			defer {
				p.next()
			}
			match name {
				'voidptr' {
					return table.voidptr_type
				}
				'byteptr' {
					return table.byteptr_type
				}
				'charptr' {
					return table.charptr_type
				}
				'i8' {
					return table.i8_type
				}
				'i16' {
					return table.i16_type
				}
				'int' {
					return table.int_type
				}
				'i64' {
					return table.i64_type
				}
				'byte' {
					return table.byte_type
				}
				'u16' {
					return table.u16_type
				}
				'u32' {
					return table.u32_type
				}
				'u64' {
					return table.u64_type
				}
				'f32' {
					return table.f32_type
				}
				'f64' {
					return table.f64_type
				}
				'string' {
					return table.string_type
				}
				'char' {
					return table.char_type
				}
				'bool' {
					return table.bool_type
				}
				else {
					// struct / enum / placeholder
					// struct / enum
					mut idx := p.table.find_type_idx(name)
					if idx > 0 {
						return table.new_type(idx)
					}
					// not found - add placeholder
					idx = p.table.add_placeholder_type(name)
					// println('NOT FOUND: $name - adding placeholder - $idx')
					return table.new_type(idx)
				}
			}
		}
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

import v.ast
import v.table
import v.token

pub fn (mut p Parser) expr(precedence int) ast.Expr {
	// println('\n\nparser.expr()')
	mut typ := table.void_type
	mut node := ast.Expr{}
	is_stmt_ident := p.is_stmt_ident
	p.is_stmt_ident = false
	// Prefix
	match p.tok.kind {
		.key_mut, .key_static {
			node = p.parse_assign_ident()
		}
		.name {
			node = p.name_expr()
			p.is_stmt_ident = is_stmt_ident
		}
		.string {
			node = p.string_expr()
		}
		.dot {
			// .enum_val
			node = p.enum_val()
		}
		.chartoken {
			node = ast.CharLiteral{
				val: p.tok.lit
				pos: p.tok.position()
			}
			p.next()
		}
		.minus, .amp, .mul, .not, .bit_not {
			// -1, -a, !x, &x, ~x
			node = p.prefix_expr()
		}
		.key_true, .key_false {
			node = ast.BoolLiteral{
				val: p.tok.kind == .key_true
				pos: p.tok.position()
			}
			p.next()
		}
		.key_match {
			node = p.match_expr()
		}
		.number {
			node = p.parse_number_literal()
		}
		.lpar {
			p.check(.lpar)
			node = p.expr(0)
			p.check(.rpar)
			node = ast.ParExpr{
				expr: node
			}
		}
		.key_if {
			node = p.if_expr()
		}
		.lsbr {
			if p.expecting_type {
				// parse json.decode type (`json.decode([]User, s)`)
				node = p.name_expr()
			} else {
				node = p.array_init()
			}
		}
		.key_none {
			p.next()
			node = ast.None{}
		}
		.key_sizeof {
			p.next() // sizeof
			p.check(.lpar)
			sizeof_type := p.parse_type()
			if p.tok.lit == 'C' {
				p.next()
				p.check(.dot)
				node = ast.SizeOf{
					type_name: p.check_name()
					typ: sizeof_type
				}
			} else {
				node = ast.SizeOf{
					typ: sizeof_type
				}
			}
			p.check(.rpar)
		}
		.key_typeof {
			p.next()
			p.check(.lpar)
			expr := p.expr(0)
			p.check(.rpar)
			node = ast.TypeOf{
				expr: expr
			}
		}
		.lcbr {
			// Map `{"age": 20}` or `{ x | foo:bar, a:10 }`
			p.next()
			if p.tok.kind == .string {
				node = p.map_init()
			} else {
				// it should be a struct
				if p.peek_tok.kind == .pipe {
					node = p.assoc()
				} else if p.peek_tok.kind == .colon || p.tok.kind == .rcbr {
					node = p.struct_init(true) // short_syntax: true
				} else if p.tok.kind == .name {
					p.next()
					lit := if p.tok.lit != '' { p.tok.lit } else { p.tok.kind.str() }
					p.error('unexpected `$lit`, expecting `:`')
				} else {
					p.error('unexpected `$p.tok.lit`, expecting struct key')
				}
			}
			p.check(.rcbr)
		}
		.key_fn {
			// Anonymous function
			node = p.anon_fn()
			return node
		}
		else {
			if p.tok.kind == .comment {
				println(p.tok.lit)
			}
			p.error('expr(): bad token `$p.tok.kind.str()`')
		}
	}
	// Infix
	for precedence < p.tok.precedence() {
		if p.tok.kind.is_assign() && !p.is_stmt_ident {
			node = p.assign_expr(node)
		} else if p.tok.kind == .dot {
			node = p.dot_expr(node)
			p.is_stmt_ident = is_stmt_ident
		} else if p.tok.kind == .lsbr {
			node = p.index_expr(node)
		} else if p.tok.kind == .key_as {
			pos := p.tok.position()
			p.next()
			typ = p.parse_type()
			node = ast.AsCast{
				expr: node
				typ: typ
				pos: pos
			}
		} else if p.tok.kind == .left_shift && p.is_stmt_ident {
			// arr << elem
			tok := p.tok
			pos := tok.position()
			p.next()
			right := p.expr(precedence - 1)
			node = ast.InfixExpr{
				left: node
				right: right
				op: tok.kind
				pos: pos
			}
		} else if p.tok.kind.is_infix() {
			// return early for deref assign `*x = 2` goes to prefix expr
			if p.tok.kind == .mul && p.tok.line_nr != p.prev_tok.line_nr && p.peek_tok2.kind ==
				.assign {
				return node
			}
			// continue on infix expr
			node = p.infix_expr(node)
		} else if p.tok.kind in [.inc, .dec] {
			// Postfix
			node = ast.PostfixExpr{
				op: p.tok.kind
				expr: node
				pos: p.tok.position()
			}
			p.next()
			// return node // TODO bring back, only allow ++/-- in exprs in translated code
		} else {
			return node
		}
	}
	return node
}

fn (mut p Parser) infix_expr(left ast.Expr) ast.Expr {
	op := p.tok.kind
	// mut typ := p.
	// println('infix op=$op.str()')
	precedence := p.tok.precedence()
	pos := p.tok.position()
	p.next()
	mut right := ast.Expr{}
	if op == .key_is {
		p.expecting_type = true
	}
	right = p.expr(precedence)
	return ast.InfixExpr{
		left: left
		right: right
		op: op
		pos: pos
	}
}

fn (mut p Parser) prefix_expr() ast.PrefixExpr {
	pos := p.tok.position()
	op := p.tok.kind
	if op == .amp {
		p.is_amp = true
	}
	// if op == .mul && !p.inside_unsafe {
	// p.warn('unsafe')
	// }
	p.next()
	mut right := ast.Expr{}
	if op == .minus {
		right = p.expr(token.Precedence.call)
	} else {
		right = p.expr(token.Precedence.prefix)
	}
	p.is_amp = false
	return ast.PrefixExpr{
		op: op
		right: right
		pos: pos
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module parser

import v.ast
import v.table
import v.token
import v.util

fn (mut p Parser) struct_decl() ast.StructDecl {
	start_pos := p.tok.position()
	is_pub := p.tok.kind == .key_pub
	if is_pub {
		p.next()
	}
	is_union := p.tok.kind == .key_union
	if p.tok.kind == .key_struct {
		p.next()
	} else {
		p.check(.key_union)
	}
	language := if p.tok.lit == 'C' && p.peek_tok.kind == .dot {
		table.Language.c
	} else if p.tok.lit == 'JS' && p.peek_tok.kind == .dot {
		table.Language.js
	} else {
		table.Language.v
	}
	if language != .v {
		p.next() // C || JS
		p.next() // .
	}
	is_typedef := p.attr == 'typedef'
	no_body := p.peek_tok.kind != .lcbr
	if language == .v && no_body {
		p.error('`$p.tok.lit` lacks body')
	}
	end_pos := p.tok.position()
	mut name := p.check_name()
	if language == .v && p.mod != 'builtin' && name.len > 0 && !name[0].is_capital() {
		p.error_with_pos('struct name `$name` must begin with capital letter', end_pos)
	}
	// println('struct decl $name')
	mut ast_fields := []ast.StructField{}
	mut fields := []table.Field{}
	mut mut_pos := -1
	mut pub_pos := -1
	mut pub_mut_pos := -1
	mut global_pos := -1
	mut is_field_mut := false
	mut is_field_pub := false
	mut is_field_global := false
	if !no_body {
		p.check(.lcbr)
		for p.tok.kind != .rcbr {
			mut comment := ast.Comment{}
			if p.tok.kind == .comment {
				comment = p.comment()
			}
			if p.tok.kind == .key_pub {
				p.next()
				if p.tok.kind == .key_mut {
					if pub_mut_pos != -1 {
						p.error('redefinition of `pub mut` section')
					}
					p.next()
					pub_mut_pos = fields.len
					is_field_pub = true
					is_field_mut = true
					is_field_global = false
				} else {
					if pub_pos != -1 {
						p.error('redefinition of `pub` section')
					}
					pub_pos = fields.len
					is_field_pub = true
					is_field_mut = false
					is_field_global = false
				}
				p.check(.colon)
			} else if p.tok.kind == .key_mut {
				if mut_pos != -1 {
					p.error('redefinition of `mut` section')
				}
				p.next()
				p.check(.colon)
				mut_pos = fields.len
				is_field_pub = false
				is_field_mut = true
				is_field_global = false
			} else if p.tok.kind == .key_global {
				if global_pos != -1 {
					p.error('redefinition of `global` section')
				}
				p.next()
				p.check(.colon)
				global_pos = fields.len
				is_field_pub = true
				is_field_mut = true
				is_field_global = true
			}
			field_start_pos := p.tok.position()
			field_name := p.check_name()
			field_pos := field_start_pos.extend(p.tok.position())
			// p.warn('field $field_name')
			typ := p.parse_type()
			/*
			if name == '_net_module_s' {
			s := p.table.get_type_symbol(typ)
			println('XXXX' + s.str())
		}
			*/
			mut default_expr := ast.Expr{}
			mut has_default_expr := false
			if p.tok.kind == .assign {
				// Default value
				p.next()
				// default_expr = p.tok.lit
				// p.expr(0)
				default_expr = p.expr(0)
				match default_expr {
					ast.EnumVal { it.typ = typ }
					// TODO: implement all types??
					else {}
				}
				has_default_expr = true
			}
			mut attrs := []string{}
			if p.tok.kind == .lsbr {
				parsed_attrs := p.attributes()
				for attr in parsed_attrs {
					attrs << attr.name
				}
			}
			if p.tok.kind == .comment {
				comment = p.comment()
			}
			// TODO merge table and ast Fields?
			ast_fields << ast.StructField{
				name: field_name
				pos: field_pos
				typ: typ
				comment: comment
				default_expr: default_expr
				has_default_expr: has_default_expr
				attrs: attrs
				is_public: is_field_pub
			}
			fields << table.Field{
				name: field_name
				typ: typ
				default_expr: ast.ex2fe(default_expr)
				has_default_expr: has_default_expr
				is_pub: is_field_pub
				is_mut: is_field_mut
				is_global: is_field_global
				attrs: attrs
			}
			// println('struct field $ti.name $field_name')
		}
		p.check(.rcbr)
	}
	if language == .c {
		name = 'C.$name'
	} else if language == .js {
		name = 'JS.$name'
	} else {
		name = p.prepend_mod(name)
	}
	t := table.TypeSymbol{
		kind: .struct_
		name: name
		info: table.Struct{
			fields: fields
			is_typedef: is_typedef
			is_union: is_union
			is_ref_only: p.attr == 'ref_only'
		}
		mod: p.mod
		is_public: is_pub
	}
	mut ret := 0
	if p.builtin_mod && t.name in table.builtin_type_names {
		// this allows overiding the builtins type
		// with the real struct type info parsed from builtin
		ret = p.table.register_builtin_type_symbol(t)
	} else {
		ret = p.table.register_type_symbol(t)
	}
	if ret == -1 {
		p.error('cannot register type `$name`, another type with this name exists')
	}
	p.expr_mod = ''
	return ast.StructDecl{
		name: name
		is_pub: is_pub
		fields: ast_fields
		pos: start_pos.extend(end_pos)
		mut_pos: mut_pos
		pub_pos: pub_pos
		pub_mut_pos: pub_mut_pos
		language: language
		is_union: is_union
		attr: p.attr
	}
}

fn (mut p Parser) struct_init(short_syntax bool) ast.StructInit {
	first_pos := p.tok.position()
	typ := if short_syntax { table.void_type } else { p.parse_type() }
	p.expr_mod = ''
	// sym := p.table.get_type_symbol(typ)
	// p.warn('struct init typ=$sym.name')
	if !short_syntax {
		p.check(.lcbr)
	}
	mut fields := []ast.StructInitField{}
	mut i := 0
	no_keys := p.peek_tok.kind != .colon && p.tok.kind != .rcbr // `Vec{a,b,c}
	// p.warn(is_short_syntax.str())
	for p.tok.kind != .rcbr && p.tok.kind != .rpar {
		p.check_comment()
		mut field_name := ''
		if no_keys {
			expr := p.expr(0)
			// name will be set later in checker
			fields << ast.StructInitField{
				expr: expr
				pos: expr.position()
			}
		} else {
			first_field_pos := p.tok.position()
			field_name = p.check_name()
			p.check(.colon)
			expr := p.expr(0)
			last_field_pos := expr.position()
			field_pos := token.Position{
				line_nr: first_field_pos.line_nr
				pos: first_field_pos.pos
				len: last_field_pos.pos - first_field_pos.pos + last_field_pos.len
			}
			fields << ast.StructInitField{
				name: field_name
				expr: expr
				pos: field_pos
			}
		}
		i++
		if p.tok.kind == .comma {
			p.next()
		}
		p.check_comment()
	}
	last_pos := p.tok.position()
	if !short_syntax {
		p.check(.rcbr)
	}
	node := ast.StructInit{
		typ: typ
		fields: fields
		pos: token.Position{
			line_nr: first_pos.line_nr
			pos: first_pos.pos
			len: last_pos.pos - first_pos.pos + last_pos.len
		}
		is_short: no_keys
	}
	return node
}

fn (mut p Parser) interface_decl() ast.InterfaceDecl {
	start_pos := p.tok.position()
	is_pub := p.tok.kind == .key_pub
	if is_pub {
		p.next()
	}
	p.next() // `interface`
	interface_name := p.prepend_mod(p.check_name())
	// println('interface decl $interface_name')
	p.check(.lcbr)
	// Declare the type
	t := table.TypeSymbol{
		kind: .interface_
		name: interface_name
		mod: p.mod
		info: table.Interface{
			types: []
		}
	}
	typ := table.new_type(p.table.register_type_symbol(t))
	ts := p.table.get_type_symbol(typ) // TODO t vs ts
	// Parse methods
	mut methods := []ast.FnDecl{}
	for p.tok.kind != .rcbr && p.tok.kind != .eof {
		method_start_pos := p.tok.position()
		line_nr := p.tok.line_nr
		name := p.check_name()
		if util.contains_capital(name) {
			p.error('interface methods cannot contain uppercase letters, use snake_case instead')
		}
		// field_names << name
		args2, _ := p.fn_args()
		mut args := [table.Arg{
			name: 'x'
			typ: typ
			is_hidden: true
		}]
		args << args2
		mut method := ast.FnDecl{
			name: name
			args: args
			file: p.file_name
			return_type: table.void_type
			is_pub: true
			pos: method_start_pos.extend(p.prev_tok.position())
		}
		if p.tok.kind.is_start_of_type() && p.tok.line_nr == line_nr {
			method.return_type = p.parse_type()
		}
		methods << method
		// println('register method $name')
		ts.register_method(table.Fn{
			name: name
			args: args
			return_type: method.return_type
			is_pub: true
		})
	}
	p.check(.rcbr)
	return ast.InterfaceDecl{
		name: interface_name
		methods: methods
		pos: start_pos
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module pref

import os

pub const (
	default_module_path = mpath()
)

fn mpath() string {
	return os.home_dir() + '.vmodules'
}

pub fn new_preferences() Preferences {
	p := Preferences{}
	p.fill_with_defaults()
	return p
}

pub fn (mut p Preferences) fill_with_defaults() {
	if p.vroot == '' {
		// Location of all vlib files
		p.vroot = os.dir(vexe_path())
	}
	vlib_path := os.join_path(p.vroot, 'vlib')
	if p.lookup_path.len == 0 {
		p.lookup_path = ['@vlib', '@vmodules']
	}
	for i, path in p.lookup_path {
		p.lookup_path[i] = path.replace('@vlib', vlib_path).replace('@vmodules', default_module_path)
	}
	rpath := os.real_path(p.path)
	if p.out_name == '' {
		filename := os.file_name(rpath).trim_space()
		mut base := filename.all_before_last('.')
		if base == '' {
			// The file name is just `.v` or `.vsh` or `.*`
			base = filename
		}
		target_dir := if os.is_dir(rpath) { rpath } else { os.dir(rpath) }
		p.out_name = os.join_path(target_dir, base)
		if rpath == '$p.vroot/cmd/v' && os.is_dir('vlib/compiler') {
			// Building V? Use v2, since we can't overwrite a running
			// executable on Windows + the precompiled V is more
			// optimized.
			println('Saving the resulting V executable in `./v2`')
			println('Use `v -o v cmd/v` if you want to replace current ' + 'V executable.')
			p.out_name = 'v2'
		}
	}
	rpath_name := os.file_name(rpath)
	p.building_v = !p.is_repl && (rpath_name == 'v' || rpath_name == 'vfmt.v')
	if p.os == ._auto {
		// No OS specifed? Use current system
		p.os = get_host_os()
	}
	if p.ccompiler == '' {
		p.ccompiler = default_c_compiler()
	}
	p.is_test = p.path.ends_with('_test.v') || p.path.ends_with('.vv')
	p.is_script = p.path.ends_with('.v') || p.path.ends_with('.vsh')
	if p.third_party_option == '' {
		p.third_party_option = p.cflags
		$if !windows {
			if !p.third_party_option.contains('-fPIC') {
				p.third_party_option += ' -fPIC'
			}
		}
	}
}

fn default_c_compiler() string {
	// fast_clang := '/usr/local/Cellar/llvm/8.0.0/bin/clang'
	// if os.exists(fast_clang) {
	// return fast_clang
	// }
	// TODO fix $if after 'string'
	$if windows {
		return 'gcc'
	}
	return 'cc'
}

pub fn vexe_path() string {
	vexe := os.getenv('VEXE')
	if vexe != '' {
		return vexe
	}
	real_vexe_path := os.real_path(os.executable())
	os.setenv('VEXE', real_vexe_path, true)
	return real_vexe_path
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module pref

pub enum OS {
	_auto // Reserved so .mac cannot be misunderstood as auto
	mac
	linux
	windows
	freebsd
	openbsd
	netbsd
	dragonfly
	js // TODO
	android
	solaris
	haiku
}

// Helper function to convert string names to OS enum
pub fn os_from_string(os_str string) ?OS {
	match os_str {
		'linux' {
			return .linux
		}
		'windows' {
			return .windows
		}
		'mac' {
			return .mac
		}
		'macos' {
			return .mac
		}
		'freebsd' {
			return .freebsd
		}
		'openbsd' {
			return .openbsd
		}
		'netbsd' {
			return .netbsd
		}
		'dragonfly' {
			return .dragonfly
		}
		'js' {
			return .js
		}
		'solaris' {
			return .solaris
		}
		'android' {
			return .android
		}
		'haiku' {
			return .haiku
		}
		'linux_or_macos' {
			return .linux
		}
		'' {
			return ._auto
		}
		else {
			return error('bad OS $os_str')
		}
	}
}

pub fn (o OS) str() string {
	match o {
		._auto {
			return 'RESERVED: AUTO'
		}
		.mac {
			return 'MacOS'
		}
		.linux {
			return 'Linux'
		}
		.windows {
			return 'Windows'
		}
		.freebsd {
			return 'FreeBSD'
		}
		.openbsd {
			return 'OpenBSD'
		}
		.netbsd {
			return 'NetBSD'
		}
		.dragonfly {
			return 'Dragonfly'
		}
		.js {
			return 'JavaScript'
		}
		.android {
			return 'Android'
		}
		.solaris {
			return 'Solaris'
		}
		.haiku {
			return 'Haiku'
		}
	}
}

pub fn get_host_os() OS {
	$if linux {
		return .linux
	}
	$if macos {
		return .mac
	}
	$if windows {
		return .windows
	}
	$if freebsd {
		return .freebsd
	}
	$if openbsd {
		return .openbsd
	}
	$if netbsd {
		return .netbsd
	}
	$if dragonfly {
		return .dragonfly
	}
	$if solaris {
		return .solaris
	}
	$if haiku {
		return .haiku
	}
	panic('unknown host OS')
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module pref

import os.cmdline
import os

pub enum BuildMode {
	// `v program.v'
	// Build user code only, and add pre-compiled vlib (`cc program.o builtin.o os.o...`)
	default_mode
	// `v -lib ~/v/os`
	// build any module (generate os.o + os.vh)
	build_module
}

pub enum OutputMode {
	stdout
	silent
}

pub enum ColorOutput {
	auto
	always
	never
}

pub enum Backend {
	c            // The (default) C backend
	js           // The JavaScript backend
	x64          // The x64 backend
}

const (
	list_of_flags_with_param            = [
		'o'
		'output', 'd', 'define', 'b', 'backend', 'cc', 'os', 'target-os', 'arch', 'csource'
		'cf', 'cflags', 'path']
)

pub struct Preferences {
pub mut:
	os                  OS   // the OS to compile for
	backend             Backend
	build_mode          BuildMode
	output_mode         OutputMode = .stdout
	//verbosity           VerboseLevel
	is_verbose bool
	// nofmt            bool   // disable vfmt
	is_test             bool // `v test string_test.v`
	is_script           bool // single file mode (`v program.v`), main function can be skipped
	is_livemain         bool // main program that contains live/hot code
	is_liveshared       bool // a shared library, that will be used in a -live main program
	is_shared           bool // an ordinary shared library, -shared, no matter if it is live or not
	is_prof             bool // benchmark every function
	profile_file        string // the profile results will be stored inside profile_file
	profile_no_inline   bool // when true, [inline] functions would not be profiled
	translated          bool // `v translate doom.v` are we running V code translated from C? allow globals, ++ expressions, etc
	is_prod             bool // use "-O2"
	obfuscate           bool // `v -obf program.v`, renames functions to "f_XXX"
	is_repl             bool
	is_run              bool
	sanitize            bool // use Clang's new "-fsanitize" option
	is_debug            bool // false by default, turned on by -g or -cg, it tells v to pass -g to the C backend compiler.
	is_vlines           bool // turned on by -g, false by default (it slows down .tmp.c generation slightly).
	keep_c              bool // -keepc , tell v to leave the generated .tmp.c alone (since by default v will delete them after c backend finishes)
	show_cc             bool // -showcc, print cc command
	// NB: passing -cg instead of -g will set is_vlines to false and is_g to true, thus making v generate cleaner C files,
	// which are sometimes easier to debug / inspect manually than the .tmp.c files by plain -g (when/if v line number generation breaks).
	use_cache            bool // turns on v usage of the module cache to speed up compilation.
	is_stats            bool // `v -stats file_test.v` will produce more detailed statistics for the tests that were run
	no_auto_free        bool // `v -nofree` disable automatic `free()` insertion for better performance in some applications  (e.g. compilers)
	// TODO Convert this into a []string
	cflags              string // Additional options which will be passed to the C compiler.
	// For example, passing -cflags -Os will cause the C compiler to optimize the generated binaries for size.
	// You could pass several -cflags XXX arguments. They will be merged with each other.
	// You can also quote several options at the same time: -cflags '-Os -fno-inline-small-functions'.
	ccompiler           string // the name of the used C compiler
	third_party_option  string
	building_v          bool
	autofree            bool
	compress            bool
	// skip_builtin     bool   // Skips re-compilation of the builtin module
	// to increase compilation time.
	// This is on by default, since a vast majority of users do not
	// work on the builtin module itself.
	// generating_vh    bool
	fast                bool // use tcc/x64 codegen
	enable_globals      bool // allow __global for low level code
	is_fmt              bool
	is_bare             bool
	lookup_path         []string
	output_cross_c      bool
	prealloc            bool
	vroot               string
	out_name            string
	path                string // Path to file/folder to compile

	// -d vfmt and -d another=0 for `$if vfmt { will execute }` and `$if another { will NOT get here }`
	compile_defines     []string // just ['vfmt']
	compile_defines_all []string // contains both: ['vfmt','another']

	mod                 string
	run_args            []string // `v run x.v 1 2 3` => `1 2 3`
	printfn_list        []string // a list of generated function names, whose source should be shown, for debugging
	print_v_files       bool     // when true, just print the list of all parsed .v files then stop.
	skip_running        bool     // when true, do no try to run the produced file (set by b.cc(), when -o x.c or -o x.js)
	skip_warnings       bool     // like C's "-w"
	use_color           ColorOutput // whether the warnings/errors should use ANSI color escapes.
	is_parallel bool
	error_limit int
}

pub fn parse_args(args []string) (&Preferences, string) {
	mut res := &pref.Preferences{}
	mut command := ''
	mut command_pos := 0
	// for i, arg in args {
	for i := 0; i < args.len; i++ {
		arg := args[i]
		current_args := args[i..]
		match arg {
			'-v' {
				res.is_verbose = true
			}
			'-silent' {
				res.output_mode = .silent
			}
			'-cg' {
				res.is_debug = true
			}
			'-repl' {
				res.is_repl = true
			}
			'-live' {
				res.is_livemain = true
			}
			'-sharedlive' {
				res.is_liveshared = true
				res.is_shared = true
			}
			'-shared' {
				res.is_shared = true
			}
			'--enable-globals' {
				res.enable_globals = true
			}
			'-autofree' {
				res.autofree = true
			}
			'-compress' {
				res.compress = true
			}
			'-freestanding' {
				res.is_bare = true
			}
			'-prof', '-profile' {
				res.profile_file = cmdline.option(current_args, '-profile', '-')
				res.is_prof = true
				i++
			}
			'-profile-no-inline' {
				res.profile_no_inline = true
			}
			'-prod' {
				res.is_prod = true
			}
			'-stats' {
				res.is_stats = true
			}
			'-obfuscate' {
				res.obfuscate = true
			}
			'-translated' {
				res.translated = true
			}
			'-color' {
				res.use_color=.always
			}
			'-nocolor' {
				res.use_color=.never
			}
			'-showcc' {
				res.show_cc = true
			}
			'-usecache' {
				res.use_cache = true
			}
			'-keepc' {
				res.keep_c = true
			}
			'-parallel' {
				res.is_parallel = true
			}
			'-x64' {
				res.backend = .x64
			}
			'-w' {
				res.skip_warnings = true
			}
			'-print_v_files' {
				res.print_v_files = true
			}
			'-error-limit' {
				res.error_limit =cmdline.option(current_args, '-error-limit', '0').int()
			}
			'-os' {
				target_os := cmdline.option(current_args, '-os', '')
				i++
				target_os_kind := pref.os_from_string(target_os) or {
					if target_os == 'cross' {
						res.output_cross_c = true
						continue
					}
					println('unknown operating system target `$target_os`')
					exit(1)
				}
				res.os = target_os_kind
			}
			'-printfn' {
				res.printfn_list << cmdline.option(current_args, '-printfn', '')
				i++
			}
			'-cflags' {
				res.cflags += ' ' + cmdline.option(current_args, '-cflags', '')
				i++
			}
			'-define', '-d' {
				if current_args.len > 1 {
					define := current_args[1]
					parse_define(mut res, define)
				}
				i++
			}
			'-cc' {
				res.ccompiler = cmdline.option(current_args, '-cc', 'cc')
				i++
			}
			'-o' {
				res.out_name = cmdline.option(current_args, '-o', '')
				i++
			}
			'-b' {
				b := pref.backend_from_string(cmdline.option(current_args, '-b', 'c')) or {
					continue
				}
				res.backend = b
				i++
			}
			else {
				mut should_continue := false
				for flag_with_param in list_of_flags_with_param {
					if '-$flag_with_param' == arg {
						should_continue = true
						i++
						break
					}
				}
				if should_continue {
					continue
				}
				if !arg.starts_with('-') && command == '' {
					command = arg
					command_pos = i
				}
			}
		}
	}
	if command.ends_with('.v') || os.exists(command) {
		res.path = command
	} else if command == 'run' {
		res.is_run = true
		if command_pos + 2 > args.len {
			eprintln('v run: no v files listed')
			exit(1)
		}
		res.path = args[command_pos + 1]
		res.run_args = args[command_pos + 2..]
	}
	if command == 'build-module' {
		res.build_mode = .build_module
		res.path = args[command_pos + 1]
	}
	if res.is_verbose {
		println('setting pref.path to "$res.path"')
	}
	res.fill_with_defaults()
	return res, command
}


pub fn backend_from_string(s string) ?Backend {
	match s {
		'c' {
			return .c
		}
		'js' {
			return .js
		}
		'x64' {
			return .x64
		}
		else {
			return error('Unknown backend type $s')
		}
	}
}

fn parse_define(prefs mut Preferences, define string) {
    define_parts := define.split('=')
    if define_parts.len == 1 {
        prefs.compile_defines << define
        prefs.compile_defines_all << define
        return
    }
    if define_parts.len == 2 {
        prefs.compile_defines_all << define_parts[0]
        match define_parts[1] {
            '0' {}
            '1' {
                prefs.compile_defines << define_parts[0]
            }
            else {
                println('V error: Unknown define argument value `${define_parts[1]}` for ${define_parts[0]}.' +
                    'Expected `0` or `1`.')
                exit(1)
            }
        }
        return
    }
    println('V error: Unknown define argument: ${define}. Expected at most one `=`.')
    exit(1)
}
module pref

import os

pub fn (prefs &Preferences) should_compile_filtered_files(dir string, files []string) []string {
	mut res := []string{}
	files.sort()
	for file in files {
		if !file.ends_with('.v') && !file.ends_with('.vh') {
			continue
		}
		if file.ends_with('_test.v') {
			continue
		}
		if prefs.backend == .c && !prefs.should_compile_c(file) {
			continue
		}
		if prefs.backend == .js && !prefs.should_compile_js(file) {
			continue
		}
		if prefs.compile_defines_all.len > 0 && file.contains('_d_') {
			mut allowed := false
			for cdefine in prefs.compile_defines {
				file_postfix := '_d_${cdefine}.v'
				if file.ends_with(file_postfix) {
					allowed = true
					break
				}
			}
			if !allowed {
				continue
			}
		}
		res << os.join_path(dir, file)
	}
	return res
}

pub fn (prefs &Preferences) should_compile_c(file string) bool {
	if !file.ends_with('.c.v') && file.split('.').len > 2 {
		// Probably something like `a.js.v`.
		return false
	}
	if (file.ends_with('_windows.c.v') || file.ends_with('_windows.v')) && prefs.os != .windows {
		return false
	}
	if (file.ends_with('_linux.c.v') || file.ends_with('_linux.v')) && prefs.os != .linux {
		return false
	}
	if (file.ends_with('_darwin.c.v') || file.ends_with('_darwin.v')) && prefs.os != .mac {
		return false
	}
	if file.ends_with('_nix.c.v') && prefs.os == .windows {
		return false
	}
	if file.ends_with('_android.c.v') && prefs.os != .android {
		return false
	}
	if file.ends_with('_freebsd.c.v') && prefs.os != .freebsd {
		return false
	}
	if file.ends_with('_solaris.c.v') && prefs.os != .solaris {
		return false
	}
	return true
}

pub fn (prefs &Preferences) should_compile_js(file string) bool {
	if !file.ends_with('.js.v') && file.split('.').len > 2 {
		// Probably something like `a.c.v`.
		return false
	}
	return true
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module scanner

import os
import v.token
import v.pref
import v.util

const (
	single_quote = `\'`
	double_quote = `"`
// char used as number separator
	num_sep = `_`
)

pub struct Scanner {
pub mut:
	file_path                   string
	text                        string
	pos                         int
	line_nr                     int
	last_nl_pos                 int // for calculating column
	is_inside_string            bool
	is_inter_start              bool // for hacky string interpolation TODO simplify
	is_inter_end                bool
	is_debug                    bool
	line_comment                string
	// prev_tok                 TokenKind
	is_started                  bool
	fn_name                     string // needed for @FN
	is_print_line_on_error      bool
	is_print_colored_error      bool
	is_print_rel_paths_on_error bool
	quote                       byte // which quote is used to denote current string: ' or "
	line_ends                   []int // the positions of source lines ends   (i.e. \n signs)
	nr_lines                    int // total number of lines in the source file that were scanned
	is_vh                       bool // Keep newlines
	is_fmt                      bool // Used only for skipping ${} in strings, since we need literal
	// string values when generating formatted code.
	comments_mode               CommentsMode
}

pub enum CommentsMode {
	skip_comments
	parse_comments
}

// new scanner from file.
pub fn new_scanner_file(file_path string, comments_mode CommentsMode) &Scanner {
	if !os.exists(file_path) {
		verror("$file_path doesn't exist")
	}
	raw_text := util.read_file( file_path ) or {
		verror(err)
		return 0
	}
	mut s := new_scanner(raw_text, comments_mode) // .skip_comments)
	// s.init_fmt()
	s.file_path = file_path
	return s
}

// new scanner from string.
pub fn new_scanner(text string, comments_mode CommentsMode) &Scanner {
	s := &Scanner{
		text: text
		is_print_line_on_error: true
		is_print_colored_error: true
		is_print_rel_paths_on_error: true
		is_fmt: util.is_fmt()
		comments_mode: comments_mode
	}
	return s
}

fn (s &Scanner) new_token(tok_kind token.Kind, lit string, len int) token.Token {
	return token.Token{
		kind: tok_kind
		lit: lit
		line_nr: s.line_nr + 1
		pos: s.pos - len + 1
		len: len
	}
}

fn (mut s Scanner) ident_name() string {
	start := s.pos
	s.pos++
	for s.pos < s.text.len && (util.is_name_char(s.text[s.pos]) || s.text[s.pos].is_digit()) {
		s.pos++
	}
	name := s.text[start..s.pos]
	s.pos--
	return name
}

// ident_fn_name look ahead and return name of function if possible, otherwise empty string
fn (mut s Scanner) ident_fn_name() string {
	start := s.pos
	mut pos := s.pos
	pos++
	// Search for function scope start
	for pos < s.text.len && s.text[pos] != `{` {
		pos++
	}
	if pos >= s.text.len {
		return ""
	}
	// Search backwards for "first" occurrence of function open paranthesis
	for pos > start && s.text[pos] != `(` {
		pos--
	}
	if pos < start {
		return ""
	}
	// Search backwards for end position of function name
	for pos > start && !util.is_func_char(s.text[pos]) {
		pos--
	}
	end_pos := pos + 1
	if pos < start {
		return ""
	}
	// Search for the start position
	for pos > start && util.is_func_char(s.text[pos]) {
		pos--
	}
	start_pos := pos + 1
	if pos < start || pos >= s.text.len  {
		return ""
	}
	if s.text[start_pos].is_digit() || end_pos > s.text.len || end_pos <= start_pos || end_pos <= start || start_pos <= start {
		return ""
	}
	fn_name := s.text[start_pos..end_pos]
	return fn_name
}

fn filter_num_sep(txt byteptr, start int, end int) string {
	unsafe{
		mut b := malloc(end - start + 1) // add a byte for the endstring 0
		mut i := start
		mut i1 := 0
		for i < end {
			if txt[i] != num_sep {
				b[i1] = txt[i]
				i1++
			}
			i++
		}
		b[i1] = 0 // C string compatibility
		return string(b,i1)
	}
}

fn (mut s Scanner) ident_bin_number() string {
	mut has_wrong_digit := false
	mut first_wrong_digit_pos := 0
	mut first_wrong_digit := `\0`
	start_pos := s.pos
	s.pos += 2 // skip '0b'
	for s.pos < s.text.len {
		c := s.text[s.pos]
		if !c.is_bin_digit() && c != num_sep {
			if (!c.is_digit() && !c.is_letter()) || s.is_inside_string {
				break
			}
			else if !has_wrong_digit {
				has_wrong_digit = true
				first_wrong_digit_pos = s.pos
				first_wrong_digit = c
			}
		}
		s.pos++
	}
	if start_pos + 2 == s.pos {
		s.pos-- // adjust error position
		s.error('number part of this binary is not provided')
	}
	else if has_wrong_digit {
		s.pos = first_wrong_digit_pos // adjust error position
		s.error('this binary number has unsuitable digit `${first_wrong_digit.str()}`')
	}
	number := filter_num_sep(s.text.str, start_pos, s.pos)
	s.pos--
	return number
}

fn (mut s Scanner) ident_hex_number() string {
	mut has_wrong_digit := false
	mut first_wrong_digit_pos := 0
	mut first_wrong_digit := `\0`
	start_pos := s.pos
	s.pos += 2 // skip '0x'
	for s.pos < s.text.len {
		c := s.text[s.pos]
		if !c.is_hex_digit() && c != num_sep {
			if !c.is_letter() || s.is_inside_string {
				break
			}
			else if !has_wrong_digit {
				has_wrong_digit = true
				first_wrong_digit_pos = s.pos
				first_wrong_digit = c
			}
		}
		s.pos++
	}
	if start_pos + 2 == s.pos {
		s.pos-- // adjust error position
		s.error('number part of this hexadecimal is not provided')
	}
	else if has_wrong_digit {
		s.pos = first_wrong_digit_pos // adjust error position
		s.error('this hexadecimal number has unsuitable digit `${first_wrong_digit.str()}`')
	}
	number := filter_num_sep(s.text.str, start_pos, s.pos)
	s.pos--
	return number
}

fn (mut s Scanner) ident_oct_number() string {
	mut has_wrong_digit := false
	mut first_wrong_digit_pos := 0
	mut first_wrong_digit := `\0`
	start_pos := s.pos
	s.pos += 2 // skip '0o'
	for s.pos < s.text.len {
		c := s.text[s.pos]
		if !c.is_oct_digit() && c != num_sep {
			if (!c.is_digit() && !c.is_letter()) || s.is_inside_string {
				break
			}
			else if !has_wrong_digit {
				has_wrong_digit = true
				first_wrong_digit_pos = s.pos
				first_wrong_digit = c
			}
		}
		s.pos++
	}
	if start_pos + 2 == s.pos {
		s.pos-- // adjust error position
		s.error('number part of this octal is not provided')
	}
	else if has_wrong_digit {
		s.pos = first_wrong_digit_pos // adjust error position
		s.error('this octal number has unsuitable digit `${first_wrong_digit.str()}`')
	}
	number := filter_num_sep(s.text.str, start_pos, s.pos)
	s.pos--
	return number
}

fn (mut s Scanner) ident_dec_number() string {
	mut has_wrong_digit := false
	mut first_wrong_digit_pos := 0
	mut first_wrong_digit := `\0`
	start_pos := s.pos
	// scan integer part
	for s.pos < s.text.len {
		c := s.text[s.pos]
		if !c.is_digit() && c != num_sep {
			if !c.is_letter() || c in [`e`, `E`] || s.is_inside_string {
				break
			}
			else if !has_wrong_digit {
				has_wrong_digit = true
				first_wrong_digit_pos = s.pos
				first_wrong_digit = c
			}
		}
		s.pos++
	}
	mut call_method := false  // true for, e.g., 5.str(), 5.5.str(), 5e5.str()
	mut is_range := false  // true for, e.g., 5..10
	mut is_float_without_fraction := false  // true for, e.g. 5.
	// scan fractional part
	if s.pos < s.text.len && s.text[s.pos] == `.` {
		s.pos++
		if s.pos < s.text.len {
			// 5.5, 5.5.str()
			if s.text[s.pos].is_digit() {
				for s.pos < s.text.len {
					c := s.text[s.pos]
					if !c.is_digit() {
						if !c.is_letter() || c in [`e`, `E`] || s.is_inside_string {
							// 5.5.str()
							if c == `.` && s.pos + 1 < s.text.len && s.text[s.pos + 1].is_letter() {
								call_method = true
							}
							break
						}
						else if !has_wrong_digit {
							has_wrong_digit = true
							first_wrong_digit_pos = s.pos
							first_wrong_digit = c
						}
					}
					s.pos++
				}
			}
			else if s.text[s.pos] == `.` {
			// 5.. (a range)
				is_range = true
				s.pos--
			}
			else if s.text[s.pos] in [`e`, `E`] {
			// 5.e5
			}
			else if s.text[s.pos].is_letter() {
			// 5.str()
				call_method = true
				s.pos--
			}
			else if s.text[s.pos] != `)` {
			// 5.
				is_float_without_fraction = true
				s.pos--
			}
		}
	}
	// scan exponential part
	mut has_exp := false
	if s.pos < s.text.len && s.text[s.pos] in [`e`, `E`] {
		has_exp = true
		s.pos++
		if s.pos < s.text.len && s.text[s.pos] in [`-`, `+`] {
			s.pos++
		}
		for s.pos < s.text.len {
			c := s.text[s.pos]
			if !c.is_digit() {
				if !c.is_letter() || s.is_inside_string {
					// 5e5.str()
					if c == `.` && s.pos + 1 < s.text.len && s.text[s.pos + 1].is_letter() {
						call_method = true
					}
					break
				}
				else if !has_wrong_digit {
					has_wrong_digit = true
					first_wrong_digit_pos = s.pos
					first_wrong_digit = c
				}
			}
			s.pos++
		}
	}
	if has_wrong_digit {
	// error check: wrong digit
		s.pos = first_wrong_digit_pos // adjust error position
		s.error('this number has unsuitable digit `${first_wrong_digit.str()}`')
	}
	else if s.text[s.pos - 1] in [`e`, `E`] {
	// error check: 5e
		s.pos-- // adjust error position
		s.error('exponent has no digits')
	}
	else if s.pos < s.text.len && s.text[s.pos] == `.` && !is_range && !is_float_without_fraction && !call_method {
	// error check: 1.23.4, 123.e+3.4
		if has_exp {
			s.error('exponential part should be integer')
		}
		else {
			s.error('too many decimal points in number')
		}
	}
	number := filter_num_sep(s.text.str, start_pos, s.pos)
	s.pos--
	return number
}

fn (mut s Scanner) ident_number() string {
	if s.expect('0b', s.pos) {
		return s.ident_bin_number()
	}
	else if s.expect('0x', s.pos) {
		return s.ident_hex_number()
	}
	else if s.expect('0o', s.pos) {
		return s.ident_oct_number()
	}
	else {
		return s.ident_dec_number()
	}
}

fn (mut s Scanner) skip_whitespace() {
	// if s.is_vh { println('vh') return }
	for s.pos < s.text.len && s.text[s.pos].is_space() {
		if util.is_nl(s.text[s.pos]) && s.is_vh {
			return
		}
		// Count \r\n as one line
		if util.is_nl(s.text[s.pos]) && !s.expect('\r\n', s.pos - 1) {
			s.inc_line_number()
		}
		s.pos++
	}
}

fn (mut s Scanner) end_of_file() token.Token {
	s.pos = s.text.len
	s.inc_line_number()
	return s.new_token(.eof, '', 1)
}

pub fn (mut s Scanner) scan() token.Token {
	// if s.comments_mode == .parse_comments {
	// println('\nscan()')
	// }
	// if s.line_comment != '' {
	// s.fgenln('// LC "$s.line_comment"')
	// s.line_comment = ''
	// }
	if s.is_started {
		s.pos++
	}
	s.is_started = true
	if s.pos >= s.text.len {
		return s.end_of_file()
	}
	if !s.is_inside_string {
		s.skip_whitespace()
	}
	// End of $var, start next string
	if s.is_inter_end {
		if s.text[s.pos] == s.quote {
			s.is_inter_end = false
			return s.new_token(.string, '', 1)
		}
		s.is_inter_end = false
		ident_string := s.ident_string()
		return s.new_token(.string, ident_string, ident_string.len + 2) // + two quotes
	}
	s.skip_whitespace()
	// end of file
	if s.pos >= s.text.len {
		return s.end_of_file()
	}
	// handle each char
	c := s.text[s.pos]
	nextc := if s.pos + 1 < s.text.len { s.text[s.pos + 1] } else { `\0` }

	// name or keyword
	if util.is_name_char(c) {
		name := s.ident_name()
		// tmp hack to detect . in ${}
		// Check if not .eof to prevent panic
		next_char := if s.pos + 1 < s.text.len { s.text[s.pos + 1] } else { `\0` }
		if token.is_key(name) {
			kind := token.key_to_token(name)
			if kind == .key_fn {
				s.fn_name = s.ident_fn_name()
			}
			return s.new_token(kind, name, name.len)
		}
		// 'asdf $b' => "b" is the last name in the string, dont start parsing string
		// at the next ', skip it
		if s.is_inside_string {
			if next_char == s.quote {
				s.is_inter_end = true
				s.is_inter_start = false
				s.is_inside_string = false
			}
		}
		// end of `$expr`
		// allow `'$a.b'` and `'$a.c()'`
		if s.is_inter_start && next_char != `.` && next_char != `(` {
			s.is_inter_end = true
			s.is_inter_start = false
		}
		if s.pos == 0 && next_char == ` ` {
			// If a single letter name at the start of the file, increment
			// Otherwise the scanner would be stuck at s.pos = 0
			s.pos++
		}
		return s.new_token(.name, name, name.len)
	}
	else if c.is_digit() || (c == `.` && nextc.is_digit()) {
	// `123`, `.123`
		if !s.is_inside_string {
			// In C ints with `0` prefix are octal (in V they're decimal), so discarding heading zeros is needed.
			mut start_pos := s.pos
			for start_pos < s.text.len && s.text[start_pos] == `0` {
				start_pos++
			}
			mut prefix_zero_num := start_pos - s.pos // how many prefix zeros should be jumped
			// for 0b, 0o, 0x the heading zero shouldn't be jumped
			if start_pos == s.text.len || (c == `0` && !s.text[start_pos].is_digit()) {
				prefix_zero_num--
			}
			s.pos += prefix_zero_num // jump these zeros
		}
		num := s.ident_number()
		return s.new_token(.number, num, num.len)
	}
	// Handle `'$fn()'`
	if c == `)` && s.is_inter_start {
		s.is_inter_end = true
		s.is_inter_start = false
		next_char := if s.pos + 1 < s.text.len { s.text[s.pos + 1] } else { `\0` }
		if next_char == s.quote {
			s.is_inside_string = false
		}
		return s.new_token(.rpar, '', 1)
	}
	// all other tokens
	match c {
		`+` {
			if nextc == `+` {
				s.pos++
				return s.new_token(.inc, '', 2)
			}
			else if nextc == `=` {
				s.pos++
				return s.new_token(.plus_assign, '', 2)
			}
			return s.new_token(.plus, '', 1)
		}
		`-` {
			if nextc == `-` {
				s.pos++
				return s.new_token(.dec, '', 2)
			}
			else if nextc == `=` {
				s.pos++
				return s.new_token(.minus_assign, '', 2)
			}
			return s.new_token(.minus, '', 1)
		}
		`*` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.mult_assign, '', 2)
			}
			return s.new_token(.mul, '', 1)
		}
		`^` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.xor_assign, '', 2)
			}
			return s.new_token(.xor, '', 1)
		}
		`%` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.mod_assign, '', 2)
			}
			return s.new_token(.mod, '', 1)
		}
		`?` {
			return s.new_token(.question, '', 1)
		}
		single_quote, double_quote {
			ident_string := s.ident_string()
			return s.new_token(.string, ident_string, ident_string.len + 2) // + two quotes
		}
		`\`` {
			// ` // apostrophe balance comment. do not remove
			ident_char := s.ident_char()
			return s.new_token(.chartoken, ident_char, ident_char.len + 2) // + two quotes
		}
		`(` {
			return s.new_token(.lpar, '', 1)
		}
		`)` {
			return s.new_token(.rpar, '', 1)
		}
		`[` {
			return s.new_token(.lsbr, '', 1)
		}
		`]` {
			return s.new_token(.rsbr, '', 1)
		}
		`{` {
			// Skip { in `${` in strings
			if s.is_inside_string {
				return s.scan()
			}
			return s.new_token(.lcbr, '', 1)
		}
		`$` {
			if s.is_inside_string {
				return s.new_token(.str_dollar, '', 1)
			}
			else {
				return s.new_token(.dollar, '', 1)
			}
		}
		`}` {
			// s = `hello $name !`
			// s = `hello ${name} !`
			if s.is_inside_string {
				s.pos++
				if s.text[s.pos] == s.quote {
					s.is_inside_string = false
					return s.new_token(.string, '', 1)
				}
				ident_string := s.ident_string()
				return s.new_token(.string, ident_string, ident_string.len + 2) // + two quotes
			}
			else {
				return s.new_token(.rcbr, '', 1)
			}
		}
		`&` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.and_assign, '', 2)
			}
			if nextc == `&` {
				s.pos++
				return s.new_token(.and, '', 2)
			}
			return s.new_token(.amp, '', 1)
		}
		`|` {
			if nextc == `|` {
				s.pos++
				return s.new_token(.logical_or, '', 2)
			}
			if nextc == `=` {
				s.pos++
				return s.new_token(.or_assign, '', 2)
			}
			return s.new_token(.pipe, '', 1)
		}
		`,` {
			return s.new_token(.comma, '', 1)
		}
		`@` {
			s.pos++
			name := s.ident_name()
			// @FN => will be substituted with the name of the current V function
			// @VEXE => will be substituted with the path to the V compiler
			// @FILE => will be substituted with the path of the V source file
			// @LINE => will be substituted with the V line number where it appears (as a string).
			// @COLUMN => will be substituted with the column where it appears (as a string).
			// @VHASH  => will be substituted with the shortened commit hash of the V compiler (as a string).
			// This allows things like this:
			// println( 'file: ' + @FILE + ' | line: ' + @LINE + ' | fn: ' + @FN)
			// ... which is useful while debugging/tracing
			if name == 'FN' {
				return s.new_token(.string, s.fn_name, 3)
			}
			if name == 'VEXE' {
				vexe := pref.vexe_path()
				return s.new_token(.string, util.cescaped_path(vexe), 5)
			}
			if name == 'FILE' {
				return s.new_token(.string, util.cescaped_path(os.real_path(s.file_path)), 5)
			}
			if name == 'LINE' {
				return s.new_token(.string, (s.line_nr + 1).str(), 5)
			}
			if name == 'COLUMN' {
				return s.new_token(.string, s.current_column().str(), 7)
			}
			if name == 'VHASH' {
				return s.new_token(.string, util.vhash(), 6)
			}
			if !token.is_key(name) {
				s.error('@ must be used before keywords (e.g. `@type string`)')
			}
			return s.new_token(.name, name, name.len)
		}
		/*
	case `\r`:
		if nextc == `\n` {
			s.pos++
			s.last_nl_pos = s.pos
			return s.new_token(.nl, '')
		}
	 }
	case `\n`:
		s.last_nl_pos = s.pos
		return s.new_token(.nl, '')
	 }
	*/

		`.` {
			if nextc == `.` {
				s.pos++
				if s.text[s.pos + 1] == `.` {
					s.pos++
					return s.new_token(.ellipsis, '', 3)
				}
				return s.new_token(.dotdot, '', 2)
			}
			return s.new_token(.dot, '', 1)
		}
		`#` {
			start := s.pos + 1
			s.ignore_line()
			if nextc == `!` {
				// treat shebang line (#!) as a comment
				s.line_comment = s.text[start + 1..s.pos].trim_space()
				// s.fgenln('// shebang line "$s.line_comment"')
				return s.scan()
			}
			hash := s.text[start..s.pos].trim_space()
			return s.new_token(.hash, hash, hash.len)
		}
		`>` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.ge, '', 2)
			}
			else if nextc == `>` {
				if s.pos + 2 < s.text.len && s.text[s.pos + 2] == `=` {
					s.pos += 2
					return s.new_token(.right_shift_assign, '', 3)
				}
				s.pos++
				return s.new_token(.right_shift, '', 2)
			}
			else {
				return s.new_token(.gt, '', 1)
			}
		}
		0xE2 {
			if nextc == 0x89 && s.text[s.pos + 2] == 0xA0 {
			// case ``:
				s.pos += 2
				return s.new_token(.ne, '', 3)
			}
			else if nextc == 0x89 && s.text[s.pos + 2] == 0xBD {
				s.pos += 2
				return s.new_token(.le, '', 3)
			}
			else if nextc == 0xA9 && s.text[s.pos + 2] == 0xBE {
				s.pos += 2
				return s.new_token(.ge, '', 3)
			}
		}
		`<` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.le, '', 2)
			}
			else if nextc == `<` {
				if s.pos + 2 < s.text.len && s.text[s.pos + 2] == `=` {
					s.pos += 2
					return s.new_token(.left_shift_assign, '', 3)
				}
				s.pos++
				return s.new_token(.left_shift, '', 2)
			}
			else {
				return s.new_token(.lt, '', 1)
			}
		}
		`=` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.eq, '', 2)
			}
			else if nextc == `>` {
				s.pos++
				return s.new_token(.arrow, '', 2)
			}
			else {
				return s.new_token(.assign, '', 1)
			}
		}
		`:` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.decl_assign, '', 2)
			}
			else {
				return s.new_token(.colon, '', 1)
			}
		}
		`;` {
			return s.new_token(.semicolon, '', 1)
		}
		`!` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.ne, '', 2)
			}
			else if nextc == `i` && s.text[s.pos+2] == `n` && s.text[s.pos+3].is_space() {
				s.pos += 2
				return s.new_token(.not_in, '', 3)
			}
			else {
				return s.new_token(.not, '', 1)
			}
		}
		`~` {
			return s.new_token(.bit_not, '', 1)
		}
		`/` {
			if nextc == `=` {
				s.pos++
				return s.new_token(.div_assign, '', 2)
			}
			if nextc == `/` {
				start := s.pos + 1
				s.ignore_line()
				s.line_comment = s.text[start + 1..s.pos]
				mut comment := s.line_comment.trim_space()
				s.pos--
				// fix line_nr, \n was read, and the comment is marked
				// on the next line
				s.line_nr--
				if s.comments_mode == .parse_comments {
					// Find out if this comment is on its own line (for vfmt)
					mut is_separate_line_comment := true
					for j := start-2; j >= 0 && s.text[j] != `\n`; j-- {
						if s.text[j] !in [`\t`, ` `] {
							is_separate_line_comment = false
						}
					}
					if is_separate_line_comment {
						comment = '|' + comment
					}
					return s.new_token(.comment, comment, comment.len + 2)
				}
				// s.fgenln('// ${s.prev_tok.str()} "$s.line_comment"')
				// Skip the comment (return the next token)
				return s.scan()
			}
			// Multiline comments
			if nextc == `*` {
				start := s.pos + 2
				mut nest_count := 1
				// Skip comment
				for nest_count > 0 {
					s.pos++
					if s.pos >= s.text.len {
						s.line_nr--
						s.error('comment not terminated')
					}
					if s.text[s.pos] == `\n` {
						s.inc_line_number()
						continue
					}
					if s.expect('/*', s.pos) {
						nest_count++
						continue
					}
					if s.expect('*/', s.pos) {
						nest_count--
					}
				}
				s.pos++
				if s.comments_mode == .parse_comments {
					comment := s.text[start..(s.pos - 1)].trim_space()
					return s.new_token(.comment, comment, comment.len + 4)
				}
				// Skip if not in fmt mode
				return s.scan()
			}
			return s.new_token(.div, '', 1)
		}
		else {}
	}
	$if windows {
		if c == `\0` {
			return s.end_of_file()
		}
	}
	s.error('invalid character `${c.str()}`')
	return s.end_of_file()
}

fn (s &Scanner) current_column() int {
	return s.pos - s.last_nl_pos
}

fn (s &Scanner) count_symbol_before(p int, sym byte) int {
	mut count := 0
	for i := p; i >= 0; i-- {
		if s.text[i] != sym {
			break
		}
		count++
	}
	return count
}

fn (mut s Scanner) ident_string() string {
	q := s.text[s.pos]
	is_quote := q == single_quote || q == double_quote
	is_raw := is_quote && s.pos > 0 && s.text[s.pos - 1] == `r`
	if is_quote && !s.is_inside_string {
		s.quote = q
	}
	// if s.file_path.contains('string_test') {
	// println('\nident_string() at char=${s.text[s.pos].str()}')
	// println('linenr=$s.line_nr quote=  $qquote ${qquote.str()}')
	// }
	mut start := s.pos
	s.is_inside_string = false
	slash := `\\`
	for {
		s.pos++
		if s.pos >= s.text.len {
			break
		}
		c := s.text[s.pos]
		prevc := s.text[s.pos - 1]
		// end of string
		if c == s.quote && (prevc != slash || (prevc == slash && s.text[s.pos - 2] == slash)) {
			// handle '123\\'  slash at the end
			break
		}
		if c == `\n` {
			s.inc_line_number()
		}
		// Don't allow \0
		if c == `0` && s.pos > 2 && s.text[s.pos - 1] == slash {
			if s.pos < s.text.len - 1 && s.text[s.pos + 1].is_digit() {}
			else {
				s.error('0 character in a string literal')
			}
		}
		// Don't allow \x00
		if c == `0` && s.pos > 5 && s.expect('\\x0', s.pos - 3) {
			s.error('0 character in a string literal')
		}
		// ${var} (ignore in vfmt mode)
		if c == `{` && prevc == `$` && !is_raw && !s.is_fmt && s.count_symbol_before(s.pos - 2, slash) % 2 == 0 {
			s.is_inside_string = true
			// so that s.pos points to $ at the next step
			s.pos -= 2
			break
		}
		// $var
		if util.is_name_char(c) && prevc == `$` && !s.is_fmt && !is_raw && s.count_symbol_before(s.pos - 2, slash) % 2 == 0 {
			s.is_inside_string = true
			s.is_inter_start = true
			s.pos -= 2
			break
		}
	}
	mut lit := ''
	if s.text[start] == s.quote {
		start++
	}
	mut end := s.pos
	if s.is_inside_string {
		end++
	}
	if start <= s.pos {
		if s.text[start..end].contains('\\\n') {
			lit = trim_slash_line_break(s.text[start..end])
		} else {
			lit = s.text[start..end]
		}
	}
	return lit
}

fn trim_slash_line_break(s string) string {
	mut start := 0
	mut ret_str := s
	for {
		idx := ret_str.index_after('\\\n', start)
		if idx != -1 {
			ret_str = ret_str[..idx] + ret_str[idx+2..].trim_left(' \n\t\v\f\r')
			start = idx
		} else {
			break
		}
	}
	return ret_str
}

fn (mut s Scanner) ident_char() string {
	start := s.pos
	slash := `\\`
	mut len := 0
	for {
		s.pos++
		if s.pos >= s.text.len {
			break
		}
		if s.text[s.pos] != slash {
			len++
		}
		double_slash := s.expect('\\\\', s.pos - 2)
		if s.text[s.pos] == `\`` && (s.text[s.pos - 1] != slash || double_slash) {
			// ` // apostrophe balance comment. do not remove
			if double_slash {
				len++
			}
			break
		}
	}
	len--
	c := s.text[start + 1..s.pos]
	if len != 1 {
		u := c.ustring()
		if u.len != 1 {
			s.error('invalid character literal (more than one character)\n' + 'use quotes for strings, backticks for characters')
		}
	}
	// Escapes a `'` character
	return if c == "\'" { '\\' + c } else { c }
}

fn (s &Scanner) expect(want string, start_pos int) bool {
	end_pos := start_pos + want.len
	if start_pos < 0 || start_pos >= s.text.len {
		return false
	}
	if end_pos < 0 || end_pos > s.text.len {
		return false
	}
	for pos in start_pos .. end_pos {
		if s.text[pos] != want[pos - start_pos] {
			return false
		}
	}
	return true
}

fn (mut s Scanner) debug_tokens() {
	s.pos = 0
	s.is_started = false
	s.is_debug = true
	fname := s.file_path.all_after_last(os.path_separator)
	println('\n===DEBUG TOKENS $fname===')
	for {
		tok := s.scan()
		tok_kind := tok.kind
		lit := tok.lit
		print(tok_kind.str())
		if lit != '' {
			println(' `$lit`')
		}
		else {
			println('')
		}
		if tok_kind == .eof {
			println('============ END OF DEBUG TOKENS ==================')
			break
		}
	}
}

fn (mut s Scanner) ignore_line() {
	s.eat_to_end_of_line()
	s.inc_line_number()
}

fn (mut s Scanner) eat_to_end_of_line() {
	for s.pos < s.text.len && s.text[s.pos] != `\n` {
		s.pos++
	}
}

fn (mut s Scanner) inc_line_number() {
	s.last_nl_pos = s.pos
	s.line_nr++
	s.line_ends << s.pos
	if s.line_nr > s.nr_lines {
		s.nr_lines = s.line_nr
	}
}

pub fn (s &Scanner) error(msg string) {
	pos := token.Position{
		line_nr: s.line_nr
		pos: s.pos
	}
	eprintln(util.formatted_error('error:', msg, s.file_path, pos))
	exit(1)
}

pub fn verror(s string) {
	util.verror('scanner error', s)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module scanner

import v.token

fn test_scan() {
	text := 'println(2 + 3)'
	mut scanner := new_scanner(text, .skip_comments)
	mut token_kinds := []token.Kind{}
	for {
		tok := scanner.scan()
		if tok.kind == .eof {
			break
		}
		token_kinds << tok.kind
	}
	assert token_kinds.len == 6
	assert token_kinds[0] == .name
	assert token_kinds[1] == .lpar
	assert token_kinds[2] == .number
	assert token_kinds[3] == .plus
	assert token_kinds[4] == .number
	assert token_kinds[5] == .rpar
	// test number costants input format
	mut c := 0xa0
	assert c == 0xa0
	c = 0b1001
	assert c == 9
	c = 1000000
	assert c == 1000000
	// test float conversion and reading
	d := 23000000e-3
	assert int(d) == 23000
	mut e := 1.2E3 * -1e-1
	assert e == -120.0
	e = 1.2E3 * 1e-1
	assert e == 120.0
	assert 1.23e+10 == 1.23e10
	assert 1.23e+10 == 1.23e0010
	assert (-1.23e+10) == (1.23e0010 * -1.0)
	// test @FN
	assert @FN == 'test_scan'
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
//
// Type layout information (32 bits)
// flag (8 bits) | nr_muls (8 bits) | idx (16 bits)
// pack: (int(flag)<<24) | (nr_muls<<16) | u16(idx)
// unpack:
// flag: (int(type)>>24) & 0xff
// nr_muls: (int(type)>>16) & 0xff
// idx:  u16(type) & 0xffff
module table

import strings

pub type Type int

pub type TypeInfo = Alias | Array | ArrayFixed | Enum | FnType | Interface | Map | MultiReturn |
	Struct | SumType

pub enum Language {
	v
	c
	js
}

pub struct TypeSymbol {
pub:
	parent_idx int
pub mut:
	info       TypeInfo
	kind       Kind
	name       string
	methods    []Fn
	mod        string
	is_public  bool
}

pub enum TypeFlag {
	unset
	optional
	variadic
}

pub fn (types []Type) contains(typ Type) bool {
	for t in types {
		if int(typ) == int(t) {
			return true
		}
	}
	return false
}

// return TypeSymbol idx for `t`
[inline]
pub fn (t Type) idx() int {
	return u16(t) & 0xffff
}

// return nr_muls for `t`
[inline]
pub fn (t Type) nr_muls() int {
	return (int(t) >> 16) & 0xff
}

// return true if `t` is a pointer (nr_muls>0)
[inline]
pub fn (t Type) is_ptr() bool {
	return (int(t) >> 16) & 0xff > 0
}

// set nr_muls on `t` and return it
[inline]
pub fn (t Type) set_nr_muls(nr_muls int) Type {
	if nr_muls < 0 || nr_muls > 255 {
		panic('set_nr_muls: nr_muls must be between 0 & 255')
	}
	return (((int(t) >> 24) & 0xff) << 24) | (nr_muls << 16) | (u16(t) & 0xffff)
}

// increments nr_nuls on `t` and return it
[inline]
pub fn (t Type) to_ptr() Type {
	nr_muls := (int(t) >> 16) & 0xff
	if nr_muls == 255 {
		panic('to_ptr: nr_muls is already at max of 255')
	}
	return (((int(t) >> 24) & 0xff) << 24) | ((nr_muls + 1) << 16) | (u16(t) & 0xffff)
}

// decrement nr_muls on `t` and return it
[inline]
pub fn (t Type) deref() Type {
	nr_muls := (int(t) >> 16) & 0xff
	if nr_muls == 0 {
		panic('deref: type `$t` is not a pointer')
	}
	return (((int(t) >> 24) & 0xff) << 24) | ((nr_muls - 1) << 16) | (u16(t) & 0xffff)
}

// return the flag that is set on `t`
[inline]
pub fn (t Type) flag() TypeFlag {
	return (int(t) >> 24) & 0xff
}

// set the flag on `t` to `flag` and return it
[inline]
pub fn (t Type) set_flag(flag TypeFlag) Type {
	return (int(flag) << 24) | (((int(t) >> 16) & 0xff) << 16) | (u16(t) & 0xffff)
}

// return true if the flag set on `t` is `flag`
[inline]
pub fn (t Type) flag_is(flag TypeFlag) bool {
	return (int(t) >> 24) & 0xff == flag
}

// return new type with TypeSymbol idx set to `idx`
[inline]
pub fn new_type(idx int) Type {
	if idx < 1 || idx > 65536 {
		panic('new_type_id: idx must be between 1 & 65536')
	}
	return idx
}

// return new type with TypeSymbol idx set to `idx` & nr_muls set to `nr_muls`
[inline]
pub fn new_type_ptr(idx, nr_muls int) Type {
	if idx < 1 || idx > 65536 {
		panic('new_type_ptr: idx must be between 1 & 65536')
	}
	if nr_muls < 0 || nr_muls > 255 {
		panic('new_type_ptr: nr_muls must be between 0 & 255')
	}
	return (nr_muls << 16) | u16(idx)
}

// built in pointers (voidptr, byteptr, charptr)
[inline]
pub fn (typ Type) is_pointer() bool {
	return typ.idx() in pointer_type_idxs
}

[inline]
pub fn (typ Type) is_float() bool {
	return typ.idx() in float_type_idxs
}

[inline]
pub fn (typ Type) is_int() bool {
	return typ.idx() in integer_type_idxs
}

[inline]
pub fn (typ Type) is_signed() bool {
	return typ.idx() in signed_integer_type_idxs
}

[inline]
pub fn (typ Type) is_unsigned() bool {
	return typ.idx() in unsigned_integer_type_idxs
}

[inline]
pub fn (typ Type) is_any_int() bool {
	return typ.idx() == any_int_type_idx
}

[inline]
pub fn (typ Type) is_number() bool {
	return typ.idx() in number_type_idxs
}

pub const (
	void_type_idx    = 1
	voidptr_type_idx = 2
	byteptr_type_idx = 3
	charptr_type_idx = 4
	i8_type_idx      = 5
	i16_type_idx     = 6
	int_type_idx     = 7
	i64_type_idx     = 8
	byte_type_idx    = 9
	u16_type_idx     = 10
	u32_type_idx     = 11
	u64_type_idx     = 12
	f32_type_idx     = 13
	f64_type_idx     = 14
	char_type_idx    = 15
	bool_type_idx    = 16
	none_type_idx    = 17
	string_type_idx  = 18
	ustring_type_idx = 19
	array_type_idx   = 20
	map_type_idx     = 21
	any_type_idx     = 22
	t_type_idx       = 23
	any_flt_type_idx = 24
	any_int_type_idx = 25
)

pub const (
	integer_type_idxs          = [i8_type_idx, i16_type_idx, int_type_idx, i64_type_idx, byte_type_idx,
		u16_type_idx,
		u32_type_idx,
		u64_type_idx,
		any_int_type_idx
	]
	signed_integer_type_idxs   = [i8_type_idx, i16_type_idx, int_type_idx, i64_type_idx]
	unsigned_integer_type_idxs = [byte_type_idx, u16_type_idx, u32_type_idx, u64_type_idx]
	float_type_idxs            = [f32_type_idx, f64_type_idx, any_flt_type_idx]
	number_type_idxs           = [i8_type_idx, i16_type_idx, int_type_idx,
		i64_type_idx, byte_type_idx,
		u16_type_idx,
		u32_type_idx,
		u64_type_idx,
		f32_type_idx,
		f64_type_idx,
		any_int_type_idx,
		any_flt_type_idx
	]
	pointer_type_idxs          = [voidptr_type_idx, byteptr_type_idx, charptr_type_idx]
	string_type_idxs           = [string_type_idx, ustring_type_idx]
)

pub const (
	void_type    = new_type(void_type_idx)
	voidptr_type = new_type(voidptr_type_idx)
	byteptr_type = new_type(byteptr_type_idx)
	charptr_type = new_type(charptr_type_idx)
	i8_type      = new_type(i8_type_idx)
	int_type     = new_type(int_type_idx)
	i16_type     = new_type(i16_type_idx)
	i64_type     = new_type(i64_type_idx)
	byte_type    = new_type(byte_type_idx)
	u16_type     = new_type(u16_type_idx)
	u32_type     = new_type(u32_type_idx)
	u64_type     = new_type(u64_type_idx)
	f32_type     = new_type(f32_type_idx)
	f64_type     = new_type(f64_type_idx)
	char_type    = new_type(char_type_idx)
	bool_type    = new_type(bool_type_idx)
	none_type    = new_type(none_type_idx)
	string_type  = new_type(string_type_idx)
	ustring_type = new_type(ustring_type_idx)
	array_type   = new_type(array_type_idx)
	map_type     = new_type(map_type_idx)
	any_type     = new_type(any_type_idx)
	t_type       = new_type(t_type_idx)
	any_flt_type = new_type(any_flt_type_idx)
	any_int_type = new_type(any_int_type_idx)
)

pub const (
	builtin_type_names = ['void', 'voidptr', 'charptr', 'byteptr', 'i8', 'i16', 'int', 'i64',
		'u16',
		'u32',
		'u64', 'any_int', 'f32', 'f64', 'any_float', 'string', 'ustring', 'char', 'byte',
		'bool', 'none', 'array', 'array_fixed',
		'map', 'any', 'struct',
		'mapnode', 'size_t']
)

pub struct MultiReturn {
pub:
	name  string
pub mut:
	types []Type
}

pub struct FnType {
pub:
	is_anon  bool
	has_decl bool
	func     Fn
}

pub enum Kind {
	placeholder
	void
	voidptr
	byteptr
	charptr
	i8
	i16
	int
	i64
	byte
	u16
	u32
	u64
	f32
	f64
	char
	size_t
	bool
	none_
	string
	ustring
	array
	array_fixed
	map
	any
	struct_
	multi_return
	sum_type
	alias
	enum_
	function
	interface_
	any_float
	any_int
}

pub fn (t &TypeSymbol) str() string {
	return t.name.replace('array_', '[]')
}

[inline]
pub fn (t &TypeSymbol) enum_info() Enum {
	match t.info {
		Enum { return it }
		else { panic('TypeSymbol.enum_info(): no enum info for type: $t.name') }
	}
}

[inline]
pub fn (t &TypeSymbol) mr_info() MultiReturn {
	match t.info {
		MultiReturn { return it }
		else { panic('TypeSymbol.mr_info(): no multi return info for type: $t.name') }
	}
}

[inline]
pub fn (t &TypeSymbol) array_info() Array {
	match t.info {
		Array { return it }
		else { panic('TypeSymbol.array_info(): no array info for type: $t.name') }
	}
}

[inline]
pub fn (t &TypeSymbol) array_fixed_info() ArrayFixed {
	match t.info {
		ArrayFixed { return it }
		else { panic('TypeSymbol.array_fixed(): no array fixed info for type: $t.name') }
	}
}

[inline]
pub fn (t &TypeSymbol) map_info() Map {
	match t.info {
		Map { return it }
		else { panic('TypeSymbol.map_info(): no map info for type: $t.name') }
	}
}

[inline]
pub fn (t &TypeSymbol) struct_info() Struct {
	match t.info {
		Struct { return it }
		else { panic('TypeSymbol.struct_info(): no struct info for type: $t.name') }
	}
}

/*
pub fn (t TypeSymbol) str() string {
	return t.name
}
*/
pub fn (mut t Table) register_builtin_type_symbols() {
	// reserve index 0 so nothing can go there
	// save index check, 0 will mean not found
	t.register_type_symbol({
		kind: .placeholder
		name: 'reserved_0'
	})
	t.register_type_symbol(TypeSymbol{
		kind: .void
		name: 'void'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .voidptr
		name: 'voidptr'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .byteptr
		name: 'byteptr'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .charptr
		name: 'charptr'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .i8
		name: 'i8'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .i16
		name: 'i16'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .int
		name: 'int'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .i64
		name: 'i64'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .byte
		name: 'byte'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .u16
		name: 'u16'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .u32
		name: 'u32'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .u64
		name: 'u64'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .f32
		name: 'f32'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .f64
		name: 'f64'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .char
		name: 'char'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .bool
		name: 'bool'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .none_
		name: 'none'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .string
		name: 'string'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .ustring
		name: 'ustring'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .array
		name: 'array'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .map
		name: 'map'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .any
		name: 'any'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .any
		name: 'T'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .any_float
		name: 'any_float'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .any_int
		name: 'any_int'
		mod: 'builtin'
	})
	t.register_type_symbol({
		kind: .size_t
		name: 'size_t'
		mod: 'builtin'
	})
	// TODO: remove. for v1 map compatibility
	map_string_string_idx := t.find_or_register_map(string_type, string_type)
	map_string_int_idx := t.find_or_register_map(string_type, int_type)
	t.register_type_symbol({
		kind: .alias
		name: 'map_string'
		mod: 'builtin'
		parent_idx: map_string_string_idx
	})
	t.register_type_symbol({
		kind: .alias
		name: 'map_int'
		mod: 'builtin'
		parent_idx: map_string_int_idx
	})
}

[inline]
pub fn (t &TypeSymbol) is_pointer() bool {
	return t.kind in [.byteptr, .charptr, .voidptr]
}

[inline]
pub fn (t &TypeSymbol) is_int() bool {
	return t.kind in [.i8, .i16, .int, .i64, .byte, .u16, .u32, .u64, .any_int]
}

[inline]
pub fn (t &TypeSymbol) is_float() bool {
	return t.kind in [.f32, .f64, .any_float]
}

[inline]
pub fn (t &TypeSymbol) is_number() bool {
	return t.is_int() || t.is_float()
}

// for debugging/errors only, perf is not an issue
pub fn (k Kind) str() string {
	k_str := match k {
		.placeholder { 'placeholder' }
		.void { 'void' }
		.voidptr { 'voidptr' }
		.charptr { 'charptr' }
		.byteptr { 'byteptr' }
		.struct_ { 'struct' }
		.int { 'int' }
		.i8 { 'i8' }
		.i16 { 'i16' }
		.i64 { 'i64' }
		.byte { 'byte' }
		.u16 { 'u16' }
		.u32 { 'u32' }
		.u64 { 'u64' }
		.any_int { 'any_int' }
		.f32 { 'f32' }
		.f64 { 'f64' }
		.any_float { 'any_float' }
		.string { 'string' }
		.char { 'char' }
		.bool { 'bool' }
		.size_t { 'size_t' }
		.none_ { 'none' }
		.array { 'array' }
		.array_fixed { 'array_fixed' }
		.map { 'map' }
		.multi_return { 'multi_return' }
		.sum_type { 'sum_type' }
		.alias { 'alias' }
		.enum_ { 'enum' }
		.any { 'any' }
		else { 'unknown' }
	}
	return k_str
}

pub fn (kinds []Kind) str() string {
	mut kinds_str := ''
	for i, k in kinds {
		kinds_str += k.str()
		if i < kinds.len - 1 {
			kinds_str += '_'
		}
	}
	return kinds_str
}

pub struct Struct {
pub mut:
	fields      []Field
	is_typedef  bool // C. [typedef]
	is_union    bool
	is_ref_only bool
}

pub struct Interface {
pub mut:
	types []Type
}

pub struct Enum {
pub:
	vals []string
}

pub struct Alias {
pub:
	parent_typ Type
	language   Language
}

// NB: FExpr here is a actually an ast.Expr .
// It should always be used by casting to ast.Expr, using ast.fe2ex()/ast.ex2fe()
// That hack is needed to break an import cycle between v.ast and v.table .
pub type FExpr = byteptr | voidptr

pub struct Field {
pub:
	name             string
pub mut:
	typ              Type
	default_expr     FExpr
	has_default_expr bool
	default_val      string
	attrs            []string
	is_pub           bool
	is_mut           bool
	is_global        bool
}

pub struct Array {
pub:
	nr_dims   int
pub mut:
	elem_type Type
}

pub struct ArrayFixed {
pub:
	nr_dims   int
	size      int
pub mut:
	elem_type Type
}

pub struct Map {
pub mut:
	key_type   Type
	value_type Type
}

pub struct SumType {
pub:
	variants []Type
}

// TODO simplify this method
pub fn (table &Table) type_to_str(t Type) string {
	sym := table.get_type_symbol(t)
	mut res := sym.name
	if sym.kind == .multi_return {
		res = '('
		if t.flag_is(.optional) {
			res = '?' + res
		}
		mr_info := sym.info as MultiReturn
		for i, typ in mr_info.types {
			res += table.type_to_str(typ)
			if i < mr_info.types.len - 1 {
				res += ', '
			}
		}
		res += ')'
		return res
	}
	if sym.kind == .array || 'array_' in res {
		res = res.replace('array_', '[]')
	}
	if sym.kind == .map || 'map_string_' in res {
		res = res.replace('map_string_', 'map[string]')
	}
	// mod.submod.submod2.Type => submod2.Type
	if res.contains('.') {
		vals := res.split('.')
		if vals.len > 2 {
			res = vals[vals.len - 2] + '.' + vals[vals.len - 1]
		}
		if sym.kind == .array && !res.starts_with('[]') {
			res = '[]' + res
		}
	}
	nr_muls := t.nr_muls()
	if nr_muls > 0 {
		res = strings.repeat(`&`, nr_muls) + res
	}
	if t.flag_is(.optional) {
		res = '?' + res
	}
	/*
	if res.starts_with(cur_mod +'.') {
	res = res[cur_mod.len+1.. ]
	}
	*/
	return res
}

pub fn (t &Table) fn_to_str(func &Fn) string {
	mut sb := strings.new_builder(20)
	sb.write('${func.name}(')
	for i in 1 .. func.args.len {
		arg := func.args[i]
		sb.write('$arg.name')
		if i == func.args.len - 1 || func.args[i + 1].typ != arg.typ {
			sb.write(' ${t.type_to_str(arg.typ)}')
		}
		if i != func.args.len - 1 {
			sb.write(', ')
		}
	}
	sb.write(')')
	if func.return_type != void_type {
		sb.write(' ${t.type_to_str(func.return_type)}')
	}
	return sb.str()
}

pub fn (t &TypeSymbol) has_method(name string) bool {
	t.find_method(name) or {
		return false
	}
	return true
}

pub fn (t &TypeSymbol) find_method(name string) ?Fn {
	for method in t.methods {
		if method.name == name {
			return method
		}
	}
	return none
}

pub fn (t &TypeSymbol) str_method_info() (bool, bool, int) {
	mut has_str_method := false
	mut expects_ptr := false
	mut nr_args := 0
	if sym_str_method := t.find_method('str') {
		has_str_method = true
		nr_args = sym_str_method.args.len
		if nr_args > 0 {
			expects_ptr = sym_str_method.args[0].typ.is_ptr()
		}
	}
	return has_str_method, expects_ptr, nr_args
}

pub fn (s Struct) find_field(name string) ?Field {
	for field in s.fields {
		if field.name == name {
			return field
		}
	}
	return none
}

pub fn (s Struct) get_field(name string) Field {
	if field := s.find_field(name) {
		return field
	}
	panic('unknown field `$name`')
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module table

import v.cflag

// check if cflag is in table
fn (table &Table) has_cflag(flag cflag.CFlag) bool {
	for cf in table.cflags {
		if cf.os == flag.os && cf.name == flag.name && cf.value == flag.value {
			return true
		}
	}
	return false
}

// parse the flags to (table.cflags) []CFlag
// Note: clean up big time (joe-c)
pub fn (mut table Table) parse_cflag(cflg, mod string, ctimedefines []string) ?bool {
	allowed_flags := ['framework', 'library', 'Wa', 'Wl', 'Wp', 'I', 'l', 'L']
	flag_orig := cflg.trim_space()
	mut flag := flag_orig
	if flag == '' {
		return none
	}
	mut fos := ''
	mut allowed_os_overrides := ['linux', 'darwin', 'freebsd', 'windows', 'mingw', 'solaris']
	allowed_os_overrides << ctimedefines
	for os_override in allowed_os_overrides {
		if !flag.starts_with(os_override) {
			continue
		}
		pos := flag.index(' ') or {
			return none
		}
		fos = flag[..pos].trim_space()
		flag = flag[pos..].trim_space()
	}
	for {
		mut name := ''
		mut value := ''
		if flag[0] == `-` {
			for f in allowed_flags {
				i := 1 + f.len
				if i <= flag.len && f == flag[1..i] {
					name = flag[..i].trim_space()
					flag = flag[i..].trim_space()
					break
				}
			}
		}
		mut index := flag.index(' -') or {
			-1
		}
		for index > -1 {
			mut has_next := false
			for f in allowed_flags {
				i := index + 2 + f.len
				if i <= flag.len && f == flag[index + 2..i] {
					value = flag[..index + 1].trim_space()
					flag = flag[index + 1..].trim_space()
					has_next = true
					break
				}
			}
			if has_next {
				break
			}
			index = flag.index_after(' -', index + 1)
		}
		if index == -1 {
			value = flag.trim_space()
		}
		if (name in ['-I', '-l', '-L']) && value == '' {
			hint := if name == '-l' { 'library name' } else { 'path' }
			return error('bad #flag `$flag_orig`: missing $hint after `$name`')
		}
		cf := cflag.CFlag{
			mod: mod
			os: fos
			name: name
			value: value
		}
		if !table.has_cflag(cf) {
			table.cflags << cf
		}
		if index == -1 {
			break
		}
	}
	return true
}
import table
import v.cflag

const (
	module_name = 'main'
	cdefines    = []string{}
	no_name     = ''
	no_flag     = ''
	no_os       = ''
)

fn test_parse_valid_cflags() {
	t := table.new_table()
	expected_flags := [
		make_flag('freebsd', '-I', '/usr/local/include/freetype2'),
		make_flag('linux', '-l', 'glfw'),
		make_flag('mingw', no_name, '-mwindows'),
		make_flag('solaris', '-L', '/opt/local/lib'),
		make_flag('darwin', '-framework', 'Cocoa'),
		make_flag('windows', '-l', 'gdi32'),
		make_flag(no_os, '-l', 'mysqlclient'),
		make_flag(no_os, no_name, '-test')
	]
	parse_valid_flag(t, '-lmysqlclient')
	parse_valid_flag(t, '-test')
	parse_valid_flag(t, 'darwin -framework Cocoa')
	parse_valid_flag(t, 'freebsd -I/usr/local/include/freetype2')
	parse_valid_flag(t, 'linux -lglfw')
	parse_valid_flag(t, 'mingw -mwindows')
	parse_valid_flag(t, 'solaris -L/opt/local/lib')
	parse_valid_flag(t, 'windows -lgdi32')
	assert t.cflags.len == expected_flags.len
	for f in expected_flags {
		assert t.has_cflag(f)
	}
}

fn test_parse_invalid_cflags() {
	t := table.new_table()
	// -I, -L, -l must have values
	assert_parse_invalid_flag(t, 'windows -l')
	assert_parse_invalid_flag(t, '-I')
	assert_parse_invalid_flag(t, '-L')
	// OS/compiler name only is not allowed
	assert_parse_invalid_flag(t, 'darwin')
	assert_parse_invalid_flag(t, 'freebsd')
	assert_parse_invalid_flag(t, 'linux')
	assert_parse_invalid_flag(t, 'mingw')
	assert_parse_invalid_flag(t, 'solaris')
	assert_parse_invalid_flag(t, 'windows')
	// Empty flag is not allowed
	assert_parse_invalid_flag(t, no_flag)
	assert t.cflags.len == 0
}

fn parse_valid_flag(t &table.Table, flag string) {
	t.parse_cflag(flag, module_name, cdefines) or {
	}
}

fn assert_parse_invalid_flag(t &table.Table, flag string) {
	t.parse_cflag(flag, module_name, cdefines) or {
		return
	}
	assert false
}

fn make_flag(os, name, value string) cflag.CFlag {
	return cflag.CFlag{
		mod: module_name
		os: os
		name: name
		value: value
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module table

import os
import v.cflag

pub struct Table {
pub mut:
	types         []TypeSymbol
	type_idxs     map[string]int
	fns           map[string]Fn
	imports       []string // List of all imports
	modules       []string // List of all modules registered by the application
	cflags        []cflag.CFlag
	redefined_fns []string
	fn_gen_types  map[string][]Type // for generic functions
}

pub struct Fn {
pub:
	args        []Arg
	return_type Type
	is_variadic bool
	language    Language
	is_generic  bool
	is_pub      bool
	mod         string
	ctdefine    string // compile time define. myflag, when [if myflag] tag
pub mut:
	name        string
}

pub struct Arg {
pub:
	name      string
	is_mut    bool
	typ       Type
	is_hidden bool // interface first arg
}

pub struct Var {
pub:
	name   string
	is_mut bool
mut:
	typ    Type
}

pub fn new_table() &Table {
	mut t := &Table{}
	t.register_builtin_type_symbols()
	return t
}

// used to compare fn's & for naming anon fn's
pub fn (f &Fn) signature() string {
	mut sig := ''
	for i, arg in f.args {
		// TODO: for now ignore mut/pts in sig for now
		typ := arg.typ.set_nr_muls(0)
		// if arg.is_mut {
		// sig += 'mut_'
		// }
		// sig += '$arg.typ'
		sig += '$typ'
		if i < f.args.len - 1 {
			sig += '_'
		}
	}
	sig += '_$f.return_type'
	return sig
}

pub fn (f &Fn) is_same_method_as(func &Fn) bool {
	if f.return_type != func.return_type {
		return false
	}
	if f.args.len != func.args.len {
		return false
	}
	for i in 1 .. f.args.len {
		if f.args[i].typ != func.args[i].typ {
			return false
		}
	}
	return true
}

pub fn (t &Table) find_fn(name string) ?Fn {
	f := t.fns[name]
	if f.name.str != 0 {
		// TODO
		return f
	}
	return none
}

pub fn (t &Table) known_fn(name string) bool {
	t.find_fn(name) or {
		return false
	}
	return true
}

pub fn (mut t Table) register_fn(new_fn Fn) {
	// println('reg fn $new_fn.name nr_args=$new_fn.args.len')
	t.fns[new_fn.name] = new_fn
}

pub fn (mut t TypeSymbol) register_method(new_fn Fn) {
	t.methods << new_fn
}

pub fn (t &Table) type_has_method(s &TypeSymbol, name string) bool {
	// println('type_has_method($s.name, $name) types.len=$t.types.len s.parent_idx=$s.parent_idx')
	if _ := t.type_find_method(s, name) {
		return true
	}
	return false
}

// search from current type up through each parent looking for method
pub fn (t &Table) type_find_method(s &TypeSymbol, name string) ?Fn {
	// println('type_find_method($s.name, $name) types.len=$t.types.len s.parent_idx=$s.parent_idx')
	mut ts := s
	for {
		if method := ts.find_method(name) {
			return method
		}
		if ts.parent_idx == 0 {
			break
		}
		ts = &t.types[ts.parent_idx]
	}
	return none
}

pub fn (t &Table) struct_has_field(s &TypeSymbol, name string) bool {
	// println('struct_has_field($s.name, $name) types.len=$t.types.len s.parent_idx=$s.parent_idx')
	if _ := t.struct_find_field(s, name) {
		return true
	}
	return false
}

// search from current type up through each parent looking for field
pub fn (t &Table) struct_find_field(s &TypeSymbol, name string) ?Field {
	// println('struct_find_field($s.name, $name) types.len=$t.types.len s.parent_idx=$s.parent_idx')
	mut ts := s
	for {
		if ts.info is Struct {
			struct_info := ts.info as Struct
			if field := struct_info.find_field(name) {
				return field
			}
		}
		if ts.parent_idx == 0 {
			break
		}
		ts = &t.types[ts.parent_idx]
	}
	return none
}

[inline]
pub fn (t &Table) find_type_idx(name string) int {
	return t.type_idxs[name]
}

[inline]
pub fn (t &Table) find_type(name string) ?TypeSymbol {
	idx := t.type_idxs[name]
	if idx > 0 {
		return t.types[idx]
	}
	return none
}

[inline]
pub fn (t &Table) get_type_symbol(typ Type) &TypeSymbol {
	// println('get_type_symbol $typ')
	idx := typ.idx()
	if idx > 0 {
		return &t.types[idx]
	}
	// this should never happen
	panic('get_type_symbol: invalid type (typ=$typ idx=${idx}). Compiler bug. This should never happen')
}

[inline]
pub fn (t &Table) get_type_name(typ Type) string {
	typ_sym := t.get_type_symbol(typ)
	return typ_sym.name
}

// this will override or register builtin type
// allows prexisitng types added in register_builtins
// to be overriden with their real type info
[inline]
pub fn (mut t Table) register_builtin_type_symbol(typ TypeSymbol) int {
	existing_idx := t.type_idxs[typ.name]
	if existing_idx > 0 {
		if existing_idx >= string_type_idx {
			if existing_idx == string_type_idx {
				existing_type := t.types[existing_idx]
				t.types[existing_idx] = {
					typ |
					kind: existing_type.kind
				}
			} else {
				t.types[existing_idx] = typ
			}
		}
		return existing_idx
	}
	return t.register_type_symbol(typ)
}

[inline]
pub fn (mut t Table) register_type_symbol(typ TypeSymbol) int {
	// println('register_type_symbol( $typ.name )')
	existing_idx := t.type_idxs[typ.name]
	if existing_idx > 0 {
		ex_type := t.types[existing_idx]
		match ex_type.kind {
			.placeholder {
				// override placeholder
				// println('overriding type placeholder `$typ.name`')
				t.types[existing_idx] = {
					typ |
					methods: ex_type.methods
				}
				return existing_idx
			}
			else {
				if ex_type.kind == typ.kind {
					return existing_idx
				}
				// panic('cannot register type `$typ.name`, another type with this name exists')
				return -1
			}
		}
	}
	typ_idx := t.types.len
	t.types << typ
	t.type_idxs[typ.name] = typ_idx
	return typ_idx
}

pub fn (t &Table) known_type(name string) bool {
	_ = t.find_type(name) or {
		return false
	}
	return true
}

[inline]
pub fn (t &Table) array_name(elem_type Type, nr_dims int) string {
	elem_type_sym := t.get_type_symbol(elem_type)
	return 'array_${elem_type_sym.name}' + if elem_type.is_ptr() {
		'_ptr'
	} else {
		''
	} + if nr_dims > 1 {
		'_${nr_dims}d'
	} else {
		''
	}
}

[inline]
pub fn (t &Table) array_fixed_name(elem_type Type, size, nr_dims int) string {
	elem_type_sym := t.get_type_symbol(elem_type)
	return 'array_fixed_${elem_type_sym.name}_${size}' + if elem_type.is_ptr() {
		'_ptr'
	} else {
		''
	} + if nr_dims > 1 {
		'_${nr_dims}d'
	} else {
		''
	}
}

[inline]
pub fn (t &Table) map_name(key_type, value_type Type) string {
	key_type_sym := t.get_type_symbol(key_type)
	value_type_sym := t.get_type_symbol(value_type)
	suffix := if value_type.is_ptr() { '_ptr' } else { '' }
	return 'map_${key_type_sym.name}_${value_type_sym.name}' + suffix
	// return 'map_${value_type_sym.name}' + suffix
}

pub fn (mut t Table) find_or_register_map(key_type, value_type Type) int {
	name := t.map_name(key_type, value_type)
	// existing
	existing_idx := t.type_idxs[name]
	if existing_idx > 0 {
		return existing_idx
	}
	// register
	map_typ := TypeSymbol{
		parent_idx: map_type_idx
		kind: .map
		name: name
		info: Map{
			key_type: key_type
			value_type: value_type
		}
	}
	return t.register_type_symbol(map_typ)
}

pub fn (mut t Table) find_or_register_array(elem_type Type, nr_dims int) int {
	name := t.array_name(elem_type, nr_dims)
	// existing
	existing_idx := t.type_idxs[name]
	if existing_idx > 0 {
		return existing_idx
	}
	// register
	array_type := TypeSymbol{
		parent_idx: array_type_idx
		kind: .array
		name: name
		info: Array{
			elem_type: elem_type
			nr_dims: nr_dims
		}
	}
	return t.register_type_symbol(array_type)
}

pub fn (mut t Table) find_or_register_array_fixed(elem_type Type, size, nr_dims int) int {
	name := t.array_fixed_name(elem_type, size, nr_dims)
	// existing
	existing_idx := t.type_idxs[name]
	if existing_idx > 0 {
		return existing_idx
	}
	// register
	array_fixed_type := TypeSymbol{
		kind: .array_fixed
		name: name
		info: ArrayFixed{
			elem_type: elem_type
			size: size
			nr_dims: nr_dims
		}
	}
	return t.register_type_symbol(array_fixed_type)
}

pub fn (mut t Table) find_or_register_multi_return(mr_typs []Type) int {
	mut name := 'multi_return'
	for mr_typ in mr_typs {
		mr_type_sym := t.get_type_symbol(mr_typ)
		name += '_$mr_type_sym.name'
	}
	// existing
	existing_idx := t.type_idxs[name]
	if existing_idx > 0 {
		return existing_idx
	}
	// register
	mr_type := TypeSymbol{
		kind: .multi_return
		name: name
		info: MultiReturn{
			types: mr_typs
		}
	}
	return t.register_type_symbol(mr_type)
}

pub fn (mut t Table) find_or_register_fn_type(mod string, f Fn, is_anon, has_decl bool) int {
	name := if f.name.len == 0 { 'anon_fn_$f.signature()' } else { f.name }
	anon := f.name.len == 0 || is_anon
	return t.register_type_symbol(TypeSymbol{
		kind: .function
		name: name
		mod: mod
		info: FnType{
			is_anon: anon
			has_decl: has_decl
			func: f
		}
	})
}

pub fn (mut t Table) add_placeholder_type(name string) int {
	ph_type := TypeSymbol{
		kind: .placeholder
		name: name
	}
	// println('added placeholder: $name - $ph_type.idx')
	return t.register_type_symbol(ph_type)
}

[inline]
pub fn (t &Table) value_type(typ Type) Type {
	typ_sym := t.get_type_symbol(typ)
	if typ.flag_is(.variadic) {
		// ...string => string
		return typ.set_flag(.unset)
	}
	if typ_sym.kind == .array {
		// Check index type
		info := typ_sym.info as Array
		return info.elem_type
	}
	if typ_sym.kind == .array_fixed {
		info := typ_sym.info as ArrayFixed
		return info.elem_type
	}
	if typ_sym.kind == .map {
		info := typ_sym.info as Map
		return info.value_type
	}
	if typ_sym.kind == .string && typ.is_ptr() {
		// (&string)[i] => string
		return string_type
	}
	if typ_sym.kind in [.byteptr, .string] {
		return byte_type
	}
	if typ.is_ptr() {
		// byte* => byte
		// bytes[0] is a byte, not byte*
		return typ.deref()
	}
	// TODO: remove when map_string is removed
	if typ_sym.name == 'map_string' {
		return string_type
	}
	return void_type
}

// Once we have a module format we can read from module file instead
// this is not optimal
pub fn (table &Table) qualify_module(mod, file_path string) string {
	for m in table.imports {
		if m.contains('.') && m.contains(mod) {
			m_parts := m.split('.')
			m_path := m_parts.join(os.path_separator)
			if mod == m_parts[m_parts.len - 1] && file_path.contains(m_path) {
				return m
			}
		}
	}
	return mod
}

pub fn (table &Table) register_fn_gen_type(fn_name string, typ Type) {
	mut a := table.fn_gen_types[fn_name]
	if typ in a {
		return
	}
	a << typ
	table.fn_gen_types[fn_name] = a
}
struct Tester {
	b bool
	i int
}

enum Color {
	red green blue
}

fn test_array_equality() {
	strs := ['a', 'b', 'c']
	assert strs == ['a', 'b', 'c']
	assert strs != ['a', 'c', 'b']
	assert strs != ['b', 'c', 'a']
	assert strs != ['b', 'a', 'c']
	assert strs != ['c', 'b', 'a']
	assert strs != ['c', 'a', 'b']
	bools := [true, true, false]
	assert bools == [true, true, false]
	assert bools != [true, false, false]
	assert bools != [false, true, true]
	assert bools != [false, false, true]
	assert bools != [false, false, false]
	assert bools != [false, true, false]
	ints := [1, 2, 3]
	assert ints == [1, 2, 3]
	assert ints != [1, 3, 2]
	assert ints != [2, 3, 1]
	assert ints != [2, 1, 3]
	assert ints != [3, 2, 1]
	assert ints != [3, 1, 2]
	a := Tester{true, 100}
	b := Tester{false, 200}
	testers := [a, b]
	assert testers == [a, b]
	assert testers != [a, a]
	assert testers != [b, b]
	assert testers != [b, a]
	colors := [Color.red, Color.green, Color.blue]
	assert colors == [Color.red, Color.green, Color.blue]
	assert colors != [Color.red, Color.blue, Color.green]
	assert colors != [Color.green, Color.blue, Color.red]
	assert colors != [Color.green, Color.red, Color.blue]
	assert colors != [Color.blue, Color.green, Color.red]
	assert colors != [Color.blue, Color.red, Color.green]
}
struct Init {
	len int
}

fn test_array_init() {
	b := [1, 2, 3]
	mut a := []int{cap: b.len}
	a << 1
	'$a, $a.len, $a.cap' == '[1], 1, 3'

	c := Init{len: 3}
	mut d := []string{cap: c.len}
	d << 'aaa'
	d << 'bbb'
	'$d, $d.len, $d.cap' == "['aaa', 'bbb'], 2, 3"
}

fn test_array_init_with_default() {
	a1 := []int{len: 4, init: 2}
	assert '$a1' == '[2, 2, 2, 2]'

	a2 := []int{len: 3, init: 12345}
	assert '$a2' == '[12345, 12345, 12345]'

	b1 := []string{len: 3, init: 'abc'}
	assert '$b1' == "['abc', 'abc', 'abc']"

	b2 := []string{len: 2, init: '111'}
	assert '$b2' == "['111', '111']"
}

fn test_array_init_with_len_no_default() {
	a1 := []int{len: 4}
	assert '$a1' == '[0, 0, 0, 0]'

	a2 := []string{len: 4}
	assert '$a2' == "['', '', '', '']"

	a3 := []bool{len: 3}
	assert '$a3' == '[false, false, false]'
}

fn test_array_int_full_options() {
	println('Test array of int values')

	a := []int{len: 2, cap: 10} // this creates an array with 2 items, initial capacity 10, default value of array type
	println('array a: length: ${a.len}, capacity: ${a.cap}, content: $a')
	assert a.len == 2
	assert a.cap == 10
	assert a.cap >= a.len
	assert a.str() == "[0, 0]"

	b := []int{len: 10, cap: 100, init: 1} // this creates an array with 10 one and initial capacity 100 elements, value given
	_ := b.clone() // discard result variable, sample
	println('array b: length: ${b.len}, capacity: ${b.cap}, content: $b')
	assert b.len == 10
	assert b.cap == 100
	assert b.cap >= b.len
	assert b.str() == "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"

	mut c := []int{len: 2, cap: 10, init: 1} // this creates an array with 2 one and initial capacity 10 elements, value given
	_ := c.clone() // discard result variable, sample
	println('array c: length: ${c.len}, capacity: ${c.cap}, content: $c')
	assert c.len == 2
	assert c.cap == 10
	assert c.cap >= c.len
	assert c.str() == "[1, 1]"
	// add some items to the array, to check limits
	c << [3, 4, 5, 6, 7, 8, 9, 10] // add 8 items, from another array
	// update one item, to have the right number in the sequence ...
	c[1] = 2
	println('array c: length: ${c.len}, capacity: ${c.cap}, content now: $c')
	assert c.len == 10
	assert c.cap == 10
	assert c.cap >= c.len
	assert c.str() == "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
	// add some more item after initial capacity, to ensure it's expandable
	c << [11, 12, 13, 14, 15, 16]
	println('array c: length: ${c.len}, capacity: ${c.cap}, content now: $c')
	assert c.len == 16
	assert c.cap >= c.len
	assert c.str() == "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]"
}

fn test_array_string_full_options() {
	println('Test array of string values')

	a := []string{len: 2, cap: 10} // this creates an array with 2 items, initial capacity 10, default value of array type
	println('array a: length: ${a.len}, capacity: ${a.cap}') // ok
	println('array a: length: ${a.len}, capacity: ${a.cap}, content: "$a"')
	assert a.len == 2
	assert a.cap == 10
	assert a.cap >= a.len
	assert a.str() == "['', '']"

	b := []string{len: 10, cap: 100, init: 'b'} // this creates an array with 10 'b', initial capacity 100 elements, value given
	_ := b.clone() // discard result variable, sample
	println('array b: length: ${b.len}, capacity: ${b.cap}') // ok
	println('array b: length: ${b.len}, capacity: ${b.cap}, content: $b')
	assert b.len == 10
	assert b.cap == 100
	assert b.cap >= b.len
	assert b.str() == "['b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b']"

	mut c := []string{len: 2, cap: 10, init: 'c'} // this creates an array with 2 'c' and initial capacity 10 elements, value given
	_ := c.clone() // discard result variable, sample
	println('array c: length: ${c.len}, capacity: ${c.cap}, content: $c')
	assert c.len == 2
	assert c.cap == 10
	assert c.cap >= c.len
	assert c.str() == "['c', 'c']"
	// add some items to the array, to check limits
	c << ['c', 'c', 'c', 'c', 'c', 'c', 'c', 'c'] // add 8 items, from another array
	// update some items, to have the right number in the sequence ...
	c[0] = 'a'
	c[1] = 'b'
	println('array c: length: ${c.len}, capacity: ${c.cap}, content now: $c')
	assert c.len == 10
	assert c.cap == 10
	assert c.cap >= c.len
	assert c.str() == "['a', 'b', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c']"
	// add some more item after initial capacity, to ensure all is good
	c << ['11', '12', '13', '14', '15', '16']
	// c << ['11', nil, '13', '14', '15', '16'] // check later if/how to handle this ...
	println('array c: length: ${c.len}, capacity: ${c.cap}, content now: $c')
	assert c.len == 16
	assert c.cap >= c.len
	assert c.str() == "['a', 'b', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '11', '12', '13', '14', '15', '16']"
}

struct MyStruct {
pub mut:
	ar []f32
}

fn test_array_init_in_struct_field() {
	m := MyStruct {
		ar: []f32{len: 4, init:1.2}
	}
	println(m)
	assert m.ar.str() == '[1.2, 1.2, 1.2, 1.2]'
}
fn test_array_to_string_conversion() {
	a := ['1', '2', '3', '4']
	assert a.str() == "['1', '2', '3', '4']"

	b := [1, 2, 3, 4]
	assert b.str() == '[1, 2, 3, 4]'

	c := [1.1, 2.2, 3.3, 4.4]
	assert c.str() == '[1.1, 2.2, 3.3, 4.4]'

	d := [i16(1), 2, 3]
	assert d.str() == '[1, 2, 3]'

	e := [i64(1), 2, 3]
	assert e.str() == '[1, 2, 3]'
}

fn test_interpolation_array_to_string() {
	a := ['1', '2', '3']
	assert '$a' == "['1', '2', '3']"

	b := [1, 2, 3, 4]
	assert '$b' == '[1, 2, 3, 4]'

	c := [1.1, 2.2, 3.3, 4.4]
	assert '$c' == '[1.1, 2.2, 3.3, 4.4]'

	d := [i16(1), 2, 3]
	assert '$d' == '[1, 2, 3]'

	e := [i64(1), 2, 3]
	assert '$e' == '[1, 2, 3]'
}

fn test_interpolation_array_of_map_to_string() {
	mut ams := []map[string]string{}
	ams << {'a': 'b', 'c': 'd'}
	ams << {'e': 'f', 'g': 'h'}
	assert '$ams' == "[{'a': 'b', 'c': 'd'}, {'e': 'f', 'g': 'h'}]"
}
fn test_inline_asm() {
	/*
	// QTODO
	a := 10
	b := 0
	unsafe {
		asm {
			"movl %1, %%eax;"
			"movl %%eax, %0;"
			:"=r"(b)
			:"r"(a)
			:"%eax"
		}
	}
	assert a == 10
	assert b == 10
	//
	e := 0
	unsafe {
		asm {
			//".intel_syntax noprefix;"
			//"mov %0, 5"
			"movl $5, %0"
			:"=a"(e)
		}
	}
	assert e == 5
*/
}
[testing]
struct StructAttrTest {
	foo string
	bar int
}

[testing]
pub struct PubStructAttrTest {
	foo string
	bar int
}

[testing]
enum EnumAttrTest {
	one
	two
}

[testing]
pub enum PubEnumAttrTest {
	one
	two
}

[testing]
fn test_fn_attribute() {
	assert true
}

[testing]
pub fn test_pub_fn_attribute() {
	assert true
}
/*
 Test for backtrace capability
*/
fn a_method() {
	print_backtrace()
}

fn test_backtrace() {
	a_method()
	// panic('hi')
}
fn test_assign() {
	_ = 123
}

fn fn_with_blank_param(_ int) {
	_ = 456
}

fn test_fn_with_blank_param() {
	fn_with_blank_param(321)
}

fn test_for_in_range() {
	for _ in 1 .. 10 {
		assert true
	}
}

fn test_nested_range() {
	for _ in 1 .. 10 {
		for _ in 1 .. 10 {
			assert true
		}
	}
}

fn test_for_in_array_simple() {
	for _ in [1, 2, 3] {
		assert true
	}
}

fn test_for_in_array_key() {
	mut i := 1
	for _, v in [1, 2, 3] {
		assert v == i
		i++
	}
}

fn test_for_in_array_val() {
	mut j := 0
	for i, _ in [3, 4, 5] {
		assert i == j
		j++
	}
}

fn test_for_in_array_both() {
	for _, _ in [1, 2, 3] {
		assert true
	}
}

fn test_nested_for_in_array_simple() {
	for _ in [1, 2, 3] {
		for _ in [1, 2, 3] {
			assert true
		}
	}
}

fn test_nested_for_in_array_key() {
	for _, v in [1, 2, 3] {
		for _, w in [1, 2, 3] {
			assert true
		}
	}
}

fn test_nested_for_in_array_val() {
	for i, _ in [1, 2, 3] {
		for j, _ in [1, 2, 3] {
			assert true
		}
	}
}

fn test_nested_for_in_array_both() {
	for _, _ in [1, 2, 3] {
		for _, _ in [1, 2, 3] {
			assert true
		}
	}
}

const (
	m = {
		'key': 'value'
	}
)

fn test_for_in_map_key() {
	for _, v in m {
		assert v == 'value'
	}
}

fn test_for_in_map_val() {
	for i, _ in m {
		assert i == 'key'
	}
}

fn test_for_in_map_both() {
	for _, _ in m {
		assert true
	}
}

fn test_nested_for_in_map_key() {
	for _, v in m {
		assert v == 'value'
		for _, w in m {
			assert w == 'value'
		}
	}
}

fn test_nested_for_in_map_val() {
	for i, _ in m {
		assert i == 'key'
		for j, _ in m {
			assert j == 'key'
		}
	}
}

fn test_nested_for_in_map_both() {
	for _, _ in m {
		for _, _ in m {
			assert true
		}
	}
}

fn fn_for_in_variadic_args_simple(arr ...string) {
	for _ in arr {
		assert true
	}
}

fn fn_for_in_variadic_args_key(arr ...string) {
	for _, v in arr {
		assert true
	}
}

fn fn_for_in_variadic_args_val(arr ...string) {
	for i, _ in arr {
		assert true
	}
}

fn fn_for_in_variadic_args_both(arr ...string) {
	for _, _ in arr {
		assert true
	}
}

fn fn_nested_for_in_variadic_args(arr ...string) {
	for _ in arr {
		for _ in arr {
			assert true
		}
	}
}

fn fn_nested_for_in_variadic_args_key(arr ...string) {
	for _, v in arr {
		for _, w in arr {
			assert true
		}
	}
}

fn fn_nested_for_in_variadic_args_val(arr ...string) {
	for i, _ in arr {
		for j, _ in arr {
			assert true
		}
	}
}

fn fn_nested_for_in_variadic_args_both(arr ...string) {
	for _, _ in arr {
		for _, _ in arr {
			assert true
		}
	}
}

fn test_for_in_variadic_args() {
	fn_for_in_variadic_args_simple('a', 'b', 'c')
	fn_for_in_variadic_args_key('a', 'b', 'c')
	fn_for_in_variadic_args_val('a', 'b', 'c')
	fn_for_in_variadic_args_both('a', 'b', 'c')
	fn_nested_for_in_variadic_args('a', 'b', 'c')
	fn_nested_for_in_variadic_args_key('a', 'b', 'c')
	fn_nested_for_in_variadic_args_val('a', 'b', 'c')
	fn_nested_for_in_variadic_args_both('a', 'b', 'c')
}

fn test_for_in_string_simple() {
	for _ in 'abcd' {
		assert true
	}
}

fn test_for_in_string_key() {
	for _, v in 'a' {
		assert v == `a`
	}
}

fn test_for_in_string_val() {
	for i, _ in 'a' {
		assert i == 0
	}
}

fn test_for_in_string_both() {
	for _, _ in 'abcd' {
		assert true
	}
}

fn test_nested_for_in_string_simple() {
	for _ in 'abcd' {
		for _ in 'abcd' {
			assert true
		}
	}
}

fn test_nested_for_in_string_key() {
	for _, v in 'a' {
		assert v == `a`
		for _, w in 'a' {
			assert w == `a`
		}
	}
}

fn test_nested_for_in_string_val() {
	for i, _ in 'a' {
		assert i == 0
		for j, _ in 'a' {
			assert j == 0
		}
	}
}

fn test_nested_for_in_string_both() {
	for _, _ in 'abcd' {
		for _, _ in 'abcd' {
			assert true
		}
	}
}
struct Object {
	name string
	value int
}

fn multireturner(n int, s string) (int, string) {
	return n + 1, s
}

fn test_assign_multi_expr_func() {
	e, f := if false {
		multireturner(-1, 'notawesome')
	} else if false {
		multireturner(-1, 'notawesome')
	} else {
		multireturner(17, 'awesomer')
	}
	assert e == 18
	assert f == 'awesomer'

	g, h := match true {
		true { multireturner(0, 'good') }
		false { multireturner(100, 'bad') }
		else { multireturner(200, 'bad') }
	}
	assert g == 1
	assert h == 'good'
}

fn test_assign_multi_expr() {
	// helpers
	val1 := 1
	val2 := 2

	// simple case for match
	a,b,c := match false {
		true { 1,2,3 }
		false { 4,5,6 }
		else { 7,8,9 }
	}
	assert a == 4
	assert b == 5
	assert c == 6

	// test with first value `literal`
	d, e, f := if true {
		1, 'awesome', [13]
	} else {
		0, 'bad', [0]
	}
	assert d == 1
	assert e == 'awesome'
	assert f == [13]

	// test with first value `literal expr` and statement
	awesome := 'awesome'
	g, h, i := if true {
		1 + val1, awesome, [13]
	} else {
		int(0), 'bad', [0]
	}
	assert g == 2
	assert h == 'awesome'
	assert i == [13]

	// test with first value `.name`
	j, k, l := if true {
		val1, 'awesome', [13]
	} else {
		val2, 'bad', [0]
	}
	assert j == 1
	assert k == 'awesome'
	assert l == [13]

	// test with first value name and peek != .comma
	m, n, o := if true {
		val1 + 1, val1, val1
	} else {
		val2, val2, val2
	}
	assert m == val1 + 1
	assert n == val1
	assert o == val1

	// test practical complex expressions
	val3 := Object { name: 'initial', value: 19 }
	mut q, mut r, mut s := if true {
		1 + 1, 'awe' + 'some', { val3 | name: 'ok' }
	} else {
		0, '0', Object {}
	}
	assert q == 2
	assert r == 'awesome'
	assert s.name == 'ok'
	assert s.value == 19

	// test assign to existing variables
	q, r, s = if false {
		0, '0', Object {}
	} else {
		5, '55', { val3 | value: 555 }
	}
	assert q == 5
	assert r == '55'
	assert s.value == 555
	assert s.name == 'initial'
}
fn test_bitness() {
	mut x := 0
	$if x32 {
		println('system is 32 bit')
		x = 1
	}
	$if x64 {
		println('system is 64 bit')
		x = 2
	}
	assert x > 0
}

fn test_endianness() {
	mut x := 0
	$if little_endian {
		println('system is little endian')
		x = 1
	}
	$if big_endian {
		println('system is big endian')
		x = 2
	}
	assert x > 0
}
import math

const (
	max_float = math.max_f32
)

fn test_const_embed() {
	println(max_float)
	println(math.max_f32)
	assert max_float == math.max_f32
}
pub const (
	a = b
	c = a + b
	b = 1
	d = (e / 2) + 7
	e = 9
)

fn test_const() {
	assert a == 1
	assert d == 11
	assert c == 1
}
fn test_cstring() {
	w := c'world'
	hlen := C.strlen(c'hello')
	hlen2 := C.strlen('hello')
	wlen := C.strlen(w)
	assert hlen == 5
	assert hlen2 == 5
	assert wlen == 5
}
fn foo() string {
	println('foo()')
	return 'foo'
}

fn foo2() string {
	println('start')
	defer {
		println('defer')
	}
	defer {
		println('defer2')
	}
	println('end')
	return foo()
}

fn test_defer() {
	assert foo2() == 'foo'
}

fn set_num(i int, n mut Num) {
	defer {
		println('exiting')
		n.val++
	}
	println('Hi')
	if i < 5 {
		return
	}
	else {
		n.val++
	}
}

fn set_num_opt(n mut Num) ?int {
	defer {
		n.val = 1
	}
	return 99
}

struct Num {
mut:
	val int
}

fn test_defer_early_exit() {
	mut sum := Num{0}
	for i in 0 .. 10 {
		set_num(i, mut sum)
	}
	println('sum: $sum.val')
	assert sum.val == 15
}

fn test_defer_option() {
	mut ok := Num{0}
	set_num_opt(mut ok) or {}
	assert ok.val == 1
}

struct DB { name string }
struct DxB { name string }
struct DeclExprA { name string }
struct AStructWithAVeryLongName { name string }

fn test_struct_names_can_be_used_for_creating_them() {
	a := DB{}
	assert true
	b := DxB{}
	assert true
	c := DeclExprA{}
	assert true
	d := AStructWithAVeryLongName{}
	assert true
}
[flag]
enum BfPermission {
	read
	write
	execute
	other
}

struct BfFile {
mut:
	perm BfPermission
}

fn test_enum_bitfield() {
	mut a := BfFile{}
	a.perm.set(.read)
	a.perm.set(.write)
	a.perm.toggle(.execute)
	a.perm.clear(.write)
	// a.perm.set(.other)
	assert a.perm.has(.read)
	assert a.perm.has(.execute)
	assert !a.perm.has(.write)
	assert !a.perm.has(.other)
	mut b := BfPermission.read	// TODO:  this does nothing currenty just sets the type
	b.set(.write)
	b.set(.other)
	assert b.has(.write)
	assert b.has(.other)
	assert !b.has(.read)
	assert !b.has(.execute)
}
pub enum MyEnum {
	first = 20
	second
	third
}

pub struct MyStruct {
mut:
	e MyEnum = .second
}

fn test_enum_first_value() {
	assert MyEnum.first == 20
}

fn test_enum_default_value() {
	d := MyStruct{}
	assert int(d.e) == 21
	assert 'd.e: $d.e | int(d.e): ${int(d.e).str()}' == 'd.e: second | int(d.e): 21'
}

fn test_enum_non_default_value() {
	t := MyStruct{
		e: .third
	}
	assert int(t.e) == 22
	assert 't.e: $t.e | int(t.e): ${int(t.e).str()}' == 't.e: third | int(t.e): 22'
}

fn test_generation_of_string_interpolation_method_for_pointer_to_struct_containing_enum_fields(){
	t := &MyStruct{
		e: .third
	}
	assert 't: $t' == 't: &MyStruct {\n    e: third\n}'
}
enum WHex {
	a = 0x001
	b = 0x010
	c = 0x100
}

enum WDecimal {
	a = 1
	b = 16
	c = 256
}

const (
	ca = 1
	cb = 16
	cc = 256
)

fn test_enum_hex() {
	assert ca == int(WDecimal.a)
	assert cb == int(WDecimal.b)
	assert cc == int(WDecimal.c)
	assert int(WHex.a) == ca
	assert int(WHex.b) == cb
	assert int(WHex.c) == cc
	assert int(WHex.a) == int(WDecimal.a)
	assert int(WHex.b) == int(WDecimal.b)
	assert int(WHex.c) == int(WDecimal.c)
}
enum Color {
	red
	blue
	green
}

fn enum_optional_helper(b bool) ?Color {
	if b {
		return .red
	}
	return error('failed')
}

fn test_enum_optional() {
	a := enum_optional_helper(true) or {
		assert false
		return
	}
	assert a == .red
}

fn test_enum() {
	assert Color.red == .red
	assert Color.blue == .blue
	assert Color.green == .green
	assert Color.red != .blue
	assert Color.red != .green
	assert Color.blue != .green
	mut color := Color.red
	assert color == .red
	color = .green
	assert color == .green
}

fn test_in() {
	color := Color.red
	num := 3	// used to be an expr bug before `in`
	assert color in [.red, .green]
	assert num == 3
	println(color)
	assert true
}

fn test_match() {
	color := Color.green
	num := 3
	match color {
		.red {
			assert false
		}
		.green {
			assert true
		}
		else {
			assert false
		}
	}
	println(color)
	assert num == 3
}

enum Foo {
	a = 1
	b = 2
	c = 3
	d = -10
}

fn test_nums() {
	foo := Foo.a
	assert foo == 1
	assert Foo.c == 3
	d := Foo.d
	assert d == -10
}

/*
enum Expr {
	BoolExpr(bool)
	IntExpr(int)
	//FloatExpr(int)
}

fn get_expr() Expr {
	return Expr.IntExpr(10)

}

fn test_typed_enum() {
	i := Expr.IntExpr(10)
	expr := Expr.BoolExpr(true)
	//println(i)
	//if i == expr {

	//}
	println('done')
	// expr = i
	/*
	match expr {
		IntExpr(n)  { println('INT $n')  }
		BoolExpr(b) { println('BOOL $b') }
	}
	*/
}
*/
/*
fn test_typed_enum() {
	Expr i = { .obj = 10, .typ = IntExpr_type };
	Expr expr = { .obj = true, .typ = BoolExpr_type };
	//    val = expr;
	if (expr.typ == IntExpr_type) {
		int n = (int)expr.obj;
		println('INT $n');
	}
	else if (expr.typ == BoolExpr_type) {
		int b = (bool)expr.obj;
		println('BOOL $b');
	}
}
*/
fn test_fixed_array_init() {
	a1 := ['1', '2', '3']!!
	assert typeof(a1) == '[3]string'
	assert '$a1' == "['1', '2', '3']"

	a2 := ['a', 'b']!!
	assert typeof(a2) == '[2]string'
	assert '$a2' == "['a', 'b']"

	c1 := [1, 2, 3]!!
	assert typeof(c1) == '[3]int'
	assert '$c1' == '[1, 2, 3]'

	c2 := [i16(1), 2, 3]!!
	assert typeof(c2) == '[3]i16'
	assert '$c2' == '[1, 2, 3]'

	mut c3 := [i64(1), 2, 3]!!
	assert typeof(c3) == '[3]i64'
	assert '$c3' == '[1, 2, 3]'

	mut c4 := [u64(1), 2, 3]!!
	assert typeof(c4) == '[3]u64'
	assert '$c4' == '[1, 2, 3]'

	mut d1 := [1.1, 2.2, 3.3]!!
	assert typeof(d1) == '[3]f64'
	assert '$d1' == '[1.1, 2.2, 3.3]'

	mut d2 := [f32(1.1), 2.2, 3.3]!!
	assert typeof(d2) == '[3]f32'
	assert '$d2' == '[1.1, 2.2, 3.3]'
}
fn test_fixed_array_can_be_assigned() {
	x := 2.32
	mut v := [8]f64
	v = [1.0, x, 3.0,4.0,5.0,6.0,7.0,8.0]!!
	assert v[1] == x
}

fn test_fixed_array_can_be_used_in_declaration() {
	x := 2.32
	v := [1.0, x, 3.0,4.0,5.0,6.0,7.0,8.0]!!
	assert v[1] == x
}


struct Context {
	pub mut:
	vb [8]f64
}

fn test_fixed_array_can_be_assigned_to_a_struct_field() {
	mut ctx := Context{}
	x := 2.32
	ctx.vb = [1.1, x, 3.3, 4.4, 5.0, 6.0, 7.0, 8.9]!!
	assert ctx.vb[1] == x
	assert ctx.vb[7] == 8.9
	/*
	println( ctx.vb[0] )
	println( ctx.vb[1] )
	println( ctx.vb[2] )
	println( ctx.vb[3] )
	*/
}
fn test_fixed_array_to_string() {
	mut a1 := [3]string
	a1[0] = '1'
	a1[1] = '2'
	a1[2] = '3'
	assert '$a1' == "['1', '2', '3']"

	mut a2 := [2]string
	a2[0] = 'a'
	a2[1] = 'b'
	assert '$a2' == "['a', 'b']"

	mut c1 := [3]int
	c1[0] = 1
	c1[1] = 2
	c1[2] = 3
	assert '$c1' == '[1, 2, 3]'

	mut c2 := [3]i16
	c2[0] = 1
	c2[1] = 2
	c2[2] = 3
	assert '$c2' == '[1, 2, 3]'

	mut c3 := [3]i64
	c3[0] = 1
	c3[1] = 2
	c3[2] = 3
	assert '$c3' == '[1, 2, 3]'

	mut c4 := [3]u64
	c4[0] = 1
	c4[1] = 2
	c4[2] = 3
	assert '$c4' == '[1, 2, 3]'

	mut d1 := [3]f64
	d1[0] = 1.1
	d1[1] = 2.2
	d1[2] = 3.3
	assert '$d1' == '[1.1, 2.2, 3.3]'

	mut d2 := [3]f32
	d2[0] = 1.1
	d2[1] = 2.2
	d2[2] = 3.3
	assert '$d2' == '[1.1, 2.2, 3.3]'
}
struct Foo {
	x int
}

pub fn (f Foo) str() string { return 'Foo{}' }

fn process_foo(foo &Foo) {
	println('>process_foo, called for ${foo} === ${*foo}')
}

fn get_foo() Foo {
	println('>get_foo')
	return Foo{}
}

/*
// TODO: Fix this. It 'works' only with tcc, but is not stable.
fn test_ref_fn_arg() {
	process_foo(get_foo())
	println(3434)
	assert true
}
*/

fn test_dummy() {}
import time.misc as tmisc

// using a manual temporary intermediate variable should always work:
fn test_call_fn_that_requires_reference_with_function_that_returns_a_struct_manual() {
	t1 := tmisc.random()
	t2 := t1.unix_time()
	println('res: $t2')
	assert true
}

/*
// TODO: Fix this.
// v should produce temporary intermediate variables in chained calls:
fn test_call_fn_that_requires_reference_with_function_that_returns_a_struct_chained() {
	res := (tmisc.random().unix_time())
	println('res: $res')
	assert true
}
*/
// helper
fn sqr(x int) int {
	return x * x
}

fn high_fn(f fn(int) int) {
	x := f(111)
	println('x == $x')
}

fn high_fn_no_ret(f fn(int)) {
	f(111)
}

fn high_fn_array(f fn(a []int) []int) {

}

fn high_fn_multi_return(a int, b fn (c []int, d []string) ([]int, []string)) {

}

fn high_fn_return_single_anon() (fn(int)f32) {
	_ := 1
	correct := fn(n int)f32 {
		return n * n
	}
	return correct
}
fn high_fn_return_multi_anons() (fn(int)f32, fn(int)string) {
	// parsing trap
	_ := fn(n int)byte {
		return 0x00
	}
	correct_second := fn(n int)string {
		return '$n'
	}
	correct_first := fn(n int)f32 {
		return n * n
	}
	// parsing trap
	_ := fn(n int)[]int {
		return [n]
	}
	return correct_first, correct_second
}
fn high_fn_return_named_fn() (fn(int)int) {
	return sqr
}
fn test_high_fn_ret_anons() {
	param := 13
	func_sqr1 := high_fn_return_single_anon()
	assert func_sqr1(param) == param * param

	func_sqr2, func_repr := high_fn_return_multi_anons()
	assert func_sqr2(param) == (param * param)
	assert func_repr(param) == '$param'

	top_lvl_sqr := high_fn_return_named_fn()
	assert top_lvl_sqr(param) == param * param
}

fn high_fn_applier(arg int, func fn(a int)string) string {
	return func(arg)
}
fn test_high_fn_applier() {
	arg := 13
	expect := '$arg $arg'
	func := fn (arg int) string {
		return '$arg $arg'
	}
	assert expect == high_fn_applier(arg, func)
}

fn test_fns() {
	// no asserts for now, just test function declarations above
	high_fn(sqr)
}

fn test_anon_fn() {
	f1 := fn(a int){
		println('hello from f1')
	}
	f1(1)

	f2 := fn(a int) int {
		println('hello from f2')
		return 10
	}
	f2res := f2(1)
	println('f2res == $f2res')
	// TODO/FIXME: assert bug? uncomment to see
	// assert f2res == 10

	high_fn(fn (x int) int {
		return x + 1
	})

	high_fn_no_ret(fn (x int) {
		println('hello $x')
	})
}

//
// Test assigning functions (IdentFn)
//

fn simple_fn1() int {
	return 1
}

fn simple_fn2(n f32) (int, string) {
	return 1 + n, "fish"
}

fn test_assigning_fns() {
	func1 := simple_fn1
	assert func1() == 1

	func2 := simple_fn2
	res2_1, res2_2 := func2(13.0)
	assert res2_1 == 14.0
	assert res2_2 == "fish"

	anon_func1 := fn(s string)int {
		return s.len
	}
	func3 := anon_func1
	res3 := func3("fish")
	assert res3 == 4
}

//
// End assigning functions (IdentFn)
//
struct UserData {
	test string
}

fn test_fn_multiple_returns() {
	name, age, groups, data := fn_mr_get_user()
	assert name == 'joe'
	assert age == 34
	assert groups[0] == 'admins'
	assert groups[1] == 'users'
	assert data.test == 'Test Data'
	println('name: $name | age: $age | groups: ' + groups.join(',') + ' | data: $data.test')
}

fn fn_mr_get_user() (string, int, []string, UserData) {
	groups := ['admins', 'users']
	data := UserData{test: 'Test Data'}
	return 'joe', 34, groups, data
}

fn split_to_two(s string) ?(string, string) {
	mut tokens := s.split_nth(' ', 2)
	if s.len == 0 {
		return none
	}
	if tokens.len != 2 {
		return error('error')
	}
	return tokens[0], tokens[1]
}

fn returnable_fail() string {
	_,_ := split_to_two('bad') or {
		return 'ok'
	}
	return 'nok'
}

fn test_multiple_ret() {
	// returnable test
	assert returnable_fail() == 'ok'

	// good case
	res1_1, res1_2 := split_to_two("fish house") or {
		assert false
		return
	}
	assert res1_1 == 'fish'
	assert res1_2 == 'house'

	// none case
	wrapper1 := fn()(string, string){
		res2_1, res2_2 := split_to_two("") or {
			assert err == ''
			return 'replaced', 'val'
		}
		return res2_1, res2_2
	}
	res2_1, res2_2 := wrapper1()
	assert res2_1 == 'replaced'
	assert res2_2 == 'val'

	// error case
	wrapper2 := fn()(string, string){
		res3_1, res3_2 := split_to_two('fishhouse') or {
			assert err == 'error'
			return 'replaced', 'val'
		}
		return res3_1, res3_2
	}
	res3_1, res3_2 := wrapper2()
	assert res3_1 == 'replaced'
	assert res3_2 == 'val'
}
// 1 line comment // 1 line comment
/*
multi line comment (1)
multi line comment (2)
multi line comment (3)
*/
/*
multi line comment (1)
	/*
		nested comment
	*/
	/*nested comment*/
	/*nested comment
*/
	/* nested comment */
	/* /* nested comment */ */
	multi line comment (2)
*/
type MyFn1 = fn (int) string

type MyFn2 = fn (a int, b int) int

type MyFn3 = fn (int, int)

fn myfn4(string)

fn foobar()

fn slopediv(num, den u32) int

type F1 = fn ()

type F2 = fn (voidptr)

type F3 = fn (voidptr, voidptr)

type F4 = fn (voidptr) int

type F5 = fn (int, int) int

type F6 = fn (int, int)

fn C.atoi(byteptr) int

fn foo() {
}

type ActionfV = fn ()

type ActionfP1 = fn (voidptr)

type ActionfP2 = fn (voidptr, voidptr)

// TODO
fn modify_array(mut a []int) {
	a[0] = 10
	for i in 0 .. a.len {
		a[i] = a[i] * 2
	}
	// a << 888
}

fn modify_array2(mut a []int) {
	a[0] = 10
	for i in 0 .. a.len {
		a[i] = a[i] * 2
	}
	// a << 888
}

fn test_mut_array() {
	mut nums := [1, 2, 3]
	modify_array(mut nums)
	// assert nums.len == 4
	// println(nums)
	assert nums[0] == 20
	assert nums[1] == 4
	assert nums[2] == 6
	// assert nums[3] == 888
	// workaround for // [91, 32, -33686272] windows bug
	println(nums.clone())
}

fn mod_struct(mut user User) {
	user.age++
}

struct User {
mut:
	age int
}

fn test_mut_struct() {
	mut user := User{18}
	mod_struct(mut user)
	assert user.age == 19
}

fn mod_ptr(mut buf &byte) {
	buf[0] = 77
}

fn test_mut_ptr() {
	buf := malloc(10)
	mod_ptr(mut buf)
	assert buf[0] == 77
}

fn assert_in_bool_fn(v int) bool {
	assert v < 3
	return true
}

fn test_assert_in_bool_fn() {
	assert_in_bool_fn(2)
}

type MyFn = fn (int) int

fn test(n int) int {
	return n + 1000
}

struct MySt {
	f MyFn
}

fn test_fn_type_call() {
	mut arr := []MyFn{}
	arr << MyFn(test)
	// TODO: `arr[0](10)`
	// assert arr[0](10) == 1010
	x1 := arr[0]
	x2 := x1(10)
	assert x2 == 1010
	st := MySt{
		f: test
	}
	assert st.f(10) == 1010
	st1 := &MySt{
		f: test
	}
	assert st1.f(10) == 1010
}
struct VaTestGroup {
	name string
}

// basic
fn variadic_test(name string, groups ...VaTestGroup) {
	assert groups.len == 2
	assert groups[0].name == 'users'
	assert groups[1].name == 'admins'
}

fn test_fn_variadic() {
	group1 := VaTestGroup{
		name: 'users'
	}
	group2 := VaTestGroup{
		name: 'admins'
	}
	variadic_test('joe', group1, group2)
}

/*
// QTODO
// generic
fn variadic_test_generic<T>(a int, b ...T) T {
	b1 := b[0]
	b2 := b[1]
	return '$a $b1 $b2'
}

fn test_fn_variadic_generic() {
	assert variadic_test_generic(111, 'hello', 'v') == '111 hello v'
}
*/
// forwarding
fn variadic_forward_a(a ...string) string {
	return variadic_forward_b(a)
}

fn variadic_forward_b(a ...string) string {
	a0 := a[0]
	a1 := a[1]
	a2 := a[2]
	return '$a0$a1$a2'
}

fn test_fn_variadic_forward() {
	assert variadic_forward_a('a', 'b', 'c') == 'abc'
}

fn fn_variadic_with_arg_no_vargs(name string, groups ...VaTestGroup) {
	assert groups.len == 0
}

fn test_fn_variadic_with_arg_no_vargs() {
	fn_variadic_with_arg_no_vargs('marko')
}

fn fn_variadic_only_with_no_vargs(groups ...VaTestGroup) {
	assert groups.len == 0
}

fn test_variadic_only_with_no_vargs() {
	fn_variadic_only_with_no_vargs()
}

struct VaTestStruct {}

fn (a VaTestStruct) variadic_method(name string, groups ...VaTestGroup) {
	assert groups.len == 2
	assert groups[0].name == 'users'
	assert groups[1].name == 'admins'
}

fn (a VaTestStruct) variadic_method_no_args(name string, groups ...VaTestGroup) {
	assert groups.len == 0
}

fn test_fn_variadic_method() {
	a := VaTestStruct{}
	group1 := VaTestGroup{
		name: 'users'
	}
	group2 := VaTestGroup{
		name: 'admins'
	}
	a.variadic_method('marko', group1, group2)
}

fn test_fn_variadic_method_no_args() {
	a := VaTestStruct{}
	a.variadic_method_no_args('marko')
}
const (
	nums = [1, 2, 3]
)

fn test_for_char_in() {
	mut sum := 0
	for char in nums {
		sum += char
	}
	assert sum == 6
}

fn test_for_char_in_range() {
	mut sum := 0
	for char in 0 .. nums.len {
		sum += nums[char]
	}
	assert sum == 6
}

fn test_for_blank_in_range() {
	mut sum := 0
	for _ in 1 .. 3 {
		sum++
	}
	assert sum == 2
}

fn test_for_char_complex() {
	mut sum := 0
	for char := 0; char < nums.len; char++ {
		sum += nums[char]
	}
	assert sum == 6
}

fn test_for_char_in_string() {
	s := 'abcd'
	mut sum := 0
	for char in s {
		sum += char
	}
	assert sum == 394 // ascii codes of `a` + `b` + `c` + `d`
}

fn test_for_char_in_map() {
	m := {
		'a': 'b'
		'c': 'd'
	}
	mut acc := ''
	for k, char in m {
		acc += '$k: $char, '
	}
	assert acc == 'a: b, c: d, '
}
fn test_todo() {
}

fn simple<T>(p T) T {
	return p
}

fn plus<T>(xxx, b T) T {
	// x := a
	// y := b
	// ww := ww
	// q := xx + 1
	return xxx + b
}

fn test_generic_fn() {
	assert simple<int>(1) == 1
	assert simple<int>(1 + 0) == 1
	assert simple<string>('g') == 'g'
	assert simple<string>('g') + 'h' == 'gh'
	a := plus<int>(2, 3)
	println(a)
	assert a == 5
	assert plus<int>(10, 1) == 11
	assert plus<string>('a', 'b') == 'ab'
}

fn sum<T>(l []T) T {
	mut r := T(0)
	for e in l {
		r += e
	}
	return r
}

fn test_foo() {
	b := [1, 2, 3]
	assert sum<int>(b) == 6
}

/*
fn map_f<T,U>(l []T, f fn(T)U) []U {
    mut r := []U{}
    for e in l {
        r << f(e)
    }
    return r
}

fn foldl<T>(l []T, nil T, f fn(T,T)T) T {
    mut r := nil
    for e in l {
        r = f(r, e)
    }
    return r
}

fn square(x int) int {
    return x*x
}

fn mul_int(x int, y int) int {
    return x*y
}

fn assert_eq<T>(a, b T) {
    r := a == b
    println('$a == $b: ${r.str()}')
    assert r
}

fn print_nice<T>(x T, indent int) {
    mut space := ''
    for _ in 0..indent {
        space = space + ' '
    }
    println('$space$x')
}

fn test_generic_fn() {
    assert_eq(simple(0+1), 1)
    assert_eq(simple('g') + 'h', 'gh')
    assert_eq(sum([5.1,6.2,7.0]), 18.3)
    assert_eq(plus(i64(4), i64(6)), i64(10))
    a := [1,2,3,4]
    b := map_f(a, square)
    assert_eq(sum(b), 30)     // 1+4+9+16 = 30
    assert_eq(foldl(b, 1, mul_int), 576)   // 1*4*9*16 = 576
    print_nice('str', 8)
}

struct Point {
mut:
    x f64
    y f64
}

fn (mut p Point) translate<T>(x, y T) {
    p.x += x
    p.y += y
}

fn test_generic_method() {
    mut p := Point{}
    p.translate(2, 1.0)
    assert p.x == 2.0 && p.y == 1.0
}

fn get_values<T>(i T) []T {
    return [i]
}

fn test_generic_fn_in_for_in_expression() {
    for value in get_values(1) {
        assert value == 1
    }

    for i, val in get_values(0) {
        assert i == val
    }

    for value in get_values('a') {
        assert value == 'a'
    }
}

// test generic struct
struct DB {
    driver string
}

struct User {
	db DB
mut:
	name string
}

struct Repo<T> {
	db DB
mut:
	model  T
}

fn new_repo<U>(db DB) Repo<U> {
	return Repo<U>{db: db}
}

fn test_generic_struct() {
	mut a :=  new_repo<User>(DB{})
	a.model.name = 'joe'
	mut b := Repo<User>{db: DB{}
	}
	b.model.name = 'joe'
	assert a.model.name == 'joe'
	assert b.model.name == 'joe'
}
*/
fn test_goto() {
	mut i := 0
	a: b := 1
	_ = b
	i++
	if i < 3 {
		goto a
	}
	assert i == 3
}
fn test_if_expression_precedence_false_condition() {
	b := 10
	c := 20
	res := 1 + if b > c { b } else { c } + 1
	assert res == c + 2
}

fn test_if_expression_precedence_true_condition() {
	b := 20
	c := 10
	res := 1 + if b > c { b } else { c } + 1
	assert res == b + 2
}

fn test_if_expression_with_stmts() {
	a := if true {
		b := 1
		b
	} else {
		b := 4
		b
	}
	assert a == 1
	mut b := 0
	b = if false {
		42
	} else {
		24
	}
	assert b == 24
}

fn noop() {}

fn test_if_expression_with_function_assign() {
	a := if true {
		my_fn := noop
		my_fn()
		0
	} else {
		1
	}
	assert a == 0
}

fn get_bool_str(b bool) string {
	return b.str()
}

fn test_if_expression_mutate_var() {
	mut b := false
	r := b && if true {
		b = true
		true
	} else {
		true
	}
	assert r == false
	// test in function call
	assert get_bool_str(b && if true {
		b = true
		true
	} else {
		true
	}) == 'false'
	// test on method call
	assert (b && if true {
		b = true
		true
	} else {
		true
	}).str() == 'false'
	// test on array
	mut a := [1, 2]
	assert a.len == 2 && if true {
		a << 3
		true
	} else {
		false
	}
}

fn test_simple_nested_if_expressions() {
	a := if false {
		b := 1
		if b == 0 {
			0
		} else {
			b
		}
	} else {
		println('Hello world !')
		if 1 == 1 {
			t := 12
			t + 42
		} else {
			43
		}
	}
	assert a == 54
}

fn test_complex_nested_if_expressions() {
	mut a := false
	a = 1 == 2 || true && if true {
		g := 6
		h := if false { 3 } else { 5 }
		mut d := false
		if h == 2 {
			d = g + 4 == 5
		}
		if d {
			if true {
				d = false
			} else {
				d = true
			}
		}
		d
	} else {
		x := 6
		y := 8
		if x + y > 0 {
			x > 0
		} else {
			false
		}
	}
	assert a == false
}
module main

interface Speaker {
	say() string
}

fn test_todo() {}

/*
// QTODO
struct ChatRoom {
mut:
	talkers map[string]Speaker
}

fn new_room() &ChatRoom {
	return &ChatRoom{
		talkers: map[string]Speaker
	}
}

fn (mut r ChatRoom) add(name string, s Speaker) {
	r.talkers[name] = s
}

fn test_using_a_map_of_speaker_interfaces() {
	mut room := new_room()
	room.add('my cat', Cat{name: 'Tigga'} )
	room.add('my dog', Dog{name: 'Pirin'} )
	room.add('stray dog', Dog{name: 'Anoni'} )
	room.add('me', Human{name: 'Bilbo'} )
	room.add('she', Human{name: 'Maria'} )
	mut text := ''
	for name, subject in room.talkers {
		line := '${name:12s}: ${subject.say()}'
		println(line)
		text += line
	}
	assert text.contains(' meows ')
	assert text.contains(' barks ')
	assert text.contains(' says ')
}

//

struct Cat { name string }
fn (c &Cat) say() string { return '${c.name} meows "MEOW!"' }

struct Dog { name string }
fn (d &Dog) say() string { return '${d.name} barks "Bau Bau!"' }

struct Human { name string }
fn (h &Human) say() string { return '${h.name} says "Hello"' }
*/
struct Dog {
	breed string
}

struct Cat {
mut:
	breed string
}

fn (mut c Cat) name() string {
	if c.breed != '' {
		assert c.breed == 'Persian'
	}
	return 'Cat'
}

fn (c &Cat) speak(s string) {
	if c.breed != '' {
		assert c.breed == 'Persian'
	}
	assert s == 'Hi !'
	println('meow')
}

fn (c Cat) name_detailed(pet_name string) string {
	return '$pet_name the ${typeof(c)}, breed:${c.breed}'
}

fn (mut c Cat) set_breed(new string) {
	c.breed = new
}

// utility function to override default conversion to string, as a sample
fn (c Cat) str() string {
	return 'Custom string conversion for Cat: $c.breed'
}

fn (d Dog) speak(s string) {
	assert s == 'Hi !'
	println('woof')
}

fn (d Dog) name() string {
	assert d.breed == 'Labrador Retriever'
	return 'Dog'
}

fn (d Dog) name_detailed(pet_name string) string {
	return '$pet_name the ${typeof(d)}, breed:${d.breed}'
}

fn (mut d Dog) set_breed(new string) {
	println('Nah')
}

// do not add to Dog the utility function 'str', so the default one will be used, as a sample
fn test_todo() {
	if true {
	} else {
	}
}

fn perform_speak(a Animal) {
	a.speak('Hi !')
	assert true
	name := a.name()
	assert name == 'Dog' || name == 'Cat'
	if a is Dog {
		assert name == 'Dog'
	}
	println(a.name())
	println('Got animal of type: ${typeof(a)}') // TODO: get implementation type (if possible)
	// assert a is Dog || a is Cat // TODO: enable when available
}

fn perform_speak_on_ptr(a &Animal) {
	a.speak('Hi !')
	assert true
	name := a.name()
	assert name == 'Dog' || name == 'Cat'
	// if a is Dog {
	// assert name == 'Dog'
	// }
	println(a.name())
	println('Got animal of type: ${typeof(a)}') // TODO: get implementation type (if possible)
	// assert a is Dog || a is Cat // TODO: enable when available
}

fn test_perform_speak() {
	dog := Dog{
		breed: 'Labrador Retriever'
	}
	perform_speak(dog)
	perform_speak_on_ptr(dog)
	cat := Cat{
		breed: 'Persian'
	}
	perform_speak(cat)
	perform_speak(Cat{
		breed: 'Persian'
	})
	perform_speak_on_ptr(cat)
	perform_speak_on_ptr(Cat{
		breed: 'Persian'
	})
	handle_animals([dog, cat])
	/*
	f := Foo {
		speaker: dog
	}
	*/
}

fn change_animal_breed(a &Animal, new string) {
	a.set_breed(new)
}

fn test_interface_ptr_modification() {
	mut cat := Cat{
		breed: 'Persian'
	}
	// TODO Should fail and require `mut cat`
	change_animal_breed(cat, 'Siamese')
	assert cat.breed == 'Siamese'
}

fn perform_name_detailed(a Animal) {
	name_full := a.name_detailed('MyPet')
	println(name_full)
	assert name_full.starts_with('MyPet the Dog') || name_full.starts_with('MyPet the Cat')
}

fn test_perform_name_detailed() {
	dog := Dog{
		breed: 'Labrador Retriever'
	}
	println('Test on Dog: $dog ...') // using default conversion to string
	perform_name_detailed(dog)
	cat := Cat{}
	println('Test on empty Cat: $cat ...')
	perform_speak(cat)
	println('Test on a Persian Cat: ...')
	perform_speak(Cat{
		breed: 'Persian'
	})
	cat_persian2 := Cat{
		breed: 'Persian'
	}
	println('Test on another Persian Cat: "$cat_persian2" ...')
	perform_speak(cat_persian2)
	cat_persian2_str := cat_persian2.str()
	println("Persian Cat 2: '$cat_persian2_str' ...")
	assert cat_persian2_str == 'Custom string conversion for Cat: Persian'
	println('Test (dummy/empty) on array of animals ...')
	handle_animals([dog, cat])
	handle_animals_mutable([dog, cat])
	assert true
}

fn handle_animals(a []Animal) {
}

fn handle_animals_mutable(a []Animal) {
}

interface Register {
	register()
}

struct RegTest {
	a int
}

fn (f RegTest) register() {
}

fn handle_reg(r Register) {
}

fn test_register() {
	f := RegTest{}
	f.register()
	handle_reg(f)
}

interface Speaker2 {
	name() string
	speak()
}

struct Foo {
	animal  Animal
	animals []Animal
}

interface Animal {
	name() string
	name_detailed(pet_name string) string
	speak(s string)
	set_breed(s string)
}

fn test_interface_array() {
	println('Test on array of animals ...')
	mut animals := []Animal{}
	animals = [Cat{}, Dog{
		breed: 'Labrador Retriever'
	}]
	assert true
	animals << Cat{}
	assert true
	// TODO .str() from the real types should be called
	// println('Animals array contains: ${animals.str()}') // explicit call to 'str' function
	// println('Animals array contains: ${animals}') // implicit call to 'str' function
	assert animals.len == 3
}

fn test_interface_ptr_array() {
	mut animals := []&Animal{}
	animals = [Cat{}, Dog{
		breed: 'Labrador Retriever'
	}]
	assert true
	animals << Cat{}
	assert true
	assert animals.len == 3
}
enum Colors {
	red green blue yellow
}

fn test_in_expression() {
	mut a := false
	arr1 := [1, 2]
	arr2 := [0, 2]
	arr3 := [1, 0]

	a = true && 2 in arr1
	assert a == true
	a = false && 2 in arr1
	assert a == false

	a = true && 0 in arr2
	assert a == true
	a = false && 0 in arr3
	assert a == false
	a = true && 0 in arr1
	assert a == false
	a = true && 3 in arr1
	assert a == false
	a = true && 2 !in arr2
	assert a == false
	a = true && 3 !in arr2
	assert a == true

	a = true && 2 !in arr2
	assert a == false
	a = true && 3 !in arr2
	assert a == true

	a = 1 in arr1 && true
	assert a == true
	a = 1 in arr1 && false
	assert a == false
}

/*
not implemented
fn test_in_expression_with_enum() {
	mut a := false
	arr1 := [Colors.green, .blue]
	arr2 := [Colors.red, .blue]
	arr3 := [Colors.green, .red]
	a = true && Colors.blue in arr1
	assert a == true
	a = false && Colors.blue in arr1
	assert a == false
	a = true && Colors.red in arr2
	assert a == true
	a = false && Colors.red in arr3
	assert a == false

	a = true && Colors.red in arr1
	assert a == false
	a = true && Colors.yellow in arr1
	assert a == false

	a = true && !(Colors.blue in arr2)
	assert a == false
	a = true && !(Colors.yellow in arr2)
	assert a == true

	a = Colors.green in arr1 && true
	assert a == true
	a = Colors.green in arr1 && false
	assert a == false
}
*/
fn test_in_expression_with_string() {
	mut a := false
	arr1 := ['ab', 'bc']
	arr2 := ['', 'bc']
	arr3 := ['ab', '']

	a = true && 'bc' in arr1
	assert a == true
	a = false && 'bc' in arr1
	assert a == false

	a = true && '' in arr2
	assert a == true
	a = false && '' in arr3
	assert a == false
	a = true && '' in arr1
	assert a == false
	a = true && 'abc' in arr1
	assert a == false
	a = true && 'bc' !in arr2
	assert a == false
	a = true && 'abc' !in arr2
	assert a == true

	a = true && 'bc' !in arr2
	assert a == false
	a = true && 'abc' !in arr2
	assert a == true

	a = 'ab' in arr1 && true
	assert a == true
	a = 'ab' in arr1 && false
	assert a == false
}

fn test_in_expression_in_map() {
	m := {
		'one': 1
		'two': 2
		'three': 3
	}
	assert 'one' in m
	assert 'four' !in m
}

fn test_in_expression_in_string() {
	s := 'abcd'
	assert 'a' in s
	assert 'ab' in s
	assert 'abcd' in s
	assert 'dbca' !in s
}

fn test_optimized_in_expression() {
	mut a := false
	a = true && 2 in [1, 2]
	assert a == true
	a = false && 2 in [1, 2]
	assert a == false

	a = true && 0 in [0, 2]
	assert a == true
	a = false && 0 in [1, 0]
	assert a == false
	a = true && 0 in [1, 2]
	assert a == false
	a = true && 3 in [1, 2]
	assert a == false
	a = true && 2 !in [0, 2]
	assert a == false
	a = true && 3 !in [0, 2]
	assert a == true

	a = true && 2 !in [0, 2]
	assert a == false
	a = true && 3 !in [0, 2]
	assert a == true

	a = 1 in [1, 2] && true
	assert a == true
	a = 1 in [1, 2] && false
	assert a == false
}

fn test_optimized_in_expression_with_enum() {
	mut a := false
	a = true && Colors.blue in [.green, .blue]
	assert a == true
	a = false && Colors.blue in [.green, .blue]
	assert a == false

	a = true && Colors.red in [.red, .blue]
	assert a == true
	a = false && Colors.red in [.green, .red]
	assert a == false
	a = true && Colors.red in [.green, .blue]
	assert a == false
	a = true && Colors.yellow in [.green, .blue]
	assert a == false
	a = true && Colors.blue !in [.red, .blue]
	assert a == false
	a = true && Colors.yellow !in [.red, .blue]
	assert a == true

	a = true && Colors.blue !in [.red, .blue]
	assert a == false
	a = true && Colors.yellow !in [.red, .blue]
	assert a == true

	a = Colors.green in [.green, .blue] && true
	assert a == true
	a = Colors.green in [.green, .blue] && false
	assert a == false
}

fn test_optimized_in_expression_with_string() {
	mut a := false
	a = true && 'bc' in ['ab', 'bc']
	assert a == true
	a = false && 'bc' in ['ab', 'bc']
	assert a == false

	a = true && '' in ['', 'bc']
	assert a == true
	a = false && '' in ['ab', '']
	assert a == false
	a = true && '' in ['ab', 'bc']
	assert a == false
	a = true && 'abc' in ['ab', 'bc']
	assert a == false
	a = true && 'bc' !in ['', 'bc']
	assert a == false
	a = true && 'abc' !in ['', 'bc']
	assert a == true

	a = true && 'bc' !in ['', 'bc']
	assert a == false
	a = true && 'abc' !in ['', 'bc']
	assert a == true

	a = 'ab' in ['ab', 'bc'] && true
	assert a == true
	a = 'ab' in ['ab', 'bc'] && false
	assert a == false
}
import os
import time

/*
The goal of this test, is to simulate a developer, that has run a program, compiled with -live flag.

It does so by writing a new generated program containing a [live] fn pmessage() string {...} function,
then runs the generated program at the start *in the background*, 
waits some time, so that the program could run a few iterations, then modifies its source 
(simulates a developer that has saved a new version of the program source), 
then it waits some more, modifies it again and saves it once more.

On each modification, the running program, should detect that its source code has changed, 
and recompile a shared library, which it then it should load, and thus modify its own 
behavior at runtime (the pmessage function).

If everything works fine, the output of the generated program would have changed at least 1-2 times,
which then is detected by the test program (the histogram checks).

Since this test program is sensitive to coordination (or lack of) of several processes, 
it tries to sidestep the coordination issue by polling the file system for the existance 
of files, ORIGINAL.txt ... STOP.txt , which are appended to by the generated program.

NB: That approach of monitoring the state of the running generated program, is clearly not ideal, 
but sidesteps the issue of coordinating processes through IPC or stdin/stdout in hopefully 
not very flaky way.

TODO: Cleanup this when/if v has better process control/communication primitives.
*/

const (
	vexe                = os.getenv('VEXE')
	tmp_file            = os.join_path(os.temp_dir(), 'generated_live_program.tmp.v')
	source_file         = os.join_path(os.temp_dir(), 'generated_live_program.v')
	genexe_file         = os.join_path(os.temp_dir(), 'generated_live_program')
	output_file         = os.join_path(os.temp_dir(), 'generated_live_program.output.txt')
	res_original_file   = os.join_path(os.temp_dir(), 'ORIGINAL.txt')
	res_changed_file    = os.join_path(os.temp_dir(), 'CHANGED.txt')
	res_another_file    = os.join_path(os.temp_dir(), 'ANOTHER.txt')
	res_stop_file       = os.join_path(os.temp_dir(), 'STOP.txt')
	live_program_source = "
module main

import time
import os
import live

fn append_to_file(fname, s string) {
	f := os.open_append(fname) or {
		println('>>>> could not open file \$fname for appending, err: \$err ')
		return 
	}
	f.writeln('\$s')
	//info := live.info()    
	//f.writeln('>>> reloads: \${info.reloads} | ok reloads: \${info.reloads_ok}')
	f.flush()
	f.close()
}    

fn myprintln(s string) {
	append_to_file('$output_file', s)
	println(s)
	os.flush()
}

[live]
fn pmessage() string {
	s := 'ORIGINAL'
	myprintln(s)
	return s
}

const (
	delay = 5
)

fn main() {
	mut info := live.info()
    info.recheck_period_ms = 5
	myprintln('START')
	myprintln('DATE: ' + time.now().str())
	pmessage()
	pmessage()
    // NB: 1000 * 5 = maximum of ~5s runtime
	for i:=0; i<1000; i++ {
		s := pmessage()
		append_to_file(os.resource_abs_path(s + '.txt'), s)
		time.sleep_ms(delay)
		if s == 'STOP' {
			break
		}
	}
	pmessage()
	pmessage()
	myprintln('DATE: ' + time.now().str())
	myprintln('END')
}
"
)

fn atomic_write_source( source string ){
	// NB: here wrtiting is done in 2 steps, since os.write_file can take some time,
	// during which the file will be modified, but it will still be not completely written.
	// The os.mv after that, guarantees that the reloader will see a complete valid V program.
	os.write_file(tmp_file, source)
	os.mv(tmp_file, source_file )
}

//
fn testsuite_begin() {
	if os.user_os() !in ['linux', 'solaris'] && os.getenv('FORCE_LIVE_TEST').len == 0 {
		eprintln('Testing the runtime behaviour of -live mode,')
		eprintln('is reliable only on Linux for now.')
		eprintln('You can still do it by setting FORCE_LIVE_TEST=1 .')
		exit(0)
	}
	for f in [ tmp_file, source_file, output_file, res_original_file, res_changed_file, res_another_file, res_stop_file] {
		os.rm(f)
	}
	atomic_write_source( live_program_source )
}

[if debuglivetest]
fn vprintln(s string) {
	eprintln(s)
}

fn testsuite_end() {
	vprintln('source: $source_file')
	vprintln('output: $output_file')
	vprintln('---------------------------------------------------------------------------')
	output_lines := os.read_lines(output_file) or {
		eprintln('could not read $output_file, error: $err')
		return
	}
	mut histogram := map[string]int
	for line in output_lines {
		histogram[line] = histogram[line] + 1
	}
	for k, v in histogram {
		eprintln('> found ${v:5d} times: ${k}')
	}
	vprintln('---------------------------------------------------------------------------')
	assert histogram['START'] > 0
	assert histogram['ORIGINAL'] > 0
	assert histogram['CHANGED'] + histogram['ANOTHER'] > 0
	//assert histogram['END'] > 0
}

fn change_source(new string) {
	time.sleep_ms(100)
	vprintln('> change ORIGINAL to: $new')
	atomic_write_source( live_program_source.replace('ORIGINAL', new) )
	wait_for_file(new)
}    

fn wait_for_file(new string){
	time.sleep_ms(100)
	expected_file := os.join_path(os.temp_dir(), new + '.txt')
	eprintln('waiting for $expected_file ...')
	for i:=0 ; i <= 400 ; i++ {
		if i % 25 == 0 {
			vprintln('   checking ${i:-10d} for $expected_file ...')
		}
		if os.exists( expected_file ) {
			assert true
			vprintln('> done.')
			time.sleep_ms(100)
			break
		}
		time.sleep_ms(5)
	}
}

//
fn test_live_program_can_be_compiled() {
	eprintln('Compiling...')
	os.system('$vexe -live -o $genexe_file $source_file')
	//
	cmd := '$genexe_file > /dev/null &'
	eprintln('Running with: $cmd')
	res := os.system(cmd)
	assert res == 0
	eprintln('... running in the background')
	wait_for_file('ORIGINAL')
}

fn test_live_program_can_be_changed_1() {
	change_source('CHANGED')
	assert true
}

fn test_live_program_can_be_changed_2() {
	change_source('ANOTHER')
	assert true
}

fn test_live_program_can_be_changed_3() {
	change_source('STOP')
	assert true
}
import v.tests.local

fn test_local_module_is_callable() {
	assert local.local_fn()
}
struct Test {
	a bool
	b int
	y string
}

fn test_interpolation_map_to_string() {
	mut a := map[string]string
	a['1'] = 'one'
	a['2'] = 'two'
	a['3'] = 'three'
	assert '$a' == "{'1': 'one', '2': 'two', '3': 'three'}"

	mut b := map[string]int
	b['1'] = 1
	b['2'] = 2
	b['3'] = 3
	assert '$b' == "{'1': 1, '2': 2, '3': 3}"

	mut c := map[string]bool
	c['1'] = true
	c['2'] = false
	assert '$c' == "{'1': true, '2': false}"

	d := {'f1': 1.1, 'f2': 2.2, 'f3': 3.3, 'f4': 4.4}
	println('d: $d')
	assert '$d' == "{'f1': 1.1, 'f2': 2.2, 'f3': 3.3, 'f4': 4.4}"

	mut e := map[string]Test
	e['1'] = Test{true, 0, 'abc'}
	e['2'] = Test{true, 1, 'def'}
	e['3'] = Test{false, 2, 'ghi'}
	s := '$e'
	assert s.contains("{'1': Test {")
	assert s.contains('a: true')
	assert s.contains("y: 'abc'")
	assert s.contains("}, '2': Test {")
	assert s.contains("y: 'def'")
}

type SumType = int | string

fn s2s(s SumType) SumType { return s }

fn test_match_expression_on_sumtype_ordinary_branch(){
	// tests whether an ordinary branch supports multiple statements,
	// followed by a default expression
	mut c := 0
	s := s2s('abc')
	res := match s {
		string {
			c = 1
			eprintln('hi')
			'a string'
		}else{
			'unknown'
		}
	}
	assert res == 'a string'
	assert c == 1
}


fn test_match_expression_on_sumtype_else(){
	// tests whether else branches support multiple statements,
	// when the other branches are simple default expressions
	mut c := 0
	s := s2s(int(123))
	res := match s {
		string {
			'a string'
		}else{
			c = 3
			eprintln('hi')
			'unknown'
		}
	}
	assert res == 'unknown'
	assert c == 3
}

fn test_match_expression_on_sumtype_full(){
	// tests whether all branches can have multiple statements,
	// followed by a default expression
	mut c := 0
	s := s2s(int(123))
	res := match s {
		int {
			c = 1
			eprintln('hi')
			'an integer'
		}
		string {
			c = 2
			eprintln('hi')
			'a string'
		}
	}
	assert res == 'an integer'
	assert c == 1
}
enum Color {
	red
	green
	blue
}

pub fn (c Color) str() string {
	return 'tmp'
}

fn test_match_integers() {
	mut a := 3
	mut b := 0
	match a {
		2 { println('two') }
		3 {
			println('three')
			b = 3
		}
		4 { println('four') }
		else { println('???') }
	}
	assert b == 3
	assert match 2 {
		1 { 2 }
		2 { 3 }
		else { 5 }
	} == 3
	assert match 0 {
		1 { 2 }
		2 { 3 }
		else { 5 }
	} == 5
	assert match 1 {
		else { 5 }
	} == 5
	a = 0
	match 2 {
		0 { a = 1 }
		1 { a = 2 }
		else {
			a = 3
			println('a is $a')
		}
	}
	assert a == 3
	a = 0
	match 1 {
		0 { a = 1 }
		1 {
			a = 2
			a = a + 2
			a = a + 2
		}
		else {}
	}
	assert a == 6
	a = 0
	match 1 {
		else { a = -2 }
	}
	assert a == -2
}

fn test_match_enums() {
	mut b := Color.red
	match b {
		.red { b = .green }
		.green { b = .blue }
		else {
			println('b is ${b.str()}')
			b = .red
		}
	}
	assert b == .green
	match b {
		.red { b = .green }
		else {
			println('b is ${b.str()}')
			b = .blue
		}
	}
	assert b == .blue
}
import os
import time as t
import crypto.sha256
import math
import log as l
import crypto.sha512

struct TestAliasInStruct {
	time t.Time
}

fn test_import() {
	info := l.Level.info
	assert os.o_rdonly == os.o_rdonly && t.month_days[0] == t.month_days[0] && sha256.size ==
		sha256.size && math.pi == math.pi && info == .info && sha512.size == sha512.size
}

fn test_alias_in_struct_field() {
	a := TestAliasInStruct{
		time: t.Time{
			year: 2020
		}
	}
	assert a.time.year == 2020
}
fn test_multiple_assign() {
	a, b, c := 1, 2, 3
	assert a == 1
	assert b == 2
	assert c == 3
}
fn multi_voidptr_ret() (voidptr, bool) {
	return voidptr(0), true
}

fn multi_byteptr_ret() (byteptr, bool) {
	return byteptr(0), true
}

fn test_multi_ptrtype_ret() {
	a, b := multi_voidptr_ret()
	assert a == voidptr(0)
	assert b == true
	c, d := multi_byteptr_ret()
	assert c == byteptr(0)
	assert d == true
}
struct A {
pub mut:
	v []int
}

struct B {
pub mut:
	a []A
}

fn foo(b int, a mut []int) {
	a[0] = 7
	// a << 4
}

fn test_mut() {
	mut numbers := [1, 2, 3]
	foo(7, mut numbers)
	assert numbers.len == 3
	// TODO bring back once << works with mutable args
	// assert numbers.len == 4
	// assert numbers[0] == 7
	// assert numbers[3] == 4
	println(numbers)
	n := 1
	mut b := (&n)
	//
	(*b) = 10
	// mut b := mut a
	// b = 10
}

fn test_mut_2() {
	zero := 0
	mut b := B{}
	b.a << A{}
	b.a[0].v = [9, 8, 7]
	b.a[0].v << 6
	b.a[zero].v << 5
	b.a[0].v[zero] = 3
	b.a[0].v[b.a[zero].v[zero]] += 2 - 1 // TODO
	b.a[0].v[b.a[0].v[zero]] += 2 - 1 // TODO
	assert b.a[0].v.len == 5
	assert b.a[0].v[0] == 3
	assert b.a[0].v[1] == 8
	assert b.a[0].v[2] == 7
	assert b.a[0].v[3] == 8
	assert b.a[0].v[4] == 5
}
fn test_todo() {}

/*
fn simple<T>(p T) string {
	tname := nameof(T)
	println("Hello generic, I'm an [$tname]")
	return tname
}

struct FunkyStruct{ }

fn test_nameof_on_various_types_in_generic() {
	assert simple(42) == "int"
	assert simple(3.14) == "f64"
	assert simple("FuBar") == "string"
	assert simple(FunkyStruct{}) == "FunkyStruct"
	assert simple(test_nameof_on_various_types_in_generic) == "fn ()"
}
*/
fn test_nested_maps() {
	if true{}
	//
	else{}
	mut x := map[string]map[string]int
	x["a"] = map[string]int
	assert x["a"]["b"] == 0
	x["a"]["b"] = 5
	assert x["a"]["b"] == 5
	x["a"]["b"] = 7
	assert x["a"]["b"] == 7
	mut y := map[string]map[string]map[string]int
	y["a"] = map[string]map[string]int
	y["a"]["b"] = map[string]int
	assert y["a"]["b"]["c"] == 0
	y["a"]["b"]["c"] = 5
	assert y["a"]["b"]["c"] == 5
	y["a"]["b"]["c"] = 7
	assert y["a"]["b"]["c"] == 7
}
fn test_int_lit_call_method() {
	x1 := 1234.str()
	assert x1 == '1234'
	x2 := -0xffff.str()
	assert x2 == '-65535'
	x3 := 0b1001001.str()
	assert x3 == '73'
	x4 := 0o653262.str()
	assert x4 == '218802'
	x5 := 0.str()
	assert x5 == '0'
}

fn test_float_lit_call_method() {
	x1 := -123.66.str()
	assert x1 == '-1.2366e+02'
	x2 := 12.5e-2.str()
	assert x2 == '1.25e-01'
	x3 := .789.str()
	assert x3 == '7.89e-01'
	x4 := .003e2.str()
	assert x4 == '3.e-01'
	x5 := 2.e-3.str()
	assert x5 == '2.e-03'
	x6 := 5.0.str()
	assert x6 == '5.e+00'
	// x7 := 5..str()    Syntax `5.` is allowed, but do not call method on it (`5..str()` is parsed as a range). Use `5.0.str()` instead.
}
struct Vec {
	x int
	y int
}

pub fn (a Vec) str() string {
	return '{$a.x, $a.y}'
}

fn (a Vec) +(b Vec) Vec {
	return Vec{a.x + b.x, a.y + b.y}
}

fn (a Vec) -(b Vec) Vec {
	return Vec{a.x - b.x, a.y - b.y}
}

fn (a Vec) *(b Vec) Vec {
	return Vec{a.x * b.x, a.y * b.y}
}

fn (a Vec) /(b Vec) Vec {
	return Vec{a.x / b.x, a.y / b.y}
}

fn (a Vec) %(b Vec) Vec {
	return Vec{a.x % b.x, a.y % b.y}
}

fn test_operator_overloading_with_string_interpolation() {
	a := Vec{2, 3}
	b := Vec{4, 5}

	c := a + b
	assert a.x + b.x == c.x
	assert a.y + b.y == c.y

	d := a - b
	assert a.x - b.x == d.x
	assert a.y - b.y == d.y

	e := a * b
	assert a.x * b.x == e.x
	assert a.y * b.y == e.y

	f := a / b
	assert a.x / b.x == f.x
	assert a.y / b.y == f.y

	g := a % b
	assert a.x % b.x == g.x
	assert a.y % b.y == g.y

	assert c.str() == '{6, 8}'
	assert d.str() == '{-2, -2}'
	assert e.str() == '{8, 15}'
	assert f.str() == '{0, 0}'
	assert g.str() == '{2, 3}'
}
struct Abc {
	x int
}

fn i_0(x int) ?int {
	if x == 0 {
		return error('my error 1')
	}
	return x
}

fn struct_0(x int) ?Abc {
	if x == 0 {
		return error('my error 2')
	}
	return Abc{x}
}

fn string_0(x int) ?string {
	if x == 0 {
		return error('my error 3')
	}
	return '$x'
}

fn b_0(b bool) ?bool {
	if b == false {
		return error('my error 4')
	}
	return b
}

fn return_a_string() string {
	return 'abcdef'
}

//
fn test_optional_int() {
	a := i_0(0) or {
		4999
	}
	assert a == 4999
	b := i_0(4123) or {
		4999
	}
	assert b == 4123
}

/*
fn test_optional_bool() {
	a := true && b_0(false) {
		true
	}
	assert a == true
	b := false || b_0(true) {
		false
	}
	assert b == true
}
*/
fn test_optional_struct() {
	sa := struct_0(0) or {
		Abc{7999}
	}
	assert sa.x == 7999
	sb := struct_0(3456) or {
		Abc{7999}
	}
	assert sb.x == 3456
}

fn test_optional_with_statements_before_last_expression() {
	s := struct_0(0) or {
		eprintln('hello')
		Abc{12345}
	}
	assert s.x == 12345
	b := b_0(true) or {
		false
	}
	assert b == true
}

fn test_optional_with_fn_call_as_last_expression() {
	s := string_0(0) or {
		return_a_string()
	}
	assert s == 'abcdef'
}

fn test_optional_with_fn_call_last_expr_and_preceding_statements() {
	s := string_0(0) or {
		eprintln('hello')
		println('world')
		return_a_string()
	}
	assert s == 'abcdef'
}

fn test_nested_optional() {
	a := i_0(1) or {
		b := i_0(0) or {
			3
		}
		b
	}
	assert a == 1
	b := i_0(0) or {
		c := i_0(1) or {
			3
		}
		c
	}
	assert b == 1
	c := i_0(0) or {
		d := i_0(0) or {
			3
		}
		d
	}
	assert c == 3
}

fn test_nested_optional_with_opt_fn_call_as_last_value() {
	a := i_0(1) or {
		i_0(0) or {
			3
		}
	}
	assert a == 1
	b := i_0(0) or {
		i_0(1) or {
			3
		}
	}
	assert b == 1
	c := i_0(0) or {
		i_0(0) or {
			3
		}
	}
	assert c == 3
	// TODO Enable once optional in boolean expressions are working
	// d := b_0(true) or {
	// 	false && b_0(true) or {
	// 		true
	// 	}
	// }
	// assert d == false
	// e := b_0(true) or {
	// 	true && b_0(true) or {
	// 		false
	// 	}
	// }
	// assert e == false
}
fn err_call(ok bool) ?int {
	if ok {
		return 42
	}
	return error('Not ok!')
}

fn test_if_opt() {
	if val := err_call(true) {
		eprintln('  val should be available here: $val')
		assert val == 42
	}
	assert true
}

fn test_opt_with_fall_through() {
	mut x := 1
	err_call(false) or {
		eprintln('  this *should* be an error: $err')
		x++
		assert true
	}
	assert x == 2
}

fn test_error_can_be_converted_to_string(){
	assert 'Option{ error: "an error" }' == error('an error').str()
}

fn test_error_can_be_assigned_to_a_variable(){
	f := error('an error')
	assert 'Option{ error: "an error" }' == f.str()
}

fn test_error_can_be_printed(){
	f := error('an error')
	println(f)
	assert true
}

fn test_error_can_be_interpolated_in_a_string(){
	f := error('an error')
	s := 'hi $f'
	assert s == 'hi Option{ error: "an error" }'
}
fn opt_err_with_code() ?string {
	return error_with_code('hi', 137)
}

fn test_err_with_code() {
	v := opt_err_with_code() or {
		assert err == 'hi'
		assert errcode == 137
		return
	}
	assert false
	println(v) // suppress not used error
}

fn opt_err() ?string {
	return error('hi')
}

fn test_err() {
	v := opt_err() or {
		assert err == 'hi'
		return
	}
	assert false
	println(v) // suppress not used error
}

fn err_call(ok bool) ?int {
	if !ok {
		return error('Not ok!')
	}
	return 42
}

fn ret_none() ?int {
	// return error('wtf') //none
	return none
}

fn test_option_for_base_type_without_variable() {
	mut val := err_call(true) or {
		assert false
		0
	}
	assert val == 42
	val = ret_none() or {
		return
	}
	assert false
	// This is invalid:
	// x := 5 or {
	// return
	// }
}

fn test_if_opt() {
	if val := err_call(false) {
		assert val == 42
	}
	assert 1 == 1
}

fn test_if_else_opt() {
	if val := err_call(true) {
		assert val == 42
	} else {
		assert false
	}
	if _ := err_call(false) {
		assert false
	} else {
		assert true
	}
}

fn for_opt_default() ?string {
	return error('awww')
}

fn test_opt_default() {
	a := for_opt_default() or {
		// panic(err)
		'default'
	}
	assert a == 'default'
}

fn foo_ok() ?int {
	return 777
}

fn foo_str() ?string {
	return 'something'
}

fn propagate_optional(b bool) ?int {
	a := err_call(b)?
	return a
}

fn propagate_different_type(b bool) ?bool {
	err_call(b)?
	return true
}

fn test_propagation() {
	a := propagate_optional(true) or {
		0
	}
	assert a == 42
	if _ := propagate_optional(false) {
		assert false
	}
	b := propagate_different_type(true) or {
		false
	}
	assert b == true
	if _ := propagate_different_type(false) {
		assert false
	}
}

fn test_q() {
	// assert foo_ok()? == true
}

fn or_return_val() int {
	a := ret_none() or {
		return 1
	}
	return a
}

fn or_return_error() ?int {
	a := ret_none() or {
		return error('Nope')
	}
	return a
}

fn or_return_none() ?int {
	a := ret_none() or {
		return none
	}
	return a
}

fn test_or_return() {
	assert or_return_val() == 1
	if _ := or_return_error() {
		assert false
	} else {
		assert true
	}
	if _ := or_return_none() {
		assert false
	} else {
		assert true
	}
}

fn test_reassignment() {
	mut x2 := foo_ok() or {
		assert false
		return
	}
	assert x2 == 777
	x2 = 100
	assert x2 == 100
	x2 += 1
	assert x2 == 101
	//
	mut x3 := 0
	x3 = foo_ok() or {
		assert false
		return
	}
	assert x3 == 777
}

struct Person {
mut:
	name  string
	age   int
	title ?string
}

fn test_field_or() {
	name := foo_str() or {
		'nada'
	}
	assert name == 'something'
	/*
	QTODO
	mut p := Person{}
	p.name = foo_str() or {
		'nothing'
	}
	assert p.name == 'something'
	p.age = foo_ok() or {
		panic('no age')
	}
	assert p.age == 777
	mytitle := p.title or {
		'default'
	}
	assert mytitle == 'default'
	*/
}

struct Thing {
mut:
	opt ?int
}

fn test_opt_field() {
	/*
	QTODO
	mut t := Thing{}
	t.opt = 5
	val := t.opt or { return }
	assert val == 5
	*/
}

fn opt_ptr(a &int) ?&int {
	if isnil(a) {
		return none
	}
	return a
}

fn test_opt_ptr() {
	if true {
	}
	//
	else {
	}
	a := 3
	mut r := opt_ptr(&a) or {
		&int(0)
	}
	assert r == &a
	r = opt_ptr(&int(0)) or {
		return
	}
	assert false
}

/*
// QTODO
fn multi_return_opt(err bool) (string, string) {
	if err {
		return error('oops')
	}
	return 'hello', 'v'
}

fn test_multi_return_opt() {
	a, b := multi_return_opt(false) or {
		panic(err)
	}
	assert a == 'hello' && b == 'v'
	_, _ := multi_return_opt(true) or {
		assert err == 'oops'
		return
	}
}
*/
fn foo() ?void {
	return error('something')
}

fn test_optional_void() {
	foo() or {
		println(err)
		assert err == 'something'
		return
	}
}

fn bar() ? {
	return error('bar error')
}

fn test_optional_void_only_question() {
	bar() or {
		println(err)
		assert err == 'bar error'
		return
	}
}

fn test_optional_void_with_empty_or() {
	foo() or {}
	assert true
}

fn test_optional_val_with_empty_or() {
	ret_none() or {}
	assert true
}
struct A {
	foo int
}

fn test_pointer_to_string() {
	a := A{}
	assert a.foo.str() != (&a.foo).str()
}
fn test_pointer_arithmetic() {
	arr := [1, 2, 3, 4]
	unsafe {
		mut parr := &int(arr.data)
		assert 1 == *parr
		parr++
		assert 2 == *parr
		parr++
		assert 3 == *parr
		assert *(parr + 1) == 4
	}
}

/*
fn test_multi_level_pointer_dereferencing() {
	n := 100
	pn := &n
	ppn := &pn
	unsafe {
		mut pppn := &ppn
		***pppn = 300
		pppa := ***int(pppn)
		assert 300 == ***pppa
	}
	assert n == 300	// updated by the unsafe pointer manipulation
}
*/fn test_print() {
	println(2.0)
}
// Build and run files in ./prod/ folder, comparing their output to *.expected.txt files.
// (Similar to REPL tests, but in -prod mode.)
import v.tests.repl.runner
import benchmark

fn test_all_v_prod_files() {
	// TODO: Fix running this test on Windows:
	$if !windows {
		options := runner.new_prod_options()
		mut bmark := benchmark.new_benchmark()
		for file in options.files {
			// println('file:$file')
			bmark.step()
			fres := runner.run_prod_file(options.wd, options.vexec, file) or {
				bmark.fail()
				eprintln(bmark.step_message_fail(err))
				assert false
				continue
			}
			bmark.ok()
			println(bmark.step_message_ok(fres))
			assert true
		}
		bmark.stop()
		println(bmark.total_message('total time spent running PROD files'))
	}
}
// verify fix for #2913
fn some_multiret_fn(a, b int) (int, int) {
	return a + 1, b + 1
}

fn test_repeated_multiple_multiret() {
	a, b := some_multiret_fn(1, 2)
	assert a == 2
	assert b == 3
	c, d := some_multiret_fn(3, 4)
	assert c == 4
	assert d == 5
}

struct Zest { val int }
    
fn (t Zest) get_a_finger_to_the_moon() voidptr {
	return voidptr(0)
}

fn get_the_dao_way() voidptr {
	return voidptr(0)
}
        
fn test_returning_a_void_pointer_from_a_method() {
	t := &Zest{ val: 123 }	
	z := voidptr(0)
	assert z == t.get_a_finger_to_the_moon()
	assert t.get_a_finger_to_the_moon() == 0
}

fn test_returning_a_void_pointer_from_a_function() {
	z := voidptr(0)
	assert z == get_the_dao_way()
	assert get_the_dao_way() == 0
}
// verify fix for #2913
fn some_multiret_fn(a, b int) (int, int) {
	return a + 1, b + 1
}

fn test_reuse_multiple_multiret() {
	mut c, mut d := some_multiret_fn(4, 10)
	mut a, mut b := some_multiret_fn(c, d)
	assert a == c + 1
	assert b == d + 1
	for i in 1 .. 10 {
		c += i
		d += i
		a, b = some_multiret_fn(c, d)
		assert a == c + 1
		assert b == d + 1
		c += i + 1
		d += i + 1
		a, b = some_multiret_fn(c, d)
		assert a == c + 1
		assert b == d + 1
	}
}
fn test_shift_operators() {
	// check that shift works with all integer types
	// as the right-hand side operand
	a := 1
	b := 1024
	i := 10
	assert b == a << i8(i)
	assert b == a << byte(i)
	assert b == a << i16(i)
	assert b == a << u16(i)
	assert b == a << int(i)
	assert b == a << u32(i)
	assert b == a << i64(i)
	assert b == a << u64(i)
	assert a == b >> i8(i)
	assert a == b >> byte(i)
	assert a == b >> i16(i)
	assert a == b >> u16(i)
	assert a == b >> int(i)
	assert a == b >> u32(i)
	assert a == b >> i64(i)
	assert a == b >> u64(i)
	// check that shift operation result type is
	// the same as the type of the left-hand side operand
	mut c := u64(0)
	d := u64(1)
	c = d << i8(63)
	assert c == 9223372036854775808
	// check that shift-assign works with all types
	// of integers on the right-hand side
	mut e := 1
	e <<= i8(i)
	assert e == b
	e >>= i8(i)
	assert e == a
	e <<= i16(i)
	assert e == b
	e >>= i16(i)
	assert e == a
	e <<= int(i)
	assert e == b
	e >>= int(i)
	assert e == a
	mut e2 := i64(1)
	e2 <<= i64(i)
	assert e2 == b
	e2 >>= i64(i)
	assert e2 == a
	e <<= byte(i)
	assert e == b
	e >>= byte(i)
	assert e == a
	e <<= u16(i)
	assert e == b
	e >>= u16(i)
	assert e == a
	mut e3 := u64(1)
	e3 <<= u32(i)
	assert e3 == b
	e3 >>= u32(i)
	assert e == a
	e3 <<= u64(i)
	assert e3 == b
	e3 >>= u64(i)
	assert e3 == a
}
struct TOptions {
	a int
}

fn t(options TOptions) bool {
	if options.a == 1 {
		return true
	}
	return false
}

fn test_short_struct_as_parameter() {
	if t({
		a: 1
	}) {
		assert true
		return
	}
	assert false
}
const (
	sbuffer_size = 10
)

fn test_hardcoded_static_arr() {
	myints := [10]int
	size := sizeof(myints)
	assert size == 40
}

fn test_const_based_static_arr() {
	myints := [sbuffer_size]int
	size := sizeof(myints)
	assert size == 40
}

fn test_const_based_static_arr_of_f64() {
	myf64 := [sbuffer_size]f64
	size := sizeof(myf64)
	assert size == 80
}

fn test_const_based_static_arr_of_f32() {
	myf32 := [sbuffer_size]f32
	size := sizeof(myf32)
	assert size == 40
}

fn test_const_based_static_arr_of_i8() {
	myi8 := [sbuffer_size]i8
	size := sizeof(myi8)
	assert size == 10
}

fn test_const_based_static_arr_of_i16() {
	myi16 := [sbuffer_size]i16
	size := sizeof(myi16)
	assert size == 20
}
// This file tests whether v can generate default string methods for both:
// a) an array of custom structs,
// b) also for the custom struct itself (when the .str() for it is missing).
//
// NB: this is very simillar to string_interpolation_struct_test.v
// but they should NOT be merged into 1 file.  If you merge it with
// string_interpolation_struct_test.v, which tests whether the compiler
// can generate the default method for a struct, then the b) case of
// this test will be done by *that* test, and so the testing will
// be incomplete.
struct Man {
	name      string
	age       int
	interests []string
}

fn test_array_of_structs_interpolation() {
	people := [
		Man{'Superman', 30, ['flying','fighting evil','being nice']},
		Man{'Bilbo Baggins', 111, ['exploring', 'hiding']},
	]
	s := '$people' // the compiler should generate code for both a) and b)
	assert s.contains('Man {')
	assert s.contains("name: 'Superman'")
	assert s.contains('age: 30')
	assert s.contains("'being nice'")
	assert s.contains('}, Man {')
	assert s.contains("name: 'Bilbo Baggins'")
	assert s.contains('age: 111')
	assert s.contains("interests: ['exploring', 'hiding']")
	assert s.contains('}]')
	// println(s)
}

fn test_array_of_floats_interpolation() {
	// f64 array
	aa := [1.2, 3.4, 5.67]
	assert '$aa' == '[1.2, 3.4, 5.67]'
	// f32 array
	bb := [f32(1.2), 3.4, 5.67]
	assert '$bb' == '[1.2, 3.4, 5.67]'
}

fn test_array_of_bools_interpolation() {
	aa := [true, false, true]
	assert '$aa' == '[true, false, true]'
}

fn test_array_of_ints_interpolation() {
	// int
	a1 := [11, 22, 33]
	assert '$a1' == '[11, 22, 33]'
	// u32
	a2 := [u32(11), 22, 33]
	assert '$a2' == '[11, 22, 33]'
	// i16
	b1 := [i16(11), 22, 33]
	assert '$b1' == '[11, 22, 33]'
	// u16
	b2 := [u16(11), 22, 33]
	assert '$b2' == '[11, 22, 33]'
	// i64
	c1 := [i64(11), 22, 33]
	assert '$c1' == '[11, 22, 33]'
	// u64
	c2 := [u64(11), 22, 33]
	assert '$c2' == '[11, 22, 33]'
}

fn test_array_of_bytes_interpolation() {
	aa := [`a`, `b`, `c`]
	assert '$aa' == '[a, b, c]'
}

fn test_array_of_strings_interpolation() {
	aa := ['aa', 'bb', 'cc']
	assert '$aa' == "['aa', 'bb', 'cc']"
}

fn test_array_of_map_interpolation() {
	mut a := []map[string]int{}
	a << {'a': int(1), 'b': 2}
	a << {'c': int(3), 'd': 4}
	assert '$a' == "[{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]"
}
module main

struct Anything {
mut:
	name string = ""
	keepo int = 0
}

fn (a Anything) str() string {
	return a.name
}

fn test_array_of_ptrs_to_structs_can_be_printed() {
	mut testing := []&Anything{}
	testing << &Anything{name: "Hehe"}
	testing << &Anything{name: "other"}
	testing << &Anything{name: "test"}
	for test in testing {
		println(test)
		assert true
	}
	println('testing: $testing')
	println( testing )
	assert true
}

// At the same time, this should also work:
// (note the str method defined on (a &T), instead on (a T))

struct PstrAnything {
mut:
	name string = ""
	keepo int = 0
}
fn (a &PstrAnything) str() string {
	return a.name
}

fn test_array_of_ptrs_to_structs_can_be_printed_when_structs_have_str_with_ptr() {
	mut testing := []&PstrAnything{}
	testing << &PstrAnything{name: "abc"}
	testing << &PstrAnything{name: "def"}
	testing << &PstrAnything{name: "ghi"}
	for test in testing {
		println(test)
		assert true
	}
	println('testing: $testing')
	println( testing )
	assert true
}

//

fn test_stack_array_of_structs_can_be_printed_when_structs_have_ordinary_str() {
	mut t := [3]Anything
	t[0] = Anything{name: "012"}
	t[1] = Anything{name: "345"}
	t[2] = Anything{name: "678"}
	for test in t {
		println(test)
		assert true
	}
	println('t: $t')
	println( t )
	println( 't[0] := ${t[0]}')
	assert true
}

fn test_stack_array_of_structs_can_be_printed_when_structs_have_str_with_ptr() {
	// this generates a C error
	mut pt := [3]PstrAnything
	pt[0] = PstrAnything{name: "P012"}
	pt[1] = PstrAnything{name: "P345"}
	pt[2] = PstrAnything{name: "P678"}
	for test in pt {
		println(test)
		assert true
	}
	println('pt: $pt')
	println( pt )
	print( 'pt[0] := ')
	print( pt[0] )
	println('')
	assert true

	$if debug_buggy_println ? {
		//TODO: fix string interpolation for structs with `fn (t &T) str() string` too:
		println( 'pt[0] := ${pt[0]}')
	}
}
// This file tests whether V can generate a convenience default .str() method
// for a custom struct, when the developer has not defined one himself.
// The .str() methods are used for string interpolation and for println() calls.
struct Man {
	name      string
	age       int
	interests []string
}

fn test_default_struct_string_interpolation() {
	superman := Man{'Superman', 30, ['flying', 'fighting evil', 'being nice']}
	s := '$superman'
	assert s.starts_with('Man {')
	assert s.contains("name: 'Superman'")
	assert s.contains('age: 30')
	assert s.contains('interests: [')
	assert s.contains("'being nice'")
	assert s.ends_with('}')
	// println(s)
}

struct Context {
pub mut:
	vb [8]f64
}

fn test_fixed_array_struct_string_interpolation() {
	mut ctx := Context{}
	x := 2.32
	ctx.vb = [1.1, x, 3.3, 4.4, 5.0, 6.0, 7.0, 8.9]!!
	s := '$ctx'
	assert s.starts_with('Context {')
	assert s.contains('vb: [1.1, 2.32, 3.3, 4.4, 5, 6, 7, 8.9]')
	assert s.ends_with('}')
}

struct Info {
	name string
	dict map[string]int
}

fn test_struct_map_field_string_interpolation() {
	info := Info{
		name: 'test'
		dict: {'a': int(1), 'b': 2}
	}
	s := '$info'
	assert s.starts_with('Info {')
	assert s.contains("name: 'test'")
	assert s.contains("dict: {'a': 1, 'b': 2}")
	assert s.ends_with('}')
}
fn test_simple_string_interpolation() {
	a := 'Hello'
	b := 'World'
	res := '$a $b'
	assert res == 'Hello World'
}

fn test_mixed_string_interpolation() {
	num := 7
	str := 'abc'
	s1 := 'number=$num'
	assert s1 == 'number=7'
	s2 := 'string=$str'
	assert s2 == 'string=abc'
	s3 := 'a: $num | b: $str'
	assert s3 == 'a: 7 | b: abc'
}

fn test_formatted_string_interpolation() {
	x := 'abc'
	axb := 'a:$x:b'
	assert axb == 'a:abc:b'
	x_10 := 'a:${x:10s}:b'
	x10_ := 'a:${x:-10s}:b'
	assert x_10 == 'a:       abc:b'
	assert x10_ == 'a:abc       :b'
	i := 23
	si_right := '${i:10d}'
	si__left := '${i:-10d}'
	assert si_right == '        23'
	assert si__left == '23        '
}

fn test_excape_dollar_in_string() {
	i := 42
	assert '($i)' == '(42)'
	assert '(\$i)'.contains('i') && !'(\$i)'.contains('42')
	assert !'(\\$i)'.contains('i') && '(\\$i)'.contains('42') && '(\\$i)'.contains('\\')
	assert '(\\\$i)'.contains('i') && !'(\\\$i)'.contains('42') && '(\\$i)'.contains('\\')
	assert !'(\\\\$i)'.contains('i') && '(\\\\$i)'.contains('42') && '(\\\\$i)'.contains('\\\\')
	assert '(${i})' == '(42)'
	assert '(\${i})'.contains('i') && !'(\${i})'.contains('42')
	assert !'(\\${i})'.contains('i') && '(\\${i})'.contains('42') && '(\\${i})'.contains('\\')
	assert '(\\\${i})'.contains('i') && !'(\\\${i})'.contains('42') && '(\\${i})'.contains('\\')
	assert !'(\\\\${i})'.contains('i') && '(\\\\${i})'.contains('42') && '(\\\\${i})'.contains('\\\\')
	assert i == 42
}

fn test_implicit_str() {
	i := 42
	assert 'int $i' == 'int 42'
	assert '$i' == '42'
	check := '$i' == '42'
	assert check
	text := '$i' + '42'
	assert text == '4242'
}

fn test_string_interpolation_percent_escaping() {
	test := 'hello'
	hello := 'world'
	x := '%.*s$hello$test |${hello:-30s}|'
	assert x == '%.*sworldhello |world                         |'
}

fn test_string_interpolation_string_prefix() {
	// `r`, `c` and `js` are also used as a string prefix.
	r := 'r'
	rr := '$r$r'
	assert rr == 'rr'
	c := 'c'
	cc := '$c$c'
	assert cc == 'cc'
	js := 'js'
	jsjs := '$js$js'
	assert jsjs == 'jsjs'
}

fn test_inttypes_string_interpolation() {
	c := i8(-103)
	uc := byte(217)
	uc2 := byte(13)
	s := i16(-23456)
	us := u16(54321)
	i := -1622999040
	ui := u32(3421958087)
	vp := voidptr(ui)
	bp := byteptr(15541149836)
	l := i64(-7694555558525237396)
	ul := u64(17234006112912956370)
	assert '$s $us' == '-23456 54321'
	assert '$ui $i' == '3421958087 -1622999040'
	assert '$l $ul' == '-7694555558525237396 17234006112912956370'
	assert '>${s:11}:${us:-13}<' == '>     -23456:54321        <'
	assert '0x${ul:-19x}:${l:22d}' == '0xef2b7d4001165bd2   :  -7694555558525237396'
	assert '${c:5}${uc:-7}x' == ' -103217    x'
	assert '${c:x}:${uc:x}:${uc2:02X}' == '99:d9:0D'
	assert '${s:X}:${us:x}:${u16(uc):04x}' == 'A460:d431:00d9'
	assert '${i:x}:${ui:X}:${int(s):x}' == '9f430000:CBF6EFC7:ffffa460'
	assert '${l:x}:${ul:X}' == '9537727cad98876c:EF2B7D4001165BD2'
	// default pointer format is platform dependent, so try a few
	eprintln("platform pointer format: '${vp:p}:$bp'")
	assert '${vp:p}:$bp' == '0xcbf6efc7:0x39e53208c' ||
		'${vp:p}:$bp' == 'CBF6EFC7:39E53208C' ||
		'${vp:p}:$bp' == 'cbf6efc7:39e53208c' ||
		'${vp:p}:$bp' == '00000000CBF6EFC7:000000039E53208C'
}

fn test_utf8_string_interpolation() {
	a := '-ct'
	st := 'Strle'
	m := '10'
	assert '$a $st $m' == '-ct Strle 10'
	zz := '>${a:10}< >${st:-8}< >${m:5}<-'
	zz_expected := '>    -ct< >Strle < >  10<-'
	eprintln('         zz: $zz')
	eprintln('zz_expected: $zz_expected')
	assert zz == zz_expected
	// e := '\u20AC' // Eurosign doesn' work with MSVC and tcc
	e := ''
	assert '100.00 $e' == '100.00 '
	m2 := '' // cyrillic : combination of U+0430 and U+0301, UTF-8: d0 b0 cc 81
	d := 'Antonn Dvok' // latin : U+00E1, UTF-8: c3 a1
	assert ':${m2:7}:${d:-15}:' == ': :Antonn Dvok :'
	g := ''
	assert '>${g:-13}<' == '> <'
}

struct S {
	v1 int
	v2 f64
}

fn (s S) str() string {
	return '[${s.v1}, ${s.v2:.3f}]'
}

fn test_string_interpolation_str_evaluation() {
	mut x := S{17, 13.455893}
	assert '$x' == '[17, 13.456]'
}


fn test_string_interpolation_with_negative_format_width_should_compile_and_run_without_segfaulting() {
	// discovered during debugging VLS
	i := 3
	input := '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}'
	eprintln('---------------------------------------------------------------------------------------------')
	eprintln('+60 ${i:10} | input.len: ${input.len:10} | ${input.bytes().hex():60} | $input')
	eprintln('-60 ${i:10} | input.len: ${input.len:10} | ${input.bytes().hex():-60} | $input')
	eprintln('---------------------------------------------------------------------------------------------')
	assert true
}
// This file tests whether V can generate a convenience default .str() method
// for var args of a custom type, when the developer has NOT defined one.
// Although similar to string_interpolation_struct_test.v, they should not be
// merged.
struct Man {
	name      string
	age       int
	interests []string
}

fn my_variadic_function(x ...Man) string {
	return '$x'	// this interpolation should generate .str() methods for Man
}

fn test_vargs_string_interpolation() {
	man := Man{'Me', 38, ['programming', 'reading', 'hiking']}
	superman := Man{'Superman', 30, ['flying', 'fighting evil', 'being nice']}
	results := my_variadic_function(superman, man)
	assert results.contains('Man {')
	//
	assert results.contains("name: 'Superman'")
	assert results.contains('age: 30')
	assert results.contains('}, Man {')
	//
	assert results.contains("interests: ['programming'")
	assert results.contains("name: 'Me'")
	//
	assert results.contains('}]')
	//
	println(results)
}
struct Foo {
	bar int
mut:
	str string
}

fn (f Foo) baz() string {
	return 'baz'
}

fn test_string_method_interpolation() {
	foo := Foo{}
	s := 'baz=${foo.baz()}'
	assert s == 'baz=baz'
}

fn test_adding_to_mutable_string_field() {
	mut foo := Foo{10, 'hi'}
	assert foo.bar == 10
	assert foo.str == 'hi'
	foo.str += '!'
	eprintln(foo.str)
	assert foo.str == 'hi!'
}

struct Axx { mut: v int }
struct Bxx {      a Axx }
struct Cxx { mut: b Bxx }
struct Dxx { mut: c Cxx }
struct Exx { mut: v []int }
struct Fxx { e []Exx }

fn test_chained_string() {
	mut b := Bxx{} b = Bxx{Axx{2}}
	assert 'b is: ' + b.a.v.str() == 'b is: 2'
}

fn test_chained_assignments() {
	mut c := Cxx{}
	c.b = Bxx{}
	mut d := Dxx{}
	d.c.b = Bxx{}
	assert true
}

fn test_chained_array_access() {
	f := Fxx{[Exx{[10, 20, 30]}, Exx{[100, 200, 300, 400]}]}
	assert 'f.e[0].v.len: 3' == 'f.e[0].v.len: ${f.e[0].v.len}'
	assert 'f.e[1].v.len: 4' == 'f.e[1].v.len: ${f.e[1].v.len}'
}
struct Aa {
mut:
	val  int
	nums []int
}

struct Bb {
mut:
	a Aa
}

struct Cu {
mut:
	b    Bb
	nums []int
	aarr []Aa
	num  int
}

struct Lol {
	b    []string [json:lol]
	c    string   [json:cc]
	d    int
}

struct User {
	name string
	age  int
}

struct Foo {
	typ string
}

struct Empty {
}

// We need to make sure that this compiles with all the reserved names.
struct ReservedKeywords {
	delete   int
	exit     int
	unix     int
	error    int
	malloc   int
	calloc   int
	free     int
	panic    int
	auto     int
	char     int
	do       int
	double   int
	extern   int
	float    int
	inline   int
	long     int
	register int
	restrict int
	short    int
	signed   int
	typedef  int
	unsigned int
	void     int
	volatile int
	while    int
}

fn test_empty_struct() {
	d := &Empty{}
	d2 := Empty{}
	println('&empty:')
	println(d)	// != voidptr(0)
	println('empty:')
	println(d2)	// empty struct print
	println(sizeof(Empty))	// == 0
}

fn test_struct_levels() {
	mut c := Cu{}
	println(c.nums.len)
	assert c.nums.len == 0
	c.nums << 3
	assert c.nums.len == 1
	assert c.nums[0] == 3
	c.nums[0] = 4
	assert c.nums[0] == 4
	c.b.a.val = 34
	assert c.b.a.val == 34
	c.b.a.nums = [0].repeat(0)
	c.b.a.nums << 0
	c.b.a.nums << 2
	assert c.b.a.nums.len == 2
	assert c.b.a.nums[0] == 0
	assert c.b.a.nums[1] == 2
	c.b.a.nums[0] = 7
	assert c.b.a.nums[0] == 7
	c.aarr << Aa{
		val: 8
	}
	assert c.aarr.len == 1
	assert c.aarr[0].val == 8
	c.num = 20
	assert c.num == 20
	c.aarr[0].val = 10
	assert c.aarr[0].val == 10
}

fn test_struct_str() {
	u := User{'Bob', 30}
	println(u)	// make sure the struct is printable
	// assert u.str() == '{name:"Bob", age:30}'  // QTODO
}

fn test_at() {
	foo := Foo{
		typ: 'test'
	}
	// type: 'test'
	println(foo.typ)
}

fn test_reserved_keywords() {
	// Make sure we can initialize them correctly using full syntax.
	rk_holder := ReservedKeywords{0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3}
	// Test a few as it'll take too long to test all. If it's initialized
	// correctly, other fields are also probably valid.
	assert rk_holder.unix == 5
	assert rk_holder.while == 3
	rk_holder2 := ReservedKeywords{
		inline: 9
		volatile: 11
	}
	// Make sure partial initialization works too.
	assert rk_holder2.inline == 9
	assert rk_holder2.volatile == 11
	assert rk_holder2.while == 0	// Zero value as not specified.
}

struct User2 {
mut:
	name string
}

fn test_mutable_fields() {
	mut u := User2{}
	u.name = 'Peter'
	assert u.name == 'Peter'
}

struct Def {
	a int
	b int = 7
}

fn test_default_vals() {
	d := Def{}
	assert d.a == 0
	assert d.b == 7
	d2 := Def{10, 20}
	assert d2.a == 10
	assert d2.b == 20
}

fn test_assoc_with_vars() {
	def2 := Def{
		a: 12
	}
	merged := {
		def2 |
		a: 42
	}
	assert merged.a == 42
	assert merged.b == 7
}

const (
	const_def = Def{
		a: 100
	}
)

fn test_assoc_with_constants() {
	println(1)
	/*
	QTODO
	merged := { const_def | a: 42 }
	assert merged.a == 42
	assert merged.b == 7

	again := { const_def | b: 22 }
	assert again.a == 100
	assert again.b == 22
*/
}

struct AttrTest {
	a int // private immutable (default)
mut:
	b int // private mutable
	c int // (you can list multiple fields with the same access modifier)
pub:
	d int // public immmutable (readonly)
pub mut:
	e int // public, but mutable only in parent module
	f int // public and mutable both inside and outside parent module
}

fn fooo() {
	a := AttrTest{1, 2, 3, 4, 5, 6}
}

/*
[typedef]
struct C.fixed {
	points [10]C.point
}

[typedef]
struct C.point {
	x int
	y int
}

fn test_fixed_field() {
	f := &C.fixed{}
	p := f.points[0]
	//f.nums[0] = 10
	//println(f.nums[0])
	println(p.x)
		//nums: [10]int
	//}
}
*/
struct Config {
	n   int
	def int = 10
}

fn foo_config(c Config) {
}

fn foo2(u User) {
}

fn test_config() {
	foo_config({
		n: 10
		def: 20
	})
	foo_config({})
	foo2({
		name: 'Peter'
	})
	foo2(name: 'Peter')
}

struct City {
	name       string
	population int
}

struct Country {
	name    string
	capital City
}

fn test_levels() {
	c := Country{
		name: 'UK'
		capital: {
			name: 'London'
			population: 10
		}
	}
}

// Struct where an inizialized field is after a non-initilized field.
struct StructWithDefaultValues1 {
	field_required int
	field_optional int = 5
}

// Struct where an inizialized field is before a non-initilized field.
struct StructWithDefaultValues2 {
	field_optional  int = 3
	field_required  int
}

// Struct where an inizialized field is before several non-initilized fields.
struct StructWithDefaultValues3 {
	field_optional     int = 2
	field_required     int
	field_required_too int
}

fn test_struct_with_default_values_init() {
	s1 := StructWithDefaultValues1{ field_required: 5 }
	s2 := StructWithDefaultValues2{ field_required: 5 }
	// Partially initialized
	s3 := StructWithDefaultValues3{ field_required: 5 }

	assert s1.field_optional == 5
	assert s2.field_optional == 3
	assert s3.field_optional == 2
}

fn test_struct_with_default_values_no_init() {
	// Don't inititialize
	s1 := StructWithDefaultValues1{}
	s2 := StructWithDefaultValues2{}
	s3 := StructWithDefaultValues3{}

	assert s1.field_optional == 5
	assert s2.field_optional == 3
	assert s3.field_optional == 2
}
fn test_array_of_floats() {
	// f64 array
	aa := [1.2, 3.4, 5.67]
	assert aa.str() == '[1.2, 3.4, 5.67]'
	assert '$aa' == '[1.2, 3.4, 5.67]'
	// f32 array
	bb := [f32(1.2), 3.4, 5.67]
	assert bb.str() == '[1.2, 3.4, 5.67]'
	assert '$bb' == '[1.2, 3.4, 5.67]'
}

fn test_array_of_bools() {
	aa := [true, false, true]
	assert aa.str() == '[true, false, true]'
	assert '$aa' == '[true, false, true]'
}

fn test_array_of_ints() {
	// int
	a1 := [11, 22, 33]
	assert a1.str() == '[11, 22, 33]'
	assert '$a1' == '[11, 22, 33]'
	// u32
	a2 := [u32(11), 22, 33]
	assert a2.str() == '[11, 22, 33]'
	assert '$a2' == '[11, 22, 33]'
	// i16
	b1 := [i16(11), 22, 33]
	assert b1.str() == '[11, 22, 33]'
	assert '$b1' == '[11, 22, 33]'
	// u16
	b2 := [u16(11), 22, 33]
	assert b2.str() == '[11, 22, 33]'
	assert '$b2' == '[11, 22, 33]'
	// i64
	c1 := [i64(11), 22, 33]
	assert c1.str() == '[11, 22, 33]'
	assert '$c1' == '[11, 22, 33]'
	// u64
	c2 := [u64(11), 22, 33]
	assert c2.str() == '[11, 22, 33]'
	assert '$c2' == '[11, 22, 33]'
}

fn test_array_of_bytes() {
	aa := [`a`, `b`, `c`]
	assert aa.str() == '[a, b, c]'
	assert '$aa' == '[a, b, c]'
}

fn test_array_of_strings() {
	aa := ['aa', 'bb', 'cc']
	assert aa.str() == "['aa', 'bb', 'cc']"
	assert '$aa' == "['aa', 'bb', 'cc']"
}

fn test_map_of_ints() {
	aa := {'a': 1, 'b': 2, 'c': 3}
	assert aa.str() == "{'a': 1, 'b': 2, 'c': 3}"
	assert '$aa' == "{'a': 1, 'b': 2, 'c': 3}"
}

fn test_map_of_strings() {
	aa := {'a': '1', 'b': '2', 'c': '3'}
	assert aa.str() == "{'a': '1', 'b': '2', 'c': '3'}"
	assert '$aa' == "{'a': '1', 'b': '2', 'c': '3'}"
}

fn test_map_of_floats() {
	aa := {'a': 1.1, 'b': 2.2, 'c': 3.3}
	assert aa.str() == "{'a': 1.1, 'b': 2.2, 'c': 3.3}"
	assert '$aa' == "{'a': 1.1, 'b': 2.2, 'c': 3.3}"
}

fn test_map_of_bytes() {
	aa := {'a': `a`, 'b': `b`, 'c': `c`}
	assert aa.str() == "{'a': a, 'b': b, 'c': c}"
	assert '$aa' == "{'a': a, 'b': b, 'c': c}"
}

fn test_map_of_bools() {
	aa := {'a': true, 'b': false, 'c': true}
	assert aa.str() == "{'a': true, 'b': false, 'c': true}"
	assert '$aa' == "{'a': true, 'b': false, 'c': true}"
}

fn test_fixed_array_of_floats() {
	// f64 array
	aa := [1.2, 3.4, 5.67]!!
	assert aa.str() == '[1.2, 3.4, 5.67]'
	assert '$aa' == '[1.2, 3.4, 5.67]'
	// f32 array
	bb := [f32(1.2), 3.4, 5.67]!!
	assert bb.str() == '[1.2, 3.4, 5.67]'
	assert '$bb' == '[1.2, 3.4, 5.67]'
}

fn test_fixed_array_of_bools() {
	aa := [true, false, true]!!
	assert aa.str() == '[true, false, true]'
	assert '$aa' == '[true, false, true]'
}

fn test_fixed_array_of_ints() {
	// int
	a1 := [11, 22, 33]!!
	assert a1.str() == '[11, 22, 33]'
	assert '$a1' == '[11, 22, 33]'
	// u32
	a2 := [u32(11), 22, 33]!!
	assert a2.str() == '[11, 22, 33]'
	assert '$a2' == '[11, 22, 33]'
	// i16
	b1 := [i16(11), 22, 33]!!
	assert b1.str() == '[11, 22, 33]'
	assert '$b1' == '[11, 22, 33]'
	// u16
	b2 := [u16(11), 22, 33]!!
	assert b2.str() == '[11, 22, 33]'
	assert '$b2' == '[11, 22, 33]'
	// i64
	c1 := [i64(11), 22, 33]!!
	assert c1.str() == '[11, 22, 33]'
	assert '$c1' == '[11, 22, 33]'
	// u64
	c2 := [u64(11), 22, 33]!!
	assert c2.str() == '[11, 22, 33]'
	assert '$c2' == '[11, 22, 33]'
}

fn test_fixed_array_of_bytes() {
	aa := [`a`, `b`, `c`]!!
	assert aa.str() == '[a, b, c]'
	assert '$aa' == '[a, b, c]'
}

fn test_fixed_array_of_strings() {
	aa := ['aa', 'bb', 'cc']!!
	assert aa.str() == "['aa', 'bb', 'cc']"
	assert '$aa' == "['aa', 'bb', 'cc']"
}
struct Foo {
}

type Expr = BinExpr | BoolExpr | DeclExprA | DeclExprB | Foo | UnaryExpr

type DeclExpr = DeclExprA | DeclExprB

struct BoolExpr {
	foo int
}

struct BinExpr {
	name string
}

struct DeclExprA {
	name string
}

struct DeclExprB {
	name string
}

fn expr1() Expr {
	mut e := Expr{}
	e = BinExpr{
		name: 'binexpr'
	}
	return e
	// return BinExpr{}
}

fn expr() Expr {
	return BinExpr{}
}

struct UnaryExpr {
}

fn handle_expr(e Expr) {
}

fn handle_decl_expr(de DeclExpr) {
}

fn parse_bool() BoolExpr {
	return BoolExpr{}
}

fn test_sum_type_cast() {
	a := expr1()
	b := a as BinExpr
	assert b.name == 'binexpr'
}

fn test_sum_types() {
	b := parse_bool()
	handle_expr(b)
	de := DeclExprA{}
	handle_expr(de)
	handle_decl_expr(de)
}

/*
#define ExprType_BoolExpr 0
#define ExprType_BinExpr 1
#define ExprType_UnaryExpr 2

struct Expr {
	int   typ;
	void* obj;
}
*/
type Expr = IfExpr | IntegerLiteral

struct IfExpr {
	pos int
}

struct IntegerLiteral {
	val string
}

fn handle(e Expr) string {
	assert e is IntegerLiteral
	if e is IntegerLiteral {
		println('int')
	}
	match e {
		IntegerLiteral {
			assert it.val == '12'
			// assert e.val == '12' // TODO
			return 'int'
		}
		IfExpr {
			return 'if'
		}
	}
	return ''
}

fn test_expr() {
	expr := IntegerLiteral{
		val: '12'
	}
	assert handle(expr) == 'int'
	// assert expr is IntegerLiteral // TODO
}

fn test_assignment_and_push() {
	mut expr1 := Expr{}
	mut arr1 := []Expr{}
	expr := IntegerLiteral{
        val: '111'
    }
	arr1 << expr
	match arr1[0] {
		IntegerLiteral {
			arr1 << it
			// should ref/dereference on assignent be made automatic?
			// currently it is done for return stmt and fn args
			expr1 = *it
		}
		else {}
	}
}

// Test moving structs between master/sub arrays

type Master = Sub1 | Sub2
struct Sub1 {
mut:
	val int
	name string
}
struct Sub2 {
	name string
	val int
}

fn test_converting_down() {
	mut out := []Master{}
	out << Sub1 { val: 1, name: 'one' }
	out << Sub2 { val: 2, name: 'two'}
	out << Sub2 { val: 3, name: 'three'}

	mut res := []Sub2{cap: out.len}
	for d in out {
		match d {
			Sub2 { res << it }
			else {}
		}
	}

	assert res[0].val == 2
	assert res[0].name == 'two'
	assert res[1].val == 3
	assert res[1].name == 'three'
}

struct Abc {
	x int
}

struct Xyz {
	y int
}

struct XxYyZz {
	y int
}

type MySumType = Abc | Xyz

type AnotherSumType = XxYyZz | int

type SuperSumType = MySumType | AnotherSumType | string

fn test_typeof_for_builtin_int_types() {
	assert typeof(i8(1)) == 'i8'
	assert typeof(i16(1)) == 'i16'
	assert typeof(int(1)) == 'int'
	// assert typeof(1) == 'any_int'
	assert typeof(i64(1)) == 'i64'
	assert typeof(byte(1)) == 'byte'
	assert typeof(u16(1)) == 'u16'
	assert typeof(u32(1)) == 'u32'
	assert typeof(u64(1)) == 'u64'
}

fn test_typeof_for_builtin_float_types() {
	assert typeof(f32(1.0)) == 'f32'
	assert typeof(f64(1.0)) == 'f64'
	// assert typeof(1.0) == 'any_float'
}

fn test_typeof_for_builtin_string_type() {
	assert typeof('abc') == 'string'
	assert typeof('/v/nv/vlib/v/tests/typeof_simple_types_test.v') == 'string'
	assert typeof('22') == 'string'
}

fn test_typeof_for_structs() {
	assert typeof(Abc{}) == 'Abc'
	assert typeof(Xyz{}) == 'Xyz'
}

//
fn mysumtype_typeof(x MySumType) string {
	return typeof(x)
}

fn test_typeof_for_sumtypes() {
	z_abc := Abc{}
	z_xyz := Xyz{}
	assert mysumtype_typeof(z_abc) == 'Abc'
	assert mysumtype_typeof(z_xyz) == 'Xyz'
}

//
fn supersumtype_typeof(x SuperSumType) string {
	return typeof(x)
}

fn mst(x MySumType) MySumType {
	return x
}

fn test_typeof_for_sumtypes_of_sumtypes() {
	assert supersumtype_typeof('abc') == 'string'
	assert supersumtype_typeof(mst(Abc{})) == 'MySumType'
}
fn test_typeof_on_simple_expressions() {
	a := int(123)
	assert typeof(int(42)) == 'int'
	assert typeof(f64(3.14)) == 'f64'
	assert typeof(int(2)+2*10) == 'int'
	assert typeof(f64(1.0) * 12.2) == 'f64'
	// assert typeof(1.0 * f32(12.2)) == 'f32'
	assert typeof(a) == 'int'
	// a2 := 123
	// assert typeof(a2) == 'any_int'
	// assert typeof(42) == 'any_int'
	// assert typeof(3.14) == 'any_float'
	// assert typeof(2+2*10) == 'any_int'
	// assert typeof(1.0 * 12.2) == 'any_float'
}

fn test_typeof_on_atypes() {
	aint := []int{}
	astring := []string{}
	assert typeof(aint) == 'array_int'
	assert typeof(astring) == 'array_string'
}

struct FooBar {
	x int
}

fn test_typeof_on_structs() {
	assert typeof(FooBar{}) == 'FooBar'
	astruct_static := [2]FooBar
	astruct_dynamic := [FooBar{}, FooBar{}]
	assert typeof(astruct_static) == '[2]FooBar'
	assert typeof(astruct_dynamic) == 'array_FooBar'
}

type MySumType = int | f32 | FooBar

pub fn (ms MySumType) str() string {
	match ms {
		int { return it.str() }
		f32 { return it.str() }
		//FooBar { return it.x.str() }
		else { return 'unknown: ' + typeof(ms) }
	}
}

fn test_typeof_on_sumtypes() {
	a := MySumType(int(32))
	b := MySumType(f32(123.0))
	c := MySumType(FooBar{x:43})
	assert typeof(a) == 'int'
	assert typeof(b) == 'f32'
	assert typeof(c) == 'FooBar'
}

//

struct UnaryExpr { a string }
struct BinExpr { a string b string }
struct BoolExpr { z int }
type ExprType = BoolExpr | BinExpr | UnaryExpr

fn fexpr(k int) ExprType {
	match k {
		1 { return UnaryExpr{} }
		2 { return BinExpr{} }
		3 { return BoolExpr{} }
		else { return UnaryExpr{} }
	}
}

fn test_typeof_on_sumtypes_of_structs() {
	a := fexpr(1)
	b := fexpr(2)
	c := fexpr(3)
	d := ExprType(UnaryExpr{})
	assert typeof(a) == 'UnaryExpr'
	assert typeof(b) == 'BinExpr'
	assert typeof(c) == 'BoolExpr'
	assert typeof(d) == 'UnaryExpr'
}

fn myfn(i int) int {
	return i
}
fn myfn2() {}
fn myfn3(i int, s string) byte {
	return byte(0)
}
fn myfn4() i8 {
	return -1
}

fn test_typeof_on_fn() {
	assert typeof(myfn) == 'fn (int) int'
	assert typeof(myfn2) == 'fn ()'
	assert typeof(myfn3) == 'fn (int, string) byte'
	assert typeof(myfn4) == 'fn () i8'
}
struct Human {
	name string
}

fn (h Human) str() string {
	return 'Human: $h.name'
}

type Person Human

fn (h Person) str() string {
	return 'Person: $h.name'
}

fn test_type_print() {
	p := Human{
		name: 'Bilbo'
	}
	println(p)
	assert p.str() == 'Human: Bilbo'
}

fn test_person_str() {
	p := Person{
		name: 'Bilbo'
	}
	println(p)
	assert p.str() == 'Person: Bilbo'
}
type Myint int
type Myf32 f32
type Myf64 f64

fn test_type_alias() {
	i := Myint(10)
	assert i + 100 == 110
	f := Myf32(7.4)
	assert f + f32(0.6) == f32(8.0)
	g := Myf64(10.4)
	assert g + 0.5 == 10.9
}

type Myint_2 = int
type Myf32_2 = f32
type Myf64_2 = f64

fn test_type_alias_v2() {
	i := Myint_2(10)
	assert i + 100 == 110
	f := Myf32_2(7.4)
	assert f + f32(0.6) == f32(8.0)
	g := Myf64_2(10.4)
	assert g + 0.5 == 10.9
}
module main

fn test_autoprint_string_vargs() {
	add_s('a')
	assert true
	add_s('a', 'b', 'c')
	assert true
}

fn add_s(column string, other_columns ...string) {
	println(column)
	println(other_columns)
}

//
fn test_autoprint_int_vargs() {
	add_i(1)
	assert true
	add_i(1, 2, 3)
	assert true
}

fn add_i(column int, other_columns ...int) {
	println(column)
	println(other_columns)
}

//
struct Point {
	x int
	y int
}

fn test_autoprint_struct_vargs() {
	add_point(Point{1, 2})
	assert true
	add_point(Point{1, 2}, Point{3, 4}, Point{5, 6})
	assert true
}

fn add_point(column Point, other_columns ...Point) {
	println(column)
	println(other_columns)
}
import vmod

fn test_from_file() {
	data := vmod.from_file('./v.mod') or {
		panic(err)
	}
	assert data.name == 'V'
	assert data.description == 'The V programming language.'
	assert data.version == '0.1.27'
	assert data.dependencies.len == 0
}

fn test_decode() {
	content := "
	  Module {
		name: \'foobar\',
		description: \'Just a sample module\'
		version: \'0.2.0\',
		repo_url: \'https://gitlab.com\',
		author: \'Fooz Bar\',
		license: \'GPL-2.0\',
		dependencies: [\'hello\'],
		test: \'foo\'
	  }
	"
	data := vmod.decode(content) or {
		println(err)
		exit(1)
	}
	assert data.name == 'foobar'
	assert data.version == '0.2.0'
	assert data.description == 'Just a sample module'
	assert data.repo_url == 'https://gitlab.com'
	assert data.author == 'Fooz Bar'
	assert data.license == 'GPL-2.0'
	assert data.dependencies[0] == 'hello'
	assert data.unknown['test'][0] == 'foo'
	_ := vmod.decode('') or {
		assert err == 'vmod: no content.'
		exit(0)
	}
}
fn receive_addr_return_u64(addr voidptr) u64 {
	return u64(addr)
}

fn test_void_pointer_to_u64_cast_via_fn_call() {
	a := u64(10)
	b := voidptr(a)
	c := receive_addr_return_u64(b)
	assert (a == c)
}
fn receive_u64_return_addr(something u64) voidptr {
	return voidptr(something)
}

fn test_u64_to_void_pointer_cast_via_fn_call() {
	a := u64(100)
	b := receive_u64_return_addr(a)
	c := u64(b)
	assert (a == c)
}
struct EmptyStruct {}
pub fn (f EmptyStruct) str() string { return 'EmptyStruct{}' }
fn new_s() EmptyStruct {
	println('>get_foo')
	return EmptyStruct{}
}

fn test_using_an_empty_struct_compiles_and_works() {
	s := new_s()
	eprintln('s: $s')
	assert true
}
#include <stdio.h>

int increment_val(int n) {
	return n + 2;
}

// ~26% faster
void increment_ptr(int* n) {
	*n += 2;
}

int main() {
	int n = 0;
	for (int i = 0; i < 1000000000; i++) {
		n = increment_val(n);
		//increment_ptr(&n);
	}
	printf("%d\n", n);
	return 0;
}

*.v
!*_test.v
!*.outFoo
================ V panic ================
   module: builtin
 function: __as_cast()
  message: as cast: cannot cast
struct Struct {struct_name string }
struct Interface {interface_name string}

type Info = Struct | Interface

fn main() {
	mut info := Info{}
	info = Struct{struct_name: 'Foo'}
	s := info as Struct
	println(s.struct_name)
	i := info as Interface // wrong
	println(i.interface_name)
}
import os
import term
import v.util

fn test_all() {
	mut total_errors := 0
	vexe := os.getenv('VEXE')
	vroot := os.dir(vexe)
	diff_cmd := util.find_working_diff_command() or { '' }
	dir := 'vlib/v/tests/inout'
	files := os.ls(dir) or {
		panic(err)
	}
	tests := files.filter(it.ends_with('.vv'))
	if tests.len == 0 {
		println('no compiler tests found')
		assert false
	}
	for test in tests {
		path := os.join_path(dir, test).replace('\\', '/')
		print(path + ' ')
		program := path.replace('.vv', '.v')
		os.cp(path, program) or {
			panic(err)
		}
		compilation := os.exec('$vexe -o test -cflags "-w" -cg $program') or {
			panic(err)
		}
		if compilation.exit_code != 0 {
			panic('compilation failed: $compilation.output')
		}
		// os.rm(program)
		res := os.exec('./test') or {
			println('nope')
			panic(err)
		}
		$if windows {
			os.rm('./test.exe')
			$if msvc {
				os.rm('./test.ilk')
				os.rm('./test.pdb')
			}
		} $else {
			os.rm('./test')
		}
		// println('============')
		// println(res.output)
		// println('============')
		mut found := res.output.trim_space().trim('\n').replace('\r\n', '\n')
		mut expected := os.read_file(program.replace('.v', '') + '.out') or {
			panic(err)
		}
		expected = expected.trim_space().trim('\n').replace('\r\n', '\n')
		if expected.contains('================ V panic ================') {
			// panic include backtraces and absolute file paths, so can't do char by char comparison
			n_found := normalize_panic_message( found, vroot )
			n_expected := normalize_panic_message( expected, vroot )
			if found.contains('================ V panic ================') {
				if n_found.contains(n_expected) {
					println(term.green('OK (panic)'))
					continue
				} else {
					// Both have panics, but there was a difference...
					// Pass the normalized strings for further reporting.
					// There is no point in comparing the backtraces too.
					found = n_found
					expected = n_expected
				}
			}
		}
		if expected != found {
			println(term.red('FAIL'))
			println(term.header('expected:','-'))
			println(expected)
			println(term.header('found:','-'))
			println(found)
			if diff_cmd != '' {
				println(term.header('difference:','-'))
				println(util.color_compare_strings(diff_cmd, expected, found))
			} else {
				println(term.h_divider('-'))
			}
			total_errors++
		} else {
			println(term.green('OK'))
		}
	}
	assert total_errors == 0
}

fn normalize_panic_message(message string, vroot string) string {
	mut msg := message.all_before('=========================================')
	msg = msg.replace(vroot + os.path_separator, '')
	msg = msg.trim_space()
	return msg
}
orange
yellow
green
green
interp: green
interp: greenmodule main

enum Color {
	orange
	green = 5
	red = 2
	yellow = 3
}

struct A{
	color Color
}

fn main() {
	col := Color.green
	a := A{color: col}
	orange := Color.orange
	println(orange)
	println(Color.yellow)
	println(col)
	println(a.color)
	println('interp: ${col}')
	println('interp: ${a.color}')
}
hello worldimport os

fn main() {
	println('hello world')
}
Hello, game developers!
Hello, web developers!
Hello, tools developers!
Hello, science developers!
Hello, systems developers!
Hello, embedded developers!import os

fn main() {
	areas := ['game', 'web', 'tools', 'science', 'systems', 'embedded']
	for i :=0; i < areas.len; i++{
		area:=areas[i]
		println('Hello, $area developers!')
	}
}
A {
    test: false
    b: B {
        pass: false
        name: ''
    }
}
B {
    pass: false
    name: ''
}module main

struct B {
	pass bool
	name string
}

fn (b &B) print() {
	println(b)
}

struct A {
	test bool
	b B
}

fn main() {
	a := A{}
	println(a)
	b := B{}
	b.print()
}
CHANGELOG.md
CODE_OF_CONDUCT.md
CONTRIBUTING.md
README.md
import os

fn main() {
	vexe := os.getenv('VEXE')
	vroot := os.dir(vexe)
	mut files := os.ls(vroot) or { panic(err) }
	files.sort()
	for file in files {
		if file.ends_with('.md') {
			println(file)
		}
	}
}
================ V panic ================
   module: main
 function: buggy_function()
  message: panicing...
     file: vlib/v/tests/inout/panic_with_cg.v
     line: 3

fn buggy_function() {
	panic('panicing...')
}

fn main(){
	buggy_function()    
}
%.*sworldhello
fn main() {
	test := 'hello'
	hello := 'world'
    println('%.*s$hello$test')
}

module local

pub fn local_fn() bool {
  return true
}

/*
module acommentedmodule


*/
module amodule

// This tests whether _test.v files can be *internal* to a 
// module, and thus have access to its guts.

// NB: the function test_private_isub() is defined both here
// and inside internal_module_test.v . That is done on purpose, 
// with the goal of ensuring that _test.v files are compiled 
// *independently* from each other.
//
// _test.v files should *only* import all the other normal .v 
// files from the same folder, NOT other _test.v files from it.

fn test_private_isub(){
  assert private_isub(7,5) == 2
}
module amodule

// this tests whether _test.v files can be *internal* 
// to a module, and thus have access to its guts.

fn test_iadd(){
	assert iadd(10, 20) == 30
}

fn test_imul(){
	assert imul(5,8) == 40
}

fn test_private_isub(){
  assert private_isub(10,6) == 4
}
module amodule

pub fn iadd(x int, y int) int {
	return x + y
}

pub fn imul(x int, y int) int {
	return x * y
}

///////////////////////////////////////

fn private_isub(x int, y int) int {
  return x - y
}
import simplemodule

// this tests whether the tests can import the same module without any special
// custom paths setup on the CLI
fn test_iadd(){
	assert simplemodule.iadd(10, 20) == 30
}

fn test_imul(){
	assert simplemodule.imul(5,8) == 40
}
module simplemodule

pub fn iadd(x int, y int) int {
	return x + y
}

pub fn imul(x int, y int) int {
	return x * y
}
/*.prod
/*.result.txt
struct MyStruct {
	s string
}

fn new_st() MyStruct {
	return MyStruct{}
}

fn get_st() MyStruct {
	r := new_st()
	return {r|s:'6'}
}

fn main() {
    s := get_st()
    println(s)
}
MyStruct {
    s: '6'
}main
mod1/c/implementation.o
main_test
Do not delete this file.
It is used by V to stop the lookup for v.mod,
so that the top level vlib/v.mod is not found,
if you delete mod1/v.mod .
module main

import mod1

fn main(){
	res := mod1.vadd(1,2)
	println( res )
}
import mod1

fn test_using_c_code_in_the_same_module_works(){
	assert 1003 == mod1.vadd(1,2)
}
Module {
	name: 'mod1',
	description: 'A simple module, containing C code.',
	dependencies: []
}
module mod1

#flag -I @VROOT/c
#flag @VROOT/c/implementation.o

#include "header.h"

fn C.cadd(int,int) int

pub fn vadd(a int, b int) int {
	return 1000 + C.cadd(a,b)
}
#ifndef ADD_H
#define ADD_H

int cadd(int a, int b);

#endif
#include "header.h"

int cadd(int a, int b) {
    return a + b;
}
/bin/main
/tests/submodule_test

This projects demonstrates how v.mod lookup can be used so that 
a project/module can be as selfcontained as possible.

The programs under bin/ can find the modules mod1, 
because the project has a 'v.mod' file, so v module lookup for 
the programs under bin/ can still find the parent sibling folder
mod1/ through relation to the parent 'v.mod' file.

Note also that mod1/ also has its own 'v.mod' file.
This allows mod1 submodules to find and import themselves 
in relation to it too.

Finally, there is a test/ folder, so you can put all your tests
in there, without cluttering your top level folder, or your module
folders if you so desire.
#V Project#

Module {
	name: 'project_with_modules_having_submodules',
	description: 'This project was created with `v create` to prevent regressions with the way V module import lookup works.',
	dependencies: []
}
import mod1.submodule as m

fn test_mod1_can_still_be_found_through_parent_project_vmod(){
   assert 1051 == m.f()
}   

/* 
NB: this main program is under bin/ , but it still
can find mod1, because the parent project has v.mod, 
so v module lookup for this program will find mod1 through
relation to the parent v.mod file
*/
#!/usr/local/bin/v run
import mod1.submodule as m

println('This script is located inside: ' + resource_abs_path(''))

println('The result of calling m.f is: ' + m.f().str() )


/* 
NB: this main program v script is under bin/ , 
but it *still* can find mod1, because the parent project has v.mod, 
so v module lookup for this bin/main.vsh file will find mod1 through 
relation to the parent ../v.mod file
*/
module mod1

pub fn f() int {
	return 1
}
#V Module#

Module {
	name: 'mod1',
	description: 'A module with several submodules.',
	dependencies: []
}
module mod11

pub fn f() int {
	return 11
}
module mod12

pub fn f() int {
	return 12
}
module mod13

pub fn f() int {
	return 13
}
module mod14

import math

pub fn f() int {
	return 14 + int(math.cos(0))
}
module submodule

/* 
This submodule just imports its sibling submodules.
Note that they are NOT under 'submodule' itself, 
but are in its parent mod1 , and mod1 has a 'v.mod' file.
*/

import mod11
import mod12
import mod13
import mod14

pub fn f() int {
	return 1000 + mod11.f() + mod12.f() + mod13.f() + mod14.f()
}
import mod1

import mod1.submodule

fn test_mod1(){
	assert 1 == mod1.f()
}

fn test_mod1_submodule_can_find_and_use_all_its_sibling_submodules(){
  assert 1051 == submodule.f()
}

*.repl text=auto eol=lf
run
*.repl.result.txt
*.repl.expected.txt
mut a := [1, 2, 3]
b := [4, 5]
a << b
a = a.filter(it%2==0)
a
===output===
[2, 4]
[]int{len:3}
===output===
[0, 0, 0]
a := [1,2,3]
println('hi' in a)
===output===
.vrepl.v:2:18: bad element type: `string` in `[]int`
mut a := [1,2,3] // comment
// test comment
a << 4
a
===output===
[1, 2, 3, 4]
num := 1 string := 'Hello'
num
string
===output===
1
Hello
struct Empty{} ee := Empty{}
println('OK')
===output===
OK
import v.tests.modules.acommentedmodule
===output===
builder error: bad module definition: .entire_commented_module.repl.vrepl_temp.v imports module "v.tests.modules.acommentedmodule" but vlib/v/tests/modules/acommentedmodule/commentedfile.v is defined as module `main`
println(a)
===output===
.vrepl.v:2:9: error: undefined: `a` 
    1 | 
    2 | println(a)
      |         ^
a
33
===output===
undefined: `a`
33
fn test() { println('foo') } test() fn test2(a int) {  println(a) } test2(42)
===output===
foo
42
import time
time.now().unix_time() > 160000
===output===
true
mut a := [1,2,3]
a << 4
import time
time.now().unix_time() > 160000
===output===
true
name := 'Bob' age := 20 large_number := i64(9999999999)
println(name)
println(age)
println(large_number)
===output===
Bob
20
9999999999
println('Hello World')
println('Foo Bar')
println('dlroW olleH')
===output===
Hello World
Foo Bar
dlroW olleH
'abc'
'abc'+'xyz'
===output===
abc
abcxyz


===output===
a := 1
println(a)
===output===
1
===output===
'{'
'}'
===output===
{
}
fn foo() ?bool {return true}	
fn main() {
	foo()? // only works in main()
	println('done')
}	
===output===
done
mut a := 10 a++ a++ a++ a--
a
===output===
12
println('Hello, world!')
println(', !')
println('')
===output===
Hello, world!
, !

# V REPL Tests Script

### How to write a new test
  - Create a new file named `*.repl`
  - Write the input to be given to REPL
  - Add `===output===`
  - Write the output expected
  
### Notes
Keep in mind, that the way V repl works for now, every non empty line
would cause a new recompilation of the entire repl content that was
collected so far. 

*Longer REPL files would cause measurably*
*longer recompilation/testing times.*

Also, longer repl files would be slower to debug when they fail,
*It is better to have several smaller files vs one huge REPL file.*

### Example :
```
a := 1
println(a)
===output===
1
module main

import os
import v.tests.repl.runner
import benchmark
import sync

fn test_the_v_compiler_can_be_invoked() {
	vexec := runner.full_path_to_v(5)
	println('vexecutable: $vexec')
	assert vexec != ''
	vcmd := '"$vexec" -version'
	r := os.exec(vcmd) or {
		panic(err)
	}
	// println('"$vcmd" exit_code: $r.exit_code | output: $r.output')
	assert r.exit_code == 0
	vcmd_error := '"$vexec" nonexisting.v'
	r_error := os.exec(vcmd_error) or {
		panic(err)
	}
	// println('"$vcmd_error" exit_code: $r_error.exit_code | output: $r_error.output')
	assert r_error.exit_code == 1
	assert r_error.output == "builder error: nonexisting.v doesn't exist"
}

struct Session {
mut:
	options runner.RunnerOptions
	bmark   benchmark.Benchmark
}

fn test_all_v_repl_files() {
	mut session := &Session{
		options: runner.new_options()
		bmark: benchmark.new_benchmark()
	}
	// warmup, and ensure that the vrepl is compiled in single threaded mode if it does not exist
	runner.run_repl_file(os.cache_dir(), session.options.vexec, 'vlib/v/tests/repl/nothing.repl') or {
		panic(err)
	}
	session.bmark.set_total_expected_steps(session.options.files.len)
	mut pool_repl := sync.new_pool_processor({
		callback: worker_repl
	})
	pool_repl.set_shared_context(session)
	$if windows {
		// See: https://docs.microsoft.com/en-us/cpp/build/reference/fs-force-synchronous-pdb-writes?view=vs-2019
		pool_repl.set_max_jobs(1)
	}
	pool_repl.work_on_items_s(session.options.files)
	session.bmark.stop()
	println(session.bmark.total_message('total time spent running REPL files'))
}

fn worker_repl(p mut sync.PoolProcessor, idx int, thread_id int) voidptr {
	cdir := os.cache_dir()
	mut session := &Session(p.get_shared_context())
	mut tls_bench := &benchmark.Benchmark(p.get_thread_context(idx))
	if isnil(tls_bench) {
		tls_bench = benchmark.new_benchmark_pointer()
		tls_bench.set_total_expected_steps(session.bmark.nexpected_steps)
		p.set_thread_context(idx, tls_bench)
	}
	tls_bench.cstep = idx
	tfolder := os.join_path(cdir,'vrepl_tests_$idx')
	if os.is_dir(tfolder) {
		os.rmdir_all(tfolder)
	}
	os.mkdir(tfolder) or {
		panic(err)
	}
	file := p.get_string_item(idx)
	session.bmark.step()
	tls_bench.step()
	fres := runner.run_repl_file(tfolder, session.options.vexec, file) or {
		session.bmark.fail()
		tls_bench.fail()
		os.rmdir_all(tfolder)
		eprintln(tls_bench.step_message_fail(err))
		assert false
		return sync.no_result
	}
	session.bmark.ok()
	tls_bench.ok()
	os.rmdir_all(tfolder)
	println(tls_bench.step_message_ok(fres))
	assert true
	return sync.no_result
}
module main

import v.tests.repl.runner
import log
import benchmark

fn main() {
	mut logger := log.Log{}
	logger.set_level(.debug)
	options := runner.new_options()
	mut bmark := benchmark.new_benchmark()
	for file in options.files {
		bmark.step()
		fres := runner.run_repl_file(options.wd, options.vexec, file) or {
			bmark.fail()
			logger.error(bmark.step_message_fail(err))
			continue
		}
		bmark.ok()
		logger.info(bmark.step_message_ok(fres))
	}
	bmark.stop()
	logger.info(bmark.total_message('total time spent running REPL files'))
}
a := 1
println(a)
===output===
1
struct A { mut: v int }  struct B { a A }  struct C { mut: b B } struct D { mut: c C }
mut b := B{} b = B{A{2}}
b.a.v = 1   // Error (field a immutable)
b.a = A{}   // Error (field a immutable)
===output===
cannot modify immutable field `a` (type `B`)
declare the field with `mut:`
struct B {
mut:
	a A
}
cannot modify immutable field `a` (type `B`)
declare the field with `mut:`
struct B {
mut:
	a A
}
struct A { mut: v int }  struct B { a A }  struct C { mut: b B } struct D { mut: c C } 
mut c := C{} c.b = B{}
c.b.a = A{} // Error (field a immutable)
c.b.a.v = 1 // Error (field a immutable)
===output===
cannot modify immutable field `a` (type `B`)
declare the field with `mut:`
struct B {
mut:
	a A
}
cannot modify immutable field `a` (type `B`)
declare the field with `mut:`
struct B {
mut:
	a A
}
struct A { mut: v int }  struct B { a A }  struct C { mut: b B } struct D { mut: c C } 
c2 := C{}
c2.b = B{}  // Error (c2 immutable)
===output===
`c2` is immutable
struct A { mut: v int }  struct B { a A }  struct C { mut: b B } struct D { mut: c C }
mut d := D{} d.c.b = B{}
'OK'
===output===
OK
struct E { mut: v []int } struct F { e []E } mut f := F{}
f.e << E{}      // Error (field e immutable)
f.e[0].v << 1   // Error (field e immutable)
e := E{}
e.v << 1    // Error (e immutable)
===output===
cannot modify immutable field `e` (type `F`)
declare the field with `mut:`
struct F {
mut:
	e []E
}
cannot modify immutable field `e` (type `F`)
declare the field with `mut:`
struct F {
mut:
	e []E
}
`e` is immutable (can't <<)
for i := 0; i < 4; i++ {
  println(i)
}
===output===
0
1
2
3
if true {
  println('foo')
}
===output===
foo
if false {
  println('foo')
} else {
  println('bar')
}
===output===
bar
mut s := 'hello world'
s.len = 0   // Error (field len immutable)
'BYE'
===output===
cannot modify immutable field `len` (type `string`)
declare the field with `mut:`
struct string {
mut:
	len int
}
BYE
mut a := []string
a.len = 0   // Error (field len immutable)
'BYE'
===output===
cannot modify immutable field `len` (type `array`)
declare the field with `mut:`
struct array {
mut:
	len int
}
BYE
mut ints := []int
ints.len = 0   // Error (field len immutable)
println('BYE')
===output===
cannot modify immutable field `len` (type `array`)
declare the field with `mut:`
struct array {
mut:
	len int
}
BYE
module runner

import os
import v.util

pub struct RunnerOptions {
pub:
	wd string
	vexec string
	files []string
}

pub fn full_path_to_v(dirs_in int) string {
	vexe_from_env := os.getenv('VEXE')
	if vexe_from_env.len > 0 {
		return vexe_from_env
	}
	vname := if os.user_os() == 'windows' { 'v.exe' } else { 'v' }
	mut path := os.executable()
	for i := 0; i < dirs_in; i++ {
		path = os.dir(path)
	}
	vexec := os.join_path(path, vname)
	/*
	args := os.args
	vreal  := os.real_path('v')
	myself := os.real_path( os.executable() )
	wd := os.getwd()
	println('args are: $args')
	println('vreal   : $vreal')
	println('myself  : $myself')
	println('wd      : $wd')
    */
	return vexec
}

fn diff_files( file_result, file_expected string ) string {
	diffcmd := util.find_working_diff_command() or { return err }
	return util.color_compare_files(diffcmd, file_result, file_expected)
}

pub fn run_repl_file(wd string, vexec string, file string) ?string {
	vexec_folder := os.dir(vexec) + os.path_separator
	fcontent := os.read_file(file) or {	return error('Could not read file ${file}') }
	content := fcontent.replace('\r', '')
	input := content.all_before('===output===\n')
	output := content.all_after('===output===\n')

	fname := os.file_name( file )

	input_temporary_filename := os.real_path(os.join_path( wd, 'input_temporary_filename.txt'))
	os.write_file(input_temporary_filename, input)
	os.write_file(  os.real_path(os.join_path( wd, 'original.txt' ) ), fcontent )
	rcmd := '"$vexec" repl -replfolder "$wd" -replprefix "${fname}." < $input_temporary_filename'
	r := os.exec(rcmd) or {
		os.rm(input_temporary_filename)
		return error('Could not execute: $rcmd')
	}
	os.rm(input_temporary_filename)

	result := r.output.replace('\r','')
	.replace('>>> ', '')
	.replace('>>>', '')
	.replace('... ', '')
	.all_after('Use Ctrl-C or `exit` to exit\n')
	.replace(wd  + os.path_separator, '' )
	.replace(vexec_folder, '')
	.replace('\\', '/')

	if result != output {
		file_result   := '${file}.result.txt'
		file_expected := '${file}.expected.txt'
		os.write_file( file_result, result )
		os.write_file( file_expected, output )
		diff := diff_files( file_result, file_expected )
		return error('Difference found in REPL file: ${file}
====> Got      :
|$result|
====> Expected :
|$output|
====> Diff     :
$diff
		')
	} else {
		return 'Repl file ${file} is OK'
	}
}

pub fn run_prod_file(wd string, vexec string, file string) ?string {
	file_expected := '${file}.expected.txt'
	f_expected_content := os.read_file(file_expected) or { return error('Could not read file ${file}') }
	expected_content := f_expected_content.replace('\r', '')

	cmd := '"$vexec" -prod run "${file}"'
	r := os.exec(cmd) or {
		return error('Could not execute: $cmd')
	}

	if r.exit_code != 0 {
		return error('$cmd return exit code: $r.exit_code')
	}

	result := r.output.replace('\r','')

	if result != expected_content {
		file_result   := '${file}.result.txt'
		os.write_file( file_result, result )
		diff := diff_files( file_result, file_expected )
		return error('Difference found in test: ${file}
====> Got      :
|$result|
====> Expected :
|$expected_content|
====> Diff     :
$diff
		')
	} else {
		return 'Prod file ${file} is OK'
	}
}

pub fn new_options() RunnerOptions {
	vexec := full_path_to_v(5)
	mut wd := os.getwd()
	mut files := []string{}
	if os.args.len > 1 {
		files = os.args[1..]
	} else {
		os.chdir( os.dir(vexec) )
		wd = os.getwd()
		files = os.walk_ext('.', '.repl')
	}
	return RunnerOptions {
		wd: wd
		vexec: vexec
		files: files
	}
}

pub fn new_prod_options() RunnerOptions {
	wd := os.getwd()
	vexec := full_path_to_v(4)
	mut files := []string{}
	if os.args.len > 1 {
		files = os.args[1..]
	} else {
		files = os.walk_ext(wd, '.prod.v')
	}
	return RunnerOptions {
		wd: wd
		vexec: vexec
		files: files
	}
}
import os

fn return_array(array_arg []string) []int { // array argument must not be freed
	s := [1, 2, 3] // escaping array must not be freed
	return s
}

fn foo() {
	nums := [1, 2, 3] // local array must be freed
	println(nums)

	nums_copy := nums // array assignments call .clone()
	println(nums_copy)

	name  := 'Peter' // string literals mustn't be freed
	str_inter := 'hello, $name' // concatenated strings must be freed




	//nums.free() // this should result in a double free and a CI error
}

fn str_replace() {
	s := 'hello world'
	r := s.replace('hello', 'hi')
	cloned := s.replace('hello', 'hi').clone()
	cloned2 := r.clone()
	println(s)
	println(r)
}

fn main() {
	println('start')
	foo()
	//str_replace()
	println('end')
}

import os
import term
import benchmark

[if verbose]
fn vprintln(s string) {
	eprintln(s)
}

fn test_all() {
	if os.user_os() != 'linux' && os.getenv('FORCE_VALGRIND_TEST').len == 0 {
		eprintln('Valgrind tests can only be run reliably on Linux for now.')
		eprintln('You can still do it by setting FORCE_VALGRIND_TEST=1 .')
		exit(0)
	}
	if os.getenv('V_CI_MUSL').len > 0 {
		eprintln('This test is disabled for musl.')
		exit(0)
	}
	bench_message := 'memory leak checking with valgrind'
	mut bench := benchmark.new_benchmark()
	eprintln(term.header(bench_message, '-'))
	vexe := os.getenv('VEXE')
	vroot := os.dir(vexe)
	dir := os.join_path(vroot,'vlib/v/tests/valgrind')
	files := os.ls(dir) or {
		panic(err)
	}
	//
	wrkdir := os.join_path(os.temp_dir(),'vtests','valgrind')
	os.mkdir_all(wrkdir)
	os.chdir(wrkdir)
	//
	tests := files.filter(it.ends_with('.vv'))
	bench.set_total_expected_steps(tests.len)
	for test in tests {
		bench.step()
		full_test_path := os.real_path(test)
		println('x.v: $wrkdir/x.v')
		os.system('cp ${dir}/${test} $wrkdir/x.v') // cant run .vv file
		compile_cmd := '$vexe -cflags "-w" -verbose=3 -autofree -keepc -cg $wrkdir/x.v'
		vprintln('compile cmd: $compile_cmd')
		res := os.exec(compile_cmd) or {
			bench.fail()
			eprintln(bench.step_message_fail('valgrind $test failed'))
			continue
		}
		if res.exit_code != 0 {
			bench.fail()
			eprintln(bench.step_message_fail('file: $full_test_path could not be compiled.'))
			eprintln(res.output)
			continue
		}
		valgrind_cmd := 'valgrind --error-exitcode=1 --leak-check=full $wrkdir/x'
		vprintln('valgrind cmd: $valgrind_cmd')
		valgrind_res := os.exec(valgrind_cmd) or {
			bench.fail()
			eprintln(bench.step_message_fail('valgrind could not be executed'))
			continue
		}
		if valgrind_res.exit_code != 0 {
			bench.fail()
			eprintln(bench.step_message_fail('failed valgrind check for $test'))
			eprintln(valgrind_res.output)
			continue
		}
		bench.ok()
		eprintln(bench.step_message_ok('testing file: $test'))
	}
	bench.stop()
	eprintln(term.h_divider('-'))
	eprintln(bench.total_message(bench_message))
	if bench.nfail > 0 {
		exit(1)
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module token

pub struct Position {
pub:
	len     int // length of the literal in the source
	line_nr int // the line number in the source where the token occured
	pos     int // the position of the token in scanner text
}

pub fn (pos Position) str() string {
	return 'Position{ line_nr: $pos.line_nr, pos: $pos.pos, len: $pos.len }'
}

pub fn (pos Position) extend(end Position) Position {
	return {
		pos |
		len: end.pos - pos.pos + end.len
	}
}

[inline]
pub fn (tok &Token) position() Position {
	return Position{
		len: tok.len
		line_nr: tok.line_nr - 1
		pos: tok.pos
	}
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module token

pub struct Token {
pub:
	kind    Kind // the token number/enum; for quick comparisons
	lit     string // literal representation of the token
	line_nr int // the line number in the source where the token occured
	// name_idx int // name table index for O(1) lookup
	pos     int // the position of the token in scanner text
	len     int // length of the literal
}

pub enum Kind {
	eof
	name // user
	number // 123
	string // 'foo'
	str_inter // 'name=$user.name'
	chartoken // `A`
	plus
	minus
	mul
	div
	mod
	xor // ^
	pipe // |
	inc // ++
	dec // --
	and // &&
	logical_or
	not
	bit_not
	question
	comma
	semicolon
	colon
	arrow // =>
	amp
	hash
	dollar
	str_dollar
	left_shift
	right_shift
	not_in // !in
	// at // @
	assign // =
	decl_assign // :=
	plus_assign // +=
	minus_assign // -=
	div_assign
	mult_assign
	xor_assign
	mod_assign
	or_assign
	and_assign
	right_shift_assign
	left_shift_assign
	// {}  () []
	lcbr
	rcbr
	lpar
	rpar
	lsbr
	rsbr
	// == != <= < >= >
	eq
	ne
	gt
	lt
	ge
	le
	comment
	nl
	dot
	dotdot
	ellipsis
	// keywords
	keyword_beg
	key_as
	key_asm
	key_assert
	key_atomic
	key_break
	key_const
	key_continue
	key_defer
	key_else
	key_embed
	key_enum
	key_false
	key_for
	key_fn
	key_global
	key_go
	key_goto
	key_if
	key_import
	key_in
	key_interface
	key_is
	// key_it
	key_match
	key_module
	key_mut
	key_none
	key_return
	key_select
	key_sizeof
	key_offsetof
	key_struct
	key_switch
	key_true
	key_type
	key_typeof
	key_orelse
	key_union
	key_pub
	key_static
	key_unsafe
	keyword_end
	_end_
}

const (
	assign_tokens = [Kind.assign, .plus_assign, .minus_assign, .mult_assign,
	.div_assign, .xor_assign, .mod_assign, .or_assign, .and_assign,
	.right_shift_assign, .left_shift_assign]
	nr_tokens = int(Kind._end_)
)
// build_keys genereates a map with keywords' string values:
// Keywords['return'] == .key_return
fn build_keys() map[string]int {
	mut res := map[string]int
	for t in int(Kind.keyword_beg) + 1 .. int(Kind.keyword_end) {
		key := token_str[t]
		res[key] = t
	}
	return res
}

// TODO remove once we have `enum Kind { name('name') if('if') ... }`
fn build_token_str() []string {
	mut s := [''].repeat(nr_tokens)
	s[Kind.eof] = 'eof'
	s[Kind.name] = 'name'
	s[Kind.number] = 'number'
	s[Kind.string] = 'string'
	s[Kind.chartoken] = 'char'
	s[Kind.plus] = '+'
	s[Kind.minus] = '-'
	s[Kind.mul] = '*'
	s[Kind.div] = '/'
	s[Kind.mod] = '%'
	s[Kind.xor] = '^'
	s[Kind.bit_not] = '~'
	s[Kind.pipe] = '|'
	s[Kind.hash] = '#'
	s[Kind.amp] = '&'
	s[Kind.inc] = '++'
	s[Kind.dec] = '--'
	s[Kind.and] = '&&'
	s[Kind.logical_or] = '||'
	s[Kind.not] = '!'
	s[Kind.dot] = '.'
	s[Kind.dotdot] = '..'
	s[Kind.ellipsis] = '...'
	s[Kind.comma] = ','
	s[Kind.not_in] = '!in'
	// s[Kind.at] = '@'
	s[Kind.semicolon] = ';'
	s[Kind.colon] = ':'
	s[Kind.arrow] = '=>'
	s[Kind.assign] = '='
	s[Kind.decl_assign] = ':='
	s[Kind.plus_assign] = '+='
	s[Kind.minus_assign] = '-='
	s[Kind.mult_assign] = '*='
	s[Kind.div_assign] = '/='
	s[Kind.xor_assign] = '^='
	s[Kind.mod_assign] = '%='
	s[Kind.or_assign] = '|='
	s[Kind.and_assign] = '&='
	s[Kind.right_shift_assign] = '>>='
	s[Kind.left_shift_assign] = '<<='
	s[Kind.lcbr] = '{'
	s[Kind.rcbr] = '}'
	s[Kind.lpar] = '('
	s[Kind.rpar] = ')'
	s[Kind.lsbr] = '['
	s[Kind.rsbr] = ']'
	s[Kind.eq] = '=='
	s[Kind.ne] = '!='
	s[Kind.gt] = '>'
	s[Kind.lt] = '<'
	s[Kind.ge] = '>='
	s[Kind.le] = '<='
	s[Kind.question] = '?'
	s[Kind.left_shift] = '<<'
	s[Kind.right_shift] = '>>'
	s[Kind.comment] = '// comment'
	s[Kind.nl] = 'NLL'
	s[Kind.dollar] = '$'
	s[Kind.str_dollar] = '$2'
	s[Kind.key_assert] = 'assert'
	s[Kind.key_struct] = 'struct'
	s[Kind.key_if] = 'if'
	// s[Kind.key_it] = 'it'
	s[Kind.key_else] = 'else'
	s[Kind.key_asm] = 'asm'
	s[Kind.key_return] = 'return'
	s[Kind.key_module] = 'module'
	s[Kind.key_sizeof] = 'sizeof'
	s[Kind.key_go] = 'go'
	s[Kind.key_goto] = 'goto'
	s[Kind.key_const] = 'const'
	s[Kind.key_mut] = 'mut'
	s[Kind.key_type] = 'type'
	s[Kind.key_for] = 'for'
	s[Kind.key_switch] = 'switch'
	s[Kind.key_fn] = 'fn'
	s[Kind.key_true] = 'true'
	s[Kind.key_false] = 'false'
	s[Kind.key_continue] = 'continue'
	s[Kind.key_break] = 'break'
	s[Kind.key_import] = 'import'
	s[Kind.key_embed] = 'embed'
	s[Kind.key_unsafe] = 'unsafe'
	s[Kind.key_typeof] = 'typeof'
	s[Kind.key_enum] = 'enum'
	s[Kind.key_interface] = 'interface'
	s[Kind.key_pub] = 'pub'
	s[Kind.key_in] = 'in'
	s[Kind.key_atomic] = 'atomic'
	s[Kind.key_orelse] = 'or'
	s[Kind.key_global] = '__global'
	s[Kind.key_union] = 'union'
	s[Kind.key_static] = 'static'
	s[Kind.key_as] = 'as'
	s[Kind.key_defer] = 'defer'
	s[Kind.key_match] = 'match'
	s[Kind.key_select] = 'select'
	s[Kind.key_none] = 'none'
	s[Kind.key_offsetof] = '__offsetof'
	s[Kind.key_is] = 'is'
	return s
}

const (
	token_str = build_token_str()
	keywords = build_keys()
)

pub fn key_to_token(key string) Kind {
	a := Kind(keywords[key])
	return a
}

pub fn is_key(key string) bool {
	return int(key_to_token(key)) > 0
}

pub fn is_decl(t Kind) bool {
	return t in [.key_enum, .key_interface, .key_fn, .key_struct, .key_type, .key_const, .key_pub, .eof]
}

pub fn (t Kind) is_assign() bool {
	return t in assign_tokens
}

fn (t []Kind) contains(val Kind) bool {
	for tt in t {
		if tt == val {
			return true
		}
	}
	return false
}

pub fn (t Kind) str() string {
	return token_str[int(t)]
}

pub fn (t Token) str() string {
	return '$t.kind.str() "$t.lit"'
}

// Representation of highest and lowest precedence
/*
pub const (
	lowest_prec = 0
	highest_prec = 8
)
*/

pub enum Precedence {
	lowest
	cond // OR or AND
	in_as
	assign // =
	eq // == or !=
	// less_greater // > or <
	sum // + - | ^
	product // * / << >> &
	// mod // %
	prefix // -X or !X
	postfix // ++ or --
	call // func(X) or foo.method(X)
	index // array[index], map[key]
}

pub fn build_precedences() []Precedence {
	mut p := []Precedence{len:100, cap:100}
	p[Kind.assign] = .assign
	p[Kind.eq] = .eq
	p[Kind.ne] = .eq
	p[Kind.lt] = .eq // less_greater
	p[Kind.gt] = .eq // less_greater
	p[Kind.le] = .eq // less_greater
	p[Kind.ge] = .eq // less_greater
	p[Kind.plus] = .sum
	p[Kind.plus_assign] = .sum
	p[Kind.minus] = .sum
	p[Kind.minus_assign] = .sum
	p[Kind.div] = .product
	p[Kind.div_assign] = .product
	p[Kind.mul] = .product
	p[Kind.mult_assign] = .product
	p[Kind.mod] = .product // mod
	p[Kind.and] = .cond
	p[Kind.logical_or] = .cond
	p[Kind.lpar] = .call
	p[Kind.dot] = .call
	p[Kind.lsbr] = .index
	return p
}

const (
	precedences = build_precedences()
	// int(Kind.assign): Precedence.assign
	// }
)
// precedence returns a tokens precedence if defined, otherwise lowest_prec
pub fn (tok Token) precedence() int {
	// TODO
	// return int(precedences[int(tok)])
	match tok.kind {
		.lsbr {
			return int(Precedence.index)
		}
		.dot {
			return int(Precedence.call)
		}
		// `++` | `--`
		.inc, .dec {
			return int(Precedence.postfix)
			// return 0
			// return 7
		}
		// `*` |  `/` | `%` | `<<` | `>>` | `&`
		.mul, .div, .mod, .left_shift, .right_shift, .amp {
			return int(Precedence.product)
		}
		// `+` |  `-` |  `|` | `^`
		.plus, .minus, .pipe, .xor {
			return int(Precedence.sum)
		}
		// `==` | `!=` | `<` | `<=` | `>` | `>=`
		.eq, .ne, .lt, .le, .gt, .ge {
			return int(Precedence.eq)
		}
		// `&&`
		// .and {
		// return 3
		// }
		// `||`
		// .logical_or,
		.assign, .plus_assign, .minus_assign, .div_assign, .mod_assign, .or_assign, .and_assign,
		//
		.left_shift_assign, .right_shift_assign, .mult_assign, .xor_assign {
			return int(Precedence.assign)
		}
		.key_in, .not_in, .key_as, .key_is {
			return int(Precedence.in_as)
		}
		.logical_or, .and {
			return int(Precedence.cond)
		}
		// /.plus_assign {
		// /return 2
		// /}
		else {
			return int(Precedence.lowest)
		}
	}
}

// is_scalar returns true if the token is a scalar
pub fn (tok Token) is_scalar() bool {
	return tok.kind in [.number, .string]
}

// is_unary returns true if the token can be in a unary expression
pub fn (tok Token) is_unary() bool {
	return tok.kind in [
	// `+` | `-` | `!` | `~` | `*` | `&`
	.plus, .minus, .not, .bit_not, .mul, .amp]
}

pub fn (tok Kind) is_relational() bool {
	return tok in [
	// `<` | `<=` | `>` | `>=`
	.lt, .le, .gt, .ge, .eq, .ne]
}

pub fn (k Kind) is_start_of_type() bool {
	return k in [.name, .lpar, .amp, .lsbr, .question]
}

pub fn (kind Kind) is_infix() bool {
	return kind in [.plus, .minus, .mod, .mul, .div, .eq, .ne, .gt, .lt, .key_in,
	//
	.key_as, .ge, .le, .logical_or, .xor, .not_in, .key_is,
	//
	.and, .dot, .pipe, .amp, .left_shift, .right_shift]
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module util

import os
import term
import v.token
import time

// The filepath:line:col: format is the default C compiler error output format.
// It allows editors and IDE's like emacs to quickly find the errors in the
// output and jump to their source with a keyboard shortcut.
// NB: using only the filename may lead to inability of IDE/editors
// to find the source file, when the IDE has a different working folder than
// v itself.
// error_context_before - how many lines of source context to print before the pointer line
// error_context_after - ^^^ same, but after
const (
	error_context_before = 2
	error_context_after  = 2
)

// emanager.support_color - should the error and other messages
// have ANSI terminal escape color codes in them.
// By default, v tries to autodetect, if the terminal supports colors.
// Use -color and -nocolor options to override the detection decision.
pub const (
	emanager = new_error_manager()
)

pub struct EManager {
mut:
	support_color bool
}

pub fn new_error_manager() &EManager {
	return &EManager{
		support_color: term.can_show_color_on_stderr()
	}
}

pub fn (e &EManager) set_support_color(b bool) {
	e.support_color = b
}

fn bold(msg string) string {
	if !emanager.support_color {
		return msg
	}
	return term.bold(msg)
}

fn color(kind, msg string) string {
	if !emanager.support_color {
		return msg
	}
	if kind.contains('error') {
		return term.red(msg)
	} else {
		return term.magenta(msg)
	}
}

// formatted_error - `kind` may be 'error' or 'warn'
pub fn formatted_error(kind, emsg, filepath string, pos token.Position) string {
	mut path := filepath
	verror_paths_override := os.getenv('VERROR_PATHS')
	if verror_paths_override == 'absolute' {
		path = os.real_path(path)
	} else {
		// Get relative path
		workdir := os.getwd() + os.path_separator
		if path.starts_with(workdir) {
			path = path.replace(workdir, '')
		}
	}
	//
	source := read_file(filepath) or {
		''
	}
	mut p := imax(0, imin(source.len - 1, pos.pos))
	if source.len > 0 {
		for ; p >= 0; p-- {
			if source[p] == `\r` || source[p] == `\n` {
				break
			}
		}
	}
	column := imax(0, pos.pos - p - 1)
	position := '${path}:${pos.line_nr+1}:${util.imax(1,column+1)}:'
	scontext := source_context(kind, source, column, pos).join('\n')
	final_position := bold(position)
	final_kind := bold(color(kind, kind))
	final_msg := emsg
	final_context := if scontext.len > 0 { '\n$scontext' } else { '' }
	//
	return '$final_position $final_kind $final_msg $final_context'.trim_space()
}

pub fn source_context(kind, source string, column int, pos token.Position) []string {
	mut clines := []string{}
	if source.len == 0 {
		return clines
	}
	source_lines := source.split_into_lines()
	bline := imax(0, pos.line_nr - error_context_before)
	aline := imax(0, imin(source_lines.len - 1, pos.line_nr + error_context_after))
	tab_spaces := '    '
	for iline := bline; iline <= aline; iline++ {
		sline := source_lines[iline]
		start_column := imin(column, sline.len)
		end_column := imin(column + pos.len, sline.len)
		cline := if iline == pos.line_nr {
			sline[..start_column] + color(kind, sline[start_column..end_column]) + sline[end_column..]
		} else {
			sline
		}
		clines << '${iline+1:5d} | ' + cline.replace('\t', tab_spaces)
		//
		if iline == pos.line_nr {
			// The pointerline should have the same spaces/tabs as the offending
			// line, so that it prints the ^ character exactly on the *same spot*
			// where it is needed. That is the reason we can not just
			// use strings.repeat(` `, col) to form it.
			mut pointerline := ''
			for bchar in sline[..start_column] {
				x := if bchar.is_space() {
					bchar
				} else {
					` `
				}
				pointerline += x.str()
			}
			underline := if pos.len > 1 {
				'~'.repeat(end_column - start_column)
			} else {
				'^'
			}
			pointerline += bold(color(kind, underline))
			clines << '      | ' + pointerline.replace('\t', tab_spaces)
		}
	}
	return clines
}

pub fn verror(kind, s string) {
	final_kind := bold(color(kind, kind))
	eprintln('${final_kind}: $s')
	exit(1)
}

pub fn find_working_diff_command() ?string {
	for diffcmd in ['colordiff', 'diff', 'colordiff.exe', 'diff.exe'] {
		p := os.exec('$diffcmd --version') or {
			continue
		}
		if p.exit_code == 0 {
			return diffcmd
		}
	}
	return error('no working diff command found')
}

pub fn color_compare_files(diff_cmd, file1, file2 string) string {
	if diff_cmd != '' {
		full_cmd := '$diff_cmd --minimal --text --unified=2 ' +
		        ' --show-function-line="fn " "$file1" "$file2" '
		x := os.exec(full_cmd) or {
			return 'comparison command: `${full_cmd}` failed'
        }
        return x.output
    }
    return ''
}

fn color_compare_strings(diff_cmd string, expected string, found string) string {
	cdir := os.cache_dir()
	ctime := time.sys_mono_now()
	e_file := os.join_path(cdir, '${ctime}.expected.txt')
	f_file := os.join_path(cdir, '${ctime}.found.txt')
	os.write_file( e_file, expected)
	os.write_file( f_file, found)
	res := util.color_compare_files(diff_cmd, e_file, f_file)
	os.rm( e_file )
	os.rm( f_file )
	return res
}
module util

import os

[inline]
pub fn is_name_char(c byte) bool {
	return (c >= `a` && c <= `z`) || (c >= `A` && c <= `Z`) || c == `_`
}

[inline]
pub fn is_func_char(c byte) bool {
	return (c >= `a` && c <= `z`) || (c >= `A` && c <= `Z`) || c == `_` || c.is_digit()
}

[inline]
pub fn is_nl(c byte) bool {
	return c == `\r` || c == `\n`
}

pub fn contains_capital(s string) bool {
	for c in s {
		if c >= `A` && c <= `Z` {
			return true
		}
	}
	return false
}

// HTTPRequest  bad
// HttpRequest  good
pub fn good_type_name(s string) bool {
	if s.len < 4 {
		return true
	}
	for i in 2 .. s.len {
		if s[i].is_capital() && s[i - 1].is_capital() && s[i - 2].is_capital() {
			return false
		}
	}
	return true
}

pub fn cescaped_path(s string) string {
	return s.replace('\\', '\\\\')
}

pub fn is_fmt() bool {
	return os.executable().contains('vfmt')
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module util

import os
import v.pref

pub const (
	v_version = '0.1.27'
)

// math.bits is needed by strconv.ftoa
pub const (
	builtin_module_parts = ['math.bits', 'strconv', 'strconv.ftoa', 'hash.wyhash', 'strings']
)

// vhash() returns the build string C.V_COMMIT_HASH . See cmd/tools/gen_vc.v .
pub fn vhash() string {
	mut buf := [50]byte
	buf[0] = 0
	C.snprintf(charptr(buf), 50, '%s', C.V_COMMIT_HASH)
	return tos_clone(buf)
}

pub fn full_hash() string {
	build_hash := vhash()
	current_hash := githash(false)
	if build_hash == current_hash {
		return build_hash
	}
	return '${build_hash}.${current_hash}'
}

// full_v_version() returns the full version of the V compiler
pub fn full_v_version(is_verbose bool) string {
	if is_verbose {
		return 'V ${v_version} ${full_hash()}'
	}
	hash := githash(false)
	return 'V ${v_version} $hash'
}

// githash(x) returns the current git commit hash.
// When x is false, it is very fast - it just returns a predefined C constant.
// When x is true, it tries to get the current commit hash, by parsing the
// relevant files in the .git/ folder, or if that is not possible
// for example when using a V from a V binary release, that does not have .git/
// defaults to getting the predefined C constant again.
// NB: githash(true) must be called only when v detects that it builds itself.
// For all other programs, githash(false) should be used.
pub fn githash(should_get_from_filesystem bool) string {
	for {
		// The `for` construct here is used as a goto substitute.
		// The code in this function will break out of the `for`
		// if it detects an error and can not continue.
		if should_get_from_filesystem {
			vexe := os.getenv('VEXE')
			vroot := os.dir(vexe)
			// .git/HEAD
			git_head_file := os.join_path(vroot, '.git', 'HEAD')
			if !os.exists(git_head_file) {
				break
			}
			// 'ref: refs/heads/master' ... the current branch name
			head_content := os.read_file(git_head_file) or {
				break
			}
			mut current_branch_hash := head_content
			if head_content.starts_with('ref: ') {
				gcbranch_rel_path := head_content.replace('ref: ', '').trim_space()
				gcbranch_file := os.join_path(vroot, '.git', gcbranch_rel_path)
				// .git/refs/heads/master
				if !os.exists(gcbranch_file) {
					break
				}
				// get the full commit hash contained in the ref heads file
				branch_hash := os.read_file(gcbranch_file) or {
					break
				}
				current_branch_hash = branch_hash
			}
			desired_hash_length := 7
			if current_branch_hash.len > desired_hash_length {
				return current_branch_hash[0..desired_hash_length]
			}
		}
		break
	}
	mut buf := [50]byte
	buf[0] = 0
	C.snprintf(charptr(buf), 50, '%s', C.V_CURRENT_COMMIT_HASH)
	return tos_clone(buf)
}

//
fn set_vroot_folder(vroot_path string) {
	// Preparation for the compiler module:
	// VEXE env variable is needed so that compiler.vexe_path()
	// can return it later to whoever needs it:
	vname := if os.user_os() == 'windows' { 'v.exe' } else { 'v' }
	os.setenv('VEXE', os.real_path(os.join_path(vroot_path, vname)), true)
}

pub fn launch_tool(is_verbose bool, tool_name string) {
	vexe := pref.vexe_path()
	vroot := os.dir(vexe)
	set_vroot_folder(vroot)
	tool_args := args_quote_paths_with_spaces(os.args[1..])
	tool_exe := path_of_executable(os.real_path('$vroot/cmd/tools/$tool_name'))
	tool_source := os.real_path('$vroot/cmd/tools/${tool_name}.v')
	tool_command := '"$tool_exe" $tool_args'
	if is_verbose {
		println('launch_tool vexe        : $vroot')
		println('launch_tool vroot       : $vroot')
		println('launch_tool tool_args   : $tool_args')
		println('launch_tool tool_command: $tool_command')
	}
	// TODO Caching should be done on the `vlib/v` level.
	mut should_compile := false
	if !os.exists(tool_exe) {
		should_compile = true
	} else {
		if os.file_last_mod_unix(tool_exe) <= os.file_last_mod_unix(vexe) {
			// v was recompiled, maybe after v up ...
			// rebuild the tool too just in case
			should_compile = true
			if tool_name == 'vself' || tool_name == 'vup' {
				// The purpose of vself/up is to update and recompile v itself.
				// After the first 'v self' execution, v will be modified, so
				// then a second 'v self' will detect, that v is newer than the
				// vself executable, and try to recompile vself/up again, which
				// will slow down the next v recompilation needlessly.
				should_compile = false
			}
		}
		if os.file_last_mod_unix(tool_exe) <= os.file_last_mod_unix(tool_source) {
			// the user changed the source code of the tool, or git updated it:
			should_compile = true
		}
	}
	if is_verbose {
		println('launch_tool should_compile: $should_compile')
	}
	if should_compile {
		mut compilation_command := '"$vexe" '
		compilation_command += '"$tool_source"'
		if is_verbose {
			println('Compiling $tool_name with: "$compilation_command"')
		}
		tool_compilation := os.exec(compilation_command) or {
			panic(err)
		}
		if tool_compilation.exit_code != 0 {
			mut err := 'Permission denied'
			if !tool_compilation.output.contains('Permission denied') {
				err = '\n$tool_compilation.output'
			}
			eprintln('cannot compile `$tool_source`: $err')
			exit(1)
		}
	}
	if is_verbose {
		println('launch_tool running tool command: $tool_command ...')
	}
	exit(os.system(tool_command))
}

pub fn quote_path_with_spaces(s string) string {
	if s.contains(' ') {
		return '"${s}"'
	}
	return s
}

pub fn args_quote_paths_with_spaces(args []string) string {
	mut res := []string{}
	for a in args {
		res << quote_path_with_spaces(a)
	}
	return res.join(' ')
}

pub fn path_of_executable(path string) string {
	$if windows {
		return path + '.exe'
	}
	return path
}

pub fn read_file(file_path string) ?string {
	mut raw_text := os.read_file(file_path) or {
		return error('failed to open $file_path')
	}
	// BOM check
	if raw_text.len >= 3 {
		c_text := raw_text.str
		if c_text[0] == 0xEF && c_text[1] == 0xBB && c_text[2] == 0xBF {
			// skip three BOM bytes
			offset_from_begin := 3
			raw_text = tos(c_text[offset_from_begin], vstrlen(c_text) - offset_from_begin)
		}
	}
	return raw_text
}

[inline]
fn imin(a, b int) int {
	return if a < b {
		a
	} else {
		b
	}
}

[inline]
fn imax(a, b int) int {
	return if a > b {
		a
	} else {
		b
	}
}

pub fn replace_op(s string) string {
	last_char := s[s.len - 1]
	suffix := match last_char {
		`+` { '_plus' }
		`-` { '_minus' }
		`*` { '_mult' }
		`/` { '_div' }
		`%` { '_mod' }
		else { '' }
	}
	return s[..s.len - 1] + suffix
}

pub fn join_env_vflags_and_os_args() []string {
	vosargs := os.getenv('VOSARGS')
	if vosargs != '' {
		return non_empty(vosargs.split(' '))
	}
	mut args := []string{}
	vflags := os.getenv('VFLAGS')
	if vflags != '' {
		args << os.args[0]
		args << vflags.split(' ')
		if os.args.len > 1 {
			args << os.args[1..]
		}
		return non_empty(args)
	}
	return non_empty(os.args)
}

fn non_empty(arg []string) []string {
	return arg.filter(it != '')
}
module vmod

import os

enum TokenKind {
	module_keyword
	field_key
	lcbr
	rcbr
	labr
	rabr
	comma
	colon
	eof
	str
	ident
	unknown
}

pub struct Manifest {
pub mut:
	name         string
	version      string
	description  string
	dependencies []string
	license      string
	repo_url     string
	author       string
	unknown      map[string][]string
}

struct Scanner {
mut:
	pos         int
	text        string
	inside_text bool
	tokens      []Token
}

struct Parser {
mut:
	file_path string
	scanner   Scanner
}

struct Token {
	typ TokenKind
	val string
}

pub fn from_file(vmod_path string) ?Manifest {
	if !os.exists(vmod_path) {
		return error('v.mod: v.mod file not found.')
	}
	contents := os.read_file(vmod_path) or {
		panic('v.mod: cannot parse v.mod')
	}
	return decode(contents)
}

pub fn decode(contents string) ?Manifest {
	mut parser := Parser{
		scanner: Scanner{
			pos: 0
			text: contents
		}
	}
	return parser.parse()
}

fn (mut s Scanner) tokenize(t_type TokenKind, val string) {
	s.tokens << Token{t_type, val}
}

fn (mut s Scanner) skip_whitespace() {
	for s.pos < s.text.len && s.text[s.pos].is_space() {
		s.pos++
	}
}

fn is_name_alpha(chr byte) bool {
	return chr.is_letter() || chr == `_`
}

fn (mut s Scanner) create_string(q byte) string {
	mut str := ''
	for s.text[s.pos] != q {
		if s.text[s.pos] == `\\` && s.text[s.pos + 1] == q {
			str += s.text[s.pos..s.pos + 1]
			s.pos += 2
		} else {
			str += s.text[s.pos].str()
			s.pos++
		}
	}
	return str
}

fn (mut s Scanner) create_ident() string {
	mut text := ''
	for is_name_alpha(s.text[s.pos]) {
		text += s.text[s.pos].str()
		s.pos++
	}
	return text
}

fn (s Scanner) peek_char(c byte) bool {
	return s.pos - 1 < s.text.len && s.text[s.pos - 1] == c
}

fn (mut s Scanner) scan_all() {
	for s.pos < s.text.len {
		c := s.text[s.pos]
		if c.is_space() || c == `\\` {
			s.pos++
			continue
		}
		if is_name_alpha(c) {
			name := s.create_ident()
			if name == 'Module' {
				s.tokenize(.module_keyword, name)
				s.pos++
				continue
			} else if s.text[s.pos] == `:` {
				s.tokenize(.field_key, name + ':')
				s.pos += 2
				continue
			} else {
				s.tokenize(.ident, name)
				s.pos++
				continue
			}
		}
		if c in [`\'`, `\"`] && !s.peek_char(`\\`) {
			s.pos++
			str := s.create_string(c)
			s.tokenize(.str, str)
			s.pos++
			continue
		}
		match c {
			`{` { s.tokenize(.lcbr, c.str()) }
			`}` { s.tokenize(.rcbr, c.str()) }
			`[` { s.tokenize(.labr, c.str()) }
			`]` { s.tokenize(.rabr, c.str()) }
			`:` { s.tokenize(.colon, c.str()) }
			`,` { s.tokenize(.comma, c.str()) }
			else { s.tokenize(.unknown, c.str()) }
		}
		s.pos++
	}
	s.tokenize(.eof, 'eof')
}

fn get_array_content(tokens []Token, st_idx int) ?([]string, int) {
	mut vals := []string{}
	mut idx := st_idx
	if tokens[idx].typ != .labr {
		return error('vmod: not a valid array')
	}
	idx++
	for {
		tok := tokens[idx]
		match tok.typ {
			.str {
				vals << tok.val
				if tokens[idx + 1].typ !in [.comma, .rabr] {
					return error('vmod: invalid separator "${tokens[idx+1].val}"')
				}
				idx += if tokens[idx + 1].typ == .comma {
					2
				} else {
					1
				}
			}
			.rabr {
				idx++
				break
			}
			else {
				return error('vmod: invalid token "$tok.val"')
			}
		}
	}
	return vals, idx
}

fn (mut p Parser) parse() ?Manifest {
	err_label := 'vmod:'
	if p.scanner.text.len == 0 {
		return error('$err_label no content.')
	}
	p.scanner.scan_all()
	tokens := p.scanner.tokens
	mut mn := Manifest{}
	if tokens[0].typ != .module_keyword {
		panic('not a valid v.mod')
	}
	mut i := 1
	for i < tokens.len {
		tok := tokens[i]
		match tok.typ {
			.lcbr {
				if tokens[i + 1].typ !in [.field_key, .rcbr] {
					return error('$err_label invalid content after opening brace')
				}
				i++
				continue
			}
			.rcbr {
				break
			}
			.field_key {
				field_name := tok.val.trim_right(':')
				if tokens[i + 1].typ !in [.str, .labr] {
					return error('$err_label value of field "$field_name" must be either string or an array of strings')
				}
				field_value := tokens[i + 1].val
				match field_name {
					'name' {
						mn.name = field_value
					}
					'version' {
						mn.version = field_value
					}
					'license' {
						mn.license = field_value
					}
					'repo_url' {
						mn.repo_url = field_value
					}
					'description' {
						mn.description = field_value
					}
					'author' {
						mn.author = field_value
					}
					'dependencies' {
						deps, idx := get_array_content(tokens, i + 1) or {
							return error(err)
						}
						mn.dependencies = deps
						i = idx
						continue
					}
					else {
						if tokens[i + 1].typ == .labr {
							vals, idx := get_array_content(tokens, i + 1) or {
								return error(err)
							}
							mn.unknown[field_name] = vals
							i = idx
							continue
						}
						mn.unknown[field_name] = [field_value]
					}
				}
				i += 2
				continue
			}
			.comma {
				if tokens[i - 1].typ !in [.str, .rabr] || tokens[i + 1].typ != .field_key {
					return error('$err_label invalid comma placement')
				}
				i++
				continue
			}
			else {
				return error('$err_label invalid token "$tok.val"')
			}
		}
	}
	return mn
}
module vmod

import os

// This file provides a caching mechanism for seeking quickly whether a
// given folder has a v.mod file in it or in any of its parent folders.
//
// ModFileCacher.get(folder) works in such a way, that given this tree:
// examples/hanoi.v
// vlib/v.mod
// vlib/v/tests/project_with_c_code/mod1/v.mod
// vlib/v/tests/project_with_c_code/mod1/wrapper.v
// -----------------
// ModFileCacher.get('examples')
// => ModFileAndFolder{'', 'examples'}
// ModFileCacher.get('vlib/v/tests')
// => ModFileAndFolder{'vlib/v.mod', 'vlib'}
// ModFileCacher.get('vlib/v')
// => ModFileAndFolder{'vlib/v.mod', 'vlib'}
// ModFileCacher.get('vlib/v/test/project_with_c_code/mod1')
// => ModFileAndFolder{'vlib/v/test/project_with_c_code/mod1/v.mod', 'vlib/v/test/project_with_c_code/mod1'}


pub struct ModFileAndFolder {
pub:
	// vmod_file contains the full path of the found 'v.mod' file, or ''
	// if no 'v.mod' file was found in file_path_dir, or in its parent folders.
	vmod_file string

	// vmod_folder contains the file_path_dir, if there is no 'v.mod' file in
	// *any* of the parent folders, otherwise it is the first parent folder,
	// where a v.mod file was found.
	vmod_folder string
}

pub struct ModFileCacher {
mut:
	cache map[string]ModFileAndFolder
	// folder_files caches os.ls(key)
	folder_files map[string][]string
}

pub fn new_mod_file_cacher() &ModFileCacher {
	return &ModFileCacher{}
}

pub fn (mcache &ModFileCacher) dump() {
	$if debug {
		eprintln('ModFileCacher DUMP:')
		eprintln('	 ModFileCacher.cache:')
		for k,v in mcache.cache {
			eprintln('	 K: ${k:-32s} | V: "${v.vmod_file:32s}" | "${v.vmod_folder:32s}" ')
		}
		eprintln('	 ModFileCacher.folder_files:')
		for k,v in mcache.folder_files {
			eprintln('	 K: ${k:-32s} | V: ${v.str()}')
		}
	}
}

pub fn (mut mcache ModFileCacher) get(mfolder string) ModFileAndFolder {
	if mfolder in mcache.cache {
		return mcache.cache[ mfolder ]
	}
	traversed_folders, res := mcache.traverse( mfolder )
	for tfolder in traversed_folders {
		mcache.add( tfolder, res )
	}
	return res
}

fn (mut cacher ModFileCacher) add(path string, result ModFileAndFolder) {
	cacher.cache[ path ] = result
}

fn (mut mcache ModFileCacher) traverse(mfolder string) ([]string, ModFileAndFolder) {
	mut cfolder := mfolder
	mut folders_so_far := [cfolder]
	mut levels := 0
	for {
		if levels > 255 {
			break
		}
		if cfolder == '/' || cfolder == '' {
			break
		}
		if cfolder in mcache.cache {
			res := mcache.cache[ cfolder ]
			if res.vmod_file.len == 0 {
				mcache.mark_folders_as_vmod_free( folders_so_far )
			}else{
				mcache.mark_folders_with_vmod( folders_so_far, res )
			}
			return []string{}, res
		}
		files := mcache.get_files( cfolder )
		if 'v.mod' in files {
			// TODO: actually read the v.mod file and parse its contents to see
			// if its source folder is different
			res := ModFileAndFolder{ vmod_file: os.join_path( cfolder, 'v.mod'), vmod_folder: cfolder }
			return folders_so_far, res
		}
		if mcache.check_for_stop( cfolder, files ) {
			break
		}
		cfolder = os.base_dir( cfolder )
		folders_so_far << cfolder
		levels++
	}
	mcache.mark_folders_as_vmod_free( folders_so_far )
	return [mfolder], ModFileAndFolder{ vmod_file: '', vmod_folder: mfolder }
}

fn (mut mcache ModFileCacher) mark_folders_with_vmod( folders_so_far []string, vmod ModFileAndFolder ) {
	for f in folders_so_far {
		mcache.add( f, vmod )
	}
}

fn (mut mcache ModFileCacher) mark_folders_as_vmod_free( folders_so_far []string ) {
	// No need to check these folders anymore,
	// because their parents do not contain v.mod files
	for f in folders_so_far {
		mcache.add( f, ModFileAndFolder{ vmod_file: '', vmod_folder: f } )
	}
}

const ( mod_file_stop_paths = ['.git', '.hg', '.svn', '.v.mod.stop' ] )
fn (mcache &ModFileCacher) check_for_stop(cfolder string, files []string) bool {
	for i in mod_file_stop_paths {
		if i in files {
			return true
		}
	}
	return false
}

fn (mut mcache ModFileCacher) get_files(cfolder string) []string {
	if cfolder in mcache.folder_files {
		return mcache.folder_files[ cfolder ]
	}
	mut files := []string{}
	if os.exists( cfolder ) && os.is_dir(cfolder) {
		if listing := os.ls(cfolder) {
			files = listing
		}
	}
	mcache.folder_files[ cfolder ] = files
	return files
}

pub const (
	mod_file_cacher = new_mod_file_cacher() // used during lookup for v.mod to support @VROOT
)
This is pre-alpha software.

## Features
- Very fast: performance of C on the web.
- Small binary: hello world website is <100 KB.
- Easy to deploy: just one binary file that also includes all templates.
  No need to install any dependencies.
- Templates are precompiled, all errors are visible at compilation time,
  not at runtime.

Lots of things are broken and not implemented yet in V and vweb.

There's no documentation yet, have a look at a simple example:

https://github.com/vlang/v/tree/master/examples/vweb/vweb_example.v

There's also the V forum: https://github.com/vlang/vorum

`vorum.v` contains all GET and POST actions.

```Go
pub fn (app mut App) index() {
	posts := app.find_all_posts()
	$vweb.html()
}

// TODO ['/post/:id/:title']
// TODO `fn (app App) post(id int)`
pub fn (app App) post() {
	id := app.get_post_id()
	post := app.retrieve_post(id) or {
		app.vweb.redirect('/')
		return
	}
	comments := app.find_comments(id)
	show_form := true
	$vweb.html()
}

```

`index.html` is an example of the V template language:

```html
@for post in posts
	<div class=post>
		<a class=topic href="@post.url">@post.title</a>
		<img class=comment-img>
		<span class=nr-comments>@post.nr_comments</span>
		<span class=time>@post.time</span>
	</div>
@end
```

`$vweb.html()` compiles an HTML template into V during compilation, and embeds the resulting code in current action.

That means that the template automatically has access to that action's entire environment.


### Deploying vweb apps

Everything, including HTML templates, is in one binary file. That's all you need to deploy.

// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module vweb

import os
import net
import net.http
import net.urllib
import strings

pub const (
	methods_with_form = ['POST', 'PUT', 'PATCH']
	method_all = ['GET','POST','PUT','PATCH','DELETE']
	header_server = 'Server: VWeb\r\n'
	header_connection_close = 'Connection: close\r\n'
	headers_close = '${header_server}${header_connection_close}\r\n'
	http_404 = 'HTTP/1.1 404 Not Found\r\nContent-Type: text/plain\r\n${headers_close}404 Not Found'
	http_500 = 'HTTP/1.1 500 Internal Server Error\r\nContent-Type: text/plain\r\n${headers_close}500 Internal Server Error'
	mime_types = {
		'.css': 'text/css; charset=utf-8',
		'.gif': 'image/gif',
		'.htm': 'text/html; charset=utf-8',
		'.html': 'text/html; charset=utf-8',
		'.jpg': 'image/jpeg',
		'.js': 'application/javascript',
		'.wasm': 'application/wasm',
		'.pdf': 'application/pdf',
		'.png': 'image/png',
		'.svg': 'image/svg+xml',
		'.xml': 'text/xml; charset=utf-8'
	}
	max_http_post_size = 1024 * 1024
	default_port = 8080
)

pub struct Context {
	static_files map[string]string
	static_mime_types map[string]string
pub:
	req http.Request
	conn net.Socket
	form map[string]string
	// TODO Response
mut:
	headers string // response headers
	done bool
}

fn (mut ctx Context) send_response_to_client(mimetype string, res string) bool {
	if ctx.done { return false }
	ctx.done = true
	mut sb := strings.new_builder(1024)
	sb.write('HTTP/1.1 200 OK\r\nContent-Type: ') sb.write(mimetype)
	sb.write('\r\nContent-Length: ')              sb.write(res.len.str())
	sb.write(ctx.headers)
	sb.write('\r\n')
	sb.write(headers_close)
	sb.write(res)
	ctx.conn.send_string(sb.str()) or { return false }
	sb.free()
	return true
}

pub fn (mut ctx Context) html(s string) {
	ctx.send_response_to_client('text/html', s)
}

pub fn (mut ctx Context) text(s string) {
	ctx.send_response_to_client('text/plain', s)
}

pub fn (mut ctx Context) json(s string) {
	ctx.send_response_to_client('application/json', s)
}

pub fn (mut ctx Context) redirect(url string) {
	if ctx.done { return }
	ctx.done = true
	ctx.conn.send_string('HTTP/1.1 302 Found\r\nLocation: ${url}${ctx.headers}\r\n${headers_close}') or { return }
}

pub fn (mut ctx Context) not_found(s string) {
	if ctx.done { return }
	ctx.done = true
	ctx.conn.send_string(http_404) or { return }
}

pub fn (mut ctx Context) set_cookie(key, val string) {
	// TODO support directives, escape cookie value (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)
	//println('Set-Cookie $key=$val')
	ctx.add_header('Set-Cookie', '${key}=${val};  Secure; HttpOnly')
}

pub fn (ctx &Context) get_cookie(key string) ?string { // TODO refactor
	mut cookie_header := ctx.get_header('cookie')
	if cookie_header == '' {
		cookie_header = ctx.get_header('Cookie')
	}
	cookie_header = ' ' + cookie_header
	//println('cookie_header="$cookie_header"')
	//println(ctx.req.headers)
	cookie := if cookie_header.contains(';') {
		cookie_header.find_between(' $key=', ';')
	} else {
		cookie_header.find_between(' $key=', '\r')
	}
	if cookie != '' {
		return cookie.trim_space()
	}
	return error('Cookie not found')
}

pub fn (mut ctx Context) add_header(key, val string) {
	//println('add_header($key, $val)')
	ctx.headers = ctx.headers + '\r\n$key: $val'
	//println(ctx.headers)
}

pub fn (ctx &Context) get_header(key string) string {
	return ctx.req.headers[key]
}

//fn handle_conn(conn net.Socket) {
	//println('handle')

//}

pub fn foo<T>() {

}

pub fn run<T>(port int) {
//pub fn run<T>(app mut T, port int) {
	println('Running a Vweb app on http://localhost:$port ...')
	l := net.listen(port) or { panic('failed to listen') }
	mut app := T{}
	app.vweb = Context{}
	app.init()
	//app.reset()
	for {
		conn := l.accept() or { panic('accept() failed') }
		handle_conn(conn, mut app)
		//foobar<T>()
		// TODO move this to handle_conn<T>(conn, app)
		//message := readall(conn)
		//println(message)
/*
		if message.len > max_http_post_size {
			println('message.len = $message.len > max_http_post_size')
			conn.send_string(http_500) or {}
			conn.close() or {}
			continue
		}
		*/

		//lines := message.split_into_lines()
		//println(lines)

/*
		if lines.len < 2 {
			conn.send_string(http_500) or {}
			conn.close() or {}
			continue
		}
		*/
	}
}

fn handle_conn<T>(conn net.Socket, app mut T) {
	//first_line := strip(lines[0])
	first_line := conn.read_line()
	println('firstline="$first_line"')
	$if debug { println(first_line) }
	// Parse the first line
	// "GET / HTTP/1.1"
	//first_line := s.all_before('\n')
	vals := first_line.split(' ')
	if vals.len < 2 {
		println('no vals for http')
		conn.send_string(http_500) or {}
		conn.close() or {}
		return
		//continue
	}
	mut headers := []string{}
	mut body := ''
	mut in_headers := true
	mut len := 0
	mut body_len := 0
	//for line in lines[1..] {
	for _ in 0..100 {
		//println(j)
		line := conn.read_line()
		sline := strip(line)
		if sline == '' {
			//if in_headers {
				// End of headers, no body => exit
				if len == 0 {
					break
				}
			//} //else {
				// End of body
				//break
			//}
			//println('HHH')
			in_headers = false
		}
		if in_headers {
			//println(sline)
			headers << sline
			if sline.starts_with('Content-Length') {
				len = sline.all_after(': ').int()
				//println('GOT CL=$len')
			}
		} else {
			body += sline + '\r\n'
			body_len += body.len
			if body_len >= len {
				break
			}
			//println('body:$body')
		}
	}

	mut action := vals[1][1..].all_before('/')
	if action.contains('?') {
		action = action.all_before('?')
	}
	if action == '' {
		action = 'index'
	}
	req := http.Request{
		headers: http.parse_headers(headers) //s.split_into_lines())
		data: strip(body)
		ws_func: 0
		user_ptr: 0
		method: vals[0]
		url: vals[1]
	}
	$if debug {
		println('req.headers = ')
		println(req.headers)
		println('req.data="$req.data"' )
		println('vweb action = "$action"')
	}
	//mut app := T{
	app.vweb = Context{
		req: req
		conn: conn
		form: map[string]string
		static_files: app.vweb.static_files
		static_mime_types: app.vweb.static_mime_types
	}
	//}
	if req.method in methods_with_form {
		app.vweb.parse_form(req.data)
	}
	if vals.len < 2 {
		$if debug {
			println('no vals for http')
		}
		conn.close() or {}
		return
		//continue
	}

	// Serve a static file if it's one
	static_file := app.vweb.static_files[app.vweb.req.url]
	mime_type := app.vweb.static_mime_types[app.vweb.req.url]

	if static_file != '' && mime_type != '' {
		data := os.read_file(static_file) or {
			conn.send_string(http_404) or {}
			return
		}
		app.vweb.send_response_to_client(mime_type, data)
		return
	}

	// Call the right action
	$if debug {
		println('action=$action')
	}
	app.$action() or {
		conn.send_string(http_404) or {}
	}
	conn.close() or {}
	app.reset()
}

fn (mut ctx Context) parse_form(s string) {
	if ctx.req.method !in methods_with_form {
		return
	}
	//pos := s.index('\r\n\r\n')
	//if pos > -1 {
	mut str_form := s//[pos..s.len]
	str_form = str_form.replace('+', ' ')
	words := str_form.split('&')
	for word in words {
		$if debug {
			println('parse form keyval="$word"')
		}
		keyval := word.trim_space().split('=')
		if keyval.len != 2 { continue }
		key := keyval[0]
		val := urllib.query_unescape(keyval[1]) or {
			continue
		}
		$if debug {
			println('http form "$key" => "$val"')
		}
		ctx.form[key] = val
	}
	//}
	// todo: parse form-data and application/json
	// ...
}

fn (mut ctx Context) scan_static_directory(directory_path, mount_path string) {
	files := os.ls(directory_path) or { panic(err) }

	if files.len > 0 {
		for file in files {

			if os.is_dir(file) {
				ctx.scan_static_directory(directory_path + '/' + file, mount_path + '/' + file)
			} else if file.contains('.') && ! file.starts_with('.') && ! file.ends_with('.') {
				ext := os.file_ext(file)

				// Rudimentary guard against adding files not in mime_types.
				// Use serve_static directly to add non-standard mime types.
				if ext in mime_types {
					ctx.serve_static(mount_path + '/' + file, directory_path + '/' + file, mime_types[ext])
				}
			}
		}
	}
}

pub fn (mut ctx Context) handle_static(directory_path string) bool {
	if ctx.done || ! os.exists(directory_path) {
		return false
	}

	dir_path := directory_path.trim_space().trim_right('/')
	mut mount_path := ''

	if dir_path != '.' && os.is_dir(dir_path) {
		// Mount point hygene, "./assets" => "/assets".
		mount_path = '/' + dir_path.trim_left('.').trim('/')
	}

	ctx.scan_static_directory(dir_path, mount_path)

	return true
}

pub fn (mut ctx Context) serve_static(url, file_path, mime_type string) {
	ctx.static_files[url] = file_path
	ctx.static_mime_types[url] = mime_type
}


/*
fn readall(conn net.Socket) string {
	// read all message from socket
	//printf("waitall=%d\n", C.MSG_WAITALL)
	mut message := ''
	buf := [1024]byte
	for {
		n := C.recv(conn.sockfd, buf, 1024, 0)
		m := conn.crecv(buf, 1024)
		message += string( byteptr(buf), m )
		if message.len > max_http_post_size { break }
		if n == m { break }
	}
	return message
}
*/

fn strip(s string) string {
	// strip('\nabc\r\n') => 'abc'
	return s.trim('\r\n')
}
module assets

// this module provides an AssetManager for combining
// and caching javascript & css.

import os
import time
import crypto.md5

const (
	unknown_asset_type_error = 'vweb.assets: unknown asset type'
)

struct AssetManager {
mut:
	css       []Asset
	js        []Asset
pub mut:
	// when true assets will be minified
	minify    bool
	// the directory to store the cached/combined files
	cache_dir string
}

struct Asset {
	file_path     string
	last_modified time.Time
}

// new_manager returns a new AssetManager
pub fn new_manager() &AssetManager {
	return &AssetManager{}
}

// add_css adds a css asset
pub fn (mut am AssetManager) add_css(file string) bool {
	return am.add('css', file)
}

// add_js adds a js asset
pub fn (mut am AssetManager) add_js(file string) bool {
	return am.add('js', file)
}

// combine_css returns the combined css as a string when to_file is false
// when to_file is true it combines the css to disk and returns the path of the file
pub fn (am AssetManager) combine_css(to_file bool) string {
	return am.combine('css', to_file)
}

// combine_js returns the combined js as a string when to_file is false
// when to_file is true it combines the css to disk and returns the path of the file
pub fn (am AssetManager) combine_js(to_file bool) string {
	return am.combine('js', to_file)
}

// include_css returns the html <link> tag(s) for including the css files in a page.
// when combine is true the files are combined.
pub fn (am AssetManager) include_css(combine bool) string {
	return am.include('css', combine)
}

// include_js returns the html <script> tag(s) for including the js files in a page.
// when combine is true the files are combined.
pub fn (am AssetManager) include_js(combine bool) string {
	return am.include('js', combine)
}

fn (am AssetManager) combine(asset_type string, to_file bool) string {
	if am.cache_dir == '' {
		panic('vweb.assets: you must set a cache dir.')
	}
	cache_key := am.get_cache_key(asset_type)
	out_file := '$am.cache_dir/${cache_key}.$asset_type'
	mut out := ''
	// use cache
	if os.exists(out_file) {
		if to_file {
			return out_file
		}
		cached := os.read_file(out_file) or {
			return ''
		}
		return cached
	}
	// rebuild
	for asset in am.get_assets(asset_type) {
		data := os.read_file(asset.file_path) or {
			return ''
		}
		out += data
	}
	if am.minify {
		if asset_type == 'css' {
			out = minify_css(out)
		} else {
			out = minify_js(out)
		}
	}
	if !to_file {
		return out
	}
	if !os.is_dir(am.cache_dir) {
		os.mkdir(am.cache_dir) or { panic(err) }
	}
	mut file := os.create(out_file) or {
		panic(err)
	}
	file.write(out)
	file.close()
	return out_file
}

fn (am AssetManager) get_cache_key(asset_type string) string {
	mut files_salt := ''
	mut latest_modified := u64(0)
	for asset in am.get_assets(asset_type) {
		files_salt += asset.file_path
		if asset.last_modified.unix > latest_modified {
			latest_modified = asset.last_modified.unix
		}
	}
	hash := md5.sum(files_salt.bytes()).hex()
	return '$hash-$latest_modified'
}

fn (am AssetManager) include(asset_type string, combine bool) string {
	assets := am.get_assets(asset_type)
	mut out := ''
	if asset_type == 'css' {
		if combine {
			file := am.combine(asset_type, true)
			return '<link rel="stylesheet" href="$file">\n'
		}
		for asset in assets {
			out += '<link rel="stylesheet" href="$asset.file_path">\n'
		}
	}
	if asset_type == 'js' {
		if combine {
			file := am.combine(asset_type, true)
			return '<script type="text/javascript" src="$file"></script>\n'
		}
		for asset in assets {
			out += '<script type="text/javascript" src="$asset.file_path"></script>\n'
		}
	}
	return out
}

// dont return option until size limit is removed
// fn (mut am AssetManager) add(asset_type, file string) ?bool {
fn (mut am AssetManager) add(asset_type, file string) bool {
	if !os.exists(file) {
		// return error('vweb.assets: cannot add asset $file, it does not exist')
		return false
	}
	asset := Asset{
		file_path: file
		last_modified: time.Time{unix: u64(os.file_last_mod_unix(file))}
	}
	if asset_type == 'css' {
		am.css << asset
	} else if asset_type == 'js' {
		am.js << asset
	} else {
		panic('$unknown_asset_type_error ($asset_type).')
	}
	return true
}

fn (am AssetManager) exists(asset_type, file string) bool {
	assets := am.get_assets(asset_type)
	for asset in assets {
		if asset.file_path == file {
			return true
		}
	}
	return false
}

fn (am AssetManager) get_assets(asset_type string) []Asset {
	if asset_type != 'css' && asset_type != 'js' {
		panic('$unknown_asset_type_error ($asset_type).')
	}
	assets := if asset_type == 'css' {
		am.css
	} else {
		am.js
	}
	return assets
}

// todo: implement proper minification
pub fn minify_css(css string) string {
	mut lines := css.split('\n')
	for i, _ in lines {
		lines[i] = lines[i].trim_space()
	}
	return lines.join(' ')
}

// todo: implement proper minification
pub fn minify_js(js string) string {
	mut lines := js.split('\n')
	for i, _ in lines {
		lines[i] = lines[i].trim_space()
	}
	return lines.join(' ')
}
import vweb.assets
import os

// clean_cache_dir used before and after tests that write to a cache directory.
// Because of parallel compilation and therefore test running,
// unique cache dirs are needed per test function.
fn clean_cache_dir(dir string) {
	if os.is_dir(dir) {
		os.rmdir_all(dir)
	}
}

fn base_cache_dir() string {
	return os.join_path(os.temp_dir(), 'assets_test_cache')
}

fn cache_dir(test_name string) string {
	return os.join_path(base_cache_dir(), test_name)
}

fn get_test_file_path(file string) string {
	path := os.join_path(base_cache_dir(), file)

	if ! os.is_dir(base_cache_dir()) {
		os.mkdir_all(base_cache_dir())
	}

	if ! os.exists(path) {
		os.write_file(path, get_test_file_contents(file))
	}

	return path
}

fn get_test_file_contents(file string) string {
	contents := match file {
		'test1.js' { '{"one": 1}\n' }
		'test2.js' { '{"two": 2}\n' }
		'test1.css' { '.one {\n\tcolor: #336699;\n}\n' }
		'test2.css' { '.two {\n\tcolor: #996633;\n}\n' }
		else { 'wibble\n' }
	}

	return contents
}

fn test_set_cache() {
	mut am := assets.new_manager()
	am.cache_dir = 'cache'
}

fn test_set_minify() {
	mut am := assets.new_manager()
	am.minify = true
}

fn test_add() {
	mut am := assets.new_manager()
	assert am.add('css', 'testx.css') == false
	assert am.add('css', get_test_file_path('test1.css')) == true
	assert am.add('js', get_test_file_path('test1.js')) == true
	// assert am.add('css', get_test_file_path('test2.js')) == false // TODO: test extension on add
}

fn test_add_css() {
	mut am := assets.new_manager()
	assert am.add_css('testx.css') == false
	assert am.add_css(get_test_file_path('test1.css')) == true
	// assert am.add_css(get_test_file_path('test1.js')) == false // TODO: test extension on add
}

fn test_add_js() {
	mut am := assets.new_manager()
	assert am.add_js('testx.js') == false
	assert am.add_css(get_test_file_path('test1.js')) == true
	// assert am.add_css(get_test_file_path('test1.css')) == false // TODO: test extension on add
}

fn test_combine_css() {
	mut am := assets.new_manager()
	am.cache_dir = cache_dir('test_combine_css')
	clean_cache_dir(am.cache_dir)

	am.add_css(get_test_file_path('test1.css'))
	am.add_css(get_test_file_path('test2.css'))

	// TODO: How do I test non-minified, is there a "here doc" format that keeps formatting?
	am.minify = true
	expected := '.one { color: #336699; } .two { color: #996633; }'
	actual := am.combine_css(false)
	// assert actual == expected // TODO: Why does this not pass, file/line ending?
	assert actual.contains(expected)

	// Test cache path doesn't change when input files and minify setting do not.
	path1 := am.combine_css(true)
	clean_cache_dir(am.cache_dir)
	path2 := am.combine_css(true)
	assert path1 == path2

	clean_cache_dir(am.cache_dir)
}

fn test_combine_js() {
	mut am := assets.new_manager()
	am.cache_dir = cache_dir('test_combine_js')
	clean_cache_dir(am.cache_dir)

	am.add_js(get_test_file_path('test1.js'))
	am.add_js(get_test_file_path('test2.js'))

	expected1 := '{"one": 1}'
	expected2 := '{"two": 2}'
	expected := expected1 + '\n' + expected2
	actual := am.combine_js(false)
	// assert actual == expected // TODO: Why does this not pass, file/line ending?
	assert actual.contains(expected)
	assert actual.contains(expected1)
	assert actual.contains(expected2)

	am.minify = true
	clean_cache_dir(am.cache_dir)
	expected3 := expected1 + ' ' + expected2
	actual2 := am.combine_js(false)
	// assert actual2 == expected3 // TODO: Why does this not pass, file/line ending?
	assert actual2.contains(expected3)

	// Test cache path doesn't change when input files and minify setting do not.
	path1 := am.combine_js(true)
	clean_cache_dir(am.cache_dir)
	path2 := am.combine_js(true)
	assert path1 == path2

	clean_cache_dir(am.cache_dir)
}

fn test_include_css() {
	mut am := assets.new_manager()
	file1 := get_test_file_path('test1.css')
	am.add_css(file1)
	expected := '<link rel="stylesheet" href="$file1">'
	actual := am.include_css(false)
	// assert actual == expected // TODO: Why does this not pass, file/line ending?
	assert actual.contains(expected)

	// Two lines of output.
	file2 := get_test_file_path('test2.css')
	am.add_css(file2)
	am.cache_dir = cache_dir('test_include_css')
	clean_cache_dir(am.cache_dir)

	expected2 := expected + '\n<link rel="stylesheet" href="$file2">'
	actual2 := am.include_css(false)
	// assert actual2 == expected2 // TODO: Why does this not pass, file/line ending?
	assert actual2.contains(expected2)

	// Combined output.
	clean_cache_dir(am.cache_dir)
	actual3 := am.include_css(true)
	assert actual3.contains(expected2) == false
	assert actual3.starts_with('<link rel="stylesheet" href="${am.cache_dir}/') == true

	// Test cache path doesn't change when input files and minify setting do not.
	clean_cache_dir(am.cache_dir)
	actual4 := am.include_css(true)
	assert actual4 == actual3

	clean_cache_dir(am.cache_dir)
}

fn test_include_js() {
	mut am := assets.new_manager()
	file1 := get_test_file_path('test1.js')
	am.add_js(file1)
	expected := '<script type="text/javascript" src="$file1"></script>'
	actual := am.include_js(false)
	// assert actual == expected // TODO: Why does this not pass, file/line ending?
	assert actual.contains(expected)

	// Two lines of output.
	file2 := get_test_file_path('test2.js')
	am.add_js(file2)
	am.cache_dir = cache_dir('test_include_js')
	clean_cache_dir(am.cache_dir)

	expected2 := expected + '\n<script type="text/javascript" src="$file2"></script>'
	actual2 := am.include_js(false)
	// assert actual2 == expected2 // TODO: Why does this not pass, file/line ending?
	assert actual2.contains(expected2)

	// Combined output.
	clean_cache_dir(am.cache_dir)
	actual3 := am.include_js(true)
	assert actual3.contains(expected2) == false
	assert actual3.starts_with('<script type="text/javascript" src="${am.cache_dir}/')

	// Test cache path doesn't change when input files and minify setting do not.
	clean_cache_dir(am.cache_dir)
	actual4 := am.include_js(true)
	assert actual4 == actual3

	clean_cache_dir(am.cache_dir)
}
// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module tmpl

import os
import strings

const (
	str_start = "sb.write(\'"
	str_end = "\' ) "
)

pub fn compile_template(path string) string {
	// lines := os.read_lines(path)
	mut html := os.read_file(path)or{
		panic('html failed')
	}
	mut header := ''
	if os.exists('header.html') && html.contains('@header') {
		h := os.read_file('header.html')or{
			panic('reading file header.html failed')
		}
		header = h.replace("\'", '"')
		html = header + html
	}
	lines := html.split_into_lines()
	mut s := strings.new_builder(1000)
	// base := path.all_after_last('/').replace('.html', '')
	s.writeln("
mut sb := strings.new_builder(${lines.len * 30})
header := \' \' // TODO remove
_ = header
//footer := \'footer\'
")
	s.writeln(str_start)
	mut in_css := true // false
	for _line in lines {
		line := _line.trim_space()
		if line == '<style>' {
			in_css = true
		}
		else if line == '</style>' {
			// in_css = false
		}
		if line.contains('@if ') {
			s.writeln(str_end)
			pos := line.index('@if') or {
				continue
			}
			s.writeln('if ' + line[pos + 4..] + '{')
			s.writeln(str_start)
		}
		else if line.contains('@end') {
			s.writeln(str_end)
			s.writeln('}')
			s.writeln(str_start)
		}
		else if line.contains('@else') {
			s.writeln(str_end)
			s.writeln(' } else { ')
			s.writeln(str_start)
		}
		else if line.contains('@for') {
			s.writeln(str_end)
			pos := line.index('@for') or {
				continue
			}
			s.writeln('for ' + line[pos + 4..] + '{')
			s.writeln(str_start)
		}
		else if !in_css && line.contains('.') && line.ends_with('{') {
			class := line.find_between('.', '{')
			s.writeln('<div class="$class">')
		}
		else if !in_css && line == '}' {
			s.writeln('</div>')
		}
		// HTML, may include `@var`
		else {
			s.writeln(line.replace('@', '\x24').replace("'", '"'))
		}
	}
	s.writeln(str_end)
	s.writeln('tmpl_res := sb.str() }')
	return s.str()
}
